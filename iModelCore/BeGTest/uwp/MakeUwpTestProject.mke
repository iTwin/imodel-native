#--------------------------------------------------------------------------------------
#
#     $Source: uwp/MakeUwpTestProject.mke $
#
#  $Copyright: (c) 2016 Bentley Systems, Incorporated. All rights reserved. $
#
#--------------------------------------------------------------------------------------
%ifndef TEST_NAME
    %error Must define TEST_NAME as the name of the .exe to create
%endif

%ifndef TEST_COLLECTION_PRODUCT
    %error TEST_COLLECTION_PRODUCT must point to the product that contains the unit tests and their supporting libraries and assets
%endif

# Optional. TEST_FRAMEWORK_SQLANG - Full filepath of .db3 file to return as the "framework" sqlang file

%include mdl.mki

%if $(TARGET_PLATFORM)!="WinRT"
    %error This makefile should be used only when TARGET_PLATFORM is WinRT
%endif

baseDir             = $(_MakeFilePath)
o                   = $(OutputRootDir)build/$(TEST_NAME)UwpTest/
tmp                 = $(o)tmp/
projectDir          = $(o)Project/

collectionProduct = $(OutputRootDir)Product/${TEST_COLLECTION_PRODUCT}/
collectionAssetsDir = $(collectionProduct)Assets/
collectionAssembliesDir = $(collectionProduct)Assemblies/
collectionLibsDir = $(collectionProduct)Libs/
collectionTestObjectsDir = $(collectionProduct)Objects/

%if defined (BMAKE_DELETE_ALL_TARGETS)
    always:
        $(rmdirRecursiveCmd) $(o)

    %return 
%else
    always:
        ~mkdir $(o)
        ~mkdir $(tmp)
        !~@putenv PYTHONPATH=$(PYTHONPATH)$(bsicommon_ospathsep)$(SrcRoot)bsicommon/PublicSDK
%endif

%ifndef TEST_FRAMEWORK_SQLANG
    TEST_FRAMEWORK_SQLANG=DgnPlatform_en.sqlang.db3
%endif

always:
    !~@mkdir $(projectDir)gensrc
    > $(projectDir)gensrc/TEST_FRAMEWORK_SQLANG_DEF.h
\#define TEST_FRAMEWORK_SQLANG L"$(TEST_FRAMEWORK_SQLANG)"
    <

#--------------------------------------------------------------------------------------
# Copy the entire project structure (physical directories + symlinked files)
# The VS project file will be modified (and we don't want to check that in) so make a hard copy for it
# Also create a hard copy of the .sln so that there is no confusion over which vcxproj to open
# N.B. The key file cannot by a symlink. If it is, you'll get "Loading certificate file '...' failed. Unspecified error".
#--------------------------------------------------------------------------------------
always:
    CopyWithSymlinks.py $(baseDir)VisualStudioProject/BeTestTest1 $(projectDir)
    !-$(deleteCmd) $(projectDir)BeTestTest1.vcxproj
    $(copyCmd) $(baseDir)VisualStudioProject/BeTestTest1/BeTestTest1.vcxproj $(projectDir)BeTestTest1.vcxproj
    !-$(deleteCmd) $(projectDir)BeTestTest1.sln
    $(copyCmd) $(baseDir)VisualStudioProject/BeTestTest1/BeTestTest1.sln $(projectDir)BeTestTest1.sln
    !-$(deleteCmd) $(projectDir)BeTestTest1_TemporaryKey.pfx
    $(copyCmd) $(baseDir)VisualStudioProject/BeTestTest1/BeTestTest1_TemporaryKey.pfx $(projectDir)BeTestTest1_TemporaryKey.pfx

#--------------------------------------------------------------------------------------
# CppUnit wrappers
#
#   GenerateCppUnitSource.py finds the unit tests that are linked into a known directory.
#   For each, it generates a .cpp file that defines OCUnit test case methods that call the run_TEST_... functions that invoke the unit tests.
#   Make this depend on the *UnitTests.list.h files - these change when a unit test is added or removed
#--------------------------------------------------------------------------------------
$(tmp)GenerateCppUnitSource.mki : $[@wildcard $(collectionTestObjectsDir)*UnitTests.list.h] $(baseDir)CppUnit.cpp.template $(_MakeFileSpec)
    $(msg)
    | $(baseDir)GenerateCppUnitSource.py $(collectionTestObjectsDir) $(baseDir)CppUnit.cpp.template
    !@$(baseDir)GenerateCppUnitSource.py $(collectionTestObjectsDir) $(baseDir)CppUnit.cpp.template > $@
    ~time

%iffile $(tmp)GenerateCppUnitSource.mki
    %include $(tmp)GenerateCppUnitSource.mki

always:
    !-$(deleteCmd) $(tmp)GenerateCppUnitSource.mki
%endif

always:
    !~@mkdir $(tmp)

#--------------------------------------------------------------------------------------
# Update the .vcxproj file to reference all generated source files as compilables
#--------------------------------------------------------------------------------------
gensrc = $(o)Project/source/

always:
    >$(tmp)sourceFiles.list
    $[@wildcard $(gensrc)*.cpp]
    <
    $(baseDir)AddSourceFileReferencesToVSProject.py $(projectDir)BeTestTest1.vcxproj $(tmp)sourceFiles.list
    
#--------------------------------------------------------------------------------------
# Deliver a single DLL that contains the unit tests themselves
#--------------------------------------------------------------------------------------
unitTestObjs = $[@wildcard $(collectionTestObjectsDir)*$(oext)]

%warn $(collectionTestObjectsDir)
%warn $[@wildcard $(collectionTestObjectsDir)*$(oext)]

DLM_NAME            = UnitTests
DLM_DEST            = $(projectDir)
DLM_EXPORT_DEST     = $(projectDir)
DLM_EXTENSION       = $(shlibext)
DLM_OBJECT_FILES    = $(unitTestObjs)
DLM_EXPORT_OBJS     = $(unitTestObjs)
DLM_OBJECT_DEST     = $(o)
DLM_SYMB_DEST       = $(o)
DLM_MAP_DEST        = $(o)
DLM_NO_SIGN         = 1
DLM_NO_DEF          = 1
DLM_NO_DLS          = 1
DLM_NOENTRY         = 0
LINKER_LIBRARIES    = $[@wildcard $(collectionLibsDir)*$(libext)]

%include dlmlink.mki

#--------------------------------------------------------------------------------------
# Libs used by the test runner itself
#--------------------------------------------------------------------------------------
$(projectDir)Bentley.lib : $(BuildContext)SubParts/Libs/Bentley.lib
    $(LinkFirstDepToFirstTarget)

$(projectDir)BeSQLite.lib : $(BuildContext)SubParts/Libs/BeSQLite.lib
    $(LinkFirstDepToFirstTarget)

#--------------------------------------------------------------------------------------
# Deliver header files that VS will need in order to compile the test wrappers
#--------------------------------------------------------------------------------------
$(projectDir)PublicApi : $(BuildContext)PublicApi
    $(LinkFirstDepToFirstTargetAsDirectory)

$(projectDir)VendorApi : $(BuildContext)VendorApi
    $(LinkFirstDepToFirstTargetAsDirectory)

#--------------------------------------------------------------------------------------
# Update the .vcxproj file to reference all assets and put them to project dir
# N.B. Also need to add the actual unit tests DLL created above
# N.B. Also always need BeSQLite for our test setup, however it cannot be duplicated...
#--------------------------------------------------------------------------------------

ForcedBeSQLiteDll =
%ifnofile $(collectionAssembliesDir)BeSQLite$(DLM_API_NUMBER).dll
    ForcedBeSQLiteDll = BeSQLite$(DLM_API_NUMBER).dll
    always:
        ~linkfile "$(projectDir)BeSQLite$(DLM_API_NUMBER).dll=$(BuildContext)SubParts/Assemblies/BeSQLite$(DLM_API_NUMBER).dll"
%endif

always:
    >$(tmp)deliverables.list
    $[@subst $(collectionAssetsDir) "" $[@wildcard $(collectionAssetsDir)*]]
    $[@subst $(collectionAssembliesDir) "" $[@wildcard $(collectionAssembliesDir)*]]
    $(ForcedBeSQLiteDll)
    $(DLM_NAME)$(DLM_API_NUMBER).dll
    <
    $(baseDir)AddAssetReferencesToVSProject.py $(projectDir)BeTestTest1.vcxproj $(tmp)deliverables.list
    CopyWithSymlinks.py $(collectionAssetsDir) $(projectDir)
    CopyWithSymlinks.py $(collectionAssembliesDir) $(projectDir)

# Visual Studio cannot deal with linked WINMD files (similar for PFX files).
# You'll get "corrupt" WINMD errors when it tries to create an APPX package.
# This is a brute force way to deal with it via wildcards...
always:
    >$(o)RemoveWinmdLinks.bat
    PUSHD $(projectDir)
    MKDIR __winmdtemp
    COPY *.winmd __winmdtemp
    DEL *.winmd
    COPY __winmdtemp/*.winmd .
    RMDIR \/s \/q __winmdtemp
    POPD
    <
    $(o)RemoveWinmdLinks.bat

#--------------------------------------------------------------------------------------
# Build
#--------------------------------------------------------------------------------------
MSBuildExe = msbuild.exe
MSBuildArgs = \
    \/verbosity:Normal \
    $[@addprefix \/property:, $(MSBuildProperties)]

MSBuildProperties = Platform=x86
%if "WinRTx64" == $(TARGET_PROCESSOR_ARCHITECTURE)
    MSBuildProperties = Platform=x64
%endif

%if !defined (NDEBUG)
    MSBuildProperties + Configuration=Debug
%else
    MSBuildProperties + Configuration=Release
%endif
    
always:
    $(MSBuildExe) \/target:Build $(MSBuildArgs) $(projectDir)BeTestTest1.sln

#--------------------------------------------------------------------------------------
# Clean

# We cannot save pre-built UWP unit tests as LKGs because Microsoft uses
# obnoxiously long file names, and we end up exceeding MAX_PATH. The current
# approach is to clean the project so that we can at least post buildable unit
# test projects that can be built and run later. By "buildable", the only code
# physically in our unit test shell are the wrappers around the tests, but the
# tests and libraries themselves remain pre-built by the rest of the build, so
# this isn't cheating in terms of validating production code.

# Also note that asking msbuild to clean does not actually remove all files...

# Also note that if the user wants to run the tests (knowing they cannot save
# LKGs), don't clean the project.

#--------------------------------------------------------------------------------------
%if !defined (RUN_UWP_TESTS)
always:
    $(MSBuildExe) \/target:Clean $(MSBuildArgs) $(projectDir)BeTestTest1.sln
%if defined (NDEBUG)
    -rmdir \/s \/q $(projectDir)Release
%else
    -rmdir \/s \/q $(projectDir)Debug
%endif
%endif

#--------------------------------------------------------------------------------------
# Delivery
#--------------------------------------------------------------------------------------
$(BuildContext)Delivery/$(TEST_NAME)UwpTest : ${projectDir}
    $(LinkFirstDepToFirstTargetAsDirectory)
