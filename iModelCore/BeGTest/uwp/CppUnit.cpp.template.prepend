#include <SDKDDKVer.h>
#include "CppUnitTest.h"
#include <Bentley/BeTest.h>
#include <Bentley/BeAssert.h>
#include <Bentley/BeFileName.h>
#include <Logging/bentleylogging.h>
#include <BeSQLite/L10N.h>
#include <stdlib.h>
#include "BeTestHost.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

static void doSetUpL10N ()
    {
    BeFileName frameworkSqlang;
    BeTest::GetHost().GetFrameworkSqlangFiles(frameworkSqlang);
    // Some tests do not have language file. Skip L10N initialization because L10N assert will block the test.
    if(frameworkSqlang.DoesPathExist())
        BeSQLite::L10N::Initialize(frameworkSqlang);
    }

//static void doTearDownL10N ()
//    {
//    BeSQLite::L10N::Shutdown ();
//    }

static void doSetUp ()
    {
    if (BeTest::IsInitialized())
        return;

    BeTest::Initialize (*BeTestHost::Create(nullptr));

    NativeLogging::LoggingConfig::SetOption (CONFIG_OPTION_DEFAULT_SEVERITY, LOG_TEXT_WARNING);
    NativeLogging::LoggingConfig::ActivateProvider (NativeLogging::CONSOLE_LOGGING_PROVIDER);
    NativeLogging::LoggingConfig::SetSeverity (L"Performance", NativeLogging::LOG_ERROR);

    doSetUpL10N();
    }

static void doTearDown ()
    {
    // BeTest::Uninitialize (); No! CppTest does not call TearDownTestCase as a bookend to each SetUpTestCase method. Instead,
    //                              it calls SetUpTestCase methods as it goes along and then calls all TearDownTestCase methods
    //                              at the end, one after another. So, if each TearDownTestCase method were to uninitialize
    //                              BeTest, then it would be invalid when the next TearDownTestCase method ran. In fact, some
    //                              TearDownTestCase implementations use the BeTest host.
    }

