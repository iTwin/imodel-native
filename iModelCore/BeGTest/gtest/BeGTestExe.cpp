/*--------------------------------------------------------------------------------------+
|
|     $Source: gtest/BeGTestExe.cpp $
|
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#if defined (BENTLEY_WIN32)
    // WIP_BEFILENAME_PORTABILITY - need better way of setting temp directory
    #include <windows.h>
    #include <stdio.h>
    #include <assert.h>
#endif

#include <future>
#include <thread>
#include <chrono>
#include <iostream>

#include <Bentley/BeTest.h>
#include <Bentley/BeFileName.h>
#include <Bentley/BeTimeUtilities.h>
#include <Bentley/Desktop/FileSystem.h>
#include <BeSQLite/L10N.h>
#include <Logging/bentleylogging.h>
#include <TEST_FRAMEWORK_SQLANG_DEF.h> // This file is generated by buildGtest.mke

#if defined(BENTLEY_WIN32)
/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Farhad.Kabir                    07/2017
+---------------+---------------+---------------+---------------+---------------+------*/
bool SpawnProcessWin32 (char *command, DWORD &returnCode)
    {
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    bool ret = false;

    ZeroMemory( &si, sizeof(si) );
    si.cb = sizeof(si);
    ZeroMemory( &pi, sizeof(pi) );

    // Start the child process.
    if( !CreateProcessA (NULL,      // No module name (use command line).
                         command,    // Command line.
                         NULL,       // Process handle not inheritable.
                         NULL,       // Thread handle not inheritable.
                         FALSE,      // Set handle inheritance to FALSE.
                         0,          // No creation flags.
                         NULL,       // Use parent's environment block.
                         NULL,       // Use parent's starting directory.
                         &si,        // Pointer to STARTUPINFO structure.
                         &pi )       // Pointer to PROCESS_INFORMATION structure.
       )
        {
        DWORD error = GetLastError ();
        printf ("error == %d\n", error);
        goto exit;
        }

    // Wait until child process exits.
    WaitForSingleObject (pi.hProcess, INFINITE);

    // Check exit code
    DWORD dwExitCode = 0;

    GetExitCodeProcess (pi.hProcess, &dwExitCode);

    if(dwExitCode == STILL_ACTIVE)    
        {
        // Process did not terminate -> force it
        TerminateProcess (pi.hProcess, 0); // Zero is the exit code in this example
        returnCode = 0;
        }
    else
        {
        returnCode = dwExitCode;
        }

    // Close process and thread handles.
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );

    ret = true;

exit:
    return ret;
    }
#endif // BENTLEY_WIN32

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson
+---------------+---------------+---------------+---------------+---------------+------*/
#if defined(BENTLEY_WIN32)
static BentleyStatus getFileNameFromEnv (BeFileName& fn, CharCP envname)
    {
    WString filepath (getenv(envname), BentleyCharEncoding::Utf8);
    if (filepath.empty())
        return ERROR;
    fn.SetName (filepath);
    return SUCCESS;
    }
#endif

/*---------------------------------------------------------------------------------**//**
* This class knows how data files are linked into the Product/BeGTest directory structure.
* @bsimethod                                    Sam.Wilson                      10/2011
+---------------+---------------+---------------+---------------+---------------+------*/
struct BeGTestHost : RefCounted<BeTest::Host>
    {
    BeFileName m_programPath;

    BeGTestHost (char const* progDir)
        {
        m_programPath = BeFileName (BeFileName::DevAndDir, WString(progDir, true).c_str());
        if ( m_programPath.IsEmpty() ) // We get progdir from argv[0] , if we execute it from CWD argv[0] is blank. in which case BeFileName is not able to resolve full path. So creating path ".\" 
            {
            m_programPath.AppendString(L".");
            m_programPath.AppendSeparator();
            }
        m_programPath.BeGetFullPathName ();
        }

    void GetRunRoot (BeFileName& path)
        {
        path = m_programPath;
        path.AppendToPath (L"run");
        }

    void _GetDocumentsRoot (BeFileName& path) override
        {
        path = m_programPath;
        path.AppendToPath (L"Assets");
        path.AppendToPath (L"Documents");
        path.AppendSeparator ();
        }

    void _GetDgnPlatformAssetsDirectory (BeFileName& path) override
        {
        path = m_programPath;
        path.AppendToPath (L"Assets");
        path.AppendSeparator ();
        }

    void _GetOutputRoot (BeFileName& path) override
        {
        GetRunRoot (path);
        path.AppendToPath (L"Output");
        path.AppendSeparator ();
        }

    void _GetTempDir (BeFileName& path) override
        {
        GetRunRoot (path);
        path.AppendToPath (L"Temp");
        path.AppendSeparator ();
        }

    void _GetFrameworkSqlangFiles (BeFileName& path) override
        {
        GetDgnPlatformAssetsDirectory(path);
        path.AppendToPath(L"sqlang");
        path.AppendToPath(TEST_FRAMEWORK_SQLANG); // This macro is defined by buildGtest.mke
        }

    void*  _InvokeP (char const* request, void* arg) override
        {
        if (0==strncmp (request, "foo", 3))
            {
            return new Utf8String ("foo");
            }
        NativeLogging::LoggingManager::GetLogger(L"BeTest")->errorv ("Unknown upcall %hs", request);
        return NULL;
        }

    static RefCountedPtr<BeGTestHost> Create (char const* progDir) {return new BeGTestHost (progDir);}
    };

#if defined(BENTLEY_WIN32)
static wchar_t const* s_configFileName = L"logging.config.xml";

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson
+---------------+---------------+---------------+---------------+---------------+------*/
static BentleyStatus getLogConfigurationFilename (BeFileName& configFile, char const* argv0)
    {
    if (SUCCESS == getFileNameFromEnv (configFile, "BEGTEST_LOGGING_CONFIG"))
        {
        if (BeFileName::DoesPathExist (configFile))
            {
            printf ("BeGTest configuring logging with %s (Set by BEGTEST_LOGGING_CONFIG environment variable.)\n", Utf8String(configFile.GetName()).c_str());
            return SUCCESS;
            }
        }

    configFile = BeFileName (BeFileName::DevAndDir, WString(argv0,true).c_str());
    configFile.AppendToPath (s_configFileName);
    configFile.BeGetFullPathName ();
    if (BeFileName::DoesPathExist (configFile))
        {
        printf ("BeGTest configuring logging using %s. Override by setting BEGTEST_LOGGING_CONFIG in environment.\n", Utf8String(configFile.GetName()).c_str());
        return SUCCESS;
        }

    return ERROR;
    }
#endif

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      10/2011
+---------------+---------------+---------------+---------------+---------------+------*/
static void initLogging (char const* argv0)
    {
// The default logging provider on non-Windows Desktop goes to stdout and processes no configuration or filters.
// As such, it is extremely noisy and CPU-intensive.
// Therefore, disable it on affected platforms. The better solution would be to implement a better logging provider on these platforms.
#if defined(BENTLEY_WIN32)
    BeFileName configFile;
    if (SUCCESS == getLogConfigurationFilename(configFile, argv0))
        {
        NativeLogging::LoggingConfig::SetOption (CONFIG_OPTION_CONFIG_FILE, configFile);
        NativeLogging::LoggingConfig::ActivateProvider (NativeLogging::LOG4CXX_LOGGING_PROVIDER);
        }
    else
        {
        printf ("Logging.config.xml not found. BeGTest configuring default logging using console provider.\n");
        NativeLogging::LoggingConfig::ActivateProvider (NativeLogging::CONSOLE_LOGGING_PROVIDER);
        NativeLogging::LoggingConfig::SetSeverity (L"Performance", NativeLogging::LOG_TRACE);
        }
#endif
    }

static void recreateDir(BeFileNameCR dirName)
    {
    BeFileName::EmptyAndRemoveDirectory (dirName.c_str());
    BeFileName::CreateNewDirectory (dirName.c_str());
    }

/*---------------------------------------------------------------------------------**//**
* This is the TestListener that can act on certain events
* @bsiclass                                    Majd.Uddin                      08/2012
+---------------+---------------+---------------+---------------+---------------+------*/
class BeGTestListener : public ::testing::EmptyTestEventListener
    {
    Utf8String m_currTestCaseName;
    Utf8String m_currTestName;

    virtual void OnTestStart (const ::testing::TestInfo& test_info) override
        {
        m_currTestCaseName = test_info.test_case_name();
        m_currTestName = test_info.name();

        // Remove the temp directory at the start of every test to simulate the transitory nature of temp on some platforms.
        BeFileName dirName;
        BeTest::GetHost().GetTempDir(dirName);
        recreateDir(dirName);
        }

    virtual void OnTestEnd (const ::testing::TestInfo& test_info) override
        {
        // In case a test disabled asserts and forget to re-enable them!
        if (!BeTest::GetFailOnAssert())
            {
            FAIL() << "This test called BeTest::SetFailOnAssert(false) and failed to call it again with true.";
            }
        BeTest::SetFailOnAssert(true);
        }

    // Called after a failed assertion or a SUCCEED() invocation.
    virtual void OnTestPartResult(const ::testing::TestPartResult& test_part_result) 
        {
        }

    virtual void OnTestProgramEnd(const ::testing::UnitTest& unit_test) override
        {
        fprintf (stderr, "\n\n%d tests passed, %d tests failed, %d tests were disabled\n", unit_test.successful_test_count(), unit_test.failed_test_count(), unit_test.disabled_test_count());
        }
    };

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Bern.McCarty                   02/2013
+---------------+---------------+---------------+---------------+---------------+------*/
void initializeSqlangLocalization(BeGTestHost* hostP)
    {
    BeFileName frameworkSqlang;
    hostP->GetFrameworkSqlangFiles(frameworkSqlang);
    // Some tests do not have language file. Skip L10N initialization because L10N assert will block the test.
    if(frameworkSqlang.DoesPathExist())
        BeSQLite::L10N::Initialize(frameworkSqlang);
    }

#if defined(BENTLEY_WIN32)
/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Farhad.Kabir                    07/2017
+---------------+---------------+---------------+---------------+---------------+------*/
char const * getTestName(int argC, bvector<CharP> argv)
    {
    for (int i = 1; i < argC; i++) 
        {
        Utf8String utf8Str(argv[i]);
        if (utf8Str.Contains("--gtest_filter"))
            {
            bvector<Utf8String> tokens;
            BeStringUtilities::Split(argv[i], "=", nullptr, tokens);

            return tokens[1].c_str();
            }
        }
    return "";
    }
bool umdh_Use(int argC, char *argv[]) 
    {
    for (int i = 1; i < argC; i++) 
        {
        if (strcmp(argv[i], "--umdh") == 0) return true;
        }
    return false;
    }
#endif
#if defined(BENTLEY_WIN32)
/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Farhad.Kabir                    07/2017
+---------------+---------------+---------------+---------------+---------------+------*/
const char * WinGetEnv(const char * name)
    {
    const DWORD buffSize = 65535;
    static char buffer[buffSize];
    if (GetEnvironmentVariableA(name, buffer, buffSize))
        {
        return buffer;
        }
    else
        {
        return 0;
        }
    }
int WinSetEnv(const char * name, const char * value) 
    {
    return SetEnvironmentVariableA(name, value);
    }
#endif

//---------------------------------------------------------------------------------------
// @bsimethod                                                   Taslim.Murad    01/2018
//---------------------------------------------------------------------------------------
static int runAllTestsWithTimeout(uint64_t timeoutInSeconds)
    {
    std::promise<bool> promisedFinished;
    auto futureResult = promisedFinished.get_future();
    int testResult = 0;
    bool didComplete = false;
    
    std::thread ([&]
        {
        BeThreadUtilities::SetCurrentThreadName("Test Runner Thread");
        BeTest::setS_mainThreadId(BeThreadUtilities::GetCurrentThreadId());
        testResult = RUN_ALL_TESTS();
        didComplete = true;        
        promisedFinished.set_value(true);
        }).detach();
    
    EXPECT_TRUE(std::future_status::ready == futureResult.wait_for(std::chrono::seconds(timeoutInSeconds)));
    
    if (!didComplete)
        {
        printf("\n");
        printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
        printf("ERROR: Test suite exceeded %" PRIu64 " second(s) and was aborted.\n", timeoutInSeconds);
        printf("       Errors reported above may either be due to the termination of the test,\n");
        printf("       or may be clues for the hang and/or deadlock.\n");
        printf("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n");
        printf("\n");
        
        return 1;
        }
    
    return testResult;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      10/2011
+---------------+---------------+---------------+---------------+---------------+------*/
extern "C"
int main(int argc, char **argv)
    {
    int no = argc;
    bvector<CharP> args;
    for (int i = 0; i < no; i++) 
        {
        args.push_back(argv[i]);
        }
    auto hostPtr = BeGTestHost::Create(argv[0]);

    //  Make sure output directies exist (and remove any results hanging around from a previous run)
    BeFileName dirName;
    hostPtr->GetOutputRoot(dirName);
    recreateDir(dirName);
    hostPtr->GetTempDir(dirName);
    recreateDir(dirName);

    //  Finish initializing libraries
    initializeSqlangLocalization(hostPtr.get());
    BeTest::Initialize(*hostPtr);
    ::testing::InitGoogleTest(&argc, argv);
    ::testing::InitGoogleMock(&argc, argv);
    //listener with test failure output
    ::testing::TestEventListeners& listeners = ::testing::UnitTest::GetInstance()->listeners();
    listeners.Append(new BeGTestListener);

    initLogging(argv[0]);

    //  Configure the test runner
    BeTest::SetRunningUnderGtest();

    BeTest::SetAssertionFailureHandler([](WCharCP msg) {FAIL() << msg;});

    if (::testing::GTEST_FLAG(filter).empty() || ::testing::GTEST_FLAG(filter) == "*")
        { // use ignore lists if the user did not specify any filters on the command line
        Utf8String toignore, torun;
        BeTest::LoadFilters(toignore, torun);
        bastring filters;
        if (!toignore.empty())
            filters.assign("-").append(toignore);
        if (!torun.empty())
            {
            if (!filters.empty())
                filters.append(":");
            filters.assign("+").append(torun);
            }
        if (!filters.empty())
            ::testing::GTEST_FLAG(filter) = filters.c_str();
        }
    int check = 0;
#if defined(BENTLEY_WIN32)   

    char strCommand[1024];
    bool spawnRet;
    DWORD retCode;
    Utf8String gflagsSet;
    Utf8String pathSnapshot1;
    Utf8String pathSnapshot2;
    Utf8String pathComparison;
    Utf8String umdhPathJoin;
    Utf8String symbolPath;
    Utf8String gflagsPathJoin;

    if (umdh_Use(argc, argv))
        {
        RUN_ALL_TESTS();

        check = 1;
        
        BeFileName outdirName;
        hostPtr->GetOutputRoot(outdirName);
        outdirName.PopDir();
        WString currentDirectory(outdirName.GetName());
        //set _NT_SYMBOL_PATH
        BeStringUtilities::WCharToUtf8(symbolPath, currentDirectory.c_str());
        printf("%d\n",WinSetEnv("_NT_SYMBOL_PATH", symbolPath.c_str()));
        printf("Symbols path is   :   %s\n", WinGetEnv("_NT_SYMBOL_PATH"));

        CharCP winSdkDir = WinGetEnv("Win10SdkDir");
        CharCP  defArch = "x64";

        bvector<Utf8CP> umdhPath2 = {winSdkDir,"Debuggers\\", defArch,"\\umdh.exe" };
        bvector<Utf8CP> gflagsPath2 = {winSdkDir,"Debuggers\\", defArch,"\\gflags.exe" };
        umdhPathJoin =  BeStringUtilities::Join(umdhPath2);
        gflagsPathJoin =  BeStringUtilities::Join(gflagsPath2);

        WString currentDirectoryExe = currentDirectory ;
        currentDirectoryExe.AppendUtf8("\\");
        currentDirectoryExe.AppendUtf8(argv[0]);
        BeStringUtilities::WCharToUtf8(gflagsSet, currentDirectoryExe.c_str());
        bvector<Utf8CP> gflagsEnable = {gflagsPathJoin.c_str(), " -i ", gflagsSet.c_str(), " +ust"  };
        Utf8String setGflags =  BeStringUtilities::Join(gflagsEnable);

        sprintf_s(strCommand, sizeof(strCommand), setGflags.c_str());
        spawnRet = SpawnProcessWin32(strCommand, retCode);

        //first snapshot
        CharP log1Name = "\\FirstSnapshot.log";
        currentDirectory.AppendUtf8(log1Name);

        BeStringUtilities::WCharToUtf8(pathSnapshot1, currentDirectory.c_str());

        bvector<Utf8CP> snapshot1 = {umdhPathJoin.c_str(), " -p:%ld -f:", pathSnapshot1.c_str()  };
        Utf8String generateSnapshot1 =  BeStringUtilities::Join(snapshot1);

        // For debugging purposes, take initial snapshot of memory
        sprintf_s(strCommand, sizeof(strCommand), generateSnapshot1.c_str(), GetCurrentProcessId());
        spawnRet = SpawnProcessWin32(strCommand, retCode);
        }
#endif
    int errors = 0;
    if (check == 0)
    {//  Run the tests
       // errors = RUN_ALL_TESTS(); 
        int timeoutInSeconds = 1800;
        bool timeOutStatus = false;
        for (int i = 1; i < no; i++)
        {
            Utf8String utf8Str (argv[i]);
            if (utf8Str.Contains ("--timeout"))
            {
                timeOutStatus = true;
                bvector<Utf8String> tokens;
                BeStringUtilities::Split (argv[i], "=", nullptr, tokens);
                timeoutInSeconds = atoi (tokens[1].c_str ());
                if (timeoutInSeconds == -1)
                {
                    //run tests without timeout 
                     errors = RUN_ALL_TESTS ();
                }
                else
                {
                    //run tests with specified time out value
                     errors = runAllTestsWithTimeout (timeoutInSeconds);
                }
            }
        }
        if (timeOutStatus == false)
        {
            //run tests with default time out value which is 30 minutes
            errors = runAllTestsWithTimeout (timeoutInSeconds);
        }

    }

#if defined(BENTLEY_WIN32)
    if (umdh_Use(argc, argv))
        {
        for (int i = 0; i < 5; i++)
            {
            RUN_ALL_TESTS();
            }
        BeFileName outdirName;
        hostPtr->GetOutputRoot(outdirName);
        outdirName.PopDir();
        WString currentDirectory2(outdirName.GetName());
        WString currentDirectory3(outdirName.GetName());
        CharP log2Name = "\\SecondSnapshot.log";
        CharP logComparisonName = "";

        CharCP testName = getTestName(no, args);
        Utf8String utf8Str(testName);
        char pathCompComm[1024];

        if (utf8Str.Equals(""))
            {
            logComparisonName = "\\Comparison.log";
            currentDirectory3.AppendUtf8(logComparisonName);
            }
        else
            {
            sprintf_s(pathCompComm, sizeof(pathCompComm), "\\%s.log", testName);
            currentDirectory3.AppendUtf8(pathCompComm);
            }

        currentDirectory2.AppendUtf8(log2Name);

        BeStringUtilities::WCharToUtf8(pathSnapshot2, currentDirectory2.c_str());
        BeStringUtilities::WCharToUtf8(pathComparison, currentDirectory3.c_str());

        bvector<Utf8CP> snapshot2 = {umdhPathJoin.c_str(), " -p:%ld -f:", pathSnapshot2.c_str()  };
        Utf8String generateSnapshot2 =  BeStringUtilities::Join(snapshot2);

        // For debugging purposes, take terminal snapshot of memory
        sprintf_s(strCommand, sizeof(strCommand), generateSnapshot2.c_str(), GetCurrentProcessId());
        spawnRet = SpawnProcessWin32(strCommand, retCode);

        bvector<Utf8CP> snapshotDiff = { umdhPathJoin.c_str(), " -d ",pathSnapshot1.c_str()," ", pathSnapshot2.c_str()," -f:",pathComparison.c_str() };
        Utf8String generateComparisonLog =  BeStringUtilities::Join(snapshotDiff);
        // Now take a diff of the two dumps
        sprintf_s(strCommand, sizeof(strCommand), generateComparisonLog.c_str());
        spawnRet = SpawnProcessWin32(strCommand, retCode);

        printf(strCommand, "\n");


        bvector<Utf8CP> gflagsDisable = { gflagsPathJoin.c_str(), " -i ", gflagsSet.c_str(), " -ust" };
        Utf8String disGflags = BeStringUtilities::Join(gflagsDisable);

        sprintf_s(strCommand, sizeof(strCommand), disGflags.c_str());
        spawnRet = SpawnProcessWin32(strCommand, retCode);

    }
#endif
    return errors;
    }
