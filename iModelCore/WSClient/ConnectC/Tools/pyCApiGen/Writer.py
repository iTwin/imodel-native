import datetime
import os.path

from SchemaWriter.Helpers.PropertyTypeError import PropertyTypeError


class Writer(object):
    _COMMENT_AutoGen = "//--------------------------------------------------------------------------------------+\n"   \
                       "// <auto-generated>\n"                                                                         \
                       "//     This code was generated by the pyCApiGen tool on {0}.\n"                                 \
                       "//\n"                                                                                          \
                       "//     Changes to this file may cause incorrect behavior and will be lost if\n"                \
                       "//     the code is regenerated.\n"                                                             \
                       "// </auto-generated>\n"                                                                        \
                       "//--------------------------------------------------------------------------------------+\n"   \


    _COMMENT_Copyright = "/*--------------------------------------------------------------------------------------+\n" \
                         "|\n"                                                                                         \
                         "|     $Source: ConnectC/Tools/pyCApiGen/Writer.py $\n"                                       \
                         "|\n"                                                                                         \
                         "|  $Copyright: (c) 2017 Bentley Systems, Incorporated. All rights reserved. $\n"              \
                         "|\n"                                                                                         \
                         "+--------------------------------------------------------------------------------------*/\n" \

    _COMMENT_GroupStart = "/****************************************************************************************\n" \
                          "* \defgroup {0} {1}\n"                                                                     \
                          "* \{{\n"                                                                                    \
                          "****************************************************************************************/\n"

    _COMMENT_GroupDef = "/*!\n"      \
                        "\def {0}\n" \
                        "{1}\n"      \
                        "*/\n"

    _COMMENT_GroupBriefShort = "/**\n"            \
                               "* \\brief {0} \n" \
                               "*/\n"

    _COMMENT_GroupBriefLong = "/****************************************************************************************\n" \
                              "* \\brief {0}\n"                                                                             \
                              "* {1}\n"                                                                                     \
                              "****************************************************************************************/\n"

    _COMMENT_GroupEnd = "/** \} */\n"

    _COMMENT_BsiMethod = "/*--------------------------------------------------------------------------------------+\n" \
                         "* @bsimethod                                                                    {0}\n"       \
                         "+---------------+---------------+---------------+---------------+---------------+------*/\n" \
        .format(datetime.date.today().strftime('%m/%Y'))

    def __init__(self, ecschemas, filename, api, status_codes):
        self._ecschemas = ecschemas
        directory_name = os.path.dirname(filename)
        if not os.path.exists(directory_name):
            os.makedirs(directory_name)
        self._file = open(filename, "w")
        self._api = api
        self._status_codes = status_codes
        self._COMMENT_AutoGen = self._COMMENT_AutoGen.format(datetime.date.today().strftime("%B %d, %Y"))
        self._COMMENT_Copyright = self._COMMENT_Copyright.format(os.path.basename(self._file.name), datetime.date.today().strftime("%Y"))

    def _write_spacing(self):
        self._file.write('\n')

    def _close_file(self):
        self._file.flush()
        self._file.close()

    def ecschemas_have_ecclass_with_property_type(self, property_type):
        for ecschema in self._ecschemas:
            if self.ecschema_has_ecclass_with_property_type(ecschema, property_type):
                return True
        return False
    
    def ecschema_has_ecclass_with_property_type(self, ecschema, property_type):
        for ecclass in ecschema.get_classes():
            if ecclass.does_contain_property_type(property_type):
                return True
        return False
    
    def ecschema_has_included_ecclass_with_property_type(self, ecschema, property_type):
        for ecclass in ecschema.get_classes():
            if not ecclass.should_exclude_entire_class() and ecclass.does_contain_property_type(property_type):
                return True
        return False
    
    def _write_header_comments(self, is_header=False, should_include_in_api=None):
        self._file.write(self._COMMENT_Copyright)
        if is_header:
            self._file.write('#pragma once\n')
        if should_include_in_api is True:
            self._file.write('//__PUBLISH_SECTION_START__\n')
        elif should_include_in_api is False:
            self._file.write('//__BENTLEY_INTERNAL_ONLY__\n')
        self._file.write(self._COMMENT_AutoGen)

    @staticmethod
    def _get_wsg_buffer_accessor_function_comment(property_type):
        comment_str = "/****************************************************************************************\n"
        comment_str += "* Get a {0} property from a wsg buffer\n".format(property_type.title())
        comment_str += "****************************************************************************************/\n"
        return comment_str

    def __get_wsg_buffer_accessor_function_def(self, property_type):
        if property_type is 'StringLength':
            accessor_str = "CallStatus WSG_DataBufferGetStringLength\n"
        else:
            accessor_str = "CallStatus WSG_DataBufferGet{0}Property\n".format(property_type.title())
        accessor_str += "(\n"
        accessor_str += "LP{0} api,\nH{0}BUFFER buf,\n".format(self._api.get_upper_api_acronym())
        accessor_str += "int16_t bufferProperty,\n"
        accessor_str += "uint32_t index,\n"
        if property_type == "string":
            accessor_str += "uint32_t strLength,\n"
            accessor_str += "WCharP str\n"
        elif property_type == "StringLength":
            accessor_str += "size_t* outStringSize\n"
        elif property_type == "dateTime":
            accessor_str += "uint32_t strLength,\n"
            accessor_str += "WCharP dateTime\n"
        elif property_type == "guid":
            accessor_str += "uint32_t strLength,\n"
            accessor_str += "WCharP guid\n"
        elif property_type == "boolean":
            accessor_str += "bool* boolean\n"
        elif property_type == "int":
            accessor_str += "int32_t* integer\n"
        elif property_type == "double":
            accessor_str += "double* pDouble\n"
        elif property_type == "long":
            accessor_str += "int64_t* pLong\n"
        else:
            raise PropertyTypeError("Property type {0} not accepted".format(property_type))
        accessor_str += ")"
        return accessor_str

    def _get_wsg_buffer_accessor_function_definition(self, property_type):
        return self.__get_wsg_buffer_accessor_function_def(property_type) + ';\n'

    def _get_wsg_buffer_accessor_function_implementation(self, property_type):
        accessor_str = self.__get_wsg_buffer_accessor_function_def(property_type) + '\n'
        accessor_str += "    {\n"
        accessor_str += "    switch (buf->lSchemaType)\n"
        accessor_str += "        {\n"
        for schema in self._ecschemas:
            if self.ecschema_has_included_ecclass_with_property_type(schema, property_type):
                accessor_str += '        case SCHEMA_TYPE_{0}:\n'.format(schema.get_upper_name())
                accessor_str += '            {\n'
                if property_type is 'StringLength':
                    accessor_str += "            return {0}_GetStringLength".format(schema.get_name())
                else:
                    accessor_str += "            return {0}_Get{1}Property".format(schema.get_name(), property_type.title())
                if property_type == "string":
                    accessor_str += "(api, buf, bufferProperty, index, strLength, str);\n"
                elif property_type == "StringLength":
                    accessor_str += "(api, buf, bufferProperty, index, outStringSize);\n"
                elif property_type == "dateTime":
                    accessor_str += "(api, buf, bufferProperty, index, strLength, dateTime);\n"
                elif property_type == "guid":
                    accessor_str += "(api, buf, bufferProperty, index, strLength, guid);\n"
                elif property_type == "boolean":
                    accessor_str += "(api, buf, bufferProperty, index, boolean);\n"
                elif property_type == "int":
                    accessor_str += "(api, buf, bufferProperty, index, integer);\n"
                elif property_type == "double":
                    accessor_str += "(api, buf, bufferProperty, index, pDouble);\n"
                elif property_type == "long":
                    accessor_str += "(api, buf, bufferProperty, index, pLong);\n"
                else:
                    raise PropertyTypeError("Property type {0} not accepted".format(property_type))
                accessor_str += '            }\n'
        accessor_str += "        default:\n"
        accessor_str += '            api->SetStatusMessage("{1}");\n            api->SetStatusDescription("{2}");\n' \
                        '            return {0};\n'.format("INVALID_PARAMETER", self._status_codes["INVALID_PARAMETER"].message,
                                                            "The buffer type passed in is invalid.")
        accessor_str += "        }\n"
        accessor_str += "    }\n"
        return accessor_str
