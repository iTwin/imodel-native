import datetime
import os.path

from SchemaWriter.Helpers.PropertyTypeError import PropertyTypeError


class Writer(object):
    _COMMENT_AutoGen = "//--------------------------------------------------------------------------------------+\n"   \
                       "// <auto-generated>\n"                                                                         \
                       "//     This code was generated by the pyCApiGen tool on {0}.\n"                                 \
                       "//\n"                                                                                          \
                       "//     Changes to this file may cause incorrect behavior and will be lost if\n"                \
                       "//     the code is regenerated.\n"                                                             \
                       "// </auto-generated>\n"                                                                        \
                       "//--------------------------------------------------------------------------------------+\n"   \


    _COMMENT_Copyright = "/*--------------------------------------------------------------------------------------+\n" \
                         "|\n"                                                                                         \
                         "|     $Source: ConnectC/Tools/pyCApiGen/Writer.py $\n"                                       \
                         "|\n"                                                                                         \
                         "|  $Copyright: (c) 2016 Bentley Systems, Incorporated. All rights reserved. $\n"              \
                         "|\n"                                                                                         \
                         "+--------------------------------------------------------------------------------------*/\n" \

    _COMMENT_GroupStart = "/************************************************************************************//**\n" \
                          "* \defgroup {0} {1}\n"                                                                     \
                          "* \{{\n"                                                                                    \
                          "****************************************************************************************/\n"

    _COMMENT_GroupDef = "/*!\n"      \
                        "\def {0}\n" \
                        "{1}\n"      \
                        "*/\n"

    _COMMENT_GroupBriefShort = "/**\n"            \
                               "* \\brief {0} \n" \
                               "*/\n"

    _COMMENT_GroupBriefLong = "/************************************************************************************//**\n" \
                              "* \\brief {0}\n"                                                                             \
                              "* {1}\n"                                                                                     \
                              "****************************************************************************************/\n"

    _COMMENT_GroupEnd = "/** \} */\n"

    _COMMENT_BsiMethod = "/*---------------------------------------------------------------------------------**//**\n" \
                         "* @bsimethod                                                                    {0}\n"       \
                         "+---------------+---------------+---------------+---------------+---------------+------*/\n" \
        .format(datetime.date.today().strftime('%m/%Y'))

    def __init__(self, ecschemas, filename, api, status_codes):
        self._ecschemas = ecschemas
        directory_name = os.path.dirname(filename)
        if not os.path.exists(directory_name):
            os.makedirs(directory_name)
        self._file = open(filename, "w")
        self._api = api
        self._status_codes = status_codes
        self._COMMENT_AutoGen = self._COMMENT_AutoGen.format(datetime.date.today().strftime("%B %d, %Y"))
        self._COMMENT_Copyright = self._COMMENT_Copyright.format(os.path.basename(self._file.name), datetime.date.today().strftime("%Y"))

    def _write_spacing(self):
        self._file.write('\n')

    def _close_file(self):
        self._file.flush()
        self._file.close()

    def ecschemas_have_ecclass_with_property_type(self, property_type):
        for ecschema in self._ecschemas:
            for ecclass in ecschema.get_classes():
                if ecclass.does_contain_property_type(property_type):
                    return True
        return False

    def _write_header_comments(self, is_header=False, should_include_in_api=None):
        self._file.write(self._COMMENT_Copyright)
        if is_header:
            self._file.write('#pragma once\n')
        if should_include_in_api is True:
            self._file.write('//__PUBLISH_SECTION_START__\n')
        elif should_include_in_api is False:
            self._file.write('//__BENTLEY_INTERNAL_ONLY__\n')
        self._file.write(self._COMMENT_AutoGen)

    def _get_api_buffer_accessor_function_comment(self, property_type):
        comment_str = "/************************************************************************************//**\n"
        comment_str += "* \\brief Get a {0} property from a data buffer\n".format(property_type.title())
        comment_str += "* \param[in] apiHandle handle to api\n"
        comment_str += "* \param[in] dataBuffer Data buffer\n"
        comment_str += "* \param[in] bufferProperty buffer property\n"
        comment_str += "* \param[in] index buffer index\n"
        if property_type == "string":
            comment_str += "* \param[in] strLength buffer length\n"
            comment_str += "* \param[out] str Pointer to buffer to store string property\n"
        elif property_type == "StringLength":
            comment_str += "* \param[out] outStringSize Pointer to store the string length\n"
        elif property_type == "guid":
            comment_str += "* \param[in] strLength guid-buffer length\n"
            comment_str += "* \param[out] guid Pointer to buffer to store GUID property\n"
        elif property_type == "boolean":
            comment_str += "* \param[out] boolean Pointer to bool to store property\n"
        elif property_type == "int":
            comment_str += "* \param[out] integer Pointer to int to store property\n"
        elif property_type == "double":
            comment_str += "* \param[out] pDouble Pointer to double to store property\n"
        elif property_type == "long":
            comment_str += "* \param[out] pLong Pointer to long to store property\n"
        else:
            raise PropertyTypeError("Property type {0} not accepted".format(property_type))
        comment_str += "* \\return Success or error code. See \\ref {0}StatusCodes\n".format(self._api.get_api_name())
        comment_str += "****************************************************************************************/\n"
        return comment_str

    def __get_api_buffer_accessor_function_def(self, property_type):
        if property_type is 'StringLength':
            accessor_str = "CallStatus {0}_DataBufferGetStringLength\n".format(self._api.get_api_name())
        else:
            accessor_str = "CallStatus {0}_DataBufferGet{1}Property\n".format(self._api.get_api_name(),
                                                                              property_type.title())
        accessor_str += "(\n"
        accessor_str += "{0}HANDLE apiHandle,\n{0}DATABUFHANDLE dataBuffer,\n".format(self._api.get_upper_api_acronym())
        accessor_str += "int16_t bufferProperty,\n"
        accessor_str += "uint32_t index,\n"
        if property_type == "string":
            accessor_str += "uint32_t strLength,\n"
            accessor_str += "WCharP str\n"
        elif property_type == "StringLength":
            accessor_str += "size_t* outStringSize\n"
        elif property_type == "guid":
            accessor_str += "uint32_t strLength,\n"
            accessor_str += "WCharP guid\n"
        elif property_type == "boolean":
            accessor_str += "bool* boolean\n"
        elif property_type == "int":
            accessor_str += "int32_t* integer\n"
        elif property_type == "double":
            accessor_str += "double* pDouble\n"
        elif property_type == "long":
            accessor_str += "int64_t* pLong\n"
        else:
            raise PropertyTypeError("Property type {0} not accepted".format(property_type))
        accessor_str += ")"
        return accessor_str

    def _get_api_buffer_accessor_function_definition(self, property_type):
        return "{0}_EXPORT ".format(self._api.get_upper_api_acronym()) + self.__get_api_buffer_accessor_function_def(property_type) + ';\n'

    def _get_api_buffer_accessor_function_implementation(self, property_type):
        accessor_str = self.__get_api_buffer_accessor_function_def(property_type) + '\n'
        accessor_str += "    {\n"
        accessor_str += "    VERIFY_API\n"
        accessor_str += "    if(nullptr == dataBuffer)\n"
        accessor_str += '        {\n'
        accessor_str += '        api->SetStatusMessage("{1}");\n        api->SetStatusDescription("{2}");\n' \
                        '        return {0};\n        }}\n\n'.format("INVALID_PARAMETER", self._status_codes["INVALID_PARAMETER"].message,
                                                                     "The dataBuffer passed into {0} data access function is invalid."
                                                                     .format(self._api.get_api_name()))
        accessor_str += "    H{0}BUFFER buf = (H{0}BUFFER) dataBuffer;\n\n".format(self._api.get_api_acronym())
        accessor_str += "    switch (buf->lSchemaType)\n"
        accessor_str += "        {\n"
        for schema in self._ecschemas:
            accessor_str += '        case SCHEMA_TYPE_{0}:\n'.format(schema.get_upper_name())
            accessor_str += '            {\n'
            if property_type is 'StringLength':
                    accessor_str += "            return {0}_GetStringLength".format(schema.get_name())
            else:
                accessor_str += "            return {0}_Get{1}Property".format(schema.get_name(), property_type.title())
            if property_type == "string":
                accessor_str += "(api, buf, bufferProperty, index, strLength, str);\n"
            elif property_type == "StringLength":
                accessor_str += "(api, buf, bufferProperty, index, outStringSize);\n"
            elif property_type == "guid":
                accessor_str += "(api, buf, bufferProperty, index, strLength, guid);\n"
            elif property_type == "boolean":
                accessor_str += "(api, buf, bufferProperty, index, boolean);\n"
            elif property_type == "int":
                accessor_str += "(api, buf, bufferProperty, index, integer);\n"
            elif property_type == "double":
                accessor_str += "(api, buf, bufferProperty, index, pDouble);\n"
            elif property_type == "long":
                accessor_str += "(api, buf, bufferProperty, index, pLong);\n"
            else:
                raise PropertyTypeError("Property type {0} not accepted".format(property_type))
            accessor_str += '            }\n'
        accessor_str += "        default:\n"
        accessor_str += '            api->SetStatusMessage("{1}");\n            api->SetStatusDescription("{2}");\n' \
                        '            return {0};\n'.format("INVALID_PARAMETER", self._status_codes["INVALID_PARAMETER"].message,
                                                           "The buffer type passed in is invalid.")
        accessor_str += "        }\n"
        accessor_str += "    }\n"
        return accessor_str
