//===========================================================================
// $Header$
//
//    (C) Copyright 2007 by Autodesk, Inc.
//
// The information contained herein is confidential, proprietary
// to Autodesk, Inc., and considered a trade secret as defined 
// in section 499C of the penal code of the State of California.  
// Use of this information by anyone other than authorized employees
// of Autodesk, Inc. is granted only under a written non-disclosure 
// agreement, expressly prescribing the scope and manner of such use.       
//
// CREATED BY:
//      Norm Olsen
//
// DESCRIPTION:
//

#include "csConsoleUtilities.hpp"

extern "C" unsigned long KcsNmInvNumber;
extern "C" unsigned long KcsNmMapNoNumber;

// This module generates a test file in the OsGeo MetaCrs format.  The test
// data is generated by using a specific version of the CS-MAP library and is
// intended to be used to verify that a subsequent version of the library
// produces identical results.  That is, a rather dumb, but rigorous, 
// regression test.
//
// Clearly, this module needs to be built separately for each release to be
// tested, linking with the appropriate csmap.lib file.  Thus, it may be
// desirable to save in version control the actual executable module.
//
// The file is written with the provided name to the "csDataDir" folder.
// The dictionary files used are required to be located in the "csDictDir"
// folder.

// Generated test cases are created in the form oa the following structure.
// This structure is then passed to a specific function, csWriteRegressRecord,
// which thern writes the record to the output stream in the desired format.
// Changing the form is a matter of tweaking the csWriteRegressRecord function.
// For format variations requiring additional fields, just add such to the
// existing repetoire.

struct csRegressRecord
{
	wchar_t testName [64];
	wchar_t testMethod [32];
	wchar_t srcCrsAuthority [32];
	wchar_t srcCrsID [64];
	wchar_t trgCrsAuthority [32];
	wchar_t trgCrsID [64];
	double srcCoordinate [3];
	double trgCoordinate [3];
	double trgTolerance [3];
	wchar_t dataSource [128];
	wchar_t dataComment [256];
};

struct csCrsRange
{
	double rangeSW [2];
	double rangeNE [2];
};

// The following sdtructure is used to generate a list of coordinate systems
// to test, and the useful range associated with them.
struct csCrsTestData
{
	char crsName [32];
	ulong32_t epsgCode;
	csCrsRange range;
};

bool csGenerateTestPointsLL2D (std::wofstream& regressStrm);
bool csGenerateTestPointsCRS (std::wofstream& regressStrm);
bool csWriteRegressRecord (std::wofstream& regressStrm,csRegressRecord& testCase);
bool csRangeIntersect (csCrsRange& primary,csCrsRange& secondary,csCrsRange& intersection,
																 csCrsRange& outerLimit);
bool csGenerateSourcePoint (double testPoint [3],csCrsRange usefulRange,int testNumber);
bool csGenerateTargetPoint2D (double targetPoint [3],const char* srcName,const char* trgName,double sourcePoint [3]);

bool csGenerateRegressTestFile (const wchar_t* fileName,const wchar_t* csDataDir,const wchar_t* csDictDir)
{
	bool ok (false);

	char dictDirC [1024];
	wchar_t filePath [MAXPATH + MAXPATH];

	if (wcslen (fileName) > (MAXPATH - 10))
	{
		return false;
	}

	// Create the output stream.
	wcsncpy (filePath,csDataDir,MAXPATH);
	filePath [MAXPATH - 1] = L'\0';
	wcscat (filePath,L"\\");
	wcscat (filePath,fileName);
	std::wofstream regressStrm (filePath,std::ios_base::out | std::ios_base::trunc);
	ok = regressStrm.is_open ();
	if (ok)
	{
		wcstombs (dictDirC,csDictDir,sizeof (dictDirC));
		int st = CS_altdr (dictDirC);
		ok = (st == 0);
		if (ok)
		{
			ok = csGenerateTestPointsLL2D (regressStrm);
		}
		regressStrm.close ();
	}
	return ok;
}
bool csGenerateTestPointsCRS (std::wofstream& regressStrm)
{
	return false;
}
bool csGenerateTestPointsLL2D (std::wofstream& regressStrm)
{
	bool ok (false);
	bool intersects;

	int llCount;
	int testNumber;

	cs_Csgrplst_ *grpListPtr;
	cs_Csgrplst_ *grpListHdr;

	csCrsRange intersection;
	csCrsRange outerLimits;
	csRegressRecord regressTest;

	std::vector<csCrsTestData> testData;

	const TcsEpsgDataSetV6* epsgPtr = GetEpsgObjectPtr ();
	ok = (epsgPtr != 0);
	if (!ok) return ok;

	// This is an LL2D test generator.  We'll add a 3D module after we get
	// this to work.
	wcsncpy (regressTest.testMethod,L"CRS2D",wcCount (regressTest.testMethod));

	// The remainder of this stuff is the same for all tests.
	wcsncpy (regressTest.srcCrsAuthority,L"CSMAP",wcCount (regressTest.srcCrsAuthority));
	wcsncpy (regressTest.trgCrsAuthority,L"CSMAP",wcCount (regressTest.trgCrsAuthority));
	wcsncpy (regressTest.dataSource,L"CsMap-13.01",wcCount (regressTest.dataSource));
	wcsncpy (regressTest.dataComment,L"Generated by automatic processes using CS-MAP release 13.01",wcCount (regressTest.dataComment));

	// Loop through the coordinate system dictionary and generate a list of all
	// geographic coordinate systems, using the NameMapper to assign an EPSG
	// code to each entry, and then using the EPSG code to obtain a useful
	// range from the EPSG database.
	llCount = CS_csgrp ("LL",&grpListHdr);
	ok = (llCount > 0) && (grpListHdr != 0);
	for (grpListPtr = grpListHdr;ok && grpListPtr != NULL;grpListPtr = grpListPtr->next)
	{
		csCrsTestData nextTest;
		CS_stncp (nextTest.crsName,grpListPtr->key_nm,sizeof (nextTest.crsName));
		nextTest.range.rangeSW [0] = 0.0;
		nextTest.range.rangeSW [1] = 0.0;
		nextTest.range.rangeNE [0] = 0.0;
		nextTest.range.rangeNE [1] = 0.0;
		nextTest.epsgCode =  csMapNameToIdC (csMapGeographicCSysKeyName,csMapFlvrEpsg,csMapFlvrAutodesk,grpListPtr->key_nm);

		// Note, for now we do not generate a test if there is nmno EPSG code
		// mapping.  This leaves out a few, but all the major ones will be
		// included.
		if (nextTest.epsgCode != KcsNmInvNumber && nextTest.epsgCode != KcsNmMapNoNumber)
		{
			TcsEpsgCode epsgAreaCode;
			epsgPtr->GetFieldByCode (epsgAreaCode,epsgTblReferenceSystem,epsgFldAreaOfUseCode,nextTest.epsgCode);
			if (epsgAreaCode.IsValid ())
			{
				double south;
				double north;
				double left;
				double right;
				double deltaEW;
				double deltaNS;

				epsgPtr->GetFieldByCode (south,epsgTblArea,epsgFldAreaSouthBoundLat,epsgAreaCode);
				epsgPtr->GetFieldByCode (north,epsgTblArea,epsgFldAreaNorthBoundLat,epsgAreaCode);
				epsgPtr->GetFieldByCode (left,epsgTblArea,epsgFldAreaWestBoundLng,epsgAreaCode);
				epsgPtr->GetFieldByCode (right,epsgTblArea,epsgFldAreaEastBoundLng,epsgAreaCode);

				// Expand the region of coverage by 25%.
				deltaNS = fabs (north - south) * 0.125;
				if (right < left) 
				{ 
					deltaEW =  fabs ((right + 360.0) - left) * 0.125;
				}
				else
				{
					deltaEW = fabs (right - left) * 0.125;
				}
				south -= deltaNS;
				north += deltaNS;
				left  -= deltaEW;
				right += deltaEW;
				
				if (south <  -90.0) south =  -90.0;
				if (north >   90.0) north =   90.0;
				if (left  < -180.0) left  = -180.0;
				if (right >  180.0) right =  180.0;
				
				nextTest.range.rangeSW [0] = left;
				nextTest.range.rangeSW [1] = south;
				nextTest.range.rangeNE [0] = right;
				nextTest.range.rangeNE [1] = north;
			}
			testData.push_back (nextTest);
		}
	}
	CS_csgrpf (grpListHdr);

	testNumber = 0;
	std::vector<csCrsTestData>::iterator iiItr;
	std::vector<csCrsTestData>::iterator jjItr;
	for (iiItr = testData.begin ();ok && iiItr != testData.end ();iiItr++)
	{
		for (jjItr = (iiItr + 1);ok && jjItr != testData.end ();jjItr++)
		{
			// The following will be the same for all tests generated for
			// this unique paring of geographic systems.
			mbstowcs (regressTest.srcCrsID,iiItr->crsName,sizeof (regressTest.srcCrsID));
			mbstowcs (regressTest.trgCrsID,jjItr->crsName,sizeof (regressTest.trgCrsID));
			regressTest.trgTolerance [0] = 1.0E-10;
			regressTest.trgTolerance [1] = 1.0E-10;
			regressTest.trgTolerance [2] = 1.0E-03;

			// See if there is an intersection between the useful range of the
			// two systems.  We do this first as the intersection function also
			// gives us the outer limits.  We always generate a single test
			// based on the outer limits.
			intersects = csRangeIntersect (iiItr->range,jjItr->range,intersection,outerLimits);

			// We always generate a single test based on the outer limits.
			testNumber += 1;
			swprintf (regressTest.testName,L"CsMap-13.01-%05d",testNumber);
			ok = csGenerateSourcePoint (regressTest.srcCoordinate,outerLimits,testNumber);
			if (ok)
			{
				ok = csGenerateTargetPoint2D (regressTest.trgCoordinate,iiItr->crsName,jjItr->crsName,regressTest.srcCoordinate);
				if (ok)
				{
					ok = csWriteRegressRecord (regressStrm,regressTest);
				}
			}

			if (ok && intersects)
			{
				// We generate a few more tests if the useful ranges actually
				// intersect.
				for (int testCount = 0;ok && testCount < 4;testCount += 1)
				{
					testNumber += 1;
					swprintf (regressTest.testName,L"CsMap-13.01-%05d",testNumber);
					ok = csGenerateSourcePoint (regressTest.srcCoordinate,intersection,testNumber);
					if (ok)
					{
						ok = csGenerateTargetPoint2D (regressTest.trgCoordinate,iiItr->crsName,jjItr->crsName,regressTest.srcCoordinate);
						if (ok)
						{
							ok = csWriteRegressRecord (regressStrm,regressTest);
						}
					}
				}
			}
		}
	}
	return true;
}
bool csWriteRegressRecord (std::wofstream& regressStrm,csRegressRecord& testCase)
{
	bool ok (false);

	regressStrm	<< testCase.testName                    << L',';
	regressStrm	<< testCase.testMethod                  << L',';
	regressStrm	<< testCase.srcCrsAuthority             << L',';
	regressStrm	<< testCase.srcCrsID                    << L',';
	regressStrm	<< testCase.trgCrsAuthority             << L',';
	regressStrm	<< testCase.trgCrsID                    << L',';
	regressStrm	<< dbl2wcs (testCase.srcCoordinate [0]) << L',';
	regressStrm	<< dbl2wcs (testCase.srcCoordinate [1]) << L',';
	regressStrm	<< dbl2wcs (testCase.srcCoordinate [2]) << L',';
	regressStrm	<< dbl2wcs (testCase.trgCoordinate [0]) << L',';
	regressStrm	<< dbl2wcs (testCase.trgCoordinate [1]) << L',';
	regressStrm	<< dbl2wcs (testCase.trgCoordinate [2]) << L',';
	regressStrm	<< dbl2wcs (testCase.trgTolerance [0])  << L',';
	regressStrm	<< dbl2wcs (testCase.trgTolerance [1])  << L',';
	regressStrm	<< dbl2wcs (testCase.trgTolerance [2])  << L',';
	regressStrm	<< testCase.dataSource                  << L',';
	regressStrm	<< testCase.dataComment                 << std::endl;
	ok = regressStrm.good ();
	return ok;
}
bool csRangeIntersect (csCrsRange& primary,csCrsRange& secondary,csCrsRange& intersection,
																 csCrsRange& outerLimit)
{
	bool intersects (false);

	// The Outer limit is easy, we'll do that first.
	outerLimit.rangeSW [0] = primary.rangeSW [0];
	outerLimit.rangeSW [1] = primary.rangeSW [1];
	outerLimit.rangeNE [0] = primary.rangeNE [0];
	outerLimit.rangeNE [1] = primary.rangeNE [1];

	if (secondary.rangeSW [0] < outerLimit.rangeSW [0]) outerLimit.rangeSW [0] = secondary.rangeSW [0];
	if (secondary.rangeSW [1] < outerLimit.rangeSW [1]) outerLimit.rangeSW [1] = secondary.rangeSW [1];
	if (secondary.rangeNE [0] < outerLimit.rangeNE [0]) outerLimit.rangeNE [0] = secondary.rangeNE [0];
	if (secondary.rangeNE [1] < outerLimit.rangeNE [1]) outerLimit.rangeNE [1] = secondary.rangeNE [1];

	intersection.rangeSW [0] = primary.rangeSW [0];
	intersection.rangeSW [1] = primary.rangeSW [1];
	intersection.rangeNE [0] = primary.rangeNE [0];
	intersection.rangeNE [1] = primary.rangeNE [1];
	if (secondary.rangeSW [0] > intersection.rangeSW [0]) intersection.rangeSW [0] = secondary.rangeSW [0];
	if (secondary.rangeSW [1] > intersection.rangeSW [1]) intersection.rangeSW [1] = secondary.rangeSW [1];
	if (secondary.rangeNE [0] < intersection.rangeNE [0]) intersection.rangeNE [0] = secondary.rangeNE [0];
	if (secondary.rangeNE [1] < intersection.rangeNE [1]) intersection.rangeNE [1] = secondary.rangeNE [1];

	bool swLng = (secondary.rangeSW [0] >= primary.rangeSW [0]) && (secondary.rangeSW [0] < primary.rangeNE [0]);
	bool swLat = (secondary.rangeSW [1] >= primary.rangeSW [1]) && (secondary.rangeSW [1] < primary.rangeNE [1]);
	bool neLng = (secondary.rangeNE [0] <= primary.rangeNE [0]) && (secondary.rangeNE [0] > primary.rangeSW [0]);
	bool neLat = (secondary.rangeNE [1] <= primary.rangeNE [1]) && (secondary.rangeNE [1] > primary.rangeSW [1]);
	intersects = (swLng && swLat) || (neLng && neLat);

	return intersects;
}
bool csGenerateSourcePoint (double sourcePoint [3],csCrsRange usefulRange,int testNumber)
{
	bool ok (false);

	int myVariation;

	double deltaEW;
	double deltaNS;
	double deltaZ;
	
	myVariation = testNumber % 7;
	deltaEW = fabs (usefulRange.rangeNE [0] - usefulRange.rangeSW [0]);
	deltaNS = fabs (usefulRange.rangeNE [1] - usefulRange.rangeSW [1]);
	
	switch (myVariation) {
	case 0:
		deltaEW *= 0.5;
		deltaNS *= 0.5;
		deltaZ   = 50.0;
		ok       = true;
		break;
	case 1:
		deltaEW *= 0.125;
		deltaNS *= 0.125;
		deltaZ   = 150.0;
		ok       = true;
		break;
	case 2:
		deltaEW *= 0.125;
		deltaNS *= 0.875;
		deltaZ   = 1.0;
		ok       = true;
		break;
	case 3:
		deltaEW *= 0.875;
		deltaNS *= 0.125;
		deltaZ   = 0.0;
		ok       = true;
		break;
	case 4:
		deltaEW *= 0.25;
		deltaNS *= 0.25;
		deltaZ   = 1500.0;
		ok       = true;
		break;
	case 5:
		deltaEW *= 0.75;
		deltaNS *= 0.75;
		deltaZ   = 0.0;
		ok       = true;
		break;
	case 6:
		deltaEW *= 0.1;
		deltaNS *= 0.9;
		deltaZ   = 10.0;
		ok       = true;
		break;
	default:
		deltaEW *= 0.5;
		deltaNS *= 0.5;
		deltaZ   = -50.0;
		ok       = true;
		break;
	}
	sourcePoint [0] = usefulRange.rangeSW [0] + deltaEW;
	sourcePoint [1] = usefulRange.rangeSW [1] + deltaNS;
	sourcePoint [2] = deltaZ;

	return ok;
}
bool csGenerateTargetPoint2D (double targetPoint [3],const char* srcName,const char* trgName,double sourcePoint [3])
{
	bool ok (false);

	int srcSt, dtmSt, trgSt;

	struct cs_Csprm_ *srcCRS;
	struct cs_Csprm_ *trgCRS;
	struct cs_Dtcprm_ *dtcPrm;

	double llhWrk [3];

	srcCRS = trgCRS = 0;
	dtcPrm = 0;

	srcCRS = CS_csloc (srcName);
	ok = (srcCRS != 0);
	if (ok)
	{
		trgCRS = CS_csloc (trgName);
		ok = (trgCRS != 0);
	}
	if (ok)
	{
		dtcPrm = CS_dtcsu (srcCRS,trgCRS,cs_DTCFLG_DAT_F,cs_DTCFLG_BLK_I);
		ok = (dtcPrm != 0);
	}
	if (ok)
	{
		srcSt = CS_cs2ll (srcCRS,llhWrk,sourcePoint);
		ok = (srcSt >= 0);
		if (ok)
		{
			dtmSt = CS_dtcvt (dtcPrm,llhWrk,llhWrk);
			ok = (dtmSt >= 0);
		}
		if (ok)
		{
			trgSt = CS_ll2cs (trgCRS,targetPoint,llhWrk);
			targetPoint [2] = 0.0;
			ok = (trgSt >= 0);
		}
	}
	if (srcCRS != 0)
	{
		CS_free (srcCRS);
		srcCRS = 0;
	}
	if (trgCRS != 0)
	{
		CS_free (trgCRS);
		trgCRS = 0;
	}
	if (dtcPrm != 0)
	{
		CS_dtcls (dtcPrm);
		dtcPrm = 0;
	}
	return ok;
}
