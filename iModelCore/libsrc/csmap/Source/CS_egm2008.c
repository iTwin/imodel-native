/*
 * Copyright (c) 2022, Autodesk, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the Autodesk, Inc. nor the names of its
 *       contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Autodesk, Inc. ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL Autodesk, Inc. OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include "cs_map.h"
/*
    This file contains the implementation of the Egm2008 object; i.e.
    struct cs_Egm2008_.

    Egm2008 is based on a binary file with (180/N + 1) rows x 360/N
    columns of geoid undulations. It provides geoid height data in 
    meters for the entire world by means of a N minute by N minute 
    grid structure.

    Each line contains two values which define the nature of the grid:
      [First] => The length of data in each record.
      [Last ] => The length of data in each record.

    This transformation involves the application of a geoid-ellipsoid 
    separation value interpolated from a geoid model. The model provides
    separation values at the nodes on a regular grid of latitude and
    longitude intersection points. The geodetic latitude and longitude
    used to interpolate within the grid are not affected by this 
    transformation.

    The grid is referenced to a specific geographic CRS (the horizontal
    component of the source CRS) and interpolation must be made in the
    latitude and longitude of this system.

    Calculation of the separation is achieved through a bi-linear
    interpolation of the grid, using the latitude and longitude of the
    point. This step provides the geoid-ellipsoid separation (N) above
    the ellipsoid of the source Geographic 3D CRS.

    Then:
           H = h - N

    where h = the height above the ellipsoid in the source geographic 3D CRS
    and   H = the gravity-related height in the target vertical CRS.

    Note that the official tool interp_2p5min.exe uses spline interpolation
    method, and we use bi-linear here. So the calculated result is slightly
    different from the result generated by interp_2p5min.exe. But it is 
    almost the same as the result generated by PE and Proj. The tolerance is
    less than 1 mm.
    Edge cases are also handled differently from CS_egm96. It uses similar
    logic to Proj.
*/

#ifdef GEOCOORD_ENHANCEMENT
// copied from cs_Vertical.h which is in the trunk of Csmap but not in the version (14.06) that we are currently using
/* Status values used internally in the grid file interpolation system.
Basically the same values as those used everywhere else in CS-MAP. */
#define csVGRIDI_ST_OK 0
#define csVGRIDI_ST_COVERAGE  1
#define csVGRIDI_ST_SYSTEM   -1
#endif

void CSreleaseEgm2008(struct cs_Egm2008_* __This)
{
    if (__This != NULL)
    {
        /* Close the file if opened. */
        if (__This->strm != NULL)
        {
            CS_fclose(__This->strm);
            __This->strm = NULL;
        }

        /* Delete the buffer is allocated. */
        if (__This->dataBuffer != NULL)
        {
            CS_free(__This->dataBuffer);
            __This->dataBuffer = NULL;
        }
        __This->bufferBeginPosition = -1L;
        __This->bufferEndPosition = -2L;
    }
    return;
}

void CSdeleteEgm2008(struct cs_Egm2008_* __This)
{
    if (__This != NULL)
    {
        CSreleaseEgm2008(__This);
        CS_free(__This);
    }
    return;
}

struct cs_Egm2008_* CSnewEgm2008(const char* filePath, double density)
{
    extern double cs_Zero;
    extern double cs_Km90;
    extern double cs_K360;
    extern double cs_K90;
    extern char csErrnam[];

    struct cs_Egm2008_* __This = NULL;
    long32_t elementssize;
    long filesize;

    /* Allocate and initialize the object. */
    __This = CS_malc(sizeof(struct cs_Egm2008_));
    if (__This == NULL)
    {
        CS_erpt(cs_NO_MEM);
        goto error;
    }

    /* Initialize the structure. */
    __This->southWest[LNG] = cs_Zero;
    __This->southWest[LAT] = cs_Km90;
    __This->northEast[LNG] = cs_K360;
    __This->northEast[LAT] = cs_K90;
    __This->density[LNG] = cs_Zero;
    __This->density[LAT] = cs_Zero;
    __This->searchDensity = density;
    __This->headerSize = 0L;
    __This->rowHeaderSize = sizeof(long32_t);
    __This->rowTailSize = sizeof(long32_t);
    __This->elementCount = 0L;
    __This->recordCount = 0L;
    __This->recordSize = 0L;
    __This->elementSize = sizeof(float);    //The size of point value is REAL*4.
    __This->strm = NULL;
    __This->bufferSize = 0L;
    __This->bufferBeginPosition = -1L;
    __This->bufferEndPosition = -2L;
    __This->dataBuffer = NULL;

    CS_stncp(__This->filePath, filePath, sizeof(__This->filePath));

    /* Open the binary file. */
    __This->strm = CS_fopen(__This->filePath, _STRM_BINRD);
    if (__This->strm == NULL)
    {
        CS_stncp(csErrnam, __This->filePath, MAXPATH);
        CS_erpt(cs_DTC_FILE);
        goto error;
    }

    /* The first and last elements in the row indicate how many elements are in a row.*/
    CS_fread(&elementssize, sizeof(elementssize), 1, __This->strm);
    if (elementssize <= 0)
    {
        CS_stncp(csErrnam, __This->filePath, MAXPATH);
        CS_erpt(cs_DTC_FILE);
        goto error;
    }
    CS_fseek(__This->strm, 0, SEEK_END);
    filesize = CS_ftell(__This->strm);
    CS_fseek(__This->strm, 0, SEEK_SET);

    __This->elementCount = elementssize / __This->elementSize;
    __This->recordSize = __This->elementCount * __This->elementSize + __This->rowHeaderSize + __This->rowTailSize;
    __This->recordCount = filesize / __This->recordSize;
    if (__This->recordCount <= 0)
    {
        CS_stncp(csErrnam, __This->filePath, MAXPATH);
        CS_erpt(cs_DTC_FILE);
        goto error;
    }
    __This->bufferSize = __This->recordSize * 4;
    __This->density[LNG] = (__This->northEast[LNG] - __This->southWest[LNG]) / __This->elementCount;
    __This->density[LAT] = (__This->northEast[LAT] - __This->southWest[LAT]) / (__This->recordCount - 1);
    /* For the egm grid, it should have the same density in lng and lat.*/
    if (fabs(__This->density[LNG] - __This->density[LAT]) > 1.0E-08)
    {
        CS_stncp(csErrnam, __This->filePath, MAXPATH);
        CS_erpt(cs_DTC_FILE);
        goto error;
    }

    /* Capture the proper search density. */
    __This->searchDensity = __This->density[LNG];
    if (__This->density[LAT] > __This->searchDensity)
    {
        __This->searchDensity = __This->density[LAT];
    }
    if (density > 0.0)
    {
        __This->searchDensity = density;
    }

    /* That's that. */
    return __This;
error:
    CSreleaseEgm2008(__This);
    return NULL;
}

int CScalcEgm2008(struct cs_Egm2008_* __This, double* geoidHgt, const double ll[2])
{
    extern double cs_Mhuge;
    extern char csErrnam[];
    extern double cs_Zero;
    extern double cs_K360;

    int southEdge;
    int eastEdge;

    long32_t readCount;
    long32_t checkCount;

    long32_t checkSeek;
    long32_t recNbr, eleNbr;
    long32_t recFirst, recLast;
    long32_t fposBegin, fposEnd;

    char* chrPtr;
    float* fltPtr;

    double lclLng, lclLat;
    double tt, uu;

    double cellNW[2];

    float southWest, southEast;
    float northWest, northEast;

    lclLng = ll[LNG];
    lclLat = ll[LAT];
    if (lclLng < __This->southWest[LNG])
    {
        lclLng += cs_K360;
    }

    /* Return now if out of range. */
    if (lclLng < __This->southWest[LNG] ||
        lclLng > __This->northEast[LNG] ||
        lclLat < __This->southWest[LAT] ||
        lclLat > __This->northEast[LAT])
    {
        *geoidHgt = cs_Zero;
        return csVGRIDI_ST_COVERAGE;
    }

    /* Compute the indices of the grid cells involved.  That is, the record and
       element number of the point which represents the NORTHwest corner of
       the grid cell which covers the point we have been given.

       Note, that the file is to proceed from North to South, then East to West.
       that is the specification.  Note, first record = 0, and first element = 0. */
    recNbr = (long32_t)((__This->northEast[LAT] - lclLat) / __This->density[LAT]);
    eleNbr = (long32_t)((lclLng - __This->southWest[LNG]) / __This->density[LNG]);

    /* Redundant; defensive purposes only. */
    if (recNbr < 0L || recNbr >= __This->recordCount ||
        eleNbr < 0L || eleNbr >= __This->elementCount)
    {
        *geoidHgt = cs_Zero;
        return csVGRIDI_ST_COVERAGE;
    }

    /* Are we on an edge?*/
    southEdge = FALSE;
    eastEdge = FALSE;
    if (recNbr >= (__This->recordCount - 1)) southEdge = TRUE;
    if (eleNbr >= (__This->elementCount - 1)) eastEdge = TRUE;

    /* Compute the lat/long of the southwest corner of the grid cell identified
       by the recNbr and eleNbr variables. */
    cellNW[LAT] = __This->northEast[LAT] - __This->density[LAT] * (double)recNbr;
    cellNW[LNG] = __This->southWest[LNG] + __This->density[LNG] * (double)eleNbr;

    /* Do we have a buffer?  Could have been released.  Maybe this is the
       first access. */
    if (__This->dataBuffer == NULL)
    {
        __This->dataBuffer = CS_malc((size_t)__This->bufferSize);
        if (__This->dataBuffer == NULL)
        {
            CS_erpt(cs_NO_MEM);
            goto error;
        }

        /* Make sure the rest of this stuff knows the buffer is empty.  These values
           will fail to match any specific file position. */
        __This->bufferBeginPosition = -1L;
        __This->bufferEndPosition = -2L;
    }

    /* Determine exactly what specific data is required.  Note when we go to
       the south "well", it only needs one raw records.*/
    fposBegin = __This->headerSize + (recNbr * __This->recordSize) + (eleNbr * __This->elementSize) + __This->rowHeaderSize;
    if (!southEdge)
    {
        fposEnd = fposBegin + __This->recordSize + __This->elementSize + __This->elementSize;
    }
    else
    {
        fposEnd = fposBegin + __This->elementSize + __This->elementSize;
    }

    /* Is the necessary data in the buffer already? */
    if (fposBegin < __This->bufferBeginPosition || fposBegin > __This->bufferEndPosition ||
        fposEnd   < __This->bufferBeginPosition || fposEnd   > __This->bufferEndPosition)
    {
        /* The data we need is not in the buffer.  If the file has been released,
           open it again now. */
        if (__This->strm == NULL)
        {
            __This->strm = CS_fopen(__This->filePath, _STRM_BINRD);
            if (__This->strm == NULL)
            {
                CS_stncp(csErrnam, __This->filePath, MAXPATH);
                CS_erpt(cs_DTC_FILE);
                goto error;
            }
            /* We do our own buffering, turn stream buffering off. */
#if !defined(GEOCOORD_ENHANCEMENT)
			setvbuf (__This->strm,NULL,_IONBF,0);
#else
			CS_setvbuf (__This->strm,NULL,_IONBF,0);
#endif
        }

        /* Fill the buffer with data, including the specific data that we need.
           Normally speaking, we always get four "records".*/
        recFirst = recNbr - 1;
        if (recFirst < 0)
        {
            recFirst = 0;
        }
        recLast = recNbr + 2;
        if (recLast > (__This->recordCount - 1))
        {
            recLast = __This->recordCount - 1;
        }
        readCount = (recLast - recFirst + 1) * __This->recordSize;
        if (readCount > __This->bufferSize)
        {
            CS_stncp(csErrnam, "CS_egm2008:1", MAXPATH);
            CS_erpt(cs_ISER);
            goto error;
        }
        /* It always starts with the first element in the row. Because the first
           element may be used when it is on the east edge.*/
        __This->bufferBeginPosition = __This->headerSize + (recFirst * __This->recordSize);
        __This->bufferEndPosition = __This->bufferBeginPosition + readCount;

        /* OK, read in the data. */
        checkSeek = CS_fseek(__This->strm, __This->bufferBeginPosition, SEEK_SET);
        if (checkSeek < 0L)
        {
            CS_stncp(csErrnam, __This->filePath, MAXPATH);
            CS_erpt(cs_IOERR);
            goto error;
        }
        checkCount = (long32_t)CS_fread(__This->dataBuffer, 1, (size_t)readCount, __This->strm);
        if (checkCount != readCount)
        {
            CS_stncp(csErrnam, __This->filePath, MAXPATH);
            CS_erpt(cs_INV_FILE);
            goto error;
        }
        if (CS_ferror(__This->strm))
        {
            CS_stncp(csErrnam, __This->filePath, MAXPATH);
            CS_erpt(cs_IOERR);
            goto error;
        }
    }

    /* Extract the grid cell. */
    chrPtr = (char*)__This->dataBuffer + (fposBegin - __This->bufferBeginPosition);
    fltPtr = (float*)(chrPtr);                                                    /*lint !e826*/
    northWest = *fltPtr;
    if (!eastEdge)
    {
        northEast = *(fltPtr + 1);
    }
    else
    {
        /*When we go to the east "well", we always fetch the first element in the current row.*/
        northEast = *(float*)(chrPtr - eleNbr * __This->elementSize);             /*lint !e826*/
    }
    if (!southEdge)
    {
        chrPtr += __This->recordSize;
        fltPtr = (float*)(chrPtr);                                                /*lint !e826*/
        southWest = *fltPtr;
        if (!eastEdge)
        {
            southEast = *(fltPtr + 1);
        }
        else
        {
            /*When we go to the east "well", we always fetch the first element in the current row.*/
            southEast = *(float*)(chrPtr - eleNbr * __This->elementSize);        /*lint !e826*/
        }
    }
    else
    {
        /*When we go to the south "well", we always use the north elements as the south elements.*/
        southWest = northWest;
        southEast = northEast;
    }

    /* Perform the bi-linear calculation. */
    tt = (lclLng - cellNW[LNG]) / __This->density[LNG];
    uu = (cellNW[LAT] - lclLat) / __This->density[LAT];

    /* Again, some defensive stuff. */
    if (uu < -1.0E-12 || tt < -1.0E-12 || uu > 1.0 || tt > 1.0)
    {
        CS_stncp(csErrnam, "CS_egm2008:2", MAXPATH);
        CS_erpt(cs_ISER);
        goto error;
    }

    /* OK, do the calculation. */
    *geoidHgt = northWest +
        tt * (northEast - northWest) +
        uu * (southWest - northWest) +
        tt * uu * (northWest - northEast - southWest + southEast);

    /* We're done. */
    return csVGRIDI_ST_OK;
error:
    *geoidHgt = cs_Mhuge;
    return csVGRIDI_ST_SYSTEM;
}

#ifndef GEOCOORD_ENHANCEMENT
/*lint -esym(550,list_sz)   variable not accessed */
/
int EXP_LVL9 CSegm2008Q(struct csVerticalXfromParmsFile_* fileParms, Const char* dictDir, int err_list[], int list_sz)
{
    extern char cs_DirsepC;
    extern char cs_Dir[];

    int err_cnt;
    size_t rdCnt;

    char* cp;
    csFILE* strm;

    char chrBuffer[16];
    char pathBuffer[MAXPATH];

    cp = fileParms->fileName;
    if (*cp == '.' && (*(cp + 1) == '\\' || *(cp + 1) == '/'))
    {
        CS_stncp(pathBuffer, dictDir, sizeof(pathBuffer));
        CS_stncat(pathBuffer, cp, MAXPATH);
    }
    else
    {
        CS_stncp(pathBuffer, cp, MAXPATH);
    }

    /* Force directory separator to the correct character for this run time
       environment.*/
    CSrplDirSep(pathBuffer);

    /* We will return (err_cnt + 1) below. */
    err_cnt = -1;
    if (err_list == NULL) list_sz = 0;

    /* Verify that the file exists and that the format appears to be correct. */
    strm = CS_fopen(pathBuffer, _STRM_BINRD);
    if (strm != NULL)
    {
        rdCnt = CS_fread(chrBuffer, 1, sizeof(chrBuffer), strm);
        CS_fclose(strm);
        strm = NULL;

        if (rdCnt != sizeof(chrBuffer))
        {
            if (++err_cnt < list_sz) err_list[err_cnt] = cs_VDTQ_GFILEFRMT;
        }
    }
    else
    {
        if (++err_cnt < list_sz) err_list[err_cnt] = cs_DTQ_FILE;
    }
    return (err_cnt + 1);
}
/*lint +esym(550,list_sz) */
int EXP_LVL9 CSegm2008S(struct cs_VGridFile_* gridFile)
{
    int status;

    struct cs_Egm2008_* egm2008Ptr;

    egm2008Ptr = CSnewEgm2008(gridFile->filePath, gridFile->density);
    if (egm2008Ptr != NULL)
    {
        gridFile->fileObject.egm2008Ptr = egm2008Ptr;
        gridFile->test = (cs_VTEST_CAST)CSegm2008T;
        gridFile->frwrd = (cs_FRWRD_CAST)CSegm2008F;
        gridFile->invrs = (cs_INVRS_CAST)CSegm2008I;
        gridFile->inRange = (cs_INRANGE_CAST)CSegm2008L;
        gridFile->release = (cs_RELEASE_CAST)CSegm2008R;
        gridFile->destroy = (cs_DESTROY_CAST)CSegm2008D;
        status = csVGRIDI_ST_OK;
    }
    else
    {
        status = csVGRIDI_ST_SYSTEM;
    }
    return status;
}
double CSegm2008T(struct cs_Egm2008_* __This, Const double srcLl[3])
{
    extern double cs_Zero;
    extern double cs_K360;

    double rtnValue;
    double lclLng;
    double lclLat;

    rtnValue = cs_Zero;
    lclLng = srcLl[LNG];
    lclLat = srcLl[LAT];
    if (lclLng < __This->southWest[LNG])
    {
        lclLng += cs_K360;
    }
    if (lclLng >= __This->southWest[LNG] &&
        lclLng <= __This->northEast[LNG] &&
        lclLat >= __This->southWest[LAT] &&
        lclLat <= __This->northEast[LAT])
    {
        rtnValue = __This->searchDensity;
    }
    return rtnValue;
}
int EXP_LVL9 CSegm2008F(struct cs_Egm2008_* egm2008, Const double srcLl[3], double* trgHeight)
{
    int status;
    double offset;
    status = CScalcEgm2008(egm2008, &offset, srcLl);
    if (status == csVGRIDI_ST_OK)
    {
        *trgHeight = srcLl[HGT] - offset;
    }
    return status;
}
int EXP_LVL9 CSegm2008I(struct cs_Egm2008_* egm2008, Const double srcLl[3], double* trgHeight)
{
    int status;
    double offset;
    status = CScalcEgm2008(egm2008, &offset, srcLl);
    if (status == csVGRIDI_ST_OK)
    {
        *trgHeight = srcLl[HGT] + offset;
    }
    return status;
}

int EXP_LVL9 CSegm2008L(struct cs_Egm2008_* egm2008, int cnt, Const double pnts[][3])
{
    extern double cs_Zero;

    double density = cs_Zero;
    int status;

    status = cs_CNVRT_OK;
    for (int i = 0; i < cnt; i++)
    {
        density = CSegm2008T(egm2008, pnts[i]);
        if (fabs(density) < 1.0E-08)
        {
            status = cs_CNVRT_USFL;
            break;
        }
    }
    return status;
}
int EXP_LVL9 CSegm2008N(struct cs_Egm2008_* egm2008)
{
    return FALSE;
}
int EXP_LVL9 CSegm2008R(struct cs_Egm2008_* egm2008)
{
    CSreleaseEgm2008(egm2008);
    return csVGRIDI_ST_OK;
}
int EXP_LVL9 CSegm2008D(struct cs_Egm2008_* egm2008)
{
    CSdeleteEgm2008(egm2008);
    return csVGRIDI_ST_OK;
}
#endif