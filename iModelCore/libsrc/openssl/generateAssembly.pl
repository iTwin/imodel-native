#!/usr/bin/perl
use strict;
use warnings;

use File::Spec::Functions 'catfile';
use File::Basename;
use Cwd;

my $rootDir = getcwd;
my @perlScripts = (
"vendor/crypto/aes/asm/aes-x86_64.pl",
"vendor/crypto/aes/asm/aesni-mb-x86_64.pl",
"vendor/crypto/aes/asm/aesni-sha1-x86_64.pl",
"vendor/crypto/aes/asm/aesni-sha256-x86_64.pl",
"vendor/crypto/aes/asm/aesni-x86_64.pl",
"vendor/crypto/aes/asm/bsaes-x86_64.pl",
"vendor/crypto/aes/asm/vpaes-x86_64.pl",
"vendor/crypto/bn/asm/rsaz-2k-avx512.pl",
"vendor/crypto/bn/asm/rsaz-3k-avx512.pl",
"vendor/crypto/bn/asm/rsaz-4k-avx512.pl",
"vendor/crypto/bn/asm/rsaz-avx2.pl",
"vendor/crypto/bn/asm/rsaz-x86_64.pl",
"vendor/crypto/bn/asm/x86_64-gf2m.pl",
"vendor/crypto/bn/asm/x86_64-mont.pl",
"vendor/crypto/bn/asm/x86_64-mont5.pl",
"vendor/crypto/camellia/asm/cmll-x86_64.pl",
"vendor/crypto/chacha/asm/chacha-x86_64.pl",
"vendor/crypto/ec/asm/ecp_nistz256-x86_64.pl",
"vendor/crypto/ec/asm/x25519-x86_64.pl",
"vendor/crypto/md5/asm/md5-x86_64.pl",
"vendor/crypto/modes/asm/aes-gcm-avx512.pl",
"vendor/crypto/modes/asm/aesni-gcm-x86_64.pl",
"vendor/crypto/modes/asm/ghash-x86_64.pl",
"vendor/crypto/poly1305/asm/poly1305-x86_64.pl",
"vendor/crypto/rc4/asm/rc4-md5-x86_64.pl",
"vendor/crypto/rc4/asm/rc4-x86_64.pl",
"vendor/crypto/sha/asm/keccak1600-x86_64.pl",
"vendor/crypto/sha/asm/sha1-mb-x86_64.pl",
"vendor/crypto/sha/asm/sha1-x86_64.pl",
"vendor/crypto/sha/asm/sha256-mb-x86_64.pl",
# "vendor/crypto/sha/asm/sha256-x86_64.pl", This one gets generated by sha512-x86_64.pl depending on output file 
"vendor/crypto/sha/asm/sha512-x86_64.pl",
"vendor/crypto/sha/asm/sha512-x86_64.pl", #NEEDS TO BE TWICE, the second one will generate 256.
"vendor/ms/uplink-x86_64.pl",
"vendor/crypto/whrlpool/asm/wp-x86_64.pl",
"vendor/crypto/x86_64cpuid.pl",
);
my $sha512counter = 0;
my @mkeFile = ();
my @objParts = ();
foreach(@perlScripts) {
    #need to special case uplink, and x86_64cpuid.pl
    my $fullPathToScript = catfile($rootDir, $_); #Note: This appears to convert / to \ in the path. THIS HAS IMPLICATIONS for regex substitution later on in this loop.
    my $asmOutputPath = $fullPathToScript;
    if (index($_, "x86_64cpuid.pl") == -1 && index($_, "uplink-x86_64.pl") == -1) { # uplink and cpuid don't have /asm path so can't
        $asmOutputPath =~ s/\\asm//; #rmoves /asm path for the output file 
    } elsif (index($_, "uplink-x86_64.pl") != -1) {
        $asmOutputPath =~ s/\\ms/\\crypto/; #remove ms and replace with crypto.
    }

    if (index($_, "sha512-x86_64.pl") != -1) {
        $sha512counter++;
        if ($sha512counter > 1) {
            $asmOutputPath =~ s/512/256/
        }
    }
    $asmOutputPath =~ s/\.pl/\.asm/; #replaces the .pl with .asm 
    my @ARGS = ("masm", $asmOutputPath);
    system($^X, $fullPathToScript, @ARGS);

    my $indexOfVendorFolder = index($asmOutputPath, "vendor");
    my $fileName = getFileName($asmOutputPath);
    my $strippedAsmPath = substr($asmOutputPath, $indexOfVendorFolder);
    $strippedAsmPath =~ s/vendor/\$\(vendorSrc\)/;
    $strippedAsmPath = "$strippedAsmPath \${MultiCompileDepends}";

    my $objectPart = "\$(o)$fileName\$(oext)";
    push (@objParts, ($objectPart));
    push(@mkeFile, ("$objectPart : $strippedAsmPath"));

    print "ran $fullPathToScript\n\t generated: $asmOutputPath\n";
}
print "\n";

foreach(@mkeFile) {
    print "$_\n\n";
    
}
my $setObjs = "~set objs \$(objs)";
foreach(@objParts) {
    $setObjs = "$setObjs $_";
}
print $setObjs;

sub getFileName {
    my $path = $_[0];
    my $file = basename($path);
    $file =~ s/\.asm//;
    return $file;
}