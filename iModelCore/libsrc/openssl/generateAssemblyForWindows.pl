#!/usr/bin/perl
use strict;
use warnings;

use File::Spec::Functions 'catfile';
use File::Basename;
use Cwd;

# This script was created by running Configure and make on a linux machine, seeing all the .s (assembly) files generated and then collecting all of the perl scripts 
# which generated those .s files. This script runs each pl script passing 'masm' to it and an output file. At the end of the script, 
# it prints a wall of text which can be copy and pasted (spacing not included) into BeOpenSSL.mke to compile the assembly files.

# Note: I tried to make this script work for linux and android as well, but there were too many inconsistencies between the .s files this script was generating and the ones generated by running 
# ./Configure and make on WSL. I think most of the differences came down to ENV variables in perl not being recognized, maybe a side effect of using /bin/sh when perl was executing commands?
# Not sure it is worth figuring out. I would just suggest taking whats produced by ./Configure and make on WSL. These assembly files probably don't change very often anyways.

my $rootDir = getcwd;
my @perlScripts = (
"vendor/crypto/aes/asm/aes-x86_64.pl",
"vendor/crypto/aes/asm/aesni-mb-x86_64.pl",
"vendor/crypto/aes/asm/aesni-sha1-x86_64.pl",
"vendor/crypto/aes/asm/aesni-sha256-x86_64.pl",
"vendor/crypto/aes/asm/aesni-x86_64.pl",
"vendor/crypto/aes/asm/bsaes-x86_64.pl",
"vendor/crypto/aes/asm/vpaes-x86_64.pl",
"vendor/crypto/bn/asm/rsaz-2k-avx512.pl",
"vendor/crypto/bn/asm/rsaz-3k-avx512.pl",
"vendor/crypto/bn/asm/rsaz-4k-avx512.pl",
"vendor/crypto/bn/asm/rsaz-avx2.pl",
"vendor/crypto/bn/asm/rsaz-x86_64.pl",
"vendor/crypto/bn/asm/x86_64-gf2m.pl",
"vendor/crypto/bn/asm/x86_64-mont.pl",
"vendor/crypto/bn/asm/x86_64-mont5.pl",
"vendor/crypto/camellia/asm/cmll-x86_64.pl",
"vendor/crypto/chacha/asm/chacha-x86_64.pl",
"vendor/crypto/ec/asm/ecp_nistz256-x86_64.pl",
"vendor/crypto/ec/asm/x25519-x86_64.pl",
"vendor/crypto/md5/asm/md5-x86_64.pl",
"vendor/crypto/modes/asm/aes-gcm-avx512.pl",
"vendor/crypto/modes/asm/aesni-gcm-x86_64.pl",
"vendor/crypto/modes/asm/ghash-x86_64.pl",
"vendor/crypto/poly1305/asm/poly1305-x86_64.pl",
"vendor/crypto/rc4/asm/rc4-md5-x86_64.pl",
"vendor/crypto/rc4/asm/rc4-x86_64.pl",
"vendor/crypto/sha/asm/keccak1600-x86_64.pl",
"vendor/crypto/sha/asm/sha1-mb-x86_64.pl",
"vendor/crypto/sha/asm/sha1-x86_64.pl",
"vendor/crypto/sha/asm/sha256-mb-x86_64.pl",
"vendor/crypto/sha/asm/sha512-x86_64.pl",
"vendor/crypto/sha/asm/sha512-x86_64.pl", #NEEDS TO BE TWICE, the second one will generate 256.
# "vendor/ms/uplink-x86_64.pl", not worth adding in. Isn't used on linux (I'm assuming this because Configuring on linux adds a OPENSSL_NO_UPLINK to configuration file).
"vendor/crypto/whrlpool/asm/wp-x86_64.pl",
"vendor/crypto/x86_64cpuid.pl",
);
my $sha512counter = 0;
my @mkeFile = ();
my @objParts = ();
foreach(@perlScripts) {
    #need to special case uplink, and x86_64cpuid.pl
    my $fullPathToScript = catfile($rootDir, $_); #Note: This appears to convert / to \ in the path in windows. THIS HAS IMPLICATIONS for regex substitution later on in this loop.
    my $asmOutputPath = $fullPathToScript;
    if (index($_, "x86_64cpuid.pl") == -1 && index($_, "uplink-x86_64.pl") == -1) { # uplink and cpuid don't have /asm path so can't remove /asm path
        $asmOutputPath =~ s/\\asm//; # rmoves /asm path for the output file 
    } elsif (index($_, "uplink-x86_64.pl") != -1) {
        $asmOutputPath =~ s/\\ms/\\crypto/; # remove ms and replace with crypto.
    }

    if (index($_, "sha512-x86_64.pl") != -1) { # This script generates 256 and 512, as long as we provide the right output path.
        $sha512counter++;
        if ($sha512counter > 1) {
            $asmOutputPath =~ s/512/256/
        }
    }
    $asmOutputPath =~ s/\.pl/\.asm/; # replaces the .pl with $fileExtension
    my @ARGS;
    @ARGS = ($fullPathToScript, "masm", $asmOutputPath);

    system($^X, @ARGS); # run the .pl script. $^X is the name used to execute the current copy of Perl.
    my $indexOfVendorFolder = index($asmOutputPath, "vendor");
    my $fileName = getFileName($asmOutputPath);
    my $strippedAsmPath = substr($asmOutputPath, $indexOfVendorFolder);
    $strippedAsmPath =~ s/vendor/\$\(vendorSrc\)/;
    $strippedAsmPath = "$strippedAsmPath \${MultiCompileDepends}";

    my $objectPart = "\$(o)$fileName\$(oext)";
    push (@objParts, ($objectPart));
    push(@mkeFile, ("$objectPart : $strippedAsmPath"));

    print "ran $fullPathToScript\n\t generated: $asmOutputPath\n";
}
print "\n";

foreach(@mkeFile) {
    print "$_\n\n";
    
}
my $setObjs = "\talways:\n\t~set objs \$(objs)";
foreach(@objParts) {
    $setObjs = "$setObjs $_";
}
print $setObjs;

sub getFileName {
    my $path = $_[0];
    my $file = basename($path);
    $file =~ s/\.asm//;
    return $file;
}