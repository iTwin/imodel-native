/*---------------------------------------------------------------------------------------------
* Copyright (c) Bentley Systems, Incorporated. All rights reserved.
* See LICENSE.md in the repository root for full copyright notice.
*--------------------------------------------------------------------------------------------*/
#include <Bentley/BeFileName.h>
#include <Bentley/BeFile.h>
#include <BeSQLite/BeSQLite.h>
#include <BeSQLite/CloudSqlite.h>
#include <GeoCoord/BaseGeoCoord.h>
#include <csmap/cs_map.h>
#include <csmap/cs_NameMapperSupport.h>
#include <csmap/cs_Legacy.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>
#if defined (BENTLEY_WIN32) || defined (BENTLEY_WINRT)
# include <direct.h>
# include <io.h>
# include <sstream>
#else
# include <unistd.h>
#endif
#include <GeoCoord/BaseGeoTiffKeysList.h>
#include    <BeXml/BeXml.h>
#include <algorithm>
#include <cctype>

// cs_wkt requires __CPP__ to be defined and the class TrcWktElement to be defined (what's up with that?)
#define __CPP__
class TrcWktElement;
#include    <csmap/CS_wkt.h>
#undef  __CPP__

USING_NAMESPACE_BENTLEY_LOGGING

BEGIN_EXTERN_C
 extern int      cs_Error;
 extern char     csErrnam[];
 extern struct   cs_Unittab_     cs_Unittab[];
 extern struct   cs_PrjprmMap_   cs_PrjprmMap[];
 extern struct   cs_Prjtab_      cs_Prjtab[];
 extern struct   cs_Prjprm_      csPrjprm[];
 extern char     cs_Csname[];
 extern char     cs_Dir[];
 extern char*    cs_DirP;
 extern int32_t csLatFrmt;
 extern int32_t csLngFrmt;
 extern int32_t csAnglFrmt;
 extern int32_t csXyFrmt;
 extern int32_t csZzFrmt;
 extern int32_t csRedFrmt;
 extern int32_t csSclFrmt;
 extern int32_t csCoefFrmt;
 extern const uint32_t KcsNmInvNumber;
 extern char cs_DirsepC;
 extern struct cs_Ostn97_ *cs_Ostn97Ptr;
 extern struct cs_Ostn02_ *cs_Ostn02Ptr;
 extern struct cs_Ostn15_ *cs_Ostn15Ptr;


//=======================================================================================
// @bsiclass
//=======================================================================================
struct _csFile {
    virtual size_t read(void* buffer, size_t size, size_t count)  = 0;
    virtual int seek(int64_t offset, int origin)  = 0;
    virtual int getc() = 0;
    virtual char* gets(char* str, int n) = 0;
    virtual int64_t tell() = 0;
    virtual int close() = 0;
    virtual int setvbuf(char* buffer, int mode, size_t size) = 0;
    virtual int flush() = 0;
    virtual int eof() = 0;
    virtual int error() = 0;
    virtual size_t write(const void* ptr, size_t size, size_t count) = 0;
    virtual int putc(int character) = 0;
    virtual int puts(const char* str) = 0;
    virtual int truncate(long writePosition) = 0;
    virtual int printf(Utf8CP format...) = 0;
    virtual ~_csFile() {}
    };

END_EXTERN_C

static Utf8String s_assetsDirPrefix = "assets";
static Utf8String s_assetsDir;

extern  bool CS_wktEllipsoidLookUp (const char* ellipsoidNameInWkt, char* csEllipsoidName);
extern  bool CS_wktDatumLookUp (const char* datumNameInWkt, char* csDatumName);
extern bool CS_wktProjectionMethodEPSGLookUp(int projectionCode, int* projectionMethodCode);

#define DIM(a) (sizeof(a)/sizeof(a[0]))

#define CSMAP_FREE_AND_CLEAR(ptr) {if (NULL != ptr){CSMap::CS_free (ptr) ; ptr=NULL;}}


USING_NAMESPACE_BENTLEY_SQLITE

BEGIN_BENTLEY_NAMESPACE
namespace GeoCoordinates {

BaseGCSPtr BaseGCS::s_LL84GCS(nullptr);

struct CoordSysData
{
DgnProjectionTypes              dgnProjectionType;  // this is the value saved in our coordinate system elements.
CharCP                          csMapKeyName;       // this is the CS-Map keyname.
BaseGCS::ProjectionCodeValue    csMapProjCodeValue; // this is the CS-Map Projection Code.
};

static  CoordSysData    csDataMap[] =
{
  { COORDSYS_ALBER,     CS_ALBER,   BaseGCS::pcvAlbersEqualArea,                            /* cs_PRJCOD_ALBER    */ },
  { COORDSYS_AZMEA,     CS_AZMEA,   BaseGCS::pcvLambertEqualAreaAzimuthal,                  /* cs_PRJCOD_AZMEA    */ },
  { COORDSYS_AZMED,     CS_AZMED,   BaseGCS::pcvLambertEquidistantAzimuthal,                /* cs_PRJCOD_AZMED    */ },
  { COORDSYS_BONNE,     CS_BONNE,   BaseGCS::pcvBonne,                                      /* cs_PRJCOD_BONNE    */ },
  { COORDSYS_BPCNC,     CS_BPCNC,   BaseGCS::pcvBipolarObliqueConformalConic,               /* cs_PRJCOD_BPCNC    */ },
  { COORDSYS_CSINI,     CS_CSINI,   BaseGCS::pcvCassini,                                    /* cs_PRJCOD_CSINI    */ },
  { COORDSYS_EDCNC,     CS_EDCNC,   BaseGCS::pcvEquidistantConic,                           /* cs_PRJCOD_EDCNC    */ },
  { COORDSYS_EDCYL,     CS_EDCYL,   BaseGCS::pcvEquidistantCylindrical,                     /* cs_PRJCOD_EDCYL    */ },
  { COORDSYS_EKRT4,     CS_EKRT4,   BaseGCS::pcvEckertIV,                                   /* cs_PRJCOD_EKRT4    */ },
  { COORDSYS_EKRT6,     CS_EKRT6,   BaseGCS::pcvEckertVI,                                   /* cs_PRJCOD_EKRT6    */ },
  { COORDSYS_GNOMC,     CS_GNOMC,   BaseGCS::pcvGnomonic,                                   /* cs_PRJCOD_GNOMC    */ },
  { COORDSYS_HMLSN,     CS_HMLSN,   BaseGCS::pcvGoodeHomolosine,                            /* cs_PRJCOD_HMLSN    */ },
  { COORDSYS_LMBRT,     CS_LMBRT,   BaseGCS::pcvLambertConformalConicTwoParallel,           /* cs_PRJCOD_LM2SP    */ },
  { COORDSYS_LMTAN,     CS_LMTAN,   BaseGCS::pcvLambertTangential,                          /* cs_PRJCOD_LMTAN    */ },
  { COORDSYS_MILLR,     CS_MILLR,   BaseGCS::pcvMillerCylindrical,                          /* cs_PRJCOD_MILLR    */ },
  { COORDSYS_MODPC,     CS_MODPC,   BaseGCS::pcvModifiedPolyconic,                          /* cs_PRJCOD_MODPC    */ },
  { COORDSYS_MOLWD,     CS_MOLWD,   BaseGCS::pcvMollweide,                                  /* cs_PRJCOD_MOLWD    */ },
  { COORDSYS_MRCAT,     CS_MRCAT,   BaseGCS::pcvMercator,                                   /* cs_PRJCOD_MRCAT    */ },
  { COORDSYS_MSTRO,     CS_MSTRO,   BaseGCS::pcvModifiedStereographic,                      /* cs_PRJCOD_MSTRO    */ },
  { COORDSYS_NACYL,     CS_NACYL,   BaseGCS::pcvEqualAreaAuthalicNormal,                    /* cs_PRJCOD_NACYL    */ },
  { COORDSYS_NZLND,     CS_NZLND,   BaseGCS::pcvNewZealandNationalGrid,                     /* cs_PRJCOD_NZLND    */ },
  { COORDSYS_OBLQ1,     CS_OBLQ1,   BaseGCS::pcvHotineObliqueMercator1XY,                   /* cs_PRJCOD_HOM1XY   */ },
  { COORDSYS_OBLQ2,     CS_OBLQ2,   BaseGCS::pcvHotineObliqueMercator2XY,                   /* cs_PRJCOD_HOM2XY   */ },
  { COORDSYS_ORTHO,     CS_ORTHO,   BaseGCS::pcvOrthographic,                               /* cs_PRJCOD_ORTHO    */ },
  { COORDSYS_PLYCN,     CS_PLYCN,   BaseGCS::pcvAmericanPolyconic,                          /* cs_PRJCOD_PLYCN    */ },
  { COORDSYS_ROBIN,     CS_ROBIN,   BaseGCS::pcvRobinsonCylindrical,                        /* cs_PRJCOD_ROBIN    */ },
  { COORDSYS_SINUS,     CS_SINUS,   BaseGCS::pcvSinusoidal,                                 /* cs_PRJCOD_SINUS    */ },
  { COORDSYS_STERO,     CS_STERO,   BaseGCS::pcvSnyderObliqueStereographic,                 /* cs_PRJCOD_SSTRO    */ },
  { COORDSYS_TACYL,     CS_TACYL,   BaseGCS::pcvEqualAreaAuthalicTransverse,                /* cs_PRJCOD_TACYL    */ },
  { COORDSYS_TRMER,     CS_TRMER,   BaseGCS::pcvTransverseMercator,                         /* cs_PRJCOD_TRMER    */ },
  { COORDSYS_UNITY,     CS_UNITY,   BaseGCS::pcvUnity,                                      /* cs_PRJCOD_UNITY    */ },
  { COORDSYS_VDGRN,     CS_VDGRN,   BaseGCS::pcvVanderGrinten,                              /* cs_PRJCOD_VDGRN    */ },

  { COORDSYS_UTMZN,     CS_UTMZN,   BaseGCS::pcvUniversalTransverseMercator,                /* cs_PRJCOD_UTM      */ },
  { COORDSYS_LM1SP,     CS_LM1SP,   BaseGCS::pcvLambertConformalConicOneParallel,           /* cs_PRJCOD_LM1SP    */ },
  { COORDSYS_OSTRO,     CS_OSTRO,   BaseGCS::pcvObliqueStereographic,                       /* cs_PRJCOD_OSTRO    */ },
  { COORDSYS_PSTRO,     CS_PSTRO,   BaseGCS::pcvPolarStereographic,                         /* cs_PRJCOD_PSTRO    */ },
  { COORDSYS_RSKWC,     CS_RSKWC,   BaseGCS::pcvRectifiedSkewOrthomorphicCentered,          /* cs_PRJCOD_RSKEWC   */ },
  { COORDSYS_RSKEW,     CS_RSKEW,   BaseGCS::pcvRectifiedSkewOrthomorphic,                  /* cs_PRJCOD_RSKEW    */ },
  { COORDSYS_SWISS,     CS_SWISS,   BaseGCS::pcvObliqueCylindricalSwiss,                    /* cs_PRJCOD_SWISS    */ },
  { COORDSYS_LMBLG,     CS_LMBLG,   BaseGCS::pcvLambertConformalConicBelgian,               /* cs_PRJCOD_LMBLG    */ },
  { COORDSYS_SOTRM,     CS_SOTRM,   BaseGCS::pcvSouthOrientedTransverseMercator,            /* cs_PRJCOD_SOTRM    */ },
  { COORDSYS_HOM1U,     CS_HOM1U,   BaseGCS::pcvHotineObliqueMercator1UV,                   /* cs_PRJCOD_HOM1UV   */ },
  { COORDSYS_HOM2U,     CS_HOM2U,   BaseGCS::pcvHotineObliqueMercator2UV,                   /* cs_PRJCOD_HOM2UV   */ },

  { COORDSYS_GAUSK,     CS_GAUSK,   BaseGCS::pcvGaussKrugerTranverseMercator,               /* cs_PRJCOD_GAUSSK   */ },
  { COORDSYS_KRVKP,     CS_KRVKP,   BaseGCS::pcvCzechKrovak,                                /* cs_PRJCOD_KROVAK   */ },
  { COORDSYS_KRVKR,     CS_KRVKR,   BaseGCS::pcvCzechKrovakObsolete,                        /* cs_PRJCOD_KROVK1   */ },     // There is something wrong with this one (Krovak rounded origin) - can't really find it in CS_Map.
  { COORDSYS_MRCSR,     CS_MRCSR,   BaseGCS::pcvMercatorScaleReduction,                     /* cs_PRJCOD_MRCATK   */ },
  { COORDSYS_OCCNC,     CS_OCCNC,   BaseGCS::pcvObliqueConformalConic,                      /* cs_PRJCOD_OCCNC    */ },     // oblique conformal conic. Doesn't look like it was ever really supported.
  { COORDSYS_KRVKG,     CS_KRVKG,   BaseGCS::pcvCzechKrovakObsolete,                        /* cs_PRJCOD_KROVAK   */ },     // There is something wrong with this one (Krovak generalized) - can't really find it in CS_Map
  { COORDSYS_TRMAF,     CS_TRMAF,   BaseGCS::pcvTransverseMercatorAffinePostProcess,        /* cs_PRJCOD_TRMERAF  */ },
  { COORDSYS_PSTSL,     CS_PSTSL,   BaseGCS::pcvPolarStereographicStandardLatitude,         /* cs_PRJCOD_PSTROSL  */ },
  { COORDSYS_NERTH,     CS_NERTH,   BaseGCS::pcvNonEarth,                                   /* cs_PRJCOD_NERTH    */ },
  { COORDSYS_SPCSL,     0,          BaseGCS::pcvInvalid,                                    /* 0                  */ },     // state plane - should never be projType, requires special treatment

  { COORDSYS_HUEOV,     CS_HUEOV,   BaseGCS::pcvObliqueCylindricalHungary,                  /* cs_PRJCOD_OBQCYL   */ },
  { COORDSYS_SYS34,     CS_SYS34,   BaseGCS::pcvTransverseMercatorDenmarkSys34,             /* cs_PRJCOD_SYS34    */ },
  { COORDSYS_OST97,     CS_OST97,   BaseGCS::pcvTransverseMercatorOstn97,                   /* cs_PRJCOD_OSTN97   */ },
  { COORDSYS_OST02,     CS_OST02,   BaseGCS::pcvTransverseMercatorOstn02,                   /* cs_PRJCOD_OSTN02   */ },
  { COORDSYS_S3499,     CS_S3499,   BaseGCS::pcvTransverseMercatorDenmarkSys3499,           /* cs_PRJCOD_SYS34_99 */ },
  { COORDSYS_AZEDE,     CS_AZEDE,   BaseGCS::pcvAzimuthalEquidistantElevatedEllipsoid,      /* cs_PRJCOD_AZEDE    */ },
  { COORDSYS_KEYNM,     0,          BaseGCS::pcvInvalid,                                    /* 0                  */ },     // key name - doesn't appear in type 66.
  { COORDSYS_LMMIN,     CS_LMMIN,   BaseGCS::pcvLambertConformalConicMinnesota,             /* cs_PRJCOD_MNDOTL   */ },
  { COORDSYS_LMWIS,     CS_LMWIS,   BaseGCS::pcvLambertConformalConicWisconsin,             /* cs_PRJCOD_WCCSL    */ },
  { COORDSYS_TMMIN,     CS_TMMIN,   BaseGCS::pcvTransverseMercatorMinnesota,                /* cs_PRJCOD_MNDOTT   */ },
  { COORDSYS_TMWIS,     CS_TMWIS,   BaseGCS::pcvTransverseMercatorWisconsin,                /* cs_PRJCOD_WCCST    */ },
  { COORDSYS_RSKWO,     CS_RSKWO,   BaseGCS::pcvRectifiedSkewOrthomorphicOrigin,            /* cs_PRJCOD_RSKEWO   */ },
  { COORDSYS_WINKT,     CS_WINKT,   BaseGCS::pcvWinkelTripel,                               /* cs_PRJCOD_WINKL    */ },
  { COORDSYS_TMKRG,     CS_TMKRG,   BaseGCS::pcvTransverseMercatorKruger,                   /* cs_PRJCOD_TRMRKRG  */ },
  { COORDSYS_NESRT,     CS_NESRT,   BaseGCS::pcvNonEarthScaleRotation,                      /* cs_PRJCOD_NRTHSRT  */ },
  { COORDSYS_LMBRTAF,   CS_LMBRTAF, BaseGCS::pcvLambertConformalConicAffinePostProcess,     /* cs_PRJCOD_LMBRTAF  */ },
  { COORDSYS_UTMZNBF,   CS_UTMZNBF, BaseGCS::pcvTotalUniversalTransverseMercator,           /* cs_PRJCOD_UTMZNBF  */ },     // Total Transverse Mercator UTM Zone using Bernard Flaceliere calculation
  { COORDSYS_TRMERBF,   CS_TRMERBF, BaseGCS::pcvTotalTransverseMercatorBF,                  /* cs_PRJCOD_TRMERBF  */ },     // Total Transverse Mercator using Bernard Flaceliere calculation
  { COORDSYS_FAVOR,     0,          BaseGCS::pcvInvalid,                                    /* 0                  */ },
  { COORDSYS_S3401,     CS_S3401,   BaseGCS::pcvTransverseMercatorDenmarkSys3401,           /* cs_PRJCOD_SYS34_01 */ },
  { COORDSYS_EDCYLE,    CS_EDCYLE,  BaseGCS::pcvEquidistantCylindricalEllipsoid,            /* cs_PRJCOD_EDCYLE   */ },
  { COORDSYS_PCARREE,   CS_PCARREE, BaseGCS::pcvPlateCarree,                                /* cs_PRJCOD_PCARREE  */ },
  { COORDSYS_MRCATPV,   CS_MRCATPV, BaseGCS::pcvPopularVisualizationPseudoMercator,         /* cs_PRJCOD_MRCATPV  */ },
  { COORDSYS_MNDOTOBL,  CS_MNDOTOBL,BaseGCS::pcvObliqueMercatorMinnesota,                   /* cs_PRJCOD_MNDOTOBL */ },
  { COORDSYS_LMMICH,    CS_LMMICH,  BaseGCS::pcvLambertMichigan,                            /* cs_PRJCOD_LMMICH   */ },
  { COORDSYS_KRVK95,    CS_KRVK95,  BaseGCS::pcvCzechKrovak95,                              /* cs_PRJCOD_KRVK95   */ },
  { COORDSYS_TRMRS,     CS_TRMRS,   BaseGCS::pcvSnyderTransverseMercator,                   /* cs_PRJCOD_TRMRS    */ },
  { COORDSYS_KRVMO,     CS_KRVMO,   BaseGCS::pcvCzechKrovakModified,                        /* cs_PRJCOD_KROVAKMOD*/ },
  { COORDSYS_OST15,     CS_OST15,   BaseGCS::pcvTransverseMercatorOstn15,                   /* cs_PRJCOD_OSTN15   */ },
};

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool doubleSame(double val1, double val2) {
    double denom = fabs(val1) + fabs(val2);

    if (denom == 0)
        return true;

    double scaledDiff = fabs((val1 - val2) / denom);

    if (scaledDiff < 1e-11)
        return true;

    // This may mean that values are near 0 in that case the scale difference can be 1.0 (example 0.0 and 1e-30 results in a scale diff of 1.0)
    if (denom < 1e-11)
        return (fabs(val1 - val2) <= 1e-11);

    return false;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
* Compares two distances. The tolerance applied is automatically 0.001 which is the
* cartographic accuracy and round off values for most distances.
+---------------+---------------+---------------+---------------+---------------+------*/
bool distanceSame(double val1, double val2) {
    return (fabs(val1 - val2) <= 0.001);
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 * Compares two angles expressed in arc seconds. The tolerance applied is automatically 0.0000001
 +---------------+---------------+---------------+---------------+---------------+------*/
bool arcSecondsSame(double val1, double val2) {
    return (fabs(val1 - val2) <= 0.0000001);
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 * Compares two scales expressed as PPMs. The tolerance applied is automatically 0.00000001
 +---------------+---------------+---------------+---------------+---------------+------*/
bool scalePPMSame(double val1, double val2) {
    return (fabs(val1 - val2) <= 0.00000001);
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
void stripWhite(char* str) {
    char* p;
    p = str;
    do
        if (!isspace(*p = *str))
            p++;
    while (*str++);
}

/*---------------------------------------------------------------------------------**//**
* This method solves the ambiguity of the vdcFromDatum value.
* @returns the explicit datum code. This value cannot be vdcFromDatum
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VertDatumCode   NetVerticalDatumFromGCS (BaseGCSCR gcs)
    {
    VertDatumCode vdc = gcs.GetVerticalDatumCode();

    if (vdcFromDatum == vdc)
        {
        if (gcs.IsNAD27())
            return vdcNGVD29;
        else if (gcs.IsNAD83())
            return vdcNAVD88;
        else
            return vdcEllipsoid;
        }

    // If the datum is WGS84 coincident then Local Ellipsoid is meaningless.
    if (vdcLocalEllipsoid == vdc && gcs.HasWGS84CoincidentDatum())
        return vdcEllipsoid;

    return vdc;
    }

/*---------------------------------------------------------------------------------**//**
* Returns the net vertical datum code from the given key. If the key is invalid
* then vdcFromDatum is returned.
* @returns the explicit datum code or vdcFromDatum if the key is invalid.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VertDatumCode   VerticalDatumCodeFromKey (Utf8CP verticalKey)
    {
    Utf8String key(verticalKey);
    if (key == "NGVD29")
        return vdcNGVD29;
    else if (key == "NAVD88")
        return vdcNAVD88;
    else if (key == "GEOID")
        return vdcGeoid;
    else if (key == "ELLIPSOID")
        return vdcEllipsoid;
    else if (key == "LOCAL_ELLIPSOID")
        return vdcLocalEllipsoid;

    return vdcFromDatum;
    }

/*---------------------------------------------------------------------------------**//**
* Returns the vertical datum key from code.
* @returns the explicit datum code. This value cannot be vdcFromDatum
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8String   VerticalDatumKeyFromCode (VertDatumCode vdc)
    {
    if (vdcNGVD29 == vdc)
        return "NGVD29";
    else if (vdcNAVD88 == vdc)
        return "NAVD88";
    else if (vdcGeoid == vdc)
        return "GEOID";
    else if (vdcEllipsoid == vdc)
        return "ELLIPSOID";
     else if (vdcLocalEllipsoid == vdc)
        return "LOCAL_ELLIPSOID";

    return "";
    }

/*---------------------------------------------------------------------------------**//**
* This method solves the ambiguity of the vdcFromDatum value and generated a string key.
* @returns the explicit datum code. This value cannot be vdcFromDatum
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8String   VerticalDatumKeyFromGCS (BaseGCSCR gcs)
    {
    return VerticalDatumKeyFromCode(NetVerticalDatumFromGCS(gcs));
    }

/*---------------------------------------------------------------------------------**//**
* This method solves the ambiguity of the vdcFromDatum value.
* @returns the explicit datum code. This value cannot be vdcFromDatum
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VertDatumCode   NetVerticalDatumFromDatum (DatumCR datum, VertDatumCode vdc)
    {
    if (vdcFromDatum == vdc)
        {
        if (datum.IsNAD27())
            return vdcNGVD29;
        else if (datum.IsNAD83())
            return vdcNAVD88;
        else
            return vdcEllipsoid;
        }

    // If the datum is WGS84 coincident then Local Ellipsoid is meaningless.
    if (vdcLocalEllipsoid == vdc && datum.IsWGS84Coincident())
        return vdcEllipsoid;

    return vdc;
    }

/*---------------------------------------------------------------------------------**//**
* Returns true if the keyname corresponds to a known variation of
* NAD27 (excluding canadian variations)
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   IsNAD27Keyname(const char * datumKeyname)
    {
    if (nullptr == datumKeyname)
        return false;

    if (0 == BeStringUtilities::Stricmp (datumKeyname, "NAD27"))
        return true;
    if (0 == BeStringUtilities::Stricmp (datumKeyname, "EPSG:6267"))
        return true;
    if (0 == BeStringUtilities::Stricmp (datumKeyname, "NAD27-48"))
        return true;

    return false;
    }

/*---------------------------------------------------------------------------------**//**
* Returns true if the keyname corresponds to a known variation of
* NAD83 (excluding canadian variations)
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   IsNAD83Keyname(const char * datumKeyname)
    {
    if (nullptr == datumKeyname)
        return false;

    if (0 == BeStringUtilities::Stricmp (datumKeyname, "NAD83"))
        return true;
    if (0 == BeStringUtilities::Stricmp (datumKeyname, "EPSG:6269"))
        return true;
    if (0 == BeStringUtilities::Stricmp (datumKeyname, "HPGN"))
        return true;
    if (0 == BeStringUtilities::Stricmp (datumKeyname, "EPSG:6152"))
        return true;
    if (0 == BeStringUtilities::Stricmp (datumKeyname, "NAD83/2011"))
        return true;
    if (0 == BeStringUtilities::Stricmp (datumKeyname, "NAD83/HARN"))
        return true;
    if (0 == BeStringUtilities::Stricmp (datumKeyname, "NSRS07"))
        return true;
    if (0 == BeStringUtilities::Stricmp (datumKeyname, "NSRS11"))
        return true;
    if (0 == BeStringUtilities::Strnicmp (datumKeyname, "HARN/", 5)) // First 5 chars are HARN/
        return true;

    return false;
    }

// List of known WGS84 coincident
// This list is not exhaustive.
// This list as a simple fast way to determine if a datum is equivalent to WGS84
// If the datum is not in the list then it is possible to instantiate a datum transformation to WGS84 and
// verify that the result transformation is null
char WGS84CoincidentKeynameMap[][24] =
{
    "CSRS",
    "EPSG:6269",
    "ISN93",
    "Slovenia1996",
    "IraqKuwait1992",
    "IGM1995",
    "DGN95",
    "BDA2000",
    "JGD2011",
    "EPSG:6171",
    "EPSG:6326",
    "EPSG:6755",
    "SphereWGS84",
    "HTRS96",
    "EPSG:6761",
    "EPSG:6762",
    "EPSG:6763",
    "SVY21",
    "RSRGD2000",
    "EPSG:6764",
    "EPSG:6765",
    "EPSG:1026",
    "EPSG:1029",
    "RGRDC2005",
    "EPSG:1033",
    "EPSG:1034",
    "REGCAN95",
    "EPSG:1035",
    "EPSG:1036",
    "EPSG:1038",
    "PTRA08",
    "EPSG:1041",
    "EPSG:1042",
    "EPSG:1047",
    "BhutanNtl",
    "EPSG:1058",
    "CR05",
    "RDN2008",
    "GDA2020",
    "WGS84",
    "ETRS89",
    "ETRF89",
    "GHANA",
    "SIRGAS2000",
    "MAGNA_1",
    "Mauritania1999/gc",
    "Korean2000",
    "GR96",
    "RGN/91-93",
    "Hartebeesthoek1994",
    "YemenNtl1996",
    "GRSSA-New",
    "IRENET1995",
    "Antarctic1998",
    "Estonia1997",
    "REGVEN-New",
    "PosGAr1998",
    "SWEREF1999",
    "Guyane95a",
    "Reunion1992",
    "Antilles91/1",
    "Antilles1991",
    "ETRF1989",
    "PGA1998",
    "Jamaica2001",
    "Latvia1992_1",
};

/*---------------------------------------------------------------------------------**//**
* Returns true if the keyname corresponds to a known variation of
* NAD83 (excluding canadian variations)
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   IsWGS84CoincidentKeyname(const char * datumKeyname)
    {

    int  numRows = sizeof (WGS84CoincidentKeynameMap) / sizeof (WGS84CoincidentKeynameMap[0]);
    int  rowInd;

    if (nullptr == datumKeyname)
        return false;

    for (rowInd = 0 ; rowInd < numRows; ++rowInd)
        {
        if (0 == BeStringUtilities::Stricmp (datumKeyname, WGS84CoincidentKeynameMap[rowInd]))
            return true;
        }

    return false;
    }

/*---------------------------------------------------------------------------------**//**
* This utilitary function extracts the group name without modifying the Datum
* class signature. BIM02 Implementation is different.
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8String GetDatumGroupName(DatumCR datum)
    {
    Utf8String datumGroupName = "";

    CSDatumDef* datumFromDico = NULL;
    if (NULL == (datumFromDico = CSMap::CS_dtdef (datum.GetName())))
        return datumGroupName;
    datumGroupName = datumFromDico->group;

    CSMap::CS_free (datumFromDico);
    return datumGroupName;
    }

/*---------------------------------------------------------------------------------**//**
* local function
* returns the ellipsoid index based on the ellipsoid keyname provided.
* This searches only the system dictionary. It does not deal with user-defined
* dictionaries.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int     FindEllipsoidIndex (Utf8CP ellipsoidName)
    {
    int     index;
    int     foundIndex = -1;
    char    elKeyName[128];
    for (index = 0; ((foundIndex < 0) && (0 < CSMap::CS_elEnum (index, elKeyName, sizeof(elKeyName)))); index++)
        {
        if (0 == BeStringUtilities::Stricmp (ellipsoidName, elKeyName))
            foundIndex = index;
        }

    return foundIndex;
    }

/*---------------------------------------------------------------------------------**//**
* local function
* returns the datum index based on the ellipsoid keyname provided.
* This searches only the system dictionary. It does not deal with user-defined
* dictionaries.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int     FindDatumIndex (Utf8CP datumName)
    {
    int     index;
    int     foundIndex = -1;
    char    dtKeyName[128];
    for (index = 0; ((foundIndex < 0) && (0 < CSMap::CS_dtEnum (index, dtKeyName, sizeof(dtKeyName)))); index++)
        {
        if (0 == BeStringUtilities::Stricmp (datumName, dtKeyName))
            foundIndex = index;
        }

    return foundIndex;
    }

/*---------------------------------------------------------------------------------**//**
* local function
* returns the name of the GCS for this EPSG code.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt     FindGCSNameFromEPSGCode(Utf8String& outName, uint16_t epsgCode)
{
    // Value 0 is a flag for no code
    if (0 == epsgCode)
        return ERROR;

 //   static std::mutex EPSGCacheMutex;
 //   std::lock_guard<std::mutex> EPSGCacheLock(EPSGCacheMutex);

    static bool cacheComplete = false;
    static uint32_t cacheNextIndex = 0;
    static bmap<uint16_t, Utf8String> epsgCache;
    static bmap<uint16_t, Utf8String> epsgDeprecatedCache;     // To hold deprecated entries
    static bmap<uint16_t, Utf8String> epsgVeryDeprecatedCache; // To hold deprecated entries starting with EPSG (last resort)

    // Try finding in cache
    auto iter = epsgCache.find(epsgCode);
    if (iter != epsgCache.end())
        {
        outName = iter->second;
        return SUCCESS;
        }

    if (!cacheComplete)
        {
        // Cache building. We continue at the index we were ...
        int         index;
        char        csKeyName[128];
        BaseGCSPtr    gcs = BaseGCS::CreateGCS();
        for (index = cacheNextIndex; (0 < CSMap::CS_csEnum(index, csKeyName, sizeof(csKeyName))); index++)
            {
            gcs->SetFromCSName(csKeyName);

            cacheNextIndex = index + 1;

            if (gcs->IsValid() && gcs->GetStoredEPSGCode() != 0) // We don't care for value 0
                {
                // Add entry to cache
                bool deprecated = gcs->IsDeprecated();

                if (deprecated)
                    {
                    if (Utf8String(gcs->GetName()).substr(0,4) == "EPSG") // Deprecated entries with EPSG as keyname are the very last resort
                        epsgVeryDeprecatedCache.insert(bmap<uint16_t, Utf8String>::value_type(static_cast<uint16_t>(gcs->GetStoredEPSGCode()), Utf8String(gcs->GetName())));
                    else
                        epsgDeprecatedCache.insert(bmap<uint16_t, Utf8String>::value_type(static_cast<uint16_t>(gcs->GetStoredEPSGCode()), Utf8String(gcs->GetName())));
                    }
                else
                    epsgCache.insert(bmap<uint16_t, Utf8String>::value_type(static_cast<uint16_t>(gcs->GetStoredEPSGCode()), Utf8String(gcs->GetName())));

                if (epsgCode == static_cast<uint16_t>(gcs->GetStoredEPSGCode()))
                    {
                    outName = gcs->GetName();

                    if (!deprecated) // If the entry is not deprecated then we have our answer
                        return SUCCESS;
                    }
                }
            }
        // No more entries ... cache fully built
        cacheComplete = true;
        }

    // We know it is not part of the non-deprecated ... check deprecated.

    // Try finding in deprecated cache
    auto iter2 = epsgDeprecatedCache.find(epsgCode);
    if (iter2 != epsgDeprecatedCache.end())
        {
        outName = iter2->second;
        return SUCCESS;
        }

    // Last resort Try finding in very deprecated cache
    auto iter3 = epsgVeryDeprecatedCache.find(epsgCode);
    if (iter3 != epsgVeryDeprecatedCache.end())
        {
        outName = iter3->second;
        return SUCCESS;
        }

    // If we get here then not found
    return ERROR;
}

/*---------------------------------------------------------------------------------**//**
* local function
* Converts the Danish System 34 region CSMAP code to a name compatible to the Json format.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8String GetDanishSys34RegionStringFromCode(int code)
    {
    if (1 == code)
        return "Jylland";
    else if (2 == code)
        return "Sjaelland";
    else if (3 == code)
        return "Bornholm";

    return "UNKNOWN";
    }

/*---------------------------------------------------------------------------------**//**
* local function
* Converts the Danish System 34 region name (Json format) to a CSMAP region code.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int GetDanishSys34RegionCodeFromString(Utf8StringCR region)
    {
    if (region == "Jylland")
        return 1;
    if (region == "Sjaelland")
        return 2;
    if (region == "Bornholm")
        return 3;

    return 0;
    }

static bool     DatumEquivalent(CSDatum&    datum1,  CSDatum&    datum2,  bool tolerateEquivalentDifferencesWhenDeprecated, bool tolerateEquivalentDifferencesInAllCases, bool shallowCompare);

/*---------------------------------------------------------------------------------**//**
* Utilitarian function
* Fills the list of geodetic transforms with copies of the datum converter
* geodetic transforms. The geodetic transforms part of the list must all be destroyed
* when not needed anymore.
* All geodetic transforms returned will use the direct direction and thus inverse transforms
* will be reversed if needed and possible.
* @param listOftransforms OUT The list to add transfroms to.
* @param datumConverter IN the datum conveter to extract geodetic transforms of.
* @return SUCCESS if sucessful and ERROR if one of the geodetic transforms
*           could not be reversed to add to list. The list is then cleared in that case.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt FillListOfTransformsFromCSDatumConvert(bvector<GeodeticTransformP>& listOfTransforms, CSDatumConvert const & datumConverter);

/*---------------------------------------------------------------------------------**//**
* Returns whether the list of geodetic transforms represents a null transformation.
* To be a Null transform either all component geodetic transform must be null transforms
* or two non-null transforms must be the inverse of the other (resulting in a null transform
* once combined).
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
static bool RepresentsNullTransform(bvector<GeodeticTransformP> const& listOfTransforms);

/*---------------------------------------------------------------------------------**//**
* Returns true if given list of geodetic transforms are equivalent or false otherwise.
* @param listOfTransforms1 IN the list of geodetic transform forming the first sequence.
* @param listOfTransforms2 IN the list of geodetic transform forming the second sequence.
* @param    looselyCompare IN If false then the method checks if the
*              geodetic transform is the same including the method used and the accuracy
*              expected; the test is more strict.
*              If true then the method will verify if the two geodetic transform would
*              yield the same result.
*              For example a 7 parameter definition having no rotation and no scale would be
*              considered equivalent to a 3 parameter transform given the delta values
*              were the same.
*
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
static bool     GeodeticTransformPathAreEquivalent(bvector<GeodeticTransformP> const& listOfTransforms1, bvector<GeodeticTransformP> const& listOfTransforms2, bool looselyCompare);

/*=================================================================================**//**
*
* General Parser abstract class. Provides methods, parameter, datum and ellipsoid
* definition and resolution services common to all parsers.
*
* NOTE: Error processing is still minimal. The functions will return the generic error ERROR
* most if not all of the times. Error processing will be completed later on in the
* development process
*
+===============+===============+===============+===============+===============+======*/
class SRSGeneralParser
{
public:

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus InitCleanGCS(BaseGCSR baseGCS) const
    {
    baseGCS.AllocateClean();

    return GeoCoordParse_Success;
    }
/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus FindEllipsoidFromParams(Utf8StringR finalEllipsoidName, double equatorialRadius, double polarRadius) const
    {
    finalEllipsoidName = "";

    EllipsoidEnumeratorP ellIter = Ellipsoid::CreateEnumerator();
    if (nullptr != ellIter)
        {
        while (ellIter->MoveNext())
            {
            EllipsoidCP currentEllipsoid = ellIter->GetCurrent();

            if (nullptr != currentEllipsoid)
                {
                if (distanceSame(currentEllipsoid->GetEquatorialRadius(), equatorialRadius) && distanceSame(currentEllipsoid->GetPolarRadius(), polarRadius))
                    {
                    finalEllipsoidName = currentEllipsoid->GetName();
                    currentEllipsoid->Destroy();
                    ellIter->Destroy();
                    return GeoCoordParse_Success;
                    }
                currentEllipsoid->Destroy();
                }
            }
        ellIter->Destroy();
        }
    return GeoCoordParse_UnknownEllipsoid;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetEllipsoidNameFromNameOrAlias(Utf8StringR finalEllipsoidName, Utf8StringCR name, Utf8StringCR authorityID) const
    {
    finalEllipsoidName = "";

    // Check if ellipsoid name is known ...
    EllipsoidCP namedEllipsoid = Ellipsoid::CreateEllipsoid(name.c_str());

    if (namedEllipsoid == NULL || !namedEllipsoid->IsValid())
        {
        // Ellipsoid not found ... try with authority ID if defined and not deprecated
        if (authorityID.length() > 0)
            {
            if (nullptr != namedEllipsoid)
                {
                namedEllipsoid->Destroy();
                namedEllipsoid = nullptr;
                }

            namedEllipsoid = Ellipsoid::CreateEllipsoid(authorityID.c_str());
            if (namedEllipsoid != NULL && namedEllipsoid->IsValid())
                finalEllipsoidName = authorityID;
            }
        }
    else
        finalEllipsoidName = name;

    if (nullptr != namedEllipsoid)
        {
        namedEllipsoid->Destroy();
        namedEllipsoid = nullptr;
        }

    if (finalEllipsoidName.length() == 0)
        {
        // We do not have the ellipsoid name yet ... try looking it up in the alias table.
        Utf8String     alternateName;

        if (WKTEllipsoidLookup(name.c_str(), alternateName))
            {
            namedEllipsoid = Ellipsoid::CreateEllipsoid(alternateName.c_str());
            if (namedEllipsoid != NULL && namedEllipsoid->IsValid())
                finalEllipsoidName = alternateName;

            if (nullptr != namedEllipsoid)
                {
                namedEllipsoid->Destroy();
                namedEllipsoid = nullptr;
                }
            }

        // Either there is no alias or the alias is not good ... if authority ID is present ...
        if ((finalEllipsoidName.length() == 0) && (authorityID.length() != 0))
            {
            if (WKTEllipsoidLookup(authorityID.c_str(), alternateName))
                {
                // Alternate name should be valid
                namedEllipsoid = Ellipsoid::CreateEllipsoid(authorityID.c_str());
                if (namedEllipsoid != NULL && namedEllipsoid->IsValid())
                    finalEllipsoidName = authorityID;

                if (nullptr != namedEllipsoid)
                    {
                    namedEllipsoid->Destroy();
                    namedEllipsoid = nullptr;
                    }
                }
            }
        }

    return (finalEllipsoidName.length() == 0 ? GeoCoordParse_UnknownEllipsoid : GeoCoordParse_Success);
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetTransformMethodFromId(GenConvertCode& convertCode, GridFileFormat& fileFormat, bool& invertRotation, Utf8StringCR methodId) const
    {
    invertRotation = false;

    Utf8String upperMethodId = methodId;
    std::transform(upperMethodId.begin(), upperMethodId.end(), upperMethodId.begin(), [](char const& c){return (char)toupper(c);});

    if (upperMethodId == "NADCON")
        {
        convertCode = GenConvertCode::GenConvertType_GFILE;
        fileFormat = GridFileFormat::FORMAT_NADCON;
        }
    else if (upperMethodId == "SEVEN PARAMETER TRANSFORMATION")
        convertCode = GenConvertCode::GenConvertType_7PARM;
    else if ((upperMethodId == "COORDINATE FRAME ROTATION (GEOG2D DOMAIN)") ||
             (upperMethodId == "COORDINATE FRAME ROTATION"))
        convertCode = GenConvertCode::GenConvertType_7PARM;
    else if ((upperMethodId == "POSITION VECTOR TRANSFORMATION (GEOG2D DOMAIN)") ||
             (upperMethodId == "POSITION VECTOR TRANSFORMATION"))
        {
        convertCode = GenConvertCode::GenConvertType_7PARM;
        invertRotation = true;
        }
    else if (upperMethodId == "MULTIPLE REGRESSION")
        convertCode = GenConvertCode::GenConvertType_MREG;
    else if (upperMethodId == "NTV1")
        {
        convertCode = GenConvertCode::GenConvertType_GFILE;
        fileFormat = GridFileFormat::FORMAT_NTv1;
        }
    else if (upperMethodId == "NTV2")
        {
        convertCode = GenConvertCode::GenConvertType_GFILE;
        fileFormat = GridFileFormat::FORMAT_NTv2;
        }
    else if ((upperMethodId == "GEOCENTRIC TRANSLATIONS (GEOG2D DOMAIN)") ||
             (upperMethodId == "GEOCENTRIC TRANSLATIONS"))
        convertCode = GenConvertCode::GenConvertType_GEOCTR;
    else if (upperMethodId == "MOLODENSKY")
        convertCode = GenConvertCode::GenConvertType_MOLO;
    else if ((upperMethodId == "NULL TRANSFORMATION (NO COORDINATE CHANGE)") ||
             (upperMethodId == "NULL TRANSFORMATION"))
        convertCode = GenConvertCode::GenConvertType_NONE;
    else if ((upperMethodId == "MOLODENSKY-BADEKAS (CF GEOG2D DOMAIN)") ||
             (upperMethodId == "MOLODENSKY-BADEKAS"))
        convertCode = GenConvertCode::GenConvertType_BDKAS;
    else if (upperMethodId == "GEOCON")
        {
        convertCode = GenConvertCode::GenConvertType_GFILE;
        fileFormat = GridFileFormat::FORMAT_GEOCN;
        }
    else if (upperMethodId == "JAPANESE GRID MESH INTERPOLATION")
        {
        convertCode = GenConvertCode::GenConvertType_GFILE;
        fileFormat = GridFileFormat::FORMAT_JAPAN;
        }
    else if (upperMethodId == "FRANCE GEOCENTRIC INTERPOLATION")
        {
        convertCode = GenConvertCode::GenConvertType_GFILE;
        fileFormat = GridFileFormat::FORMAT_FRENCH;
        }
    else
        return GeoCoordParse_UnknownTransformMethod;

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool    WKTEllipsoidLookup (Utf8CP name, Utf8StringR alternateName) const
    {
    char        mbAlternateName[100];
    if (CS_wktEllipsoidLookUp (name, mbAlternateName))
        {
        alternateName = mbAlternateName;
        return true;
        }
    else
        {
        alternateName.clear();
        return false;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool WKTDatumLookup (Utf8CP name, Utf8StringR alternateName) const
    {
    char        mbAlternateName[100];
    if (CS_wktDatumLookUp (name, mbAlternateName))
        {
        alternateName = mbAlternateName;
        return true;
        }
    else
        {
        alternateName.clear();
        return false;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsiclass
* Internal helper class for the search datum by 7 parameters cache map.
+---------------+---------------+---------------+---------------+---------------+------*/
class TransformParams
    {
    public:
      double m_deltaX;
      double m_deltaY;
      double m_deltaZ;
      double m_rotX;
      double m_rotY;
      double m_rotZ;
      double m_scalePPM;

      TransformParams()
          {
          m_deltaX = 0.0;
          m_deltaY = 0.0;
          m_deltaZ = 0.0;
          m_rotX = 0.0;
          m_rotY = 0.0;
          m_rotZ = 0.0;
          m_scalePPM = 0.0;
          }

      TransformParams(double deltaX, double deltaY, double deltaZ, double rotX, double rotY, double rotZ, double scalePPM)
          {
          m_deltaX = deltaX;
          m_deltaY = deltaY;
          m_deltaZ = deltaZ;
          m_rotX = rotX;
          m_rotY = rotY;
          m_rotZ = rotZ;
          m_scalePPM = scalePPM;
          }

      TransformParams(const TransformParams& other)
          {
          m_deltaX = other.m_deltaX;
          m_deltaY = other.m_deltaY;
          m_deltaZ = other.m_deltaZ;
          m_rotX = other.m_rotX;
          m_rotY = other.m_rotY;
          m_rotZ = other.m_rotZ;
          m_scalePPM = other.m_scalePPM;
          }

      TransformParams& operator=(const TransformParams& other)
          {
          if (this != &other)
              {
              m_deltaX = other.m_deltaX;
              m_deltaY = other.m_deltaY;
              m_deltaZ = other.m_deltaZ;
              m_rotX = other.m_rotX;
              m_rotY = other.m_rotY;
              m_rotZ = other.m_rotZ;
              m_scalePPM = other.m_scalePPM;
              }

          return *this;
          }

        bool operator==(const TransformParams& other) const
            {
            return (distanceSame(m_deltaX, other.m_deltaX) && distanceSame(m_deltaY, other.m_deltaY) && distanceSame(m_deltaZ, other.m_deltaZ) &&
                  doubleSame(m_rotX, other.m_rotX) && doubleSame(m_rotY, other.m_rotY) && doubleSame(m_rotZ, other.m_rotZ) &&
                  doubleSame(m_scalePPM, other.m_scalePPM));
          }

      // Arbitrary order so map use can this class.
      bool operator<(const TransformParams& other) const
            {
            // We check if equal because equal operator applies fuzzyness that must not be reflected in the map order.
            if (*this == other)
                return false;

            return (m_deltaX + m_deltaY + m_deltaZ + m_rotX + m_rotY + m_rotZ + m_scalePPM <
                  other.m_deltaX + other.m_deltaY + other.m_deltaZ + other.m_rotX + other.m_rotY + other.m_rotZ + other.m_scalePPM);
            }
    };

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool FindDatumFromTransformationParams(Utf8String& paramDatumName, const Utf8String& ellipsoidName, double deltaX, double deltaY, double deltaZ, double rotX, double rotY, double rotZ, double scalePPM) const
    {
    // Get rid of obvious case (null transform)
    if (distanceSame(deltaX, 0.0) && distanceSame(deltaY, 0.0) && distanceSame(deltaZ, 0.0) &&
        doubleSame(rotX, 0.0) && doubleSame(rotY, 0.0) && doubleSame(rotZ,0.0) && doubleSame(scalePPM, 0.0))
        {
        paramDatumName = "WGS84";
        return true;
        }

// To be activated once we go thread safe
// static std::mutex transformCacheMutex;
// std::lock_guard<std::mutex> transformCacheLock(transformCacheMutex);
    static bool cacheComplete = false;
    static uint32_t cacheNextIndex = 0;
    static bmap<TransformParams, Utf8String> transformCache;

    // Create the transform struct (note the rotation sign reversal to apply csmap convention)
    TransformParams transform(deltaX, deltaY, deltaZ, -rotX, -rotY, -rotZ, scalePPM);
    // Try finding in cache
    auto iter = transformCache.find(transform);
    if (iter != transformCache.end())
        {
        paramDatumName = iter->second;
        return true;
        }

    int         index;
    char        dtKeyName[128];
    // Search starting at cacheNextIndex
    if (!cacheComplete)
       {
       for (index = cacheNextIndex; (0 < CSMap::CS_dtEnum(index, dtKeyName, sizeof(dtKeyName))); index++)
           {
           cacheNextIndex = index + 1;
           DatumCP indexDatum = Datum::CreateDatum(dtKeyName);

           // If the datum is not deprecated, valid and geocentric...
           if (indexDatum->IsValid() && (!indexDatum->IsDeprecated()) && indexDatum->UsesAGeocentricMethod())
               {
               DPoint3d delta;
               DPoint3d rotation;
               indexDatum->GetDelta(delta);
               indexDatum->GetRotation(rotation);
               TransformParams indexParams(delta.x, delta.y, delta.z, rotation.x, rotation.y, rotation.z, indexDatum->GetScale());

               transformCache.insert(bmap<TransformParams, Utf8String>::value_type(indexParams, indexDatum->GetName()));

               if (indexParams == transform)
                   {
                   paramDatumName = indexDatum->GetName();
                   indexDatum->Destroy();
                   return true;
                   }
               }

            if (nullptr != indexDatum)
                {
                indexDatum->Destroy();
                indexDatum = nullptr;
                }
           }

       // If we get here then the cache is complete
       cacheComplete = true;
       }

    static bool cacheReverseComplete = false;
    static uint32_t cacheReverseNextIndex = 0;
    static bmap<TransformParams, Utf8String> transformReverseCache;

    // Create the transform struct (note rotation signs are not reversed)
    TransformParams transformReverse(deltaX, deltaY, deltaZ, rotX, rotY, rotZ, scalePPM);
    // Try finding in cache
    auto iter2 = transformReverseCache.find(transformReverse);
    if (iter2 != transformReverseCache.end())
        {
        paramDatumName = iter2->second;
        return true;
        }

    // Search starting at cacheNextIndex
    if (cacheReverseComplete)
        return false;

    for (index = cacheReverseNextIndex; (0 < CSMap::CS_dtEnum(index, dtKeyName, sizeof(dtKeyName))); index++)
        {
        cacheReverseNextIndex = index + 1;
        DatumCP indexDatum = Datum::CreateDatum(dtKeyName);

        // If the datum is not deprecated, valid and geocentric...
        if (indexDatum->IsValid() && (!indexDatum->IsDeprecated()) && indexDatum->UsesAGeocentricMethod())
            {
            DPoint3d delta;
            DPoint3d rotation;
            indexDatum->GetDelta(delta);
            indexDatum->GetRotation(rotation);
            TransformParams indexParams(delta.x, delta.y, delta.z, rotation.x, rotation.y, rotation.z, indexDatum->GetScale());

            transformReverseCache.insert(bmap<TransformParams, Utf8String>::value_type(indexParams, indexDatum->GetName()));

            if (indexParams == transformReverse)
                {
                paramDatumName = indexDatum->GetName();
                indexDatum->Destroy();
                return true;
                }
            }

        if (nullptr != indexDatum)
            {
            indexDatum->Destroy();
            indexDatum = nullptr;
            }
        }

    // If we get here then the cache is complete
    cacheReverseComplete = true;

    return false;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method converts the projection method name as
*   extracted from the WKT to the CSMAP projection code. Some projection code have
*   no WKT equivalent and some WKT projection names have no equivalent projection code.
*
*   @param name IN The projection name as extracted from the WKT.
*
*   @return The projection code or a negative value if projection is not supported.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::ProjectionCodeValue GetProjectionCodeFromParseName (Utf8StringR name) const
    {
    BaseGCS::ProjectionCodeValue ID = BaseGCS::pcvInvalid;

    Utf8String upperMethodName = name;
    std::transform(upperMethodName.begin(), upperMethodName.end(), upperMethodName.begin(), [](char const& c){return (char)toupper(c);});

    if (upperMethodName == "GEOGRAPHIC (LAT/LONG)") // Strange value ... should not occur but it does ..
        ID = BaseGCS::pcvUnity;
    if ((upperMethodName == "ALBERS") ||
        (upperMethodName == "ALBERS_CONIC_EQUAL_AREA") ||  // Added OGR Name
        (upperMethodName == "ALBERS CONICAL EQUAL AREA") ||   // Oracle name
        (upperMethodName == "ALBERS EQUAL AREAAE") ||
        (upperMethodName == "ALBERS EQUAL AREA CONIC") ||
        (upperMethodName == "AE") ||
        (upperMethodName == "ALBERS EQUAL AREA") ||
        (upperMethodName == "ALBERS EQUAL-AREA CONIC") ||
        (upperMethodName == "CT_ALBERSEQUALAREA"))
        ID = BaseGCS::pcvAlbersEqualArea;
    else if ((upperMethodName == "LAMBERT_CONFORMAL_CONIC") ||
             (upperMethodName == "LAMBERT_CONFORMAL_CONIC_2SP") || // OGR name
             (upperMethodName == "LAMBERT_CONFORMAL_CONIC_SP2") || // weird name
             (upperMethodName == "LAMBERT CONFORMAL CONIC") || // Oracle name
             (upperMethodName == "CT_LAMBERTCONFCONIC_2SP") || // WKT Variation
             (upperMethodName == "LAMBERT CONFORMAL CONIC, TWO STANDARD PARALLELS") ||
             (upperMethodName == "LM") ||
             (upperMethodName == "LCC") ||
             (upperMethodName == "LAMBERT CONIC CONFORMAL (2SP)"))
        ID = BaseGCS::pcvLambertConformalConicTwoParallel;
    else if ((upperMethodName == "LAMBERT_CONFORMAL_CONIC_1SP") || // Name from OGR
             (upperMethodName == "CT_LAMBERTCONFCONIC_1SP") ||
             (upperMethodName == "LAMBERT_CONIC_CONFORMAL_1SP") ||
             (upperMethodName == "LAMBERT CONIC CONFORMAL (1SP)") ||
             (upperMethodName == "LAMBERT CONFORMAL CONIC, SINGLE STANDARD PARALLEL") )
        ID = BaseGCS::pcvLambertConformalConicOneParallel;
    else if ((upperMethodName == "MERCATOR") ||
             (upperMethodName == "MERCATOR_2SP") ||
             (upperMethodName == "MERCATOR (2SP)") ||
             (upperMethodName == "MERCATOR CYLINDRICAL WITH STANDARD PARALLEL") ||
             (upperMethodName == "CT_MERCATOR"))
        ID = BaseGCS::pcvMercator;
    else if ((upperMethodName == "MERCATOR_1SP") ||
             (upperMethodName == "MERCATOR (1SP)") ||
             (upperMethodName == "MERCATOR CYLINDRICAL PROJECTION WITH SCALE REDUCTION") ||
             (upperMethodName == "MERCATOR CYLINDRICAL WITH SCALE REDUCTION"))
        ID = BaseGCS::pcvMercatorScaleReduction;
    else if ((upperMethodName == "POLAR_STEREOGRAPHIC") ||
             (upperMethodName == "POLAR STEREOGRAPHIC") ||
             (upperMethodName == "POLAR STEROGRAPHIC") ||
             (upperMethodName == "STEREOGRAPHIC_NORTH_POLE") ||
             (upperMethodName == "STEREOGRAPHIC_SOUTH_POLE") ||
             (upperMethodName == "POLAR_STEROGRAPHIC") ||
             (upperMethodName == "CT_POLARSTEREOGRAPHIC"))
        ID = BaseGCS::pcvPolarStereographic;
    else if ((upperMethodName == "POLAR STEROGRAPHIC PROJECTION WITH STANDARD CIRCLE") ||
             (upperMethodName == "POLAR STEREOGRAPHIC (VARIANT B)") ||
             (upperMethodName == "POLAR STEROGRAPHIC WITH STANDARD CIRCLE"))
        ID = BaseGCS::pcvPolarStereographicStandardLatitude;
    else if ((upperMethodName == "MODIFIED STEROGRAPHIC PROJECTION") ||
             (upperMethodName == "MODIFIED STEREOGRAPHIC PROJECTION") ||
             (upperMethodName == "MODIFIED_STEROGRAPHIC_PROJECTION") ||
             (upperMethodName == "MODIFIED_STEREOGRAPHIC_PROJECTION") ||
             (upperMethodName == "MODIFIED_STEROGRAPHIC") ||
             (upperMethodName == "MODIFIED_STEREOGRAPHIC") ||
             (upperMethodName == "MODIFIED STEROGRAPHIC") ||
             (upperMethodName == "MODIFIED STEREOGRAPHIC"))
        ID = BaseGCS::pcvModifiedStereographic;
    else if ((upperMethodName == "OBLIQUE_STEREOGRAPHIC") ||
             (upperMethodName == "OBLIQUE STEREOGRAPHIC") ||
             (upperMethodName == "OBLIQUE STEROGRAPHIC") ||
             (upperMethodName == "CT_OBLIQUESTEREOGRAPHIC") ||
             (upperMethodName == "DOUBLE_STEREOGRAPHIC") )
        ID = BaseGCS::pcvObliqueStereographic;
    else if ((upperMethodName == "POLYCONIC") ||
             (upperMethodName == "CT_POLYCONIC") ||
             (upperMethodName == "AMERICAN_POLYCONIC") ||
             (upperMethodName == "AMERICAN POLYCONIC") ||
             (upperMethodName == "AMERICAN POLYCONIC PROJECTION")   )
        ID = BaseGCS::pcvAmericanPolyconic;
    else if ((upperMethodName == "LALLEMAND IMW MODIFIED POLYCONIC") ||
             (upperMethodName == "LALLEMAND IMW MODIFIED POLYCONIC PROJECTION"))
        ID = BaseGCS::pcvModifiedPolyconic;
    else if ((upperMethodName == "EQUIDISTANT_CONIC") ||
             (upperMethodName == "EQUIDISTANT CONIC"))
        ID = BaseGCS::pcvEquidistantConic;
    else if ((upperMethodName == "GAUSS_KRUGER") ||
             (upperMethodName == "GAUSS KRUGER") ||
             (upperMethodName == "GAUSS-KRUGER") ||
             (upperMethodName == "GAUSSKRUGER"))
        ID = BaseGCS::pcvGaussKrugerTranverseMercator;
    else if ((upperMethodName == "TRANSVERSE_MERCATOR") ||
             (upperMethodName == "UNIVERSAL TRANSVERSE MERCATOR") ||
             (upperMethodName == "UNIVERSAL_TRANSVERSE_MERCATOR") ||
             (upperMethodName == "TRANSVERSE MERCATOR") ||
             (upperMethodName == "TM") ||
             (upperMethodName == "TRANSVERSE MERCATOR PER J. P. SNYDER") ||
             (upperMethodName == "CT_TRANSVERSEMERCATOR") ||
             (upperMethodName == "TRANSVERSE_MERCATOR_MAPINFO_21") ||
             (upperMethodName == "TRANSVERSE_MERCATOR_MAPINFO_22") ||
             (upperMethodName == "TRANSVERSE_MERCATOR_MAPINFO_23") ||
             (upperMethodName == "TRANSVERSE_MERCATOR_MAPINFO_24") ||
             (upperMethodName == "TRANSVERSE MERCATOR FINNISH KKJ") ||
             (upperMethodName == "TRANSVERSE_MERCATOR_MAPINFO_25"))
        ID = BaseGCS::pcvTransverseMercator;
    else if ((upperMethodName == "TRANSVERSE MERCATOR USING KRUGER FORMULATION") ||
             (upperMethodName == "TRANSVERSE MERCATOR, KRUGER FORMULATION"))
        ID = BaseGCS::pcvTransverseMercatorKruger;
    else if (upperMethodName == "TRANSVERSE_MERCATOR_COMPLEX")
        ID = BaseGCS::pcvTotalTransverseMercatorBF;
    else if ((upperMethodName == "STEREOGRAPHIC") ||
             (upperMethodName == "OBLIQUE STEROGRAPHIC, PER SNYDER") ||
             (upperMethodName == "OBLIQUE STEROGRAPHIC PROJECTION, PER SNYDER (USA)"))
        ID = BaseGCS::pcvSnyderObliqueStereographic;
    else if ((upperMethodName == "LAMBERT_AZIMUTHAL_EQUAL_AREA") ||
             (upperMethodName == "LAMBERT AZIMUTHAL EQUAL AREA") ||
             (upperMethodName == "LAMBERT_AZIMUTHAL_EQUAL_AREA_SPHERICAL") ||
             (upperMethodName == "LAMBERT AZIMUTHAL EQUAL AREA (SPHERICAL)") ||
             (upperMethodName == "CT_LAMBERTAZIMUTHALEQUALAREA"))
        ID = BaseGCS::pcvLambertEqualAreaAzimuthal;
    else if ((upperMethodName == "AZIMUTHAL_EQUIDISTANT") ||
             (upperMethodName == "AZIMUTHAL EQUIDISTANT") ||
             (upperMethodName == "CT_LAMBERTAZIMUTHALEQUIDISTANT") ||
             (upperMethodName == "LAMBERT AZIMUTHAL EQUIDISTANT") ||
             (upperMethodName == "LAMBERT_AZIMUTHAL_EQUIDISTANT"))
        ID = BaseGCS::pcvLambertEquidistantAzimuthal;
    else if ((upperMethodName == "EQUIDISTANT_CYLINDRICAL") ||
             (upperMethodName == "EQUIRECTANGULAR") ||
             (upperMethodName == "EQUIDISTANT CYLINDRICAL") ||
             (upperMethodName == "EQUIDISTANT CYLINDRICAL PROJECTION (DEPRECATED: SPHERICAL ONLY)") ||
             (upperMethodName == "CT_EQUIRECTANGULAR") ||
             (upperMethodName == "EQUIDISTANT CYLINDRICAL PROJECTION (ELLIPSOIDAL OR SPHERICAL)"))
        ID = BaseGCS::pcvEquidistantCylindricalEllipsoid; // This replaces pcvEquidistantCylindrical which was spherical only
    else if ((upperMethodName == "GNOMONIC") ||
             (upperMethodName == "GNOMONIC PROJECTION"))
        ID = BaseGCS::pcvGnomonic;
    else if ((upperMethodName == "ORTHOGRAPHIC") ||
             (upperMethodName == "ORTHOGRAPHIC PROJECTION"))
        ID = BaseGCS::pcvOrthographic;
    else if ((upperMethodName == "SINUSOIDAL") ||
             (upperMethodName == "CT_SINUSOIDAL"))
        ID = BaseGCS::pcvSinusoidal;
// Support of Krovak projection is just too much error prone ... There are various ways to express it and sometimes the
// angle complements appear provided instead of angles proper.
// Users should simply select the appropriate projection in dictionary for the moment
    else if ((upperMethodName == "KROVAK") ||
             (upperMethodName == "KROVAKEN") ||
             (upperMethodName == "KROVAK OBLIQUE CONFORMAL CONIC") ||
             (upperMethodName == "KROVAK OBLIQUE CONIC CONFORMAL") ||
             (upperMethodName == "KROVAK_OBLIQUE_CONIC_CONFORMAL"))
        ID = BaseGCS::pcvCzechKrovak; // ?? cs_PRJCOD_KRVK95
    else if ((upperMethodName == "KROVAK MODIFIED") ||
             (upperMethodName == "KROVAK OBLIQUE CONFORMAL CONIC MODIFIED") ||
             (upperMethodName == "KROVAKMOD") ||
             (upperMethodName == "KROVAK OBLIQUE CONIC CONFORMAL MODIFIED") ||
             (upperMethodName == "KROVAK_OBLIQUE_CONIC_CONFORMAL_MODIFIED"))
        ID = BaseGCS::pcvCzechKrovakModified;
    else if ((upperMethodName == "MILLER_CYLINDRICAL") ||
             (upperMethodName == "CT_MILLERCYLINDRICAL") ||
             (upperMethodName == "MILLER") ||
             (upperMethodName == "MILLER CYLINDRICAL"))
        ID = BaseGCS::pcvMillerCylindrical;
    else if ((upperMethodName == "VAN_DER_GRINTEN_I") ||
             (upperMethodName == "VANDERGRINTEN") ||
             (upperMethodName == "CT_VANDERGRINTEN") ||
             (upperMethodName == "VAN DER GRINTEN"))
        ID = BaseGCS::pcvVanderGrinten;
    else if ((upperMethodName == "HOTINE_OBLIQUE_MERCATOR_AZIMUTHAL_NATURAL_ORIGIN") ||
             (upperMethodName == "HOTINE_OBLIQUE_MERCATOR_AZIMUTH_NATURAL_ORIGIN") ||
             (upperMethodName == "HOTINE OBLIQUE MERCATOR") ||
             (upperMethodName == "HOTINE_OBLIQUE_MERCATOR") ||
             (upperMethodName == "CT_OBLIQUEMERCATOR_HOTINE") ||
             (upperMethodName == "ALASKA VARIATION OF HOTINE OBLIQUE MERCATOR")  ||
             (upperMethodName == "OBLIQUE_MERCATOR") ||
             (upperMethodName == "OBLIQUE MERCATOR") ||
             (upperMethodName == "CT_OBLIQUEMERCATOR") ||
             (upperMethodName == "HOTINE OBLIQUE MERCATOR (VARIANT A)"))
        ID = BaseGCS::pcvHotineObliqueMercator1XY;
    else if ((upperMethodName == "RECTIFIED SKEW ORTHOMORPHIC, AZIMUTH AT PROJECTION CENTER") ||
             (upperMethodName == "RECTIFIED SKEW ORTHOMORPHIC, ORIGIN & AZIMUTH AT CENTER") ||
             (upperMethodName == "RECTIFIED_SKEW_ORTHOMORPHIC_CENTER"))
        ID = BaseGCS::pcvRectifiedSkewOrthomorphic;
    else if (upperMethodName == "RECTIFIED_SKEW_ORTHOMORPHIC_NATURAL_ORIGIN")
        ID = BaseGCS::pcvRectifiedSkewOrthomorphic;
    else if (upperMethodName == "HOTINE OBLIQUE MERCATOR (VARIANT B)")
        ID = BaseGCS::pcvRectifiedSkewOrthomorphic;
    else if ((upperMethodName == "ROBINSON CYLINDRICAL") ||
             (upperMethodName == "ROBINSON") ||
             (upperMethodName == "CT_ROBINSON"))
        ID = BaseGCS::pcvRobinsonCylindrical;
    else if ((upperMethodName == "INTERRUPTED_GOODE_HOMOLSINE") ||
             (upperMethodName == "INTERRUPTED GOODE HOMOLSINE") ||
             (upperMethodName == "GOODE HOMOLSINE") ||
             (upperMethodName == "GOODE HOMOLOSINE PROJECTION") ||
             (upperMethodName == "GOODE_HOMOLSINE"))
        ID = BaseGCS::pcvGoodeHomolosine;
    else if ((upperMethodName == "MOLLWEIDE") ||
            (upperMethodName == "INTERRUPTED MOLLWEIDE"))
        ID = BaseGCS::pcvMollweide;
    else if ((upperMethodName == "ECKERT_IV") ||
             (upperMethodName == "EKERT PSEUDOCYLINDRICAL, NUMBER IV") ||
             (upperMethodName == "ECKERT IV"))
        ID = BaseGCS::pcvEckertIV;
    else if ((upperMethodName == "ECKERT_VI") ||
             (upperMethodName == "EKERT PSEUDOCYLINDRICAL, NUMBER VI") ||
             (upperMethodName == "ECKERT VI"))
        ID = BaseGCS::pcvEckertVI;
    else if ((upperMethodName == "LAMBERT_CONFORMAL_CONIC_2SP_BELGIUM") ||
             (upperMethodName == "LAMBERT CONFORMAL CONIC (BELGIUM 1972)") ||
             (upperMethodName == "LAMBERT CONFORMAL CONIC, BELGIAN VARIATION") ||
             (upperMethodName == "LAMBERT_CONIC_CONFORMAL_2SP_BELGIUM") ||
             (upperMethodName == "LAMBERT CONIC CONFORMAL (2SP BELGIUM)"))
        ID = BaseGCS::pcvLambertConformalConicBelgian;
    else if ((upperMethodName == "NEW_ZEALAND_MAP_GRID") ||
             (upperMethodName == "NEW ZEALAND MAP GRID") ||
             (upperMethodName == "NEW ZEALAND NATIONAL GRID") ||
             (upperMethodName == "CT_NEWZEALANDMAPGRID"))
        ID = BaseGCS::pcvNewZealandNationalGrid;
    else if ((upperMethodName == "CYLINDRICAL_EQUAL_AREA") ||
             (upperMethodName == "NORMAL ASPECT, EQUAL AREA CYLINDRICAL") ||
             (upperMethodName == "NORMAL ASPECT, EQUAL AREA CYLINDRICAL PROJECTION") ||
             (upperMethodName == "CYLINDRICAL EQUAL AREA"))
        ID = BaseGCS::pcvEqualAreaAuthalicNormal;
    else if ((upperMethodName == "TRANSVERSE ASPECT, EQUAL AREA CYLINDRICAL") ||
             (upperMethodName == "TRANSVERSE ASPECT, EQUAL AREA CYLINDRICAL PROJECTION"))
        ID = BaseGCS::pcvEqualAreaAuthalicTransverse;
    else if ((upperMethodName == "SWISS_OBLIQUE_CYLINDRICAL")||
             (upperMethodName == "SWISS OBLIQUE CYLINDRICAL") ||
             (upperMethodName == "SWISS_OBLIQUE_MERCATOR") ||
             (upperMethodName == "SWISS OBLIQUE MERCATOR") ||
             (upperMethodName == "CT_SWISSOBLIQUECYLINDRICAL") ||
             (upperMethodName == "HOTINE_OBLIQUE_MERCATOR_AZIMUTH_CENTER") ||
             (upperMethodName == "RECTIFIED SKEW ORTHOMORPHIC, FALSE ORIGIN AND AZIMUTH AT CENTER"))
        ID = BaseGCS::pcvObliqueCylindricalSwiss;
// Something wrong in our interpretation of Bonne projection ... to be done
// No hurry this one is very rarely used (if at all)
    else if ((upperMethodName == "BONNE") ||
             (upperMethodName == "BONNE PSEUDOCONICAL PROJECTION") ||
             (upperMethodName == "BONNE PSEUDOCONICAL"))
        ID = BaseGCS::pcvBonne;
    else if ((upperMethodName == "CASSINI") ||
             (upperMethodName == "CASSINI_SOLDNER") ||
             (upperMethodName == "CT_CASSINISOLDNER") ||
             (upperMethodName == "CASSINI-SOLDNER"))
        ID = BaseGCS::pcvCassini;
    else if ((upperMethodName == "WINKEL_TRIPEL") ||
             (upperMethodName == "WINKEL-TRIPEL") ||
             (upperMethodName == "WINKEL-TRIPEL, VARIABLE STANDARD LATITUDE"))
        ID = BaseGCS::pcvWinkelTripel;
    else if ((upperMethodName == "UNIVERSAL TRANSVERSE MERCATOR SYSTEM") ||
             (upperMethodName == "UTM") ||
             (upperMethodName == "TRANSVERSE MERCATOR ZONED GRID SYSTEM"))
        ID = BaseGCS::pcvUniversalTransverseMercator;
    else if (upperMethodName == "TRANSVERSE MERCATOR, WISCONSIN COUNTY VARIATION")
        ID = BaseGCS::pcvTransverseMercatorWisconsin;
    else if (upperMethodName == "LAMBERT CONFORMAL CONIC, WISCONSIN COUNTY VARIATION")
        ID = BaseGCS::pcvLambertConformalConicWisconsin;
    else if (upperMethodName == "TRANSVERSE MERCATOR, MINNESOTA DOT VARIATION")
        ID = BaseGCS::pcvTransverseMercatorMinnesota;
    else if (upperMethodName == "LAMBERT CONFORMAL CONIC, MINNESOTA DOT VARIATION")
        ID = BaseGCS::pcvLambertConformalConicMinnesota;
    else if ((upperMethodName == "DANISH SYSTEM 34, UTM + POLYNOMIALS (PRE-1999 VINTAGE)") ||
             (upperMethodName == "DANISH SYSTEM 34 (PRE-1999)"))
        ID = BaseGCS::pcvTransverseMercatorDenmarkSys34;
    else if (upperMethodName == "TRANSVERSE MERCATOR DANISH SYSTEM 34 JYLLAND-FYN")
        ID = BaseGCS::pcvTransverseMercatorDenmarkSys34;
    else if (upperMethodName == "TRANSVERSE MERCATOR SJAELLAND")
        ID = BaseGCS::pcvTransverseMercatorDenmarkSys34;
    else if (upperMethodName == "TRANSVERSE MERCATOR DANISH SYSTEM 45 BORNHOLM") // The 45 applies to Bornholm zone in system 34
        ID = BaseGCS::pcvTransverseMercatorDenmarkSys34;
    else if ((upperMethodName == "DANISH SYSTEM 34, UTM + POLYNOMIALS (1999 VINTAGE)") ||
             (upperMethodName == "DANISH SYSTEM 34 (1999)"))
        ID = BaseGCS::pcvTransverseMercatorDenmarkSys3499;
    else if ((upperMethodName == "OBLIQUE CYLINDRICAL") ||
             (upperMethodName == "OBLIQUE CYLINDRICAL PROJECTION (GENERALIZED)"))
        ID = BaseGCS::pcvObliqueCylindricalHungary;
    else if ((upperMethodName == "LAMBERT TANGENTIAL CONFORMAL CONIC PROJECTION") ||
             (upperMethodName == "LAMBERT TANGENTIAL") ||
             (upperMethodName == "LAMBERT CONFORMAL CONIC") ||
             (upperMethodName == "LAMBERT TANGENTIAL CONFORMAL CONIC"))
        ID = BaseGCS::pcvLambertTangential;
    else if (upperMethodName == "POPULAR VISUALISATION PSEUDO MERCATOR")
        ID = BaseGCS::pcvPopularVisualizationPseudoMercator;
    else if (upperMethodName == "ORDNANCE SURVEY NATIONAL GRID TRANSFORMATION OF 2015")
        ID = BaseGCS::pcvTransverseMercatorOstn15;
    else if (upperMethodName == "ORDNANCE SURVEY NATIONAL GRID TRANSFORMATION OF 2002")
        ID = BaseGCS::pcvTransverseMercatorOstn02;
    else if (upperMethodName == "ORDNANCE SURVEY NATIONAL GRID TRANSFORMATION OF 1997")
        ID = BaseGCS::pcvTransverseMercatorOstn97;
    else if ((upperMethodName == "PLATE CARREE") ||
             (upperMethodName == "PLATE_CARREE") ||
             (upperMethodName == "SIMPLE CYLINDRICAL") ||
             (upperMethodName == "SIMPLE_CYLINDRICAL") ||
             (upperMethodName == "PLATE CARREE / SIMPLE CYLINDRICAL"))
        ID = BaseGCS::pcvPlateCarree;
    else if ((upperMethodName == "BIPOLAR OBLIQUE CONFORMAL CONIC") ||
             (upperMethodName == "BIPOLAR OBLIQUE CONFORMAL CONIC PROJECTION"))
        ID = BaseGCS::pcvBipolarObliqueConformalConic;
    else if ((upperMethodName == "SOUTH ORIENTED TRANSVERSE MERCATOR") ||
             (upperMethodName == "TRANSVERSE_MERCATOR_SOUTH_ORIENTATED") ||
             (upperMethodName == "TRANSVERSE_MERCATOR_SOUTH_ORIENTED") ||
             (upperMethodName == "CT_TRANSVERSEMERCATOR_SOUTHORIENTED") ||
             (upperMethodName == "TRANSVERSE MERCATOR (SOUTH ORIENTATED)"))
        ID = BaseGCS::pcvSouthOrientedTransverseMercator;
    else if ((upperMethodName == "TRANSVERSE MERCATOR WITH AFFINE POST PROCESS") ||
             (upperMethodName == "TRANSVERSE MERCATOR (GAUSS/KRUGER) WITH AFFINE POST PROCESS") ||
             (upperMethodName == "CSMAP:54"))
        ID = BaseGCS::pcvTransverseMercatorAffinePostProcess;
    else if ((upperMethodName == "LAMBERT CONFORMAL CONIC (2SP) WITH AFFINE POST PROCESS") ||
             (upperMethodName == "CSMAP:65"))
        ID = BaseGCS::pcvLambertConformalConicAffinePostProcess;
    else if (upperMethodName == "RECTIFIED SKEW ORTHOMORPHIC, SKEW AZIMUTH AT RECTIFIED ORIGIN")
        ID = BaseGCS::pcvRectifiedSkewOrthomorphicOrigin;

// The following known WKT names have no mapping to CSMAP entries.

// These projections are cute little projections for historical purposes or for atlas
// views of the world. Support is certainly not essential:

// "Space Oblique Mercator"
// "Hammer"
// "Wagner IV"
// "Wagner VII"
// "Oblated Equal Area"
// "Gall_Stereographic"
// "Aitoff"
// "Craster_Parabolic"
// "Behrmann"
// "Hammer_Aitoff"
// "Eckert_I"
// "Eckert_II"
// "Eckert_III"
// "Eckert_V"
// "Flat_Polar_Quartic"
// "Loximuthal"
// "Quartic_Authalic"
// "Times"
// "Cube"
// "Fuller"
// "Winkel_I"
// "Winkel_II"

// The following could probably be supported but would require additional study and in some
// case the imposition of specific parameters.
// "PLATE_CARREE"
// "EQUIRECTANGULAR"
// "HOTINE_OBLIQUE_MERCATOR_AZIMUTH_CENTER"
// "Alaska Conformal"
// "Transverse Mercator Danish System 45 Bornholm"
// "Transverse Mercator Danish System 34 Jylland-Fyn"
// "Transverse Mercator Sjaelland"
// "Transverse Mercator Finnish KKJ"
// "Stereographic_North_Pole"
// "Stereographic_South_Pole"

// Not supported but could probably be useful
// "Tunisia_Mining_Grid"
// "Vertical_Near_Side_Perspective" OR "General Vertical Near-Side Perspective"


// The following CSMAP projections do not appear to have equivalent WKT entries.
// cs_PRJCOD_LMTAN
// cs_PRJCOD_TACYL
// cs_PRJCOD_HOM2XY
// cs_PRJCOD_MSTRO
// cs_PRJCOD_SOTRM
// cs_PRJCOD_RSKEWC
// cs_PRJCOD_OBQCYL
// cs_PRJCOD_OSTN97
// cs_PRJCOD_OSTN02
// cs_PRJCOD_OSTN15
// cs_PRJCOD_SYS34_99
// cs_PRJCOD_SYS34_01
// cs_PRJCOD_AZEDE
// cs_PRJCOD_TRMERAF
// cs_PRJCOD_RSKEWO
// cs_PRJCOD_TRMRKRG

    return ID;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method converts the projection Oracle code
*   to the CSMAP projection code. Not all projections are supported here but those that are
*   represent the vast majority of coordinate systems supported.
*
*   @param OracleEPSGID The EPSG ID as obtained from Oracle styles WKT
*
*   @return The projection code or BaseGCS::pcvInvalid if projection is not supported.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::ProjectionCodeValue GetProjectionCodeFromOracleEPSGID(Utf8StringR OracleEPSGID) const
    {
    BaseGCS::ProjectionCodeValue projectionMethod = BaseGCS::pcvInvalid;

    if (OracleEPSGID.length() > 5)
        {
        int projectionCode = std::atoi(OracleEPSGID.substr(5).c_str());
        if (projectionCode > 0)
            {
            int projectionMethodCode = 0;
            if (CS_wktProjectionMethodEPSGLookUp(projectionCode, &projectionMethodCode))
                {
                if (9807 == projectionMethodCode)
                    projectionMethod = BaseGCS::pcvTransverseMercator;
                else if (9801 == projectionMethodCode)
                    projectionMethod = BaseGCS::pcvLambertConformalConicOneParallel;
                else if (9802 == projectionMethodCode)
                    projectionMethod = BaseGCS::pcvLambertConformalConicTwoParallel;
                else if (9803 == projectionMethodCode)
                    projectionMethod = BaseGCS::pcvLambertConformalConicBelgian;
                else if (9804 == projectionMethodCode)
                    projectionMethod = BaseGCS::pcvMercator;
                else if (9806 == projectionMethodCode)
                    projectionMethod = BaseGCS::pcvCassini;
                else if (9811 == projectionMethodCode)
                    projectionMethod = BaseGCS::pcvNewZealandNationalGrid;
                else if (9827 == projectionMethodCode)
                    projectionMethod = BaseGCS::pcvBonne;
                }
            }
        }
        return projectionMethod;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method sets the projection code of the GCS.
*   Specifically for the Lambert Conformal Conic projection since the actual
*   variant may depend on the list of provided parameters the most supporting version
*   is selected (Michigan variation which supports an additional scaling just like
*   other popular software) if the promoteLCC parameter is true. After all parameters
*   have been set if is possible to simplify the projection if desired according to set
*   parameters.
*
*   @param projectionCode IN The projection code. If Lambert2SP is requested it will
     be promoted to the Michigan variation if the promoteLCC parameter is true.
*
*   @param promoteLCC IN If true a Lambert 2SP will be promoted to the Michigan variation.
*
*   @param coordinateSystem IN/OUT The coordinate system to set the projection code.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void SetProjectionCode(BaseGCS::ProjectionCodeValue projectionCode, bool promoteLCC, BaseGCSR coordinateSystem) const
    {
    if (promoteLCC && (projectionCode == BaseGCS::pcvLambertConformalConicTwoParallel))
    {
        coordinateSystem.SetProjectionCode(BaseGCS::pcvLambertMichigan);
        coordinateSystem.SetScaleReduction(1.0);
        coordinateSystem.SetEllipsoidScaleFactor(1.0);
        coordinateSystem.SetStandardParallel1(-90.0); // Markers for un-initialized parallel
        coordinateSystem.SetStandardParallel2(-90.0);
    }
    else
        coordinateSystem.SetProjectionCode(projectionCode);
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method sets the parameter value based on the
*   parameter name and projection code used by the coordinate system.
*
*   @param parameterName IN The parameter name as extracted from WKT.
*
*   @param parameterStringValue IN The parameter string value as in the WKT. This value
*   can be used when parameter calls for a string value instead of a numeric value (rarely)
*
*   @param parameterValue IN The value of the parameter.
*
*   @param IN/OUT The coordinate system to set the parameter value of. The ProjectionCode
*   must already have been properly set as it is used in the interpretation of the
*   parameter.
*
*   @return GeoCoordParse_Success if successful and any other value in case of error.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus SetParameterToCoordSys(Utf8StringR parameterName, Utf8StringR parameterStringValue, double parameterValue, double conversionToDegree, BaseGCSR coordinateSystem) const
    {
    // Obtain uppercase value
    Utf8String upperParameterName = parameterName;
    std::transform(upperParameterName.begin(), upperParameterName.end(), upperParameterName.begin(), [](char const& c) {return (char)toupper(c); });

    if ((upperParameterName == "FALSE_EASTING") ||
        (upperParameterName == "FALSEEASTING") ||
        (upperParameterName == "FALSE EASTING"))
        coordinateSystem.SetFalseEasting(parameterValue);
    else if ((upperParameterName == "FALSE_NORTHING") ||
            (upperParameterName == "FALSENORTHING") ||
            (upperParameterName == "FALSE NORTHING"))
            coordinateSystem.SetFalseNorthing(parameterValue);
    else if ((upperParameterName == "LATITUDE_OF_ORIGIN") ||
            (upperParameterName == "LATITUDE_OF_CENTER") ||
            (upperParameterName == "CENTRAL_PARALLEL") ||
            (upperParameterName == "NATORIGINLAT") ||
            (upperParameterName == "LATITUDE OF NATURAL ORIGIN") ||
            (upperParameterName == "LATITUDE OF FALSE ORIGIN") ||
            (upperParameterName == "ORIGIN LATITUDE") ||
            (upperParameterName == "CENTERLAT") ||
            (upperParameterName == "CENTRAL POINT LATITUDE") ||
            (upperParameterName == "LATITUDE OF PROJECTION CENTRE") ||
            (upperParameterName == "LATITUDE OF PROJECTION CENTER"))
        {
        if ((BaseGCS::pcvHotineObliqueMercator1XY == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvRectifiedSkewOrthomorphic == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvRectifiedSkewOrthomorphicOrigin == coordinateSystem.GetProjectionCode()))
            coordinateSystem.SetCentralPointLatitude(parameterValue * conversionToDegree);
        else if ((BaseGCS::pcvObliqueStereographic == coordinateSystem.GetProjectionCode()) ||
                 (BaseGCS::pcvSnyderObliqueStereographic == coordinateSystem.GetProjectionCode()))
            {
            if (doubleSame(90.0, parameterValue * conversionToDegree) || doubleSame(-90.0, parameterValue * conversionToDegree))
                {
                // A 90 degrees origin stereographic is in fact a polar stereographic
                coordinateSystem.SetProjectionCode(BaseGCS::pcvPolarStereographic);
                }
            coordinateSystem.SetOriginLatitude(parameterValue * conversionToDegree);
            }
        else
            coordinateSystem.SetOriginLatitude(parameterValue * conversionToDegree);
        }
    else if ((upperParameterName == "CENTRAL_MERIDIAN") ||
            (upperParameterName == "CENTRAL MERIDIAN"))
        {
        if ((BaseGCS::pcvObliqueCylindricalSwiss == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertConformalConicTwoParallel == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertConformalConicOneParallel == coordinateSystem.GetProjectionCode()) ||     // This fixes TR# 288399
            (BaseGCS::pcvLambertConformalConicBelgian == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertTangential == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertConformalConicMinnesota == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertConformalConicWisconsin == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertConformalConicAffinePostProcess == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertMichigan == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvEquidistantConic == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvEquidistantCylindricalEllipsoid == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertEquidistantAzimuthal == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvPolarStereographic == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvPolarStereographicStandardLatitude == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvBonne == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvCzechKrovak == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvCzechKrovakModified == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertEqualAreaAzimuthal == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvObliqueStereographic == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvSnyderObliqueStereographic == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvNewZealandNationalGrid == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvVanderGrinten == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvPlateCarree == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvMollweide == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvEckertIV == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvEckertVI == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvWinkelTripel == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvObliqueCylindricalHungary == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvAlbersEqualArea == coordinateSystem.GetProjectionCode()))
            {
            if (SUCCESS != coordinateSystem.SetOriginLongitude(parameterValue * conversionToDegree))
                return GeoCoordParse_InvalidParamForMethod;
            }
        else if ((BaseGCS::pcvHotineObliqueMercator1XY == coordinateSystem.GetProjectionCode()) ||
                (BaseGCS::pcvRectifiedSkewOrthomorphic == coordinateSystem.GetProjectionCode()))
            {
            if (SUCCESS != coordinateSystem.SetCentralPointLongitude(parameterValue * conversionToDegree))
                return GeoCoordParse_InvalidParamForMethod;
            }
        else
            {
            if (SUCCESS != coordinateSystem.SetCentralMeridian(parameterValue * conversionToDegree))
                return GeoCoordParse_InvalidParamForMethod;
            }
        }
    else if ((upperParameterName == "SCALE_FACTOR") ||
            (upperParameterName == "SCALEATNATORIGIN") ||
            (upperParameterName == "SCALE FACTOR AT NATURAL ORIGIN") ||
            (upperParameterName == "SCALE REDUCTION") ||
            (upperParameterName == "SCALING FACTOR FOR COORD DIFFERENCES"))
        {
        // WKT styles allow for mixup between Lambert Conformal Conic 2SP and with scale.
        // The presence of a scale here indicates we may have been mistaken and switch to Lambert 1SP
        if (BaseGCS::pcvLambertConformalConicTwoParallel == coordinateSystem.GetProjectionCode())
            coordinateSystem.SetProjectionCode(BaseGCS::pcvLambertConformalConicOneParallel);

        if (SUCCESS != coordinateSystem.SetScaleReduction(parameterValue))
            return GeoCoordParse_InvalidParamForMethod;

        if (BaseGCS::pcvLambertMichigan == coordinateSystem.GetProjectionCode())
            {
            if (SUCCESS != coordinateSystem.SetEllipsoidScaleFactor(parameterValue))
                return GeoCoordParse_InvalidParamForMethod;
            }
        }
    else if ((upperParameterName == "STANDARD CIRCLE LATITUDE") ||
             (upperParameterName == "LATITUDE_TRUE_SCALE") ||
             (upperParameterName == "LATITUDE OF STANDARD PARALLEL"))
        {
        // Promote to Polar Stereo with latitude if required
        if (BaseGCS::pcvPolarStereographic == coordinateSystem.GetProjectionCode())
            {
            // A value at the pole is ignored as it is superflous for a polar stereo without latitude
            if (!doubleSame(parameterValue, 90) && !doubleSame(parameterValue, -90))
                coordinateSystem.SetProjectionCode(BaseGCS::pcvPolarStereographicStandardLatitude);
            else
                {
                // Sometimes the origin latitude is set through this parameter and it must be either -90 or 90
                if (SUCCESS != coordinateSystem.SetOriginLatitude(parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
                }
            }

        if (BaseGCS::pcvPolarStereographicStandardLatitude == coordinateSystem.GetProjectionCode())
            {
            if (SUCCESS != coordinateSystem.SetStandardParallel1(parameterValue * conversionToDegree))
                return GeoCoordParse_InvalidParamForMethod;
            }
        else
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if (upperParameterName == "STANDARD PARALLEL")
        {
        // Some variation use this field with a Mercator projection to indicate the prime meridian
        // of the geographic coordinate system is different than Greenwich but we would not know how to reapply to the longitude shift it implies
        // All other projection should not use this parameter.
        if ((BaseGCS::pcvEquidistantCylindricalEllipsoid == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvMercator == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvPolarStereographicStandardLatitude == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvWinkelTripel == coordinateSystem.GetProjectionCode()))
            {
            if (SUCCESS != coordinateSystem.SetStandardParallel1(parameterValue * conversionToDegree))
                return GeoCoordParse_InvalidParamForMethod;
            }
        else if (BaseGCS::pcvPolarStereographic == coordinateSystem.GetProjectionCode())
            {
            // A value at the pole is ignored as it is superflous for a polar stereo without latitude
            if (!doubleSame(parameterValue, 90) && !doubleSame(parameterValue, -90))
                {
                coordinateSystem.SetProjectionCode(BaseGCS::pcvPolarStereographicStandardLatitude); //Promote to polar stereo with latitude.

                if (SUCCESS != coordinateSystem.SetStandardParallel1(parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
                }
            else
                {
                // Sometimes the origin latitude is set through this parameter and it must be either -90 or 90
                if (SUCCESS != coordinateSystem.SetOriginLatitude(parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
                }
            }
        else
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "STANDARD_PARALLEL_1") ||
            (upperParameterName == "STDPARALLEL1") ||
            (upperParameterName == "STANDARD_PARALLEL1") ||
            (upperParameterName == "LATITUDE OF 1ST STANDARD PARALLEL") ||
            (upperParameterName == "NORTHERN STANDARD PARALLEL"))
        {
        if (BaseGCS::pcvPolarStereographic == coordinateSystem.GetProjectionCode())
            {
            // A value at the pole is ignored as it is superflous for a polar stereo without latitude
            if (!doubleSame(parameterValue, 90) && !doubleSame(parameterValue, -90))
                {
                coordinateSystem.SetProjectionCode(BaseGCS::pcvPolarStereographicStandardLatitude); //Promote to polar stereo with latitude.
                if (SUCCESS != coordinateSystem.SetStandardParallel1(parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
                }
            else
                {
                // Sometimes the origin latitude is set through this parameter and it must be either -90 or 90
                if (SUCCESS != coordinateSystem.SetOriginLatitude(parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
                }
            }
        else if ((BaseGCS::pcvBonne == coordinateSystem.GetProjectionCode()) ||
            (BaseGCS::pcvLambertConformalConicOneParallel == coordinateSystem.GetProjectionCode()))
            {
            if (SUCCESS != coordinateSystem.SetOriginLatitude(parameterValue * conversionToDegree)) // Weird occurence !
                return GeoCoordParse_InvalidParamForMethod;
            }
        else
            {
            if (BaseGCS::pcvMercatorScaleReduction == coordinateSystem.GetProjectionCode())
                {
                // Something is off ... there are WKT that use the wrong Mercator code to set method
                coordinateSystem.SetProjectionCode(BaseGCS::pcvMercator);
                }

            if (SUCCESS != coordinateSystem.SetStandardParallel1(parameterValue * conversionToDegree))
                return GeoCoordParse_InvalidParamForMethod;
            }
        }
    else if ((upperParameterName == "STANDARD_PARALLEL_2") ||
            (upperParameterName == "STDPARALLEL2") ||
            (upperParameterName == "STANDARD_PARALLEL2") ||
            (upperParameterName == "LATITUDE OF 2ND STANDARD PARALLEL") ||
            (upperParameterName == "SOUTHERN STANDARD PARALLEL"))
        {
        if (SUCCESS != coordinateSystem.SetStandardParallel2(parameterValue * conversionToDegree))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if (upperParameterName == "NORMAL PARALLEL")
        {
        if (SUCCESS != coordinateSystem.SetStandardParallel1(parameterValue * conversionToDegree))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "AZIMUTH") ||
            (upperParameterName == "AZIMUTHANGLE") ||
            (upperParameterName == "GEODESIC AZIMUTH AT PROJECTION CENTER") ||
            (upperParameterName == "AZIMUTH OF INITIAL LINE") ||
            (upperParameterName == "RECTIFIED_GRID_ANGLE") ||
            (upperParameterName == "RECTIFIEDGRIDANGLE") ||
            (upperParameterName == "SKEW AZIMUTH AT RECTIFIED ORIGIN") ||
            (upperParameterName == "ANGLE FROM RECTIFIED TO SKEW GRID"))
        {
        if ((BaseGCS::pcvObliqueCylindricalSwiss != coordinateSystem.GetProjectionCode()) && // Swiss azimuth is implicit and needs(cannot) not be specified
            (BaseGCS::pcvCzechKrovak != coordinateSystem.GetProjectionCode()) &&             // Krovak azimuth is implicit and needs(cannot) not be specified
            (BaseGCS::pcvCzechKrovakModified != coordinateSystem.GetProjectionCode()))       // Krovak azimuth is implicit and needs(cannot) not be specified
            {
            if ((BaseGCS::pcvLambertConformalConicTwoParallel == coordinateSystem.GetProjectionCode()) ||
                (BaseGCS::pcvLambertMichigan == coordinateSystem.GetProjectionCode()))
                {
                // The only Lambert 2SP that takes azimuth is the lambert variation ... we switch though the azimuth is built in
                coordinateSystem.SetProjectionCode(BaseGCS::pcvLambertConformalConicBelgian);

                // Check the value (fixed)
                if (!doubleSame(0.0081384722222, parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
                }
            else
                {
                if (SUCCESS != coordinateSystem.SetAzimuth(parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
                }
            }
        }
    else if ((upperParameterName == "ZONENUMBER") ||
            (upperParameterName == "UTM ZONE NUMBER (1 - 60)") ||
            (upperParameterName == "UTM ZONE NUMBER"))
        {
        if (SUCCESS != coordinateSystem.SetUTMZone((int)parameterValue))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "HEMISPHERE") || (upperParameterName == "HEMISPHERE, NORTH OR SOUTH"))
        {
        int hemisphere;
        if (parameterStringValue.length() == 0)
            hemisphere = 1;
        else if ((parameterStringValue == "N") || (parameterStringValue == "1.0") || (parameterStringValue == "1"))
            hemisphere = 1;
        else
            hemisphere = -1;
        if (SUCCESS != coordinateSystem.SetHemisphere(hemisphere))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "LONGITUDE_OF_ORIGIN") ||
            (upperParameterName == "LONGITUDE_OF_CENTER") ||
            (upperParameterName == "NATORIGINLONG") ||
            (upperParameterName == "LONGITUDE OF NATURAL ORIGIN") ||
            (upperParameterName == "CENTRAL POINT LONGITUDE") ||
            (upperParameterName == "CENTERLONG") ||
            (upperParameterName == "LONGITUDE OF PROJECTION CENTRE") ||
            (upperParameterName == "LONGITUDE OF PROJECTION CENTER") ||
            (upperParameterName == "LONGITUDE OF FALSE ORIGIN") ||
            (upperParameterName == "ORIGIN LONGITUDE"))
        {
        switch (coordinateSystem.GetProjectionCode())
            {
            case BaseGCS::pcvGaussKrugerTranverseMercator:
            case BaseGCS::pcvTransverseMercator:
            case BaseGCS::pcvTotalTransverseMercatorBF:
            case BaseGCS::pcvCassini:
            case BaseGCS::pcvMillerCylindrical:
            case BaseGCS::pcvAmericanPolyconic:
            case BaseGCS::pcvSouthOrientedTransverseMercator:
            case BaseGCS::pcvMercator:
            case BaseGCS::pcvMercatorScaleReduction:
            case BaseGCS::pcvModifiedPolyconic:
            case BaseGCS::pcvTransverseMercatorMinnesota:
            case BaseGCS::pcvTransverseMercatorWisconsin:
                if (SUCCESS != coordinateSystem.SetCentralMeridian(parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
                break;

            case BaseGCS::pcvHotineObliqueMercator1XY:
            case BaseGCS::pcvRectifiedSkewOrthomorphic:
            case BaseGCS::pcvRectifiedSkewOrthomorphicOrigin:
                if (SUCCESS != coordinateSystem.SetCentralPointLongitude(parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
                break;
            default:
                if (SUCCESS != coordinateSystem.SetOriginLongitude(parameterValue * conversionToDegree))
                    return GeoCoordParse_InvalidParamForMethod;
            }
        }
    else if ((upperParameterName == "HEIGHT") || (upperParameterName == "AVERAGE ELEVATION (SYSTEM UNIT)")) // Elevation
        {
        if (SUCCESS != coordinateSystem.SetElevationAboveGeoid(parameterValue))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if (upperParameterName == "AVERAGE GEOID HEIGHT (METERS)")
        {
        if (SUCCESS != coordinateSystem.SetGeoidSeparation(parameterValue))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "PSEUDO_STANDARD_PARALLEL_1") ||
            (upperParameterName == "LATITUDE OF PSEUDO STANDARD PARALLEL"))
        {
        if (SUCCESS != coordinateSystem.SetStandardParallel1(parameterValue * conversionToDegree))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if (upperParameterName == "OBLIQUE CONE STANDARD PARALLEL")
        {
        if (SUCCESS != coordinateSystem.SetStandardParallel1(parameterValue * conversionToDegree))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if (upperParameterName == "OBLIQUE POLE LONGITUDE")
        {
        if (SUCCESS != coordinateSystem.SetPoint1Longitude(parameterValue * conversionToDegree)) // For Krovak projections
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if (upperParameterName == "OBLIQUE POLE LATITUDE")
        {
        if (SUCCESS != coordinateSystem.SetPoint1Latitude(parameterValue * conversionToDegree)) // For Krovak projections
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "REGION") ||
            (upperParameterName == "DANISH 34/45 REGION (1=J, 2=S, 3=B)"))
        {
        if (SUCCESS != coordinateSystem.SetDanishSys34Region((int)parameterValue)) // For Danish projections
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if (upperParameterName == "AUXILIARY_SPHERE_TYPE") // ESRI weirdness ... we only support value 0.0
        {
        if (parameterValue != 0.0) // Floating point compare without epsilon is intensional
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "A0") ||
            (upperParameterName == "AFFINE TRANSFORMATION A0 COEFFICIENT"))
        {
        if (SUCCESS != coordinateSystem.SetAffineA0(parameterValue))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "A1") ||
            (upperParameterName == "AFFINE TRANSFORMATION A1 COEFFICIENT"))
        {
        if (SUCCESS != coordinateSystem.SetAffineA1(parameterValue))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "A2") ||
            (upperParameterName == "AFFINE TRANSFORMATION A2 COEFFICIENT"))
        {
        if (SUCCESS != coordinateSystem.SetAffineA2(parameterValue))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "B0") ||
            (upperParameterName == "AFFINE TRANSFORMATION B0 COEFFICIENT"))
        {
        if (SUCCESS != coordinateSystem.SetAffineB0(parameterValue))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "B1") ||
            (upperParameterName == "AFFINE TRANSFORMATION B1 COEFFICIENT"))
        {
        if (SUCCESS != coordinateSystem.SetAffineB1(parameterValue))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "B2") ||
            (upperParameterName == "AFFINE TRANSFORMATION B2 COEFFICIENT"))
        {
        if (SUCCESS != coordinateSystem.SetAffineB2(parameterValue))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if ((upperParameterName == "ZONE WIDTH") ||
             (upperParameterName == "ZONE_WIDTH"))
        {
        // We ignore this parameter yet validate we are dealing with a form of Transverse Mercator
        if ((BaseGCS::pcvTransverseMercator != coordinateSystem.GetProjectionCode()) &&
            (BaseGCS::pcvGaussKrugerTranverseMercator != coordinateSystem.GetProjectionCode()) &&
            (BaseGCS::pcvTransverseMercatorAffinePostProcess != coordinateSystem.GetProjectionCode()) &&
            (BaseGCS::pcvTransverseMercatorKruger != coordinateSystem.GetProjectionCode()) &&
            (BaseGCS::pcvTotalUniversalTransverseMercator != coordinateSystem.GetProjectionCode()) &&
            (BaseGCS::pcvTotalTransverseMercatorBF != coordinateSystem.GetProjectionCode()) &&
            (BaseGCS::pcvUniversalTransverseMercator != coordinateSystem.GetProjectionCode()))
            return GeoCoordParse_InvalidParamForMethod;
        }
    else if (upperParameterName == "XY_PLANE_ROTATION") // OGR weirdness ... Not really supported ... a variant for skew angle which is not supported by CSMAP
        return GeoCoordParse_UnsupportedProjectionParam;
    else
        return GeoCoordParse_UnknownProjectionParam;

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetDatumNameFromNameOrAlias(Utf8StringR finalDatumName, Utf8StringCR name, Utf8StringCR authorityID) const
    {
    Utf8String ellipsoidName;
    return GetDatumNameFromNameAliasOrTransform(finalDatumName, name, authorityID, false, ellipsoidName, false, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetDatumNameFromNameAliasOrTransform(Utf8StringR finalDatumName, Utf8StringCR name, Utf8StringCR authorityID, bool ellipsoidKnownAndPresent, Utf8String& ellipsoidName, bool transfoParamPresent, double deltaX, double deltaY, double deltaZ, double rotX, double rotY, double rotZ, double scalePPM) const
    {
    // Check that there is a datum name even specified
    // If there are none then likely this represents and ellipsoid-based unspecified datum coordinate system
    // In such case this ellipsoid may already been set in the GCS and nothing needs be done except nullify the datum code
    if (0 == name.length())
        {
        // If the ellipsoid is present and we have transformation parameters we will try to find a match
        // Note that if no match is found no error is issued and the coordinate system will remain
        // ellipsoid based.
        if (transfoParamPresent)
            {
            FindDatumFromTransformationParams(finalDatumName, ellipsoidName, deltaX, deltaY, deltaZ, rotX, rotY, rotZ, scalePPM);
            }
        }
    else
        {
        // Check if datum name is known ...
        DatumCP namedDatum = Datum::CreateDatum (name.c_str());
        bool finalNameDeprecated = false;

        if (namedDatum == NULL || ! namedDatum->IsValid())
            {
            if (nullptr != namedDatum) // In case created but invalid
                {
                namedDatum->Destroy();
                namedDatum = nullptr;
                }

            // Datum not found ... try with authority ID if defined and not deprecated
            if (authorityID.length() > 0)
                {
                namedDatum = Datum::CreateDatum (authorityID.c_str());
                if (namedDatum != NULL && namedDatum->IsValid())
                    {
                    finalNameDeprecated = namedDatum->IsDeprecated();
                    finalDatumName = authorityID;

                    namedDatum->Destroy();
                    namedDatum = nullptr;
                    }
                else if (nullptr != namedDatum)
                    {
                    namedDatum->Destroy();
                    namedDatum = nullptr;
                    }
                }
            }
        else
            {
            finalDatumName = name;
            finalNameDeprecated = namedDatum->IsDeprecated();
            namedDatum->Destroy();
            namedDatum = nullptr;
            }

        // Sometimes GDAL/OGR adds an additiona D_ before a perfectly valid name
        if ((finalDatumName.length() == 0) && (name.substr(0, 2) == "D_") && (name.length() >= 3))
            {
            Utf8String tempName = name.substr(2);

            namedDatum = Datum::CreateDatum(tempName.c_str());

            if (namedDatum == NULL || !namedDatum->IsValid())
                {
                if (nullptr != namedDatum) // In case created but invalid
                    {
                    namedDatum->Destroy();
                    namedDatum = nullptr;
                    }

                // We do not have the datum name yet ... try looking it up in the alias table.
                Utf8String     alternateName;

                if (WKTDatumLookup(tempName.c_str(), alternateName))
                    {
                    namedDatum = Datum::CreateDatum(alternateName.c_str());
                    if (namedDatum != NULL && namedDatum->IsValid())
                        {
                        if ((finalDatumName.length() == 0) || (finalNameDeprecated && (!namedDatum->IsDeprecated())))
                            finalDatumName = alternateName;

                        namedDatum->Destroy();
                        namedDatum = nullptr;
                        }
                    else if (nullptr == namedDatum)
                        {
                        namedDatum->Destroy();
                        namedDatum = nullptr;
                        }
                    }
                }
            else
                {
                finalDatumName = tempName;
                finalNameDeprecated = namedDatum->IsDeprecated();
                namedDatum->Destroy();
                namedDatum = nullptr;
                }
            }

        // Sometimes all WKT identifiers contains spaces instead of underscore ...
        if (finalDatumName.length() == 0)
            {
            Utf8String tempName = name;

            // A lot of D_ starting identifier contain space instead of underscores ... we normalize
            std::transform(tempName.begin(), tempName.end(), tempName.begin(), [](char const& c) {return (c == ' ' ? '_' : c); });

            namedDatum = Datum::CreateDatum(tempName.c_str());

            if (namedDatum == NULL || !namedDatum->IsValid())
                {
                if (nullptr != namedDatum) // In case created but invalid
                    {
                    namedDatum->Destroy();
                    namedDatum = nullptr;
                    }

                // We do not have the datum name yet ... try looking it up in the alias table.
                Utf8String     alternateName;

                if (WKTDatumLookup(tempName.c_str(), alternateName))
                    {
                    namedDatum = Datum::CreateDatum(alternateName.c_str());
                    if (namedDatum != NULL && namedDatum->IsValid())
                        {
                        if ((finalDatumName.length() == 0) || (finalNameDeprecated && (!namedDatum->IsDeprecated())))
                            finalDatumName = alternateName;

                        namedDatum->Destroy();
                        }
                    else if (nullptr != namedDatum)
                        {
                        namedDatum->Destroy();
                        namedDatum = nullptr;
                        }
                    }
                }
            else
                {
                finalDatumName = tempName;
                finalNameDeprecated = namedDatum->IsDeprecated();
                namedDatum->Destroy();
                namedDatum = nullptr;
                }
            }

        if ((finalDatumName.length() == 0) || finalNameDeprecated)
            {
            // We do not have the datum name yet ... try looking it up in the alias table.
            Utf8String     alternateName;

            if (WKTDatumLookup (name.c_str(), alternateName))
                {
                namedDatum = Datum::CreateDatum (alternateName.c_str());
                if (namedDatum != NULL && namedDatum->IsValid())
                    {
                    bool newNameDeprecated = namedDatum->IsDeprecated();
                    if ((finalDatumName.length() == 0) || (finalNameDeprecated && !newNameDeprecated))
                        {
                        finalDatumName = alternateName;
                        finalNameDeprecated = newNameDeprecated;
                        }

                    namedDatum->Destroy();
                    namedDatum = nullptr;
                    }
                else if (nullptr != namedDatum)
                    {
                    namedDatum->Destroy();
                    namedDatum = nullptr;
                    }
                }

            // Either there is no alias or the alias is not good ... if authority ID is present ...
            if (((finalDatumName.length() == 0) || finalNameDeprecated) && (authorityID.length() != 0))
                {
                if (WKTDatumLookup (authorityID.c_str(), alternateName))
                    {
                    // Alternate name should be valid
                    namedDatum = Datum::CreateDatum (authorityID.c_str());
                    if (namedDatum != NULL && namedDatum->IsValid())
                        {
                        if ((finalDatumName.length() == 0) || (finalNameDeprecated && !namedDatum->IsDeprecated()))
                            {
                            finalNameDeprecated = false;
                            finalDatumName = authorityID;
                            }

                        namedDatum->Destroy();
                        namedDatum = nullptr;
                        }
                    else if (nullptr != namedDatum)
                        {
                        namedDatum->Destroy();
                        namedDatum = nullptr;
                        }
                    }

                // If after having tried with the authority id it is still deprecated
                if (finalNameDeprecated)
                    {
                    if (WKTDatumLookup (authorityID.c_str(), alternateName))
                        {
                        // Alternate name should be valid
                        namedDatum = Datum::CreateDatum (alternateName.c_str());
                        if (namedDatum != NULL && namedDatum->IsValid())
                            {
                            if ((finalDatumName.length() == 0) || (finalNameDeprecated && !namedDatum->IsDeprecated()))
                                {
                                finalDatumName = alternateName;
                                finalNameDeprecated = false;
                                }

                            namedDatum->Destroy();
                            namedDatum = nullptr;
                            }
                        else if (nullptr != namedDatum)
                            {
                            namedDatum->Destroy();
                            namedDatum = nullptr;
                            }
                        }
                    }
                }
            }

        // Try setting by EPSG number if one is in authority id
        if ((finalDatumName.length() == 0) && (authorityID.substr(0, 5) == ("EPSG:")))
            {
            int epsgNumber = std::atoi(authorityID.substr(5).c_str());
            if (epsgNumber > 0)
                {
                namedDatum = Datum::CreateDatumFromEPSGCode(epsgNumber);
                if (namedDatum != NULL && namedDatum->IsValid())
                    {
                    finalDatumName = namedDatum->GetName();
                    namedDatum->Destroy();
                    namedDatum = nullptr;
                    }
                else if (nullptr != namedDatum)
                    {
                    namedDatum->Destroy();
                    namedDatum = nullptr;
                    }
                }
            }

        if (finalDatumName.length() != 0)
            {
            // We have a datum name ... we simply need to set it now ... in order to do this we need the code
            int foundIndex = FindDatumIndex (finalDatumName.c_str());

            if (foundIndex < 0 && !transfoParamPresent)
                return GeoCoordParse_UnknownDatum;

            if (transfoParamPresent)
                {
                Utf8String paramDatum;
                if (FindDatumFromTransformationParams(paramDatum, ellipsoidName.c_str(), deltaX, deltaY, deltaZ, rotX, rotY, rotZ, scalePPM))
                    {
                    // We found a datum ... check if same or same definition
                    if (paramDatum != finalDatumName)
                        {
                        // Create both datums and compare
                        DatumCP namedDatum1 = Datum::CreateDatum(finalDatumName.c_str());
                        DatumCP namedDatum2 = Datum::CreateDatum(paramDatum.c_str());

                        if ((nullptr != namedDatum1) && (nullptr != namedDatum2) && !DatumEquivalent(*(namedDatum1->GetCSDatum()), *(namedDatum2->GetCSDatum()), false, false, true))
                            {
                            // This case can occur when a datum has a null transformation to WGS84 but has not the same shape for the ellipsoid (example: SphereWGS84)
                            // In this case we simply check and go on
                            // It can also occur when the seleted datum is deprecated in which case we take the newly found one.
                            if (finalNameDeprecated)
                                {
                                // If the previously selected datum was deprecated and the TOWGS84 are different then we keep the one we have found.
                                finalDatumName = paramDatum;
                                }

                            else if (!(distanceSame(deltaX, 0.0) && distanceSame(deltaY, 0.0) && distanceSame(deltaZ, 0.0) &&
                                doubleSame(rotX, 0.0) && doubleSame(rotY, 0.0) && doubleSame(rotZ, 0.0) && doubleSame(scalePPM, 0.0)))
                                {
                                // If they are still different then it may be because the found datum is based on an evolved method
                                // such as grid shift files or multiple regression. In this case we consider the transformation parameters provided as fallback
                                // solution.
                                WGS84ConvertCode datumConvert = namedDatum1->GetConvertToWGS84MethodCode();

                                if ((ConvertType_MREG != datumConvert) &&
                                    (ConvertType_NAD27 != datumConvert) &&
                                    (ConvertType_HPGN != datumConvert) &&
                                    (ConvertType_AGD66 != datumConvert) &&
                                    (ConvertType_AGD84 != datumConvert) &&
                                    (ConvertType_NZGD4 != datumConvert) &&
                                    (ConvertType_ATS77 != datumConvert) &&
                                    (ConvertType_CSRS != datumConvert) &&
                                    (ConvertType_TOKYO != datumConvert) &&
                                    (ConvertType_RGF93 != datumConvert) &&
                                    (ConvertType_ED50 != datumConvert) &&
                                    (ConvertType_DHDN != datumConvert) &&
                                    (ConvertType_GENGRID != datumConvert) &&
                                    (ConvertType_CHENYX != datumConvert))
                                    {
                                    // Check if the found datum is not deprecated other wise we will keep the original and ignore the difference.
                                    if (!namedDatum2->IsDeprecated())
                                        {
                                        // datum based on transform parameters is not deprecated ... I guess since the
                                        // parameters were specified we will use it.
                                        finalDatumName = paramDatum;
                                        }
                                    }
                                }
                            }

                        if (nullptr != namedDatum1)
                            namedDatum1->Destroy();
                        if (nullptr != namedDatum2)
                            namedDatum2->Destroy();
                        }
                    }
                }
            }
        else if (transfoParamPresent)
            {
            // No datum match yet transformation parameters were located
            if (!FindDatumFromTransformationParams(finalDatumName, ellipsoidName.c_str(), deltaX, deltaY, deltaZ, rotX, rotY, rotZ, scalePPM))
                return GeoCoordParse_UnknownDatum;
            }
        else
            return GeoCoordParse_UnknownDatum;
        }

        return (finalDatumName.length() == 0 ? GeoCoordParse_UnknownDatum : GeoCoordParse_Success);
    }

}; // end of SRSGeneralParser class

/*=================================================================================**//**
*
* OSGEO XML Parser class. Parses the XML to a valid BaseGCS.
*
* NOTE: Error processing is still minimal. The functions will return the generic error ERROR
* most if not all of the times. Error processing will be completed later on in the
* development process
*
+===============+===============+===============+===============+===============+======*/
class OSGEOXMLParser: public SRSGeneralParser
{
private:
    mutable BeXmlDomPtr m_xmlDom;

public:

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
OSGEOXMLParser()
    {
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
virtual ~OSGEOXMLParser()
    {
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus Process (BaseGCSR baseGCS, Utf8CP source) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;
    BeXmlStatus xmlStatus;

    Utf8String ellipsoidAlias;
    Utf8String datumAlias;
    Utf8String gcsAlias;

    // The version of CreateAndReadFromString() taking Utf8 is flawed on LINUX. If we use the Utf8CP version it works.
    Utf8String tempXML(source);
    // Verify that the XML file header is stripped
    tempXML.Trim();
    if (tempXML.substr(0,2) == "<?")
        {
        // XML Header is present we remove it
        auto pos = tempXML.find("?>");
        if (std::string::npos != pos)
            tempXML = tempXML.substr(pos+2);
        }

    m_xmlDom = BeXmlDom::CreateAndReadFromString (xmlStatus, tempXML.c_str());

    if (!m_xmlDom.IsValid() || xmlStatus != BEXML_Success)
        return GeoCoordParse_ParseError;

    BeXmlNodeP rootNode = m_xmlDom->GetRootElement ();
    if (nullptr == rootNode)
        return GeoCoordParse_ParseError;
    if (Utf8String(rootNode->GetName()) != "Dictionary")
        return GeoCoordParse_NoRoot;

    // Get aliases and components
    BeXmlNodeP gcsNode = nullptr;
    bool gcsGeographic = false;
    BeXmlNodeP datumNode = nullptr;
    BeXmlNodeP ellipsoidNode = nullptr;

    BeXmlNodeP child = rootNode->GetFirstChild();
    if (nullptr == child)
        return GeoCoordParse_NoGCS;

    do {
        if (Utf8String(child->GetName()) == "Alias")
            {
            Utf8String typeVal;
            Utf8String referenced;
            Utf8String idVal;
            if (GeoCoordParse_Success != (status = GetAlias(idVal, typeVal, referenced, child)))
                return status;

            if (typeVal == "Ellipsoid")
                ellipsoidAlias = idVal;
            else if (typeVal == "Datum")
                datumAlias = idVal;
            else if (typeVal == "CoordinateSystem")
                gcsAlias = idVal;
            }
        else if (Utf8String(child->GetName()) == "GeodeticDatum")
            datumNode = child;
        else if (Utf8String(child->GetName()) == "Ellipsoid")
            ellipsoidNode = child;
        else if (Utf8String(child->GetName()) == "ProjectedCoordinateSystem")
            gcsNode = child;
        else if (Utf8String(child->GetName()) == "GeographicCoordinateSystem")
            {
            gcsNode = child;
            gcsGeographic = true;
            }
    } while (nullptr != (child = child->GetNextSibling()));

    if (nullptr == gcsNode)
        return GeoCoordParse_NoGCS;

    status = ParseGCS(baseGCS, gcsNode, gcsGeographic, gcsAlias, datumNode, datumAlias, ellipsoidNode, ellipsoidAlias, rootNode);

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetAlias(Utf8String& alias, Utf8String& type, Utf8String& referenced, BeXmlNodeP aliasNode) const
    {
    if (nullptr == aliasNode)
        return GeoCoordParse_Error;

    Utf8String idVal;
    if (BEXML_Success != aliasNode->GetAttributeStringValue(type, "type"))
        return GeoCoordParse_BadAlias;

    if (BEXML_Success != aliasNode->GetAttributeStringValue(idVal, "id"))
        return GeoCoordParse_BadAlias;

    if (GeoCoordParse_Success != GetNodeContent(referenced, aliasNode, "ObjectId"))
        return GeoCoordParse_BadAlias;

    Utf8String nameSpace;
    if (GeoCoordParse_Success != GetNodeContent(nameSpace, aliasNode, "Namespace"))
        return GeoCoordParse_BadAlias;

    if ("EPSG Code" == nameSpace)
        alias = "EPSG:" + idVal;
    else
        alias = nameSpace + idVal;

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   Returns the first subnode of given name of parent node. If there are no subnode of
*   of this name then nullptr is returned.
*   @param parent parent node to obtain a child from.
*   @param nodeName the name of the first child of parent to obtain.
*   @return the child or nullptr if not subnode of provided name is found.
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BeXmlNodeP GetNode(BeXmlNodeP parent, Utf8CP nodeName) const
    {
    if (nullptr == parent)
        return nullptr;

    BeXmlNodeP child = parent->GetFirstChild();

    while (nullptr != child && Utf8String(child->GetName()) != nodeName)
        child = child->GetNextSibling();

    return child;
    }

/*---------------------------------------------------------------------------------**//**
*   Returns the content of the first child of parent node.
*   @param content OUT the Utf8String that received the content of the node.
*   @param parent IN the parent node to extract the content of the child from.
*   @param nodeName IN The name of the child node to obtain the content of.
*   @return GeoCoordParse_Success if obtention of the content of the child was successful an error
*           otherwise.
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetNodeContent(Utf8String& content, BeXmlNodeP parent, Utf8CP nodeName) const
    {
    BeXmlNodeP theNode = GetNode(parent, nodeName);

    if (nullptr == theNode)
        return GeoCoordParse_NodeNotFound;

    if (BEXML_Success != theNode->GetContent(content))
        return GeoCoordParse_NoContent;

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetProjectionMethod(BaseGCSR baseGCS, BeXmlNodeP gcsNode) const
    {
    if (nullptr == gcsNode)
        return GeoCoordParse_Error;

    Utf8String projectionMethodId;

    BeXmlNodeP conversionNode = GetNode(gcsNode, "Conversion");
    if (nullptr == conversionNode)
        return GeoCoordParse_BadProjectionMethod;

    BeXmlNodeP projectionNode = GetNode(conversionNode, "Projection");
    if (nullptr == projectionNode)
        return GeoCoordParse_BadProjectionMethod;

    if (GeoCoordParse_Success != GetNodeContent(projectionMethodId, projectionNode, "OperationMethodId"))
        return GeoCoordParse_BadProjectionMethod;

    BaseGCS::ProjectionCodeValue projectionCode = GetProjectionCodeFromParseName (projectionMethodId);

    // We tried everything but could not determine the projection method.
    if (BaseGCS::pcvInvalid == projectionCode)
        return GeoCoordParse_UnknownProjectionMethod;

    baseGCS.SetProjectionCode (projectionCode);

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetParameter(BeXmlNodeP parameterValueNode, Utf8String& parameterName, double& numValue, Utf8String& stringValue) const
    {
    if (nullptr == parameterValueNode)
        return GeoCoordParse_Error;

    if (GeoCoordParse_Success != GetNodeContent(parameterName, parameterValueNode, "OperationParameterId"))
        return GeoCoordParse_BadProjectionParam;

    if (GeoCoordParse_Success == GetNodeContent(stringValue, parameterValueNode, "Value"))
        {
        numValue = std::atof(stringValue.c_str());
        }
    else if (GeoCoordParse_Success == GetNodeContent(stringValue, parameterValueNode, "IntegerValue"))
        {
        numValue = static_cast<double>(std::atoi(stringValue.c_str()));
        }
    else
        return GeoCoordParse_BadProjectionParam;

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetAllParameters(BaseGCSR baseGCS, BeXmlNodeP gcsNode) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    if (nullptr == gcsNode)
        return GeoCoordParse_Error;

    Utf8String projectionMethodId;

    BeXmlNodeP conversionNode = GetNode(gcsNode, "Conversion");
    if (nullptr == conversionNode)
        return GeoCoordParse_BadProjectionParamsSection;

    BeXmlNodeP projectionNode = GetNode(conversionNode, "Projection");
    if (nullptr == projectionNode)
        return GeoCoordParse_BadProjectionParamsSection;

    BeXmlNodeP theCurrentNode = projectionNode->GetFirstChild();
    while(nullptr != theCurrentNode)
        {
        if (Utf8String(theCurrentNode->GetName()) == "ParameterValue")
            {
            double parameterValue = 0.0;
            Utf8String parameterStringValue;
            Utf8String parameterName;
            if (GeoCoordParse_Success != (status = GetParameter (theCurrentNode, parameterName, parameterValue, parameterStringValue)))
                return status;

            if (parameterName.length() > 0)
                {
                double conversionToDegree = 1.0; // For XML a projected always uses degrees

                if (GeoCoordParse_Success != (status = SetParameterToCoordSys (parameterName, parameterStringValue, parameterValue, conversionToDegree, baseGCS)))
                    return status;
                }
            }
        theCurrentNode = theCurrentNode->GetNextSibling();
        }

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetProjection(BaseGCSR baseGCS, BeXmlNodeP gcsNode) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    if (nullptr == gcsNode)
        return GeoCoordParse_Error;

    if (GeoCoordParse_Success != (status = GetProjectionMethod(baseGCS, gcsNode)))
        return status;

    if (GeoCoordParse_Success != (status = GetAllParameters(baseGCS, gcsNode)))
        return status;

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetQuadrant(BaseGCSR baseGCS, BeXmlNodeP gcsNode) const
    {
    if (nullptr == gcsNode)
        return GeoCoordParse_Error;

    BeXmlNodeP infoNode = GetNode(gcsNode, "AdditionalInformation");
    if (nullptr == infoNode)
        return GeoCoordParse_BadQuadrant;

    BeXmlNodeP theCurrentNode = infoNode->GetFirstChild();
    while(nullptr != theCurrentNode)
        {
        if (Utf8String(theCurrentNode->GetName()) == "ParameterItem")
            {
            Utf8String keyValue;
            if (GeoCoordParse_Success == GetNodeContent(keyValue, theCurrentNode, "Key"))
                {
                if (keyValue == "CSQuadrantSimplified")
                    {
                    BeXmlNodeP quadNode = GetNode(theCurrentNode, "IntegerValue");
                    if (nullptr != quadNode)
                        {
                        uint32_t quadValue;
                        if (BEXML_Success == quadNode->GetContentUInt32Value(quadValue))
                            {
                            if (SUCCESS == baseGCS.SetQuadrant(static_cast<short>(quadValue)))
                                return GeoCoordParse_Success;
                            }
                        }
                    }
                }
            }
        theCurrentNode = theCurrentNode->GetNextSibling();
        }

    return GeoCoordParse_BadQuadrant;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetDomainOfValidity(BaseGCSR baseGCS, BeXmlNodeP gcsNode) const
    {
    if (nullptr == gcsNode)
        return GeoCoordParse_Error;

    BeXmlNodeP domainNode = GetNode(gcsNode, "DomainOfValidity");
    if (nullptr == domainNode)
        return GeoCoordParse_BadDomain;

    BeXmlNodeP extentNode = GetNode(domainNode, "Extent");
    if (nullptr == extentNode)
        return GeoCoordParse_BadDomain;

    BeXmlNodeP geogElemNode = GetNode(extentNode, "GeographicElement");
    if (nullptr == geogElemNode)
        return GeoCoordParse_BadDomain;

    BeXmlNodeP geogBoxNode = GetNode(geogElemNode, "GeographicBoundingBox");
    if (nullptr == geogBoxNode)
        return GeoCoordParse_BadDomain;

    bool westPresent = false;
    bool eastPresent = false;
    bool northPresent = false;
    bool southPresent = false;
    double west = 0.0;
    double east = 0.0;
    double north = 0.0;
    double south = 0.0;

    BeXmlNodeP theCurrentNode = geogBoxNode->GetFirstChild();
    while(nullptr != theCurrentNode)
        {
        if (Utf8String(theCurrentNode->GetName()) == "WestBoundLongitude")
            {
            westPresent = true;
            if (BEXML_Success != theCurrentNode->GetContentDoubleValue(west))
                return GeoCoordParse_BadDomain;
            }
        else if (Utf8String(theCurrentNode->GetName()) == "EastBoundLongitude")
            {
            eastPresent = true;
            if (BEXML_Success != theCurrentNode->GetContentDoubleValue(east))
                return GeoCoordParse_BadDomain;
            }
        else if (Utf8String(theCurrentNode->GetName()) == "SouthBoundLatitude")
            {
            southPresent = true;
            if (BEXML_Success != theCurrentNode->GetContentDoubleValue(south))
                return GeoCoordParse_BadDomain;
            }
        else if (Utf8String(theCurrentNode->GetName()) == "NorthBoundLatitude")
            {
            northPresent = true;
            if (BEXML_Success != theCurrentNode->GetContentDoubleValue(north))
                return GeoCoordParse_BadDomain;
            }
        theCurrentNode = theCurrentNode->GetNextSibling();
        }

    // We want coherent extent bounds. Note that even if technically east can be smaller than west
    // and vice versa when crossing the 180/-180 degree line since CMSAP has sometimes issues with
    // that and minimum and maximum are mostly informational we prefer not to set something CSMAP would reject.
    if (westPresent && eastPresent && northPresent && southPresent && east > west && north > south)
        {
        baseGCS.SetMinimumLongitude(west);
        baseGCS.SetMaximumLongitude(east);
        baseGCS.SetMinimumLatitude(south);
        baseGCS.SetMaximumLatitude(north);
        return GeoCoordParse_Success;
        }

    return GeoCoordParse_BadDomain;
    }

/*---------------------------------------------------------------------------------**//**
* gcsNode can contain the datum transformations for custom datums.
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus ParseEllipsoid(EllipsoidP& customEllipsoid, Utf8String& ellipsoidName, BeXmlNodeP ellipsoidNode, Utf8String ellipsoidAlias) const
    {
    if (nullptr == ellipsoidNode)
        return GeoCoordParse_NoEllipsoid;

    Utf8String initEllipsoidName;
    if (GeoCoordParse_Success != GetNodeContent(initEllipsoidName, ellipsoidNode, "Name"))
        return GeoCoordParse_BadEllipsoid;

    if (GeoCoordParse_Success == GetEllipsoidNameFromNameOrAlias(ellipsoidName, initEllipsoidName, ellipsoidAlias) && (ellipsoidName.length() != 0))
        return GeoCoordParse_Success;

    // We will try to find a match using the equatorial and polar radiuses
    double equatorialRadius = 0.0;
    BeXmlNodeP theNode = GetNode(ellipsoidNode, "SemiMajorAxis");

    if (nullptr == theNode)
        return GeoCoordParse_BadEllipsoid;

    if (BEXML_Success != theNode->GetContentDoubleValue(equatorialRadius))
        return GeoCoordParse_BadEllipsoid;

    double polarRadius = 0.0;
    if (nullptr == (theNode = GetNode(ellipsoidNode, "SecondDefiningParameter")))
        return GeoCoordParse_BadEllipsoid;

    BeXmlNodeP paramNode;
    if (nullptr != (paramNode = GetNode(theNode, "SemiMinorAxis")))
        {
        if (BEXML_Success != theNode->GetContentDoubleValue(polarRadius))
            return GeoCoordParse_BadEllipsoid;
        }
    else
        return GeoCoordParse_BadEllipsoid;

    if (polarRadius < 0.1 || equatorialRadius < 0.1)
        return GeoCoordParse_BadEllipsoidRadius;

    Utf8String finalEllipsoidName;
    if (GeoCoordParse_Success == FindEllipsoidFromParams(finalEllipsoidName, equatorialRadius, polarRadius))
        {
        ellipsoidName = finalEllipsoidName;
        return GeoCoordParse_Success;
        }

    // If we get here then we trully have a custom ellipsoid so we make one.
    customEllipsoid = Ellipsoid::CreateEllipsoid();

    Utf8String content;
    customEllipsoid->SetName(initEllipsoidName.c_str());

    if (GeoCoordParse_Success == GetNodeContent(content, ellipsoidNode, "Description"))
        customEllipsoid->SetDescription(content.c_str());

    if (GeoCoordParse_Success == GetNodeContent(content, ellipsoidNode, "Authority"))
        customEllipsoid->SetSource(content.c_str());

    customEllipsoid->SetEquatorialRadius(equatorialRadius);
    customEllipsoid->SetPolarRadius(polarRadius);

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetTransformParameter(Utf8String&nodeName, Utf8String& nodeValue, Utf8String& additionalValue, BeXmlNodeP searchNode) const
    {
    if (nullptr == searchNode)
        return GeoCoordParse_Error;

    if (GeoCoordParse_Success != GetNodeContent(nodeName, searchNode, "OperationParameterId"))
        return GeoCoordParse_BadTransformParam;

    BeXmlNodeP valueNode;
    if (nullptr == (valueNode = GetNode(searchNode, "Value")))
        return GeoCoordParse_BadTransformParam;

    if (BEXML_Success != valueNode->GetContent(nodeValue))
        return GeoCoordParse_BadTransformParam;

    valueNode->GetAttributeStringValue(additionalValue, "uom");

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double GetLinearAsMeter(double parameterValue, const Utf8String& unitsOfMeasure) const
    {
    if (unitsOfMeasure == "meter")
        return parameterValue;
    else if (unitsOfMeasure == "FOOT")
        return parameterValue * 1200.0 / 3937.0; // US Survey foot
    else if (unitsOfMeasure == "IFOOT")
        return parameterValue * 0.3048; // International foot
    return 0.0; // We do not support weird linear units.
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double GetAngularAsArcSecond(double parameterValue, const Utf8String& unitsOfMeasure) const
    {
    if (unitsOfMeasure == "degree")
        return parameterValue * 3600.0;

    return 0.0; // We do not support weird linear units.
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetGeocentricTransformParameters(DPoint3d& delta, DPoint3d& rotation, double& scale, DPoint3d& translation, BeXmlNodeP transformNode) const
    {
    if (nullptr == transformNode)
        return GeoCoordParse_Error;

    BeXmlNodeP searchNode;
    if (nullptr == (searchNode = transformNode->GetFirstChild()))
        return GeoCoordParse_BadTransformParamSection;

    Utf8String nodeName;
    while (nullptr != searchNode)
        {
        if (Utf8String(searchNode->GetName()) == "ParameterValue")
            {
            Utf8String paramName;
            if (GeoCoordParse_Success != GetNodeContent(paramName, searchNode, "OperationParameterId"))
                return GeoCoordParse_BadTransformParamSection;

            double parameterValue;
            BeXmlNodeP valueNode;
            if (nullptr == (valueNode = GetNode(searchNode, "Value")))
                return GeoCoordParse_BadTransformParamSection;

            if (BEXML_Success == valueNode->GetContentDoubleValue(parameterValue))
                {
                Utf8String unitsOfMeasure;
                valueNode->GetAttributeStringValue(unitsOfMeasure, "uom");

                if (paramName == "X-axis translation")
                    delta.x = GetLinearAsMeter(parameterValue, unitsOfMeasure);
                else if (paramName == "Y-axis translation")
                    delta.y = GetLinearAsMeter(parameterValue, unitsOfMeasure);
                else if (paramName == "Z-axis translation")
                    delta.z = GetLinearAsMeter(parameterValue, unitsOfMeasure);
                else if (paramName == "X-axis rotation")
                    rotation.x = GetAngularAsArcSecond(parameterValue, unitsOfMeasure);
                else if (paramName == "Y-axis rotation")
                    rotation.y = GetAngularAsArcSecond(parameterValue, unitsOfMeasure);
                else if (paramName == "Z-axis rotation")
                    rotation.z = GetAngularAsArcSecond(parameterValue, unitsOfMeasure);
                else if (paramName == "Scale difference")
                    scale = parameterValue*1000000; // Transform to PPM
                else if (paramName == "Ordinate 1 of evaluation point")
                    translation.x = GetLinearAsMeter(parameterValue, unitsOfMeasure);
                else if (paramName == "Ordinate 2 of evaluation point")
                    translation.y = GetLinearAsMeter(parameterValue, unitsOfMeasure);
                else if (paramName == "Ordinate 3 of evaluation point")
                    translation.z = GetLinearAsMeter(parameterValue, unitsOfMeasure);
                }
            }

        searchNode = searchNode->GetNextSibling();
        }
    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetGridFiles(GeodeticTransformP& customTransform, GridFileFormat format, BeXmlNodeP methodNode) const
    {
    if (nullptr == methodNode)
        return GeoCoordParse_Error;

    BeXmlNodeP searchNode;
    if (nullptr == (searchNode = methodNode->GetFirstChild()))
        return GeoCoordParse_BadGridFileDef;

    Utf8String nodeName;
    while (nullptr != searchNode)
        {
        if (Utf8String(searchNode->GetName()) == "ParameterValue")
            {
            Utf8String paramName;
            if (GeoCoordParse_Success != GetNodeContent(paramName, searchNode, "OperationParameterId"))
                return GeoCoordParse_BadGridFileDef;

            Utf8String parameterValue;
            if (BEXML_Success == searchNode->GetContent(parameterValue, "ValueGridFile"))
                {
                BeXmlNodeP valueNode;
                if (nullptr == (valueNode = GetNode(searchNode, "ValueGridFile")))
                    return GeoCoordParse_BadGridFileDef;

                Utf8String direction;
                valueNode->GetAttributeStringValue(direction, "direction");

                GridFileDirection gridDirection = GridFileDirection::DIRECTION_NONE;
                if (direction == "" || direction == "forward")
                    gridDirection = GridFileDirection::DIRECTION_DIRECT;
                else if (direction == "inverse")
                    gridDirection = GridFileDirection::DIRECTION_INVERSE;

                if (paramName == "Latitude and longitude difference file")
                    {
                    GridFileDefinition gridFileDef(parameterValue.c_str(), format, gridDirection);
                    customTransform->AddGridFileDefinition(gridFileDef);
                    }
                else if (format == GridFileFormat::FORMAT_NADCON && paramName == "Latitude difference file") // For NADCON we only process latitude diff file
                    {
                    parameterValue.replace(parameterValue.find(".las"), 4, ".l*s");
                    GridFileDefinition gridFileDef(parameterValue.c_str(), format, gridDirection);
                    customTransform->AddGridFileDefinition(gridFileDef);
                    }
                else if (format == GridFileFormat::FORMAT_FRENCH && paramName == "Geocentric translation file")
                    {
                    GridFileDefinition gridFileDef(parameterValue.c_str(), format, gridDirection);
                    customTransform->AddGridFileDefinition(gridFileDef);
                    }
                else
                    return GeoCoordParse_UnknownGridFileFormat;
                }
            }

        searchNode = searchNode->GetNextSibling();
        }
    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetTransform(GeodeticTransformP& customTransform, BeXmlNodeP transformNode) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    if (nullptr == transformNode)
        return GeoCoordParse_Error;

    BeXmlNodeP methodNode;
    if (nullptr == (methodNode = GetNode(transformNode, "OperationMethodGroup")))
        {
        // No group ... try for method node
        if (nullptr == (methodNode = GetNode(transformNode, "OperationMethod")))
            return GeoCoordParse_BadTransform;
        }
    else
        {
        if (nullptr == (methodNode = GetNode(methodNode, "OperationMethod")))
            return GeoCoordParse_BadTransform;
        }

    Utf8String method;
    if (GeoCoordParse_Success != (GetNodeContent(method, methodNode, "OperationMethodId")))
        return GeoCoordParse_BadTransform;

    GenConvertCode convert = GenConvertCode::GenConvertType_GEOCTR;
    GridFileFormat fileFormat = GridFileFormat::FORMAT_NONE;
    bool invertRotation = false;
    if (GeoCoordParse_Success != (status = GetTransformMethodFromId(convert, fileFormat, invertRotation, method)))
        return status;

    customTransform = GeodeticTransform::CreateGeodeticTransform();
    if (nullptr == customTransform)
        return GeoCoordParse_Error;

    customTransform->SetConvertMethodCode(convert);
    if (convert == GenConvertCode::GenConvertType_GFILE)
        {
        if (GeoCoordParse_Success != (status = GetGridFiles(customTransform, fileFormat, methodNode)))
            return status;
        }
    else if ((convert == GenConvertCode::GenConvertType_3PARM) || (convert == GenConvertCode::GenConvertType_MOLO) ||
             (convert == GenConvertCode::GenConvertType_GEOCTR) || (convert == GenConvertCode::GenConvertType_4PARM) ||
             (convert == GenConvertCode::GenConvertType_6PARM) || (convert == GenConvertCode::GenConvertType_BURS) ||
             (convert == GenConvertCode::GenConvertType_7PARM) || (convert == GenConvertCode::GenConvertType_BDKAS))
        {
        DPoint3d delta = {0.0, 0.0, 0.0};
        DPoint3d rotation = {0.0, 0.0, 0.0};
        DPoint3d translation = {0.0, 0.0, 0.0};
        double scalePPM = 0.0;
        if (GeoCoordParse_Success != (status = GetGeocentricTransformParameters(delta, rotation, scalePPM, translation, methodNode)))
            return status;

        if (invertRotation)
            {
            rotation.x = -rotation.x;
            rotation.y = -rotation.y;
            rotation.z = -rotation.z;
            }

        bool deltaValid = false;
        bool rotationValid = false;
        bool scaleValid = false;
        bool translationValid = false;
        bool gridValid = false;
        customTransform->ParametersValid(deltaValid, rotationValid, scaleValid, translationValid, gridValid);

        if (deltaValid)
            customTransform->SetDelta(delta);
        if (rotationValid)
            customTransform->SetRotation(rotation);
        if (scaleValid)
            customTransform->SetScale(scalePPM);
        if (translationValid)
            customTransform->SetTranslation(translation);
        }
    else if (convert == GenConvertCode::GenConvertType_MREG)
        return GeoCoordParse_MREGNotSupported; // We do not support Multiple regression yet.

    // Others (NONE and WGS72) require no parameters.

    Utf8String content;
    if (GeoCoordParse_Success == GetNodeContent(content, transformNode, "Name"))
        customTransform->SetName(content.c_str());

    if (GeoCoordParse_Success == GetNodeContent(content, transformNode, "Description"))
        customTransform->SetDescription(content.c_str());

    if (GeoCoordParse_Success == GetNodeContent(content, transformNode, "Authority"))
        customTransform->SetSource(content.c_str());

    if (GeoCoordParse_Success == GetNodeContent(content, transformNode, "SourceDatumId"))
        customTransform->SetSourceDatumName(content.c_str());

    if (GeoCoordParse_Success == GetNodeContent(content, transformNode, "TargetDatumId"))
        customTransform->SetTargetDatumName(content.c_str());

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetTransformByName(GeodeticTransformP& customTransform, BeXmlNodeP gcsNode, Utf8String& transformName) const
    {
    if (nullptr == gcsNode)
        return GeoCoordParse_Error;

    BeXmlNodeP searchNode;
    if (nullptr == (searchNode = gcsNode->GetFirstChild()))
        return GeoCoordParse_BadTransform;

    Utf8String nodeName;
    while (nullptr != searchNode)
        {
        if (Utf8String(searchNode->GetName()) == "Transformation")
            {
            if (GeoCoordParse_Success == GetNodeContent(nodeName, searchNode, "Name"))
                {
                if (nodeName == transformName)
                    return GetTransform(customTransform, searchNode);
                }
            }

        searchNode = searchNode->GetNextSibling();
        }

    return GeoCoordParse_BadTransform;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus ParseGeodeticPath(GeodeticTransformPathP& customPath, BeXmlNodeP rootNode, Utf8StringCR datumName) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    if (nullptr == rootNode)
        return GeoCoordParse_Error;

    // We first check if there is a TransformationPath element
    BeXmlNodeP trfPathNode = nullptr;
    if (nullptr != (trfPathNode = GetNode(rootNode, "TransformationPath")))
        {
        // We have the transformation path.
        BeXmlNodeP trfOpGroupNode = nullptr;
        if (nullptr == (trfOpGroupNode = GetNode(trfPathNode, "TransformationPath")))
            return GeoCoordParse_BadTransformPath;

        BeXmlNodeP trfOpNode = nullptr;
        if (nullptr == (trfOpNode = trfOpGroupNode->GetFirstChild()))
            return GeoCoordParse_BadTransformPath;

        bvector<std::pair<Utf8String, Utf8String> > listOfTransforms;
        Utf8String id;
        Utf8String direction;
        while (nullptr != trfOpNode)
            {
            if (GeoCoordParse_Success != GetNodeContent(id, trfOpNode, "TransformationId"))
                return GeoCoordParse_BadTransformPath;

            if (GeoCoordParse_Success != GetNodeContent(direction, trfOpNode, "Direction"))
                return GeoCoordParse_BadTransformPath;

            listOfTransforms.push_back(std::make_pair(id, direction));

            trfOpNode = trfOpNode->GetNextSibling();
            }

        customPath = GeodeticTransformPath::Create();
        for (auto trans: listOfTransforms)
            {
            GeodeticTransformP newTransform;
            if (GeoCoordParse_Success != (status = GetTransformByName(newTransform, rootNode, trans.second)))
                {
                customPath->Destroy();
                return status;
                }

            if (nullptr == newTransform)
                {
                customPath->Destroy();
                return GeoCoordParse_BadTransformPath;
                }

            if (trans.first == "inverse")
                {
                if (SUCCESS != newTransform->Reverse())
                    {
                    newTransform->Destroy();
                    customPath->Destroy();
                    return GeoCoordParse_BadTransformPath;
                    }
                }

            if (SUCCESS != customPath->AddGeodeticTransform(newTransform))
                {
                newTransform->Destroy();
                customPath->Destroy();
                return GeoCoordParse_BadTransformPath;
                }
            }
            return GeoCoordParse_Success;
        }
    else
        {
        // If there are no path then there must be a single transformation
        BeXmlNodeP trfNode = nullptr;
        if (nullptr == (trfNode = GetNode(rootNode, "Transformation")))
            return GeoCoordParse_BadTransformPath;

        GeodeticTransformP transform = nullptr;
        if (GeoCoordParse_Success != (status = GetTransform(transform, trfNode)))
            return status;

        if (nullptr == transform)
            return GeoCoordParse_BadTransformPath;

        customPath = GeodeticTransformPath::Create();
        customPath->AddGeodeticTransform(transform);
        return GeoCoordParse_Success;
        }

    return GeoCoordParse_BadTransformPath;
    }

/*---------------------------------------------------------------------------------**//**
* gcsNode can contain the datum transformations for custom datums.
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus ParseDatum(DatumP& customDatum, Utf8String& datumName, Utf8StringCR datumAlias, BeXmlNodeP datumNode, BeXmlNodeP ellipsoidNode, Utf8StringCR ellipsoidAlias, BeXmlNodeP gcsNode, BeXmlNodeP rootNode) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    EllipsoidP customEllipsoid = nullptr;

    if (nullptr == datumNode)
        return GeoCoordParse_NoDatum;

    Utf8String initDatumName;
    if (GeoCoordParse_Success != GetNodeContent(initDatumName, datumNode, "Name"))
        return GeoCoordParse_BadDatum;

    if (GeoCoordParse_Success == GetDatumNameFromNameOrAlias(datumName, initDatumName, datumAlias) && datumName.length() != 0)
        return GeoCoordParse_Success;

    // === ellipsoid ===
    Utf8String initialEllipsoidName;
    Utf8String ellipsoidName;
    if (GeoCoordParse_Success != GetNodeContent(initialEllipsoidName, datumNode, "EllipsoidId"))
        return GeoCoordParse_BadDatum;

    if (GeoCoordParse_Success != GetEllipsoidNameFromNameOrAlias(ellipsoidName, initialEllipsoidName, ellipsoidAlias) || ellipsoidName.length() == 0)
        {
        // Unknown ellipoid ... we parse it out
        if (GeoCoordParse_Success != (status = ParseEllipsoid(customEllipsoid, ellipsoidName, ellipsoidNode, ellipsoidAlias)))
            return status;
        }

    // At this point we either have a valid ellipsoid name or a custom ellipsoid object

    // ==== Transformation(s) ====
    GeodeticTransformPathP transformPath = nullptr;
    if (GeoCoordParse_Success != ParseGeodeticPath(transformPath, rootNode, initDatumName))
        {
        // This means there are no transform paths. This can be interpreted as no transformation to WGS84 (equivalent)
        }
    else
        {
        // We still would prefer a known datum for ease of storage in old formats (DGN files for examples)
        if (transformPath->GetGeodeticTransformCount() == 1 && nullptr == customEllipsoid)
            {
            GeodeticTransformCP transform = transformPath->GetGeodeticTransform(0);
            if (nullptr != transform)
                {
                GenConvertCode trfCode = transform->GetConvertMethodCode();
                if (GenConvertCode::GenConvertType_3PARM == trfCode || GenConvertCode::GenConvertType_MOLO == trfCode || GenConvertCode::GenConvertType_GEOCTR == trfCode ||
                    GenConvertCode::GenConvertType_4PARM == trfCode || GenConvertCode::GenConvertType_6PARM == trfCode || GenConvertCode::GenConvertType_7PARM == trfCode)
                    {
                    DPoint3d delta = {0.0, 0.0, 0.0};
                    DPoint3d rotation = {0.0, 0.0, 0.0};
                    double scalePPM = 0.0;
                    transform->GetDelta(delta);
                    transform->GetRotation(rotation);
                    scalePPM = transform->GetScale();

                    Utf8String finalDatumName;
                    if (GeoCoordParse_Success == FindDatumFromTransformationParams(finalDatumName, ellipsoidName, delta.x, delta.y, delta.z, rotation.x, rotation.y, rotation.z, scalePPM))
                        {
                        datumName = finalDatumName;
                        transformPath->Destroy();
                        return GeoCoordParse_Success;
                        }
                    }
                }
            }
        }

    // If we get here then we trully have a custom datum so we make one.
    customDatum = Datum::CreateDatum();

    Utf8String content;
    customDatum->SetName(initDatumName.c_str());

    if (GeoCoordParse_Success == GetNodeContent(content, datumNode, "Description"))
        customDatum->SetDescription(content.c_str());

    if (GeoCoordParse_Success == GetNodeContent(content, datumNode, "Authority"))
        customDatum->SetSource(content.c_str());

    if (nullptr != customEllipsoid)
        customDatum->SetEllipsoid(customEllipsoid);
    else
        {
        int foundIndex = FindEllipsoidIndex (ellipsoidName.c_str());

        if (foundIndex < 0)
            {
            if (nullptr != transformPath)
                transformPath->Destroy();

            return GeoCoordParse_UnknownEllipsoid;
            }
        customDatum->SetEllipsoidCode (foundIndex);
        }

    if (nullptr != transformPath)
        customDatum->SetStoredGeodeticTransformPath(transformPath);

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus ParseGCS (BaseGCSR baseGCS, BeXmlNodeP gcsNode, bool gcsGeographic, Utf8StringCR gcsAlias, BeXmlNodeP datumNode, Utf8StringCR datumAlias, BeXmlNodeP ellipsoidNode, Utf8StringCR ellipsoidAlias, BeXmlNodeP rootNode) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    if (nullptr == gcsNode)
        return GeoCoordParse_Error;

    // We first try using the keyname
    Utf8String gcsName;
    if (GeoCoordParse_Success != GetNodeContent(gcsName, gcsNode, "Name"))
        return GeoCoordParse_BadGCS;

    // If we were sucessful then we do not we validate the definition is similar.
    if (SUCCESS == baseGCS.SetFromCSName(gcsName.c_str()))
        return GeoCoordParse_Success;

    // Try with alias
    bool gcsAliasSuccess = false;
    if (SUCCESS == baseGCS.SetFromCSName(gcsAlias.c_str()))
        {
        gcsAliasSuccess = true;
        if (!baseGCS.IsDeprecated())
            return GeoCoordParse_Success;

        // If we get here then we have a match but it is deprecated.
        // We will try parsing and if that fails we will use the alias anyway.
        }

    // We will need to create a new one
    InitCleanGCS(baseGCS);

    if (gcsGeographic)
        baseGCS.SetProjectionCode(BaseGCS::pcvUnity);


    // If alias is EPSG number extract and try with EPSG specific function
    int epsgNumber = 0;
    bool epsgSuccess = false;
    if (gcsAlias.substr(0, 5) == "EPSG:")
        {
        epsgNumber = std::atoi(gcsAlias.substr(5).c_str());
        if (epsgNumber > 0)
            {
            if (SUCCESS == baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber))
                {
                epsgSuccess = true;
                if (!baseGCS.IsDeprecated() && epsgNumber != 27700) // EPSG 27700 is a pain as there are many valid variation ... we continue parsing to find the variation
                    return GeoCoordParse_Success;
                }
            }
        }

    // We do not have a direct match ... proceed

    // ==== Datum ====
    Utf8String datumName;
    if (GeoCoordParse_Success != GetNodeContent(datumName, gcsNode, "DatumId"))
        return GeoCoordParse_BadGCS;

    DatumP customDatumP = nullptr;
    if (GeoCoordParse_Success == GetDatumNameFromNameOrAlias(datumName, datumName, datumAlias) && datumName.length() != 0)
        {
        int foundIndex = FindDatumIndex(datumName.c_str());

        if (foundIndex >= 0)
            {
            if (SUCCESS != baseGCS.SetDatumCode(foundIndex))
                return GeoCoordParse_Error;
            }
        }
    else
        {
        // Failed obtaining the datum name from simple name or alias ...
        if (GeoCoordParse_Success != (status = ParseDatum(customDatumP, datumName, datumAlias, datumNode, ellipsoidNode, ellipsoidAlias, gcsNode, rootNode)))
            {
            if (gcsAliasSuccess)
                {
                baseGCS.SetFromCSName(gcsAlias.c_str());
                return GeoCoordParse_Success;
                }
            if (epsgSuccess)
                {
                baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber);
                return GeoCoordParse_Success;
                }

            return status;
            }

        if (nullptr != customDatumP)
            {
            if (SUCCESS != baseGCS.SetDatum(customDatumP))
                return GeoCoordParse_Error;
            }
        else if (datumName.length() != 0)
            {
            int foundIndex = FindDatumIndex(datumName.c_str());

            if (foundIndex >= 0)
                {
                if (SUCCESS != baseGCS.SetDatumCode(foundIndex))
                    return GeoCoordParse_Error;
                }
            }
        else
            {
            if (gcsAliasSuccess)
                {
                baseGCS.SetFromCSName(gcsAlias.c_str());
                return GeoCoordParse_Success;
                }
            if (epsgSuccess)
                {
                baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber);
                return GeoCoordParse_Success;
                }
            return GeoCoordParse_UnknownDatum;
            }
        }

    // We have found a datum either as a named or custom
    // We can then proceed to parse the projection
    // ==== GCS Params ====
    Utf8String description;
    if (GeoCoordParse_Success == GetNodeContent(description, gcsNode, "Description"))
        baseGCS.SetDescription(description.c_str());

    Utf8String source;
    if (GeoCoordParse_Success == GetNodeContent(source, gcsNode, "Authority"))
        baseGCS.SetSource(source.c_str());

    GetQuadrant(baseGCS, gcsNode);

    GetDomainOfValidity(baseGCS, gcsNode);

    // We extract units from the Axis clause.
    BeXmlNodeP axisNode = nullptr;
    if (nullptr == (axisNode = GetNode(gcsNode, "Axis")))
        {
        if (gcsAliasSuccess)
            {
            baseGCS.SetFromCSName(gcsAlias.c_str());
            return GeoCoordParse_Success;
            }
        if (epsgSuccess)
            {
            baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber);
            return GeoCoordParse_Success;
            }
        return GeoCoordParse_BadGCS;
        }

    Utf8String unitsOfMeasure;
    if (BEXML_Success != axisNode->GetAttributeStringValue(unitsOfMeasure, "uom"))
        {
        if (gcsAliasSuccess)
            {
            baseGCS.SetFromCSName(gcsAlias.c_str());
            return GeoCoordParse_Success;
            }
        if (epsgSuccess)
            {
            baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber);
            return GeoCoordParse_Success;
            }
        return GeoCoordParse_BadGCS;
        }

    if (SUCCESS != baseGCS.SetUnitByKeyname(unitsOfMeasure.c_str()))
        {
        if (gcsAliasSuccess)
            {
            baseGCS.SetFromCSName(gcsAlias.c_str());
            return GeoCoordParse_Success;
            }
        if (epsgSuccess)
            {
            baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber);
            return GeoCoordParse_Success;
            }
        return GeoCoordParse_BadGCS;
        }

    if (!gcsGeographic)
        {
        if (GeoCoordParse_Success != (status = GetProjection(baseGCS, gcsNode)))
            {
            if (gcsAliasSuccess)
                {
                baseGCS.SetFromCSName(gcsAlias.c_str());
                return GeoCoordParse_Success;
                }
            if (epsgSuccess)
                {
                baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber);
                return GeoCoordParse_Success;
                }
            return status;
            }
        }

    if (SUCCESS != baseGCS.DefinitionComplete())
        return GeoCoordParse_InvalidDefinition;

    return GeoCoordParse_Success;
    }
}; //class

/*=================================================================================**//**
*
* SRS WKT Parser class: Can be used as an alternate WKT parser to CSMAP.
*
* NOTE: Error processing is still minimal. The functions will return the generic error ERROR
* most if not all of the times. Error processing will be completed later on in the
* development process
*
+===============+===============+===============+===============+===============+======*/
class SRSWKTParser: public SRSGeneralParser
{
public:

    enum class AxisDirection
        {
        NORTH,
        SOUTH,
        EAST,
        WEST,
        UP,
        DOWN,
        OTHER,
        UNDEFINED
        };

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
SRSWKTParser()
    {
    }
/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
virtual ~SRSWKTParser()
    {
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus Process (BaseGCSR baseGCS, Utf8CP wktChar) const
    {
    Utf8String wkt(wktChar);
    GeoCoordParseStatus status = GeoCoordParse_Success;

    if (GeoCoordParse_Success != (status = InitCleanGCS(baseGCS)))
        return status;

    if ((wkt.length() >= 6) && (wkt.substr (0, 6) == ("PROJCS")))
        status = GetProjected (baseGCS, wkt);
    else if ((wkt.length() >= 6) && (wkt.substr (0, 6) == ("GEOGCS")))
        status = GetGeographic (baseGCS, wkt);
    else if ((wkt.length() >= 8) && (wkt.substr (0, 8) == ("LOCAL_CS")))
        status = GetLocal (baseGCS, wkt);
    else if ((wkt.length() >= 8) && (wkt.substr (0, 8) == ("COMPD_CS")))
        status = GetCompound (baseGCS, wkt);
    else
        status = GeoCoordParse_NoGCS;

    return status;
    }

private:

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts a projection coordinate reference
*   system from provided WKT stream.
*
*   @param baseGCS OUT The BaseGCS to fill definition of
*
*   @param wkt IN The WKT stream to obtain projected CRS from.
*
*   @return GeoCoordParse_Success or error value
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetProjected (BaseGCSR baseGCS, Utf8StringR wkt) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;
    GeoCoordParseStatus tempStatus = GeoCoordParse_Success;

    double conversionToDegree = 1.0;
    bool geocsPresent = false;
    bool geocsValid = true;

    // Init units to meter (to be used as default for some WKTs)
    baseGCS.SetUnitByKeyname("meter");

    wkt.Trim();

    // Validate that this is the proper section (must start with PROJCS)
    if ((wkt.length() < 6) || (!(wkt.substr (0, 6) == "PROJCS")))
        return GeoCoordParse_NoGCS;

    // Remove keyword
    wkt = wkt.substr (6);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_BadGCS;

    wkt = wkt.substr (1);

    // The first member is the name
    Utf8String name = GetName (wkt);
    Utf8String authorityID = GetAuthorityIdFromNameOracleStyle(name);
    bool sectionCompleted = false;
    size_t previousLength;
    while (wkt.length() > 0 && !sectionCompleted)
        {
        previousLength = wkt.length();

        // Trim of whites
        wkt.Trim();

        // Trim commas
        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
            wkt = wkt.substr(1);

        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
            authorityID = GetAuthority (wkt);

        if ((wkt.length() >= 6) && (wkt.substr (0, 6) == ("GEOGCS")))
            {
            geocsPresent = true;
            if (GeoCoordParse_Success != (tempStatus = GetGeographicToProjected (wkt, &conversionToDegree, baseGCS)))
                {
                if (GeoCoordParse_UnknownDatum == tempStatus)
                    geocsValid = false;
                else
                    return tempStatus;
                }
            }

        if ((wkt.length() >= 10) && (wkt.substr (0, 10) == ("PROJECTION")))
            if (GeoCoordParse_Success != (status = GetProjectionToCoordSys (wkt, conversionToDegree, baseGCS)))
                return status;

        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("UNIT")))
            if (GeoCoordParse_Success != (status = GetLinearUnitToCoordSys (wkt, baseGCS)))
                return status;

        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("EXTENSION"))) // PROJ4 Addition (Sigh!)
            {
            Utf8String     extensionName;
            Utf8String     extensionText;
            if (GeoCoordParse_Success != GetExtension (wkt, extensionName, extensionText))
                return GeoCoordParse_BadExtension;
            }

        if ((wkt.length() >= 8) && (wkt.substr (0, 8) == ("METADATA"))) // Unknown origin but occurs
            {
            if (GeoCoordParse_Success != GetRidOfMetadata (wkt))
                return GeoCoordParse_BadExtension;
            }

        // Optional
        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("AXIS")))
            {
            // For a projcs clause two axises must be specified one after the other
            AxisDirection horizontalAxis = GetAxis(wkt);

            // Trim of whites
            wkt.Trim();

            // Trim commas
            if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
                wkt = wkt.substr(1);
            // Trim of whites
            wkt.Trim();

            // The second AXIS Clause is required accordinag to specs.
            if ((wkt.length() < 4) || (wkt.substr (0, 4) != ("AXIS")))
                return GeoCoordParse_BadAxis;

            AxisDirection verticalAxis = GetAxis(wkt);

            // East and North axis is the default and need not be set.
            if (horizontalAxis != AxisDirection::EAST || verticalAxis != AxisDirection::NORTH)
                {
                if (horizontalAxis == AxisDirection::WEST && verticalAxis == AxisDirection::NORTH)
                    baseGCS.SetQuadrant(2);
                else if (horizontalAxis == AxisDirection::WEST && verticalAxis == AxisDirection::SOUTH)
                    baseGCS.SetQuadrant(3);
                else if (horizontalAxis == AxisDirection::EAST && verticalAxis == AxisDirection::SOUTH)
                    baseGCS.SetQuadrant(4);
                else if (horizontalAxis == AxisDirection::NORTH && verticalAxis == AxisDirection::EAST)
                    baseGCS.SetQuadrant(-1);
                else if (horizontalAxis == AxisDirection::NORTH && verticalAxis == AxisDirection::WEST)
                    baseGCS.SetQuadrant(-2);
                else if (horizontalAxis == AxisDirection::SOUTH && verticalAxis == AxisDirection::WEST)
                    baseGCS.SetQuadrant(-3);
                else if (horizontalAxis == AxisDirection::SOUTH && verticalAxis == AxisDirection::EAST)
                    baseGCS.SetQuadrant(-4);
                else
                    return GeoCoordParse_BadAxis;
                }
            }

        if ((wkt.length() >= 1) && (wkt.substr (0, 1) == ("]")))
            {
            wkt = wkt.substr (1);
            sectionCompleted = true;
            }

        if (wkt.length() == previousLength)
            return GeoCoordParse_ParseError;
        }

//TBD Search for an existing equivalent
//compare if required
//        baseGCS.SetKey (authorityID->GetKey());

// Specific patch for EPSG:900913
    if ((authorityID == "EPSG:900913") || (authorityID == "EPSG:3857") || (name == "EPSG:900913") || (name == "EPSG:3857"))
        {
        Utf8String datumName = baseGCS.GetDatumName();
        if (datumName == "WGS84")
            {
            // In some cases the definition specifies datum WGS84 but a WebMercator. We switch to EPSG:900913
            // as our implementation is a patch (using artefact datum SpereWGS84)
            // Note that double exact compare is intentional
            if ((baseGCS.GetProjectionCode() == GeoCoordinates::BaseGCS::pcvMercator ||
                 baseGCS.GetProjectionCode() == GeoCoordinates::BaseGCS::pcvMercatorScaleReduction) &&
                baseGCS.GetStandardParallel1() == 0.0 && baseGCS.GetCentralMeridian() == 0.0 &&
                baseGCS.GetFalseEasting() == 0.0 && baseGCS.GetFalseNorthing() == 0.0 &&
                baseGCS.GetScaleReduction() == 1.0)

                {
                baseGCS.SetFromCSName("EPSG:900913");
                return (SUCCESS == baseGCS.DefinitionComplete()? GeoCoordParse_Success : GeoCoordParse_InvalidDefinition);
                }
            }
        }

    // Check if geocs clause was invalid
    if (!geocsValid)
        {
        // It is possible to solve if the authorityId is set and EPSG compliant
        if (authorityID.substr(0, 5) == ("EPSG:"))
            {
            int epsgNumber = std::atoi(authorityID.substr(5).c_str());
            if (epsgNumber > 0)
                {
                if (SUCCESS != baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber))
                    return GeoCoordParse_InvalidDefinition;
                }
            else
                return GeoCoordParse_UnknownDatum;
            }
        else
            return GeoCoordParse_UnknownDatum;
        }

    if (baseGCS.GetProjectionCode() == BaseGCS::pcvCzechKrovak || baseGCS.GetProjectionCode() == BaseGCS::pcvCzechKrovakModified)
        {
        // Krovak projection is a strange one that can be specified various ways and sometimes the
        // defining meridians are relative to Ferro prime meridian and sometimes not.
        // If the EPSG number is provided it is best to use it. If not then we live with the parameters we have and hope.
        if (authorityID.substr(0, 5) == ("EPSG:"))
            {
            int epsgNumber = std::atoi(authorityID.substr(5).c_str());
            if (epsgNumber > 0)
                baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber);
            }
        }

    // Some WKT do not have GEOGCS Clauses which we do not have any default
    if (!geocsPresent)
        return GeoCoordParse_InvalidDefinition;

    baseGCS.SetName (name.c_str());
    baseGCS.SetDescription (name.c_str());
    baseGCS.SetSource("WKT");

    return (SUCCESS == baseGCS.DefinitionComplete() ? GeoCoordParse_Success : GeoCoordParse_InvalidDefinition);
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts a projection coordinate reference
*   system from provided WKT stream.
*
*   @param baseGCS OUT The BaseGCS to fill definition of
*   @param wkt IN The WKT stream to obtain projected CRS from.
*   @return GeoCoordParse_Success or error value
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetCompound (BaseGCSR baseGCS, Utf8StringR wkt) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    wkt.Trim();

    // Validate that this is the proper section (must start with PROJCS)
    if ((wkt.length() < 8) || (!(wkt.substr (0, 8) == "COMPD_CS")))
        return GeoCoordParse_NoGCS;

    // Remove keyword
    wkt = wkt.substr (8);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_BadGCS;

    wkt = wkt.substr (1);

    wkt.Trim();
    Utf8String name = GetName (wkt);

    // Trim of whites
    wkt.Trim();

    // Trim commas
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
         wkt = wkt.substr(1);

    // The first member must be either a PROJCS or a GEOGCS
    wkt.Trim();
    if ((wkt.length() >= 6) && (wkt.substr (0, 6) == ("PROJCS")))
        status = GetProjected (baseGCS, wkt);
    else if ((wkt.length() >= 6) && (wkt.substr (0, 6) == ("GEOGCS")))
        status = GetGeographic (baseGCS, wkt);
    else
        status = GeoCoordParse_BadGCS;

    if (GeoCoordParse_Success == status)
        {
        // Now we should have a valid BaseGCS properly filled with the projected or geographic
        // coordinate system. Since we are dealing with a compound CS there is a second section
        // We only support the VERT_CS as second coordinate system.
        wkt.Trim();

        // Trim commas
        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
            wkt = wkt.substr(1);
        wkt.Trim();

        if ((wkt.length() >= 7) && (wkt.substr (0, 7) == ("VERT_CS")))
            status = SetVerticalCS (baseGCS, wkt);
        else
            status = GeoCoordParse_BadGCS;
        }

    // Complete BaseGCS
    if (GeoCoordParse_Success == status)
        status =  (SUCCESS == baseGCS.DefinitionComplete() ? GeoCoordParse_Success : GeoCoordParse_InvalidDefinition);

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts a vertical datum
*   from provided WKT stream.
*
*   @param wkt IN The WKT stream to obtain vertical datum from. The WKT should start with the
*                 VERT_DATUM clause and contain the whole definition. Additional characters
*                 after the end of the clause are ignored and returned in the wkt
*                 stripped out of the whole VERT_DATUM clause.
*
*   @return the VertDatumCode or vdcFromDatum if datum could not be determined.
*           Note here that the explicit datum code is always returned and never vdcFromDatum
*           unless the nature of the vertical datum could not be determined. This value of vdcFromDatum
*           should not be interpreted returning from this method as the default value.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VertDatumCode GetVerticalDatum (Utf8StringR wkt) const
    {
    if ((wkt.length() < 10) || (!(wkt.substr (0, 10) == "VERT_DATUM")))
        return vdcFromDatum;

    // Remove keyword
    wkt = wkt.substr (10);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return vdcFromDatum;

    wkt = wkt.substr (1);

    Utf8String name = GetName (wkt);
    Utf8String authorityID;

    // The name should be immediately followed by a number indicating the vertical datum type.

    // Trim whites and comma
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);
    wkt.Trim();

    int WKTDatumCode = GetInteger(wkt);

    bool sectionCompleted = false;
    size_t previousLength;
    while (wkt.length() > 0 && !sectionCompleted)
        {
        previousLength = wkt.length();

        // Trim of whites
        wkt.Trim();

        // Trim commas
        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
            wkt = wkt.substr(1);

        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
            authorityID = GetAuthority (wkt);

        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("EXTENSION"))) // PROJ4 addition
            {
            Utf8String     extensionName;
            Utf8String     extensionText;

            // We do not check for an error ... the EXTENSION clause is ill-formed then
            // likely the vertical datum will be invalid
            GetExtension (wkt, extensionName, extensionText);
            }

        if ((wkt.length() >= 1) && (wkt.substr (0, 1) == ("]")))
            {
            wkt = wkt.substr (1);
            sectionCompleted = true;
            }

        if (wkt.length() == previousLength)
            return vdcFromDatum;
        }

    // We map the WKT datum code to the GeoCoord datum code ... this process is still incomplete as
    // we support few vertical datums
    VertDatumCode vertDatum = vdcFromDatum;

    // We do not support 2003 (Barometric altitude, and 2006 (Depth) but we set vertical datum to ellipsoidal height
    // We consider 2002 (ellipsoidal), 2004 (Normal) and 2000 (Other) as ellipsoidal height.
    // We elected to consider ellipsoidal as WGS84 ellipsoid or equivalent. Local Ellipsoid is not supported.
    if (2002 == WKTDatumCode || 2004 == WKTDatumCode || 2000 == WKTDatumCode)
        vertDatum = vdcEllipsoid;
    if (2005 == WKTDatumCode || 2001 == WKTDatumCode)
        {
        // This is a geoid based datum (we consider orthometric datum (2001) the same as Geoid)
        // Technically there are various geoid datums but with csmap we are stuck with the
        // fact. We first rely on the authority code or the name
        vertDatum = vdcGeoid;

        if (authorityID.length() != 0 || name.length() != 0)
            {
            if (authorityID == "EPSG:5102" || name == "NGVD29")
                vertDatum = vdcNGVD29;
            else if (authorityID == "EPSG:5103" || name == "NAVD88")
                vertDatum = vdcNAVD88;
            }
        }

    return vertDatum;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts a vertical coordinate reference
*   system from provided WKT stream.
*
*   @param baseGCS IN/OUT The BaseGCS to fill definition of vertical CS. The remainder
*                         of the BaseGCS is left untouched and should already contain
*                         the non-vertical portion of the GCS since some vertical
*                         coordinate systems have limitations related to the nature of the
*                         datum used by the GCS.
*
*   @param wkt IN The WKT stream to obtain vertical cs from. The WKT should start with the
*                 VERT_CS clause and contain the whole definition. Additional characters
*                 after the end of the clause are ignored and returned in the wkt
*                 stripped out of the whole VERT_CS clause.
*
*   @return GeoCoordParse_Success or error value
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus SetVerticalCS (BaseGCSR baseGCS, Utf8StringR wkt) const
    {
    if ((wkt.length() < 7) || (!(wkt.substr (0, 7) == "VERT_CS")))
        return GeoCoordParse_BadVertical;

    // Remove keyword
    wkt = wkt.substr (7);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_BadVertical;

    wkt = wkt.substr (1);

    Utf8String name = GetName (wkt);

    VertDatumCode vertDatum = vdcFromDatum;
    Utf8String authorityID;

    bool sectionCompleted = false;
    size_t previousLength;
    while (wkt.length() > 0 && !sectionCompleted)
        {
        previousLength = wkt.length();

        // Trim whites and comma
        wkt.Trim();
        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
            wkt = wkt.substr(1);

        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
            authorityID = GetAuthority (wkt);

        if ((wkt.length() >= 10) && (wkt.substr (0, 10) == ("VERT_DATUM")))
            vertDatum = GetVerticalDatum (wkt);

        //We only make sure the AXIS clause contains UP (We do not support anything else)
        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("AXIS")))
            if (GetAxis(wkt) != AxisDirection::UP)
                return GeoCoordParse_BadVertical;

        // We do not care about the content of the UNIT clause
        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("UNIT")))
            {
            double      unitFactor;
            Utf8String     unitName;
            GeoCoordParseStatus   status;
            if (GeoCoordParse_Success != (status = GetUnit (wkt, unitName, &unitFactor)))
                return status;
            }

        if ((wkt.length() >= 1) && (wkt.substr (0, 1) == ("]")))
            {
            wkt = wkt.substr (1);
            sectionCompleted = true;
            }

        if (wkt.length() == previousLength)
            return GeoCoordParse_ParseError;
        }

    // If the datum has not been resolved ... we try to do it. This should not happen normally
    // but we make sure in case the VERT_DATUM clause was badly formed or the vertical datum
    // was geoid based but had not authority ID
    if (vdcFromDatum == vertDatum || vdcGeoid == vertDatum)
        {
        if (authorityID == "EPSG:5702")
            vertDatum = vdcNGVD29;
        else if (authorityID == "EPSG:5703")
            vertDatum = vdcNAVD88;
        else if (authorityID == "EPSG:5773")
            vertDatum = vdcGeoid;
        }

    // We tolerate NAVD88 on WGS84 by demoting to generic geoid.
    if ((vdcNAVD88 == vertDatum) && !(baseGCS.IsNAD27() || baseGCS.IsNAD83()) && (BeStringUtilities::Strnicmp(baseGCS.GetDatumName(), "WGS84", 5) == 0))
        vertDatum = vdcGeoid;

    // NOTE: We only rely on the authority ID because the name is unthrustworty but if some
    // standard emerges we will be happy to check the vertical cs names to resolve.

    return (SUCCESS == baseGCS.SetVerticalDatumCode (vertDatum) ? GeoCoordParse_Success : GeoCoordParse_BadVertical);
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts a geographic coordinate reference
*   system from provided WKT stream.
*
*   @param baseGCS OUT The BaseGCS to fill definition of
*
*   @param wkt IN The WKT stream to obtain projected CRS from.
*
*   @return GeoCoordParse_Success or error value
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetGeographic (BaseGCSR baseGCS, Utf8StringR wkt) const
    {
    if ((wkt.length() < 6) || (!(wkt.substr (0, 6) == "GEOGCS")))
        return GeoCoordParse_BadGCS;

    GeoCoordParseStatus status;
    Utf8String geographicName;
    Utf8String geographicAuthorityID;
    double conversionToDegree = 1.0;

    if (GeoCoordParse_Success == (status = GetGeographicToCoordSys (wkt, geographicName, geographicAuthorityID, &conversionToDegree, baseGCS, true)))
        {
        if (!doubleSame(conversionToDegree, 1.0))
            {
            // Angular units are not degree. We support that only for longitude/latitude based GCS (which is the case)
            // This only means adjusting the prime meridian of the GCS.
            baseGCS.SetOriginLongitude(baseGCS.GetOriginLongitude() * conversionToDegree);
            }

        baseGCS.SetName (geographicName.c_str());
        baseGCS.SetDescription (geographicName.c_str());
        baseGCS.SetSource("WKT");

        // If an EPSG authority is provided and the result is not set we try to replace if equal
        if (geographicAuthorityID.length() > 0)
            {
            if (geographicAuthorityID.substr(0, 5) == ("EPSG:") && baseGCS.GetStoredEPSGCode() == 0)
                {
                int epsgNumber = std::atoi(geographicAuthorityID.substr(5).c_str());
                if (epsgNumber > 0)
                    {
                    BaseGCSPtr otherGCS = BaseGCS::CreateGCS();
                    if (SUCCESS == otherGCS->InitFromEPSGCode(NULL, NULL, epsgNumber))
                        {
                        if (SUCCESS == baseGCS.DefinitionComplete()) // Before comparing we need to complete the definition
                            {
                            if (otherGCS->IsEquivalent(baseGCS))
                                baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber);
                            }
                        else
                            baseGCS.InitFromEPSGCode(NULL, NULL, epsgNumber); // Invalid extracted ... we set using code.
                        }
                    }
                }
            }

        return (SUCCESS == baseGCS.DefinitionComplete() ? GeoCoordParse_Success : GeoCoordParse_InvalidDefinition);
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts a local coordinate reference
*   system from provided WKT stream.
*
*   @param baseGCS OUT The BaseGCS to fill definition of
*
*   @param wkt IN The WKT stream to obtain projected CRS from.
*
*   @return GeoCoordParse_Success or error value
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetLocal (BaseGCSR baseGCS, Utf8StringR wkt) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    wkt.Trim();

    // Validate that this is the proper section (must start with LOCAL_CS)
    if ((wkt.length() < 8) || (!(wkt.substr (0, 8) == "LOCAL_CS")))
        return GeoCoordParse_BadGCS;

    // Remove keyword
    wkt = wkt.substr (8);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    // The first member is the name
    Utf8String name = GetName (wkt);
    Utf8String authorityID = GetAuthorityIdFromNameOracleStyle(name);


    baseGCS.SetProjectionCode (BaseGCS::pcvNonEarth);
    baseGCS.SetDatumCode (Datum::NO_DATUM_CODE);

    bool sectionCompleted = false;
    size_t previousLength;
    while (wkt.length() > 0 && !sectionCompleted)
        {
        previousLength = wkt.length();

        // Trim of whites
        wkt.Trim();

        // Trim commas
        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
            wkt = wkt.substr(1);

        if ((wkt.length() >= 11) && (wkt.substr (0, 11) == ("LOCAL_DATUM")))
            if (GeoCoordParse_Success != (status = GetLocalDatumToCoordSys (wkt, baseGCS)))
                return status;

        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("UNIT")))
            if (GeoCoordParse_Success != (status = GetLinearUnitToCoordSys (wkt, baseGCS)))
                return status;

        // Optional component
        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("AXIS")))
            {
            // We currently do not support the AXIS clause ... we fail
            return GeoCoordParse_Error;
            }

        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
            authorityID = GetAuthority (wkt);

        if ((wkt.length() >= 1) && (wkt.substr (0, 1) == ("]")))
            {
            wkt = wkt.substr (1);
            sectionCompleted = true;
            }

        if (wkt.length() == previousLength)
            return GeoCoordParse_ParseError;
        }

#ifdef NOT_YET

    if (authorityID.length() > 0)
        {
// TBD Search for entry in dictionary
//        baseGCS.SetKey (authorityID->GetKey());
        }
#endif

    baseGCS.SetName (name.c_str());
    baseGCS.SetDescription (name.c_str());
    baseGCS.SetSource("WKT");

    return (SUCCESS == baseGCS.DefinitionComplete() ? GeoCoordParse_Success : GeoCoordParse_InvalidDefinition);
    }


/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts the datum, spheroid and meridian
*   definition and sets the appropriate fields in the given coordinate system.
*
*   @param wkt IN The WKT containing the geographic coordinate reference system to extract.
*
*   @param conversionToDegree OUT Receives the angular unit definition factor for interpretation
*   of angular parameters.
*
*   @param coordinateSystem IN|OUT The coordinate system to set datum, spheroid and prime
*           meridian of.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetGeographicToProjected (Utf8StringR wkt, double* conversionToDegree, BaseGCSR coordinateSystem) const
    {
    Utf8String geographicName;
    Utf8String geographicAuthorityID;

    // We do not care about name and ID
    return GetGeographicToCoordSys (wkt, geographicName, geographicAuthorityID, conversionToDegree, coordinateSystem, false);
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts the datum, spheroid and meridian
*   definition and sets the appropriate fields in the given coordinate system.
*   The GEOGCS AuthorityID and name are returned in separate field for the caller
*   to use as sees fit.
*
*   @param wkt IN The WKT containing the geographic coordinate reference system to extract.
*
*   @param geographicName OUT Reference to a string that will receive the name of the GEOGCS.
*
*   @param geographicAuthorityID OUT Reference to a string that will receive the Authority ID
*           if present
*
*   @param conversionToDegree OUT Receives the angular unit definition factor for interpretation
*   of angular parameters.
*
*   @param coordinateSystem IN|OUT The coordinate system to set datum, spheroid and prime
*           meridian of.
*
*   @param allowGreenwich IN indicates if a non-Greenwich prime meridian should result in
*          an error or not. In CSMAP the latitude/longitude GCS can have prime meridians
*          other than Greenwich while other projected GCS can only use Greenwich.
*          Since the present method is called for both case, the flag indicates appropriate behavior.
*
*   @return GeoCoordParse_Success if operation sucessful or another value otherwise.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetGeographicToCoordSys (Utf8StringR wkt, Utf8StringR geographicName, Utf8StringR geographicAuthorityID, double* conversionToDegree, BaseGCSR coordinateSystem, bool allowNonGreenwich) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;
    GeoCoordParseStatus datumStatus = GeoCoordParse_Success;

    bool datumValid = true;
    bool datumPresent = false;

    wkt.Trim();

    // Validate that this is the proper section (must start with GEOCS)
    if ((wkt.length() < 6) || (!(wkt.substr (0, 6) == "GEOGCS")))
        return GeoCoordParse_BadGCS;

    // Remove keyword
    wkt = wkt.substr (6);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    // Trim [ and ]
    wkt = wkt.substr (1);

    // The first member is the name
    geographicName = GetName (wkt);
    bool sectionCompleted = false;

    coordinateSystem.SetProjectionCode (BaseGCS::pcvUnity);

    size_t previousLength;
    while (wkt.length() > 0 && !sectionCompleted)
        {
        previousLength = wkt.length();
        // Trim of whites
        wkt.Trim();

        // Trim commas
        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
            wkt = wkt.substr(1);

        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
            geographicAuthorityID = GetAuthority (wkt);

        if ((wkt.length() >= 5) && (wkt.substr (0, 5) == ("DATUM")))
            {
            datumPresent = true;
            if (GeoCoordParse_Success != (datumStatus = GetHorizontalDatumToCoordSys (wkt, coordinateSystem)))
                datumValid = false; // We continue parsing anyway
            }

        if ((wkt.length() >= 6) && (wkt.substr (0, 6) == ("PRIMEM")))
            if (GeoCoordParse_Success != (status = GetPrimeMeridianToCoordSys (wkt, coordinateSystem, allowNonGreenwich)))
                return status;

        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("UNIT")))
            {
            if (GeoCoordParse_Success != (status = GetAngleUnit (wkt, conversionToDegree)))
                return status;

            // Conversion error may make it that a degree is slightly higher than 1.0 within 1E-11
            // This may lead to values minuscully greater than 90 degrees for latitudes
            // Clamping to 1.0 insures exact value.
            if (*conversionToDegree > 1.0 && doubleSame(*conversionToDegree, 1.0))
                *conversionToDegree = 1.0;
            }


        if ((wkt.length() >= 8) && (wkt.substr (0, 8) == ("METADATA"))) // Unknown origin but occurs
            {
            if (GeoCoordParse_Success != GetRidOfMetadata (wkt))
                return GeoCoordParse_BadExtension;
            }

        // Optional
        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("AXIS")))
            {
            // For a projcs clause two axises must be specified one after the other
            AxisDirection horizontalAxis = GetAxis(wkt);

            // Trim of whites
            wkt.Trim();

            // Trim commas
            if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
                wkt = wkt.substr(1);
            // Trim of whites
            wkt.Trim();

            // The second AXIS Clause is required accordinag to specs.
            if ((wkt.length() < 4) || (wkt.substr (0, 4) != ("AXIS")))
                return GeoCoordParse_BadAxis;

            AxisDirection verticalAxis = GetAxis(wkt);

            // East and North axis is the default and need not be set.
            if (horizontalAxis != AxisDirection::EAST || verticalAxis != AxisDirection::NORTH)
                {
                // We have a special quadrant ...
                if (horizontalAxis == AxisDirection::WEST && verticalAxis == AxisDirection::NORTH)
                    coordinateSystem.SetQuadrant(2);
                else if (horizontalAxis == AxisDirection::WEST && verticalAxis == AxisDirection::SOUTH)
                    coordinateSystem.SetQuadrant(3);
                else if (horizontalAxis == AxisDirection::EAST && verticalAxis == AxisDirection::SOUTH)
                    coordinateSystem.SetQuadrant(4);
                else if (horizontalAxis == AxisDirection::NORTH && verticalAxis == AxisDirection::EAST)
                    coordinateSystem.SetQuadrant(-1);
                else if (horizontalAxis == AxisDirection::NORTH && verticalAxis == AxisDirection::WEST)
                    coordinateSystem.SetQuadrant(-2);
                else if (horizontalAxis == AxisDirection::SOUTH && verticalAxis == AxisDirection::WEST)
                    coordinateSystem.SetQuadrant(-3);
                else if (horizontalAxis == AxisDirection::SOUTH && verticalAxis == AxisDirection::EAST)
                    coordinateSystem.SetQuadrant(-4);
                else
                    return GeoCoordParse_BadAxis;
                }
            }

        if ((wkt.length() >= 1) && (wkt.substr (0, 1) == ("]")))
            {
            wkt = wkt.substr (1);
            sectionCompleted = true;
            }

        if (wkt.length() == previousLength)
            return GeoCoordParse_ParseError;
        }

    if (datumValid && datumPresent)
        return GeoCoordParse_Success;
    else if (datumPresent && datumStatus != GeoCoordParse_Success)
        return datumStatus;
    else
        return GeoCoordParse_UnknownDatum;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the datum
*   and sets it in the given coordinate system.
*   The complete WKT datum section must be provided including the DATUM[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the DATUM section
*   removed.
*
*   IMPORTANT NOTE: At the moment we only support datums for which the definition
*   is already known in the dictionary. Although we do have the ability to parse
*   custom datum definition parameters (TOWGS84) or Oracle strange datum transformation
*   parameter format, custom datum will fail and result in an error.
*
*   @param wkt IN/OUT The WKT portion that contains the DATUM to extract.
*
*   @param coordinateSystem IN|OUT The coordinate system that gets filled with projection
*       code and parameter values.
*
*   @return GeoCoordParse_Success if successful or another value otherwise.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetHorizontalDatumToCoordSys (Utf8StringR wkt, BaseGCSR coordinateSystem) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;
    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 5) || (!(wkt.substr (0, 5) == "DATUM")))
        return GeoCoordParse_BadDatum;

    // Remove keyword
    wkt = wkt.substr (5);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    // The first member is the name
    Utf8String name = GetName (wkt);
    Utf8String authorityID = GetAuthorityIdFromNameOracleStyle(name);
    bool sectionCompleted = false;
    bool ellipsoidPresentAndKnown = false;
    bool ellipsoidPresent = false;
    bool transfoParamPresent = false;
    double deltaX = 0.0;
    double deltaY = 0.0;
    double deltaZ = 0.0;
    double rotX = 0.0;
    double rotY = 0.0;
    double rotZ = 0.0;
    double scalePPM = 0.0;


    size_t previousLength;
    while (wkt.length() > 0 && !sectionCompleted)
        {
        previousLength = wkt.length();
        // Trim of whites
        wkt.Trim();

        // Trim commas
        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
            wkt = wkt.substr(1);

        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
            authorityID = GetAuthority (wkt);

        if ((wkt.length() >= 8) && (wkt.substr(0, 8) == ("SPHEROID")))
            {
            ellipsoidPresent = true;
            if (GeoCoordParse_Success != (status = GetEllipsoidToCoordSys(wkt, coordinateSystem, ellipsoidPresentAndKnown)))
                return status;
            }

        if ((wkt.length() >= 7) && (wkt.substr (0, 7) == ("TOWGS84")))
            if (GeoCoordParse_Success != (status = GetTOWGS84 (wkt, deltaX, deltaY, deltaZ, rotX, rotY, rotZ, scalePPM)))
                return status;
            else
                transfoParamPresent = true; // Note that the rotation convention is according to operation EPSG:9606 which is reverse to our convention

        if ((wkt.length() >= 9) && (wkt.substr(0, 9) == ("EXTENSION"))) // PROJ4 Addition (Sigh!)
            {
            Utf8String     extensionName;
            Utf8String     extensionText;
            if (GeoCoordParse_Success != GetExtension(wkt, extensionName, extensionText))
                return GeoCoordParse_BadDatum;
            }

        // Check end of section
        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==("]")))
            {
            wkt = wkt.substr(1);
            sectionCompleted = true;
            }

        if (wkt.length() == previousLength)
            {
            // We have the special Oracle dialect where the 7 parameters transformation is provided
            // without TOWGS84 section.
            if (GeoCoordParse_Success == Get7ParamsDatumTransformation (wkt, deltaX, deltaY, deltaZ, rotX, rotY, rotZ, scalePPM))
                transfoParamPresent = true;

            wkt.Trim();

            // In this case the section end is mandatory
            if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
                return GeoCoordParse_ParseError;

            wkt = wkt.substr(1);
            sectionCompleted = true;
            }
        }

    coordinateSystem.SetDatumCode (Datum::NO_DATUM_CODE);

    Utf8String finalDatumName;
    Utf8String ellipsoidName(coordinateSystem.GetEllipsoidName());
    if (GeoCoordParse_Success != GetDatumNameFromNameAliasOrTransform(finalDatumName, name, authorityID, ellipsoidPresentAndKnown, ellipsoidName, transfoParamPresent, deltaX, deltaY, deltaZ, rotX, rotY, rotZ, scalePPM))
        {
        if (ellipsoidPresentAndKnown)
            {
            Utf8String ellipName(coordinateSystem.GetEllipsoidName());

            if (0 == ellipName.CompareTo("CGCS2000"))
                {
                // Special case for China ... the transformation from china datum is unknown/unpublished ... Even if datum name is provided we
                // target an ellipsoid based coordinate system.
                coordinateSystem.SetDatumCode(Datum::NO_DATUM_CODE);
                }
            else if (name == "" && authorityID == "" && ellipName != "") // Ellipsoid base GCS (empty datum name)
                coordinateSystem.SetDatumCode(Datum::NO_DATUM_CODE);
            else
                return GeoCoordParse_UnknownDatum;
            }
        else if (ellipsoidPresent)
            return GeoCoordParse_UnknownDatum;
        else
            return GeoCoordParse_NoEllipsoid;
        }
    else if (finalDatumName.length() != 0)
        {
        // We have a datum name ... we simply need to set it now ... in order to do this we need the code
        int foundIndex = FindDatumIndex(finalDatumName.c_str());

        if (foundIndex >= 0)
            coordinateSystem.SetDatumCode(foundIndex);
        else if (ellipsoidPresentAndKnown)
        {
            Utf8String ellipName(coordinateSystem.GetEllipsoidName());

            if (0 == ellipName.CompareTo("CGCS2000"))
            {
                // Special case for china ... the transformation from china datum is unknown/unpublished ... Even if datum name is provided we
                // target an ellipsoid based coordinate system.
                coordinateSystem.SetDatumCode(Datum::NO_DATUM_CODE);
            }
            else
                return GeoCoordParse_UnknownDatum;
        }
        else
            return GeoCoordParse_UnknownDatum;
    }
    else
        return GeoCoordParse_UnknownDatum;

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the ellipsoid
*   and sets it in the provided coordinate system.
*   The complete WKT ellipsoid section must be provided including the SPHEROID[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the SPHEROID section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the ellipsoid to extract.
*
*   @return GeoCoordParse_Success or an error value.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetEllipsoidToCoordSys (Utf8StringR wkt, BaseGCSR coordinateSystem, bool& ellipsoidPresentAndKnown) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    ellipsoidPresentAndKnown = false;

    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 8) || (!(wkt.substr (0, 8) == "SPHEROID")))
        return GeoCoordParse_BadEllipsoid;

    // Remove keyword
    wkt = wkt.substr (8);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    // The first member is the name
    Utf8String name = GetName (wkt);
    Utf8String authorityID = GetAuthorityIdFromNameOracleStyle(name);

    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);
    /*double semiMajorAxis =*/ GetDouble (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);
    /*double inverseFlattening =*/ GetDouble (wkt);
    wkt.Trim();


    // AUTHORITY MAY BE PRECEDED WITH COMMA
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        {
        wkt = wkt.substr(1);
        wkt.Trim();
        }

    if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
        authorityID = GetAuthority (wkt);


    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr(1);

    // Here we set the ellipsoid code even though it will likely be overridden when the datum is later set.
    // This allows for the support of ellipsoid-based GCS that specify no datum.
    coordinateSystem.SetDatumCode(Datum::NO_DATUM_CODE);

    if (0 != name.length())
        {
        Utf8String finalEllipsoidName;

        GetEllipsoidNameFromNameOrAlias(finalEllipsoidName, name, authorityID);

        if (finalEllipsoidName.length() != 0)
            {
            // We have a datum name ... we simply need to set it now ... in order to do this we need the code
            int foundIndex = FindEllipsoidIndex (finalEllipsoidName.c_str());

            if (foundIndex >= 0)
                {
                coordinateSystem.SetEllipsoidCode (foundIndex);
                ellipsoidPresentAndKnown = true;
                }
            }
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the prime meridian
*   The complete WKT prime meridian section must be provided including the PRIMEM[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the PRIMEM section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the prime meridian to extract.
*
*   @param allowGreenwich IN indicates if a non-Greenwich prime meridian should result in
*          an error or not. In CSMAP the latitude/longitude GCS can have prime meridians
*          other than Greenwich while other projected GCS can only use Greenwich.
*          Since the present method is called for both case, the flag indicates appropriate behavior.
*          Note that prime meridian Ferro is tolerated but will be validate against
*          Krovak projection.
*
*   @return GeoCoordParse_Success or an error value.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetPrimeMeridianToCoordSys (Utf8StringR wkt, BaseGCSR coordinateSystem, bool allowNonGreenwich) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;
    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 6) || (!(wkt.substr (0, 6) == "PRIMEM")))
        return GeoCoordParse_BadPrimeMeridian;

    // Remove keyword
    wkt = wkt.substr (6);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    Utf8String name = GetName (wkt);
    Utf8String authorityID = GetAuthorityIdFromNameOracleStyle(name);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);
    double longitude = GetDouble (wkt);
    wkt.Trim();

    // AUTHORITY MAY BE PRECEDED WITH COMMA
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        {
        wkt = wkt.substr(1);
        wkt.Trim();
        }

    if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
        authorityID = GetAuthority (wkt);

    wkt.Trim();

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr(1);

    // CSMAP only supports prime meridian values other than Greenwish for
    // lat/long GCS all other projections must use Greenwish.
    if (BaseGCS::pcvUnity == coordinateSystem.GetProjectionCode() &&
        (allowNonGreenwich ||
         (name == "Ferro" && doubleSame(longitude, -17.666666666666)) ||
         (name == "FerroPrecise" && doubleSame(longitude, -17.6665931666667))))
        {
        coordinateSystem.SetOriginLongitude (longitude);
        }
    else if ((longitude > (0.00000001)) || (longitude < (-0.00000001))) // Check longitude is zero for any other projections
        return GeoCoordParse_UnsupportedMeridian;

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the projection
*   The complete WKT projection and related parameters section must be provided including the
*   PROJECTION[ ] and PARAMETER[] keywords.
*   The wkt text stream may contain additional text that is returned with the PROJECTION
*   and PARAMETER sections removed.
*
*   @param wkt IN/OUT The WKT portion that contains the projection to extract.
*
*   @param conversionToDegree IN The conversion factor to degree for angular parameters.
*
*   @param coordinateSystem IN|OUT The coordinate system that gets filled with projection
*       code and parameter values.
*
*   @return GeoCoordParse_Success if successful or another value in case of error.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetProjectionToCoordSys (Utf8StringR wkt,double conversionToDegree, BaseGCSR coordinateSystem) const
    {

    GeoCoordParseStatus status = GeoCoordParse_Success;
    bool projectionFromOracleStyle = false;
    bool parameterPresent = false;

    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 10) || (!(wkt.substr (0, 10) == "PROJECTION")))
        return GeoCoordParse_BadProjection;

    // Remove keyword
    wkt = wkt.substr (10);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() <1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    // The first member is the name
    Utf8String name = GetName (wkt);
    Utf8String authorityID = GetAuthorityIdFromNameOracleStyle(name);

    BaseGCS::ProjectionCodeValue projectionCode = GetProjectionCodeFromParseName (name);

    if (BaseGCS::pcvInvalid == projectionCode)
        {
        Utf8String upperMethodName = name;
        std::transform(upperMethodName.begin(), upperMethodName.end(), upperMethodName.begin(), [](char const& c){return (char)toupper(c);});

        if (upperMethodName == "MERCATOR_AUXILIARY_SPHERE")
            {
            // This is a special case from ESRI that we process completely differently (WebMercator)
            // Datum name should be WGS84 ... verify
            Utf8String datumName = coordinateSystem.GetDatumName();
            if (datumName == "WGS84")
                {
                projectionCode = BaseGCS::pcvMercator;
                int foundIndex = FindEllipsoidIndex ("SphereWGS84");

                if (foundIndex >= 0)
                    {
                    coordinateSystem.SetDatumCode (Datum::NO_DATUM_CODE);
                    coordinateSystem.SetEllipsoidCode (foundIndex);
                    }
                else
                    return GeoCoordParse_UnknownProjectionMethod;

                foundIndex = FindDatumIndex ("SphereWGS84");

                if (foundIndex >= 0)
                    coordinateSystem.SetDatumCode (foundIndex);
                else
                    return GeoCoordParse_UnknownProjectionMethod;
                }
            else
                return GeoCoordParse_UnknownProjectionMethod;
            }
        }

    // If we still have no projection method but an Oracle style Operation ID was provided
    if ((BaseGCS::pcvInvalid == projectionCode) && (authorityID.length() > 0))
        {
        projectionCode = GetProjectionCodeFromOracleEPSGID(authorityID);
        projectionFromOracleStyle = true;
        }

    // We tried everything but could not determine the projection method.
    if (BaseGCS::pcvInvalid == projectionCode)
        return GeoCoordParse_UnknownProjectionMethod;

    if (BaseGCS::pcvCzechKrovak == projectionCode || BaseGCS::pcvCzechKrovakModified == projectionCode)
        {
        if (!doubleSame(coordinateSystem.GetOriginLongitude(), -17.666666666666) &&
            !doubleSame(coordinateSystem.GetOriginLongitude(), -17.6665931666667) &&
            !doubleSame(coordinateSystem.GetOriginLongitude(), 0.0))
            return GeoCoordParse_BadPrimeMeridian;
        }
    else
        {
        if (!doubleSame(coordinateSystem.GetOriginLongitude(), 0.0))
            return GeoCoordParse_BadPrimeMeridian;
        }

    SetProjectionCode(projectionCode, true, coordinateSystem);

    wkt.Trim();

    if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
        authorityID = GetAuthority (wkt);

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr(1);

    wkt.Trim();

    bool sectionCompleted = false;

    size_t previousLength;
    while (wkt.length() > 0 && !sectionCompleted)
        {
        previousLength = wkt.length();
        // Trim of whites
        wkt.Trim();

        // Trim commas
        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
            wkt = wkt.substr(1);

        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("PARAMETER")))
            {
            parameterPresent = true; // Indicate PARAMETER clause was present (needed to validate Oracle WKTs which often omit parameters)

            double parameterValue;
            Utf8String parameterStringValue;
            Utf8String parameterName;
            if (GeoCoordParse_Success != (status = GetParameter (wkt, parameterName, &parameterValue, parameterStringValue)))
                return status;

            if (parameterName.length() > 0)
                {
                if (GeoCoordParse_Success != (status = SetParameterToCoordSys (parameterName, parameterStringValue, parameterValue, conversionToDegree, coordinateSystem)))
                    return status;
                }
            }

        if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==("]")))
            {
            // Although not specs compliant we accept missing UNIT section
            wkt = wkt.substr(1);
            sectionCompleted = true;
            }

        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("UNIT")))
            sectionCompleted = true;

        // Even though the specs call for the linear units following immediately the PARAMETERS
        // sometimes it is not the case and we learn to live with the fact within limits.
        if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
            sectionCompleted = true;

        if ((wkt.length() >= 4) && (wkt.substr (0, 4) == ("AXIS")))
            sectionCompleted = true;

        if (wkt.length() == previousLength)
            return GeoCoordParse_ParseError;
        }

    // If we had an Oracle style projection but no parameters then we fail (flavor assumes we load parameters from table)
    if (projectionFromOracleStyle && !parameterPresent)
        return GeoCoordParse_BadProjection;

    // Special processing for Lambert Conformal Conic.
    if (BaseGCS::pcvLambertMichigan == coordinateSystem.GetProjectionCode())
        {
        // If no standard parallel set ... invalid definition
        if (doubleSame(coordinateSystem.GetStandardParallel2(), -90.0) && doubleSame(coordinateSystem.GetStandardParallel1(), -90.0))
            {
            // No standard parallel this indicates LCC 1SP at latitude of origin
            double scaleFactor = coordinateSystem.GetEllipsoidScaleFactor();
            double longitudeOfOrigin = coordinateSystem.GetOriginLongitude();
            coordinateSystem.SetProjectionCode(BaseGCS::pcvLambertConformalConicOneParallel);
            coordinateSystem.SetCentralMeridian(longitudeOfOrigin);
            coordinateSystem.SetScaleReduction(scaleFactor);
            }
        // If second parallel not set we switch to one parallel variation with parallel set as latitude of origin
        else if (doubleSame(coordinateSystem.GetStandardParallel2(), -90.0))
            {
            if (!doubleSame(coordinateSystem.GetStandardParallel1(), coordinateSystem.GetOriginLatitude()))
                coordinateSystem.SetOriginLatitude(coordinateSystem.GetStandardParallel1());

            double scaleFactor = coordinateSystem.GetEllipsoidScaleFactor();
            double longitudeOfOrigin = coordinateSystem.GetOriginLongitude();
            coordinateSystem.SetProjectionCode(BaseGCS::pcvLambertConformalConicOneParallel);
            coordinateSystem.SetCentralMeridian(longitudeOfOrigin);
            coordinateSystem.SetScaleReduction(scaleFactor);
            }
        if (doubleSame(coordinateSystem.GetStandardParallel2(), coordinateSystem.GetStandardParallel1()) &&
            doubleSame(coordinateSystem.GetStandardParallel1(), coordinateSystem.GetOriginLatitude()))
        {
            double scaleFactor = coordinateSystem.GetEllipsoidScaleFactor();
            double longitudeOfOrigin = coordinateSystem.GetOriginLongitude();
            coordinateSystem.SetProjectionCode(BaseGCS::pcvLambertConformalConicOneParallel);
            coordinateSystem.SetCentralMeridian(longitudeOfOrigin);
            coordinateSystem.SetScaleReduction(scaleFactor);
        }
        // If both parallel set but scaling is unity we switch to standard 2 parallels
        else if (doubleSame(coordinateSystem.GetEllipsoidScaleFactor(), 1.0))
            {
            coordinateSystem.SetProjectionCode(BaseGCS::pcvLambertConformalConicTwoParallel);
            }
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the parameter
*   The complete WKT parameter section must be provided including the PARAMETER[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the PARAMETER section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the parameter to extract.
*
*   @param parameterName OUT reference to a string that receives the parameter name.
*
*   @param parameterValue OUT Pointer to double that receives the floating point value of
*   parameter.
*
*   @param parameterStringValue OUT Reference to a string that receives the string value
*       of the parameter. Usually the parameter value is always numeric but some
*       dialect use strings values to specify Hemisphere or zones.
*
*   @return GeoCoordParse_Success is successful or another value in case of error.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetParameter (Utf8StringR wkt, Utf8StringR parameterName, double* parameterValue, Utf8StringR parameterStringValue) const
    {

    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 9) || (!(wkt.substr (0, 9) == "PARAMETER")))
        return GeoCoordParse_BadProjectionParam;

    // Remove keyword
    wkt = wkt.substr (9);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    parameterName = GetName (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);
    *parameterValue = GetDoubleAndString (wkt, parameterStringValue);
    wkt.Trim();

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr(1);

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the unit
*   The complete WKT unit section must be provided including the UNIT[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the UNIT section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the unit to extract.
*
*   @param unitName OUT Reference to a string that receives the unit name.
*
*   @param unitFactor OUT The unit factor as set in the unit clause.
*
*   @return GeoCoordParse_Success if succesful or another value otherwise.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetUnit (Utf8StringR wkt, Utf8StringR unitName, double* unitFactor) const
    {
    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 4) || (!(wkt.substr (0, 4) == "UNIT")))
        return GeoCoordParse_BadUnit;

    // Remove keyword
    wkt = wkt.substr (4);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    unitName = GetName (wkt);
    Utf8String authorityID = GetAuthorityIdFromNameOracleStyle(unitName);

    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);
    *unitFactor = GetDouble (wkt);
    wkt.Trim();

    // AUTHORITY MAY BE PRECEDED WITH COMMA
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        {
        wkt = wkt.substr(1);
        wkt.Trim();
        }

    // Optional component
    if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
        authorityID = GetAuthority (wkt);

    wkt.Trim();

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr(1);

#ifdef NOT_YET
    if (authorityID.length() > 0)
    {
//        pUnit->SetKey (authorityID->GetKey());
    }
#endif

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method removes the METADATA clause content
*
*   @param wkt IN/OUT The WKT portion that contains the metadata to remove.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetRidOfMetadata (Utf8StringR wkt) const
    {
    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 8) || (!(wkt.substr (0, 8) == "METADATA")))
        return GeoCoordParse_BadExtension;

    wkt = wkt.substr (8);

    wkt.Trim();

    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    size_t endPos = wkt.find("]");

    if (std::string::npos == endPos)
        return GeoCoordParse_BadExtension;

    wkt = wkt.substr(endPos);
    wkt.Trim();

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr(1);

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the extension
*   The complete WKT extension section must be provided including the EXTENSION[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the EXTENSION section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the extension to extract.
*
*   @param extensionName OUT Reference to a string that receives the extension name.
*
*   @param extentionText OUT The text associated with extension
*
*   @return GeoCoordParse_Success if succesful or another value otherwise.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetExtension (Utf8StringR wkt, Utf8StringR extensionName, Utf8StringR extensionText) const
    {
    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 9) || (!(wkt.substr (0, 9) == "EXTENSION")))
        return GeoCoordParse_BadExtension;

    // Remove keyword
    wkt = wkt.substr (9);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    extensionName = GetName (wkt);

    wkt.Trim();

    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);

    wkt.Trim();
    extensionText = GetName (wkt);

    wkt.Trim();

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr(1);

    return GeoCoordParse_Success;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the linear unit
*   and sets it in the provided coordinate system.
*
*   @param wkt IN/OUT The WKT portion that contains the unit to extract.
*
*   @param coordinateSystem IN/OUT The coordinate system to set the units of.
*
*   @return GeoCoordParse_Success if successful or another value in case of error.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetLinearUnitToCoordSys (Utf8StringR wkt, BaseGCSR coordinateSystem) const
    {
    GeoCoordParseStatus   status = GeoCoordParse_Success;
    double      unitFactor;
    Utf8String     unitName;
    if (GeoCoordParse_Success != (status = GetUnit (wkt, unitName, &unitFactor)))
        return status;

    GeoCoordinates::UnitEnumerator* unitEnumerator = new GeoCoordinates::UnitEnumerator();
    GeoCoordinates::UnitCP currentUnit;
    int currentUnitCode = 0;
    int foundUnitCode = -1;
    while ((foundUnitCode < 0) && (unitEnumerator->MoveNext()))
        {
        currentUnit = unitEnumerator->GetCurrent();

        if (currentUnit->GetBase() == GeoUnitBase::Meter)
            {
            double dictConversionFactor = currentUnit->GetConversionFactor();
            if ((unitFactor < dictConversionFactor + 0.00000001) && (unitFactor > dictConversionFactor - 0.00000001))
                foundUnitCode = currentUnitCode;
            }
        currentUnitCode++;

        currentUnit->Destroy();
        }

    unitEnumerator->Destroy();

    if (foundUnitCode < 0)
        return GeoCoordParse_UnknownUnit;

    coordinateSystem.SetUnitCode (foundUnitCode);

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the angle unit
*   and returns the conversion factor to meter.
*   The complete WKT unit section must be provided including the UNIT[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the UNIT section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the unit to extract.
*
*   @param conversionToDegree OUT The conversation factor to degree.
*
*   @return GeoCoordParse_Success or an error value.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetAngleUnit (Utf8StringR wkt, double* conversionToDegree) const
    {
    GeoCoordParseStatus   status = GeoCoordParse_Success;
    Utf8String     unitName;
    double      conversionToRadians = 1.0;
    status = GetUnit (wkt, unitName, &conversionToRadians);
    *conversionToDegree = conversionToRadians * 180.0 / PI;

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the name
*   which must be enclosed within double-quotes. The first non white character must be
*   the opening double quote. The stream is returned with name component removed
*
*   @param wkt IN The WKT portion that contains the name to extract.
*
*   @return The name
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8String     GetName (Utf8StringR wkt) const
    {
    wkt.Trim ();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "\"")))
        return "";

    // Remove keyword
    wkt = wkt.substr (1);

    // Obtain the next double quote location
    size_t index = wkt.find_first_of ("\"");

    if (index == Utf8String::npos)
        return "";

    Utf8String name = wkt.substr (0, index);

    // Remove name section from text stream
    wkt = wkt.substr (index + 1);

    return name;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the keyword
*   which must start at the first non blank character and end with a section end or a comma.
*
*   @param wkt IN The WKT portion that contains the keyword to extract.
*
*   @return The keyword
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8String     GetKeyword (Utf8StringR& wkt) const
    {
    wkt.Trim();

    // Obtain the next double quote location
    size_t index1 = wkt.find_first_of (",");
    size_t index2 = wkt.find_first_of ("]");

    size_t index = 0;
    if (index1 != Utf8String::npos && index2 != Utf8String::npos)
        index = (index1 < index2 ? index1 : index2);
    else
        {
        if (index1 != Utf8String::npos)
            index = index1;
        else
            index = index2;
        }

    if (0 == index)
        return "";

    if (index == Utf8String::npos)
        index = wkt.length();

    Utf8String keyword = wkt.substr (0, index);

    wkt = wkt.substr (index);

    return keyword;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the authority ID
*   The complete WKT authority section must be provided including the AUTHORITY[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the AUTHORITY section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the authority to extract.
*
*   @return The authority identifier
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8String GetAuthority (Utf8StringR wkt) const
    {
    Utf8String     authorityID;
    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 9) || (!(wkt.substr (0, 9) == "AUTHORITY")))
        return "";

    // Remove keyword
    wkt = wkt.substr (9);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return "";

    wkt = wkt.substr (1);

    Utf8String     authorityName = GetName (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);
    Utf8String     authorityCode = GetName (wkt);
    wkt.Trim();

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        {
        // Some weird flavors use an integer for the authority code
        int valCode = GetInteger(wkt);
        wchar_t valString[20];
        BeStringUtilities::Itow(valString, valCode, 19, 10);
        authorityCode = Utf8String(valString);
        }

    // Check end of section again
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return "";

    wkt = wkt.substr(1);

    if (authorityName.length() > 0)
        {
        if (authorityCode.length() > 0)
            authorityID = authorityName + ":" + authorityCode;
        else
            authorityID = authorityName;
        }
    else
        authorityID = authorityCode;

    return authorityID;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the axis definition
*   The complete WKT authority section must be provided including the AXIS[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the AXIS section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the axis to extract.
*
*   @return The axis identifier
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
AxisDirection GetAxis (Utf8StringR wkt) const
    {
    Utf8String     authorityID;
    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 4) || (!(wkt.substr (0, 4) == "AXIS")))
        return AxisDirection::UNDEFINED;

    // Remove keyword
    wkt = wkt.substr (4);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return AxisDirection::UNDEFINED;

    wkt = wkt.substr (1);

    Utf8String     name = GetName (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);

    Utf8String     keyword = GetKeyword (wkt);
    wkt.Trim();

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return AxisDirection::UNDEFINED;

    wkt = wkt.substr(1);

    if (keyword == "NORTH")
        return AxisDirection::NORTH;
    if (keyword == "SOUTH")
        return AxisDirection::SOUTH;
    if (keyword == "EAST")
        return AxisDirection::EAST;
    if (keyword == "WEST")
        return AxisDirection::WEST;
    if (keyword == "UP")
        return AxisDirection::UP;
    if (keyword == "DOWN")
        return AxisDirection::DOWN;
    if (keyword == "OTHER")
        return AxisDirection::OTHER;

    return AxisDirection::UNDEFINED;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the local datum
*   The complete WKT authority section must be provided including the LOCAL_DATUM[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the LOCAL_DATUM section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the local datum to extract.
*
*   @return GeoCoordParse_Success if successful or another value in case of error.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetLocalDatumToCoordSys (Utf8StringR wkt, BaseGCSR coordinateSystem) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 11) || (!(wkt.substr (0, 11) == "LOCAL_DATUM")))
        return GeoCoordParse_BadDatum;

    // Remove keyword
    wkt = wkt.substr (11);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;
    wkt = wkt.substr (1);

    Utf8String name = GetName (wkt);
    Utf8String authorityID = GetAuthorityIdFromNameOracleStyle(name);

    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);
    /*int32_t type = (int32_t)*/(GetDouble (wkt));
    wkt.Trim();

    if ((wkt.length() >= 9) && (wkt.substr (0, 9) == ("AUTHORITY")))
        authorityID = GetAuthority (wkt);

    wkt.Trim();

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr(1);

    // Since the NERTH coordinate system does not make any use
    // of a local datum concept, we will simply ignore the data that
    // has been parsed out of the WKT stream

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the TOWGS84
*   horizontal datum transformation.
*   The complete WKT authority section must be provided including the TOWGS84[ ] keyword.
*   The wkt text stream may contain additional text that is returned with the TOWGS84 section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the horizontal datum transformation to extract.
*   @param deltaX - The delta X in meters
*   @param deltaY - The delta Y in meters
*   @param deltaZ - The delta Z in meters
*   @param rotationX - [OUT] X Rotation in arcseconds
*   @param rotationY - [OUT] Y rotation in arcseconds
*   @param rotationZ - [OUT] Z rotation in arcseconds
*   @param scalePPM - [OUT] Scale in parts per million
*
*   @return GeoCoordParse_Success if 7 params were extracted and false otherwise
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus GetTOWGS84 (Utf8StringR wkt, double& deltaX, double& deltaY, double& deltaZ, double& rotationX, double& rotationY, double& rotationZ, double& scalePPM) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    wkt.Trim();

    // Validate that this is the proper section (must start with ")
    if ((wkt.length() < 7) || (!(wkt.substr (0, 7) == "TOWGS84")))
        return GeoCoordParse_BadTransform;

    // Remove keyword
    wkt = wkt.substr (7);

    // Trim again
    wkt.Trim();

    // Make sure that remainder starts with [
    if ((wkt.length() < 1) || (!(wkt.substr (0, 1) == "[")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr (1);

    status = Get7ParamsDatumTransformation (wkt, deltaX, deltaY, deltaZ, rotationX, rotationY, rotationZ, scalePPM);

    // Check end of section
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    wkt = wkt.substr(1);

    // Since custom datum specifications are not currently supported we simply go on with parsed out
    // TOWGS84 clause without setting any GCS member.

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the 7 parameters
*   horizontal datum transformation.
*   The complete 7 double WKT authority section must be provided.
*   The wkt text stream may contain additional text that is returned with the 7 parameters section
*   removed.
*
*   @param wkt IN/OUT The WKT portion that contains the horizontal datum transformation to extract.
*   @param deltaX - The delta X in meters
*   @param deltaY - The delta Y in meters
*   @param deltaZ - The delta Z in meters
*   @param rotationX - [OUT] X Rotation in arcseconds
*   @param rotationY - [OUT] Y rotation in arcseconds
*   @param rotationZ - [OUT] Z rotation in arcseconds
*   @param scalePPM - [OUT] Scale in parts per million
*
*   @return GeoCoordParse_Success or an error value.
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus Get7ParamsDatumTransformation (Utf8StringR wkt, double& deltaX, double& deltaY, double& deltaZ, double& rotationX, double& rotationY, double& rotationZ, double& scalePPM) const
    {
    GeoCoordParseStatus status = GeoCoordParse_Success;

    wkt.Trim();

    // This may mean that the datum contains the datum shift definitions
    // 7 numbers to follow
    deltaX = GetDouble (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);

    deltaY = GetDouble (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);

    deltaZ = GetDouble (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);

    rotationX = GetDouble (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);

    rotationY = GetDouble (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);

    rotationZ = GetDouble (wkt);
    wkt.Trim();
    if ((wkt.length() >= 1) && (wkt.substr(0, 1) ==(",")))
        wkt = wkt.substr(1);

    scalePPM = GetDouble (wkt);
    wkt.Trim();

    // In this case the section end is mandatory
    if ((wkt.length() < 1) || (!(wkt.substr(0, 1) == "]")))
        return GeoCoordParse_ParseError;

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the double
*   The first non white character must be the number to extract.
*
*   @param wkt IN The WKT portion that contains the number to extract.
*
*   @return The number
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double GetDouble (Utf8StringR wkt) const
    {
    wkt.Trim();

    // Obtain the next param or end of clause
    size_t index1 = wkt.find_first_of (",");
    size_t index2 = wkt.find_first_of ("]");

    size_t index = 0;
    if (index1 != Utf8String::npos && index2 != Utf8String::npos)
        index = (index1 < index2 ? index1 : index2);
    else
        {
        if (index1 != Utf8String::npos)
            index = index1;
        else
            index = index2;
        }

    if (0 == index)
        return 0.0; // Return default value and let parser fail elsewhere in case of structural problem

    if (index == Utf8String::npos)
        index = wkt.length();

    double value = std::atof (wkt.substr(0, index).c_str());

    wkt = wkt.substr (index);

    return value;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the integer
*   The first non white character must be the number to extract.
*
*   @param wkt IN The WKT portion that contains the number to extract.
*
*   @return The number
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
long GetInteger (Utf8StringR wkt) const
    {
    wkt.Trim();

    // Obtain the next double quote location
    size_t index1 = wkt.find_first_of (",");
    size_t index2 = wkt.find_first_of ("]");

    size_t index = 0;
    if (index1 != Utf8String::npos && index2 != Utf8String::npos)
        index = (index1 < index2 ? index1 : index2);
    else
        {
        if (index1 != Utf8String::npos)
            index = index1;
        else
            index = index2;
        }

    if (0 == index)
        return 0; // Return default value and let parser fail elsewhere in case of structural problem

    if (index == Utf8String::npos)
        index = wkt.length();

    long value = std::atoi (wkt.substr(0, index).c_str());

    wkt = wkt.substr (index);

    return value;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts from the provided stream the double
*   The first non white character must be the number ot extract.
*
*   @param wkt IN The WKT portion that contains the number to extract.
*
*   @param stringValue OUT A reference to a string that will receive the string value
*   prior to conversion to a floating-point value. In rare dialects the parameter
*   value is in text form for obscure parameter types such as Zone or Hemisphere.
*
*   @return The number
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double GetDoubleAndString (Utf8StringR wkt, Utf8StringR stringValue) const
    {
    wkt.Trim();

    // Obtain the next double quote location
    size_t index1 = wkt.find_first_of (",");
    size_t index2 = wkt.find_first_of ("]");

    size_t index = 0;
    if (index1 != Utf8String::npos && index2 != Utf8String::npos)
        index = (index1 < index2 ? index1 : index2);
    else
        {
        if (index1 != Utf8String::npos)
            index = index1;
        else
            index = index2;
        }

    if (0 == index)
        return 0.0; // Return default value and let parser fail elsewhere in case of structural problem

    if (index == Utf8String::npos)
        index = wkt.length();

    stringValue = wkt.substr(0, index);
    double value = std::atof(stringValue.c_str());

    wkt = wkt.substr (index);

    return value;
    }

/*---------------------------------------------------------------------------------**//**
*   @description PRIVATE This private method extracts, strips and returns the Oracle style
*   authority ID from the datum, spehroid, prime meridian, or operation name. At one
*   point Oracle used to append to the object name an authority ID in between parenthesis
*   of the form "Anguilla 1957 (EPSG ID 6600)". This function will extract this authroity ID
*   and return it in the form "EPSG:6600" and remove the part from the name.
*
*   @param name IN/OUT The name as extracted from WKT. On output it will contain the stripped name
*               if applicable
*
*   @return The authority ID or an empty string if none can be found
*
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8String GetAuthorityIdFromNameOracleStyle(Utf8StringR name) const
    {
    Utf8String EPSGNumber;
    size_t StartEPSG = name.find("EPSG ID ");
    if (StartEPSG != Utf8String::npos)
        {
        size_t EndEPSG = name.find (")", StartEPSG);
        if (EndEPSG != Utf8String::npos && EndEPSG > StartEPSG)
            {
            EPSGNumber = "EPSG:" + name.substr (StartEPSG + 8, EndEPSG - StartEPSG - 8);
            name = name.substr(0, StartEPSG-1);
            name.Trim();
            }
        }
    else
        {
        StartEPSG = name.find("EPSG OP ");
        if (StartEPSG != Utf8String::npos)
            {
            size_t EndEPSG = name.find(")", StartEPSG);
            if (EndEPSG != Utf8String::npos && EndEPSG > StartEPSG)
                {
                EPSGNumber = "EPSG:" + name.substr(StartEPSG + 8, EndEPSG - StartEPSG - 8);
                name = name.substr(0, StartEPSG - 1);
                name.Trim();
                }
            }
        }
    return EPSGNumber;
    }

}; // End class WKT Parser

/*=================================================================================**//**
* GeoTiffKey interpreter class.
+===============+===============+===============+===============+===============+======*/
struct GeoTiffKeyInterpreter
{
friend struct GeoTiffKeyCreator;
private:

// These are directly cut from http://www.remotesensing.org/geotiff/spec/geotiff6.html#6.1
enum    GeoKeyIds
    {
    // 6.2.1 GeoTIFF Configuration Keys
    GTModelTypeGeoKey               = 1024, /*  Section 6.3.1.1 Codes       */
    GTRasterTypeGeoKey              = 1025, /*  Section 6.3.1.2 Codes       */
    GTCitationGeoKey                = 1026, /* documentation */

    // 6.2.2 Geographic CS Parameter Keys
    GeographicTypeGeoKey            = 2048, /*  Section 6.3.2.1 Codes     */
    GeogCitationGeoKey              = 2049, /* documentation             */
    GeogGeodeticDatumGeoKey         = 2050, /*  Section 6.3.2.2 Codes     */
    GeogPrimeMeridianGeoKey         = 2051, /*  Section 6.3.2.4 codes     */
    GeogLinearUnitsGeoKey           = 2052, /*  Section 6.3.1.3 Codes     */
    GeogLinearUnitSizeGeoKey        = 2053, /* meters                    */
    GeogAngularUnitsGeoKey          = 2054, /*  Section 6.3.1.4 Codes     */
    GeogAngularUnitSizeGeoKey       = 2055, /* radians                   */
    GeogEllipsoidGeoKey             = 2056, /*  Section 6.3.2.3 Codes     */
    GeogSemiMajorAxisGeoKey         = 2057, /* GeogLinearUnits           */
    GeogSemiMinorAxisGeoKey         = 2058, /* GeogLinearUnits           */
    GeogInvFlatteningGeoKey         = 2059, /* ratio                     */
    GeogAzimuthUnitsGeoKey          = 2060, /*  Section 6.3.1.4 Codes     */
    GeogPrimeMeridianLongGeoKey     = 2061, /* GeogAngularUnit           */

    // 6.2.3 Projected CS Parameter Keys
    ProjectedCSTypeGeoKey           = 3072, /*  Section 6.3.3.1 codes   */
    PCSCitationGeoKey               = 3073, /* documentation           */
    ProjectionGeoKey                = 3074, /*  Section 6.3.3.2 codes   */
    ProjCoordTransGeoKey            = 3075, /*  Section 6.3.3.3 codes   */
    ProjLinearUnitsGeoKey           = 3076, /*  Section 6.3.1.3 codes   */
    ProjLinearUnitSizeGeoKey        = 3077, /* meters                  */
    ProjStdParallel1GeoKey          = 3078, /* GeogAngularUnit */
    ProjStdParallel2GeoKey          = 3079, /* GeogAngularUnit */
    ProjNatOriginLongGeoKey         = 3080, /* GeogAngularUnit */
    ProjNatOriginLatGeoKey          = 3081, /* GeogAngularUnit */
    ProjFalseEastingGeoKey          = 3082, /* ProjLinearUnits */
    ProjFalseNorthingGeoKey         = 3083, /* ProjLinearUnits */
    ProjFalseOriginLongGeoKey       = 3084, /* GeogAngularUnit */
    ProjFalseOriginLatGeoKey        = 3085, /* GeogAngularUnit */
    ProjFalseOriginEastingGeoKey    = 3086, /* ProjLinearUnits */
    ProjFalseOriginNorthingGeoKey   = 3087, /* ProjLinearUnits */
    ProjCenterLongGeoKey            = 3088, /* GeogAngularUnit */
    ProjCenterLatGeoKey             = 3089, /* GeogAngularUnit */
    ProjCenterEastingGeoKey         = 3090, /* ProjLinearUnits */
    ProjCenterNorthingGeoKey        = 3091, /* ProjLinearUnits */
    ProjScaleAtNatOriginGeoKey      = 3092, /* ratio   */
    ProjScaleAtCenterGeoKey         = 3093, /* ratio   */
    ProjAzimuthAngleGeoKey          = 3094, /* GeogAzimuthUnit */
    ProjStraightVertPoleLongGeoKey  = 3095, /* GeogAngularUnit */

    // 6.2.4 Vertical CS Keys
    VerticalCSTypeGeoKey            = 4096, /*  Section 6.3.4.1 codes   */
    VerticalCitationGeoKey          = 4097, /* documentation */
    VerticalDatumGeoKey             = 4098, /*  Section 6.3.4.2 codes   */
    VerticalUnitsGeoKey             = 4099, /*  Section 6.3.1.3 codes   */

    //Private Keys
    ProjectedCSTypeGeoKeyLong       = 60000 /* ProjectedCSTypeGeoKey for values greater than 65535 - Used by Imagepp*/
    };

enum    GeoKeyModelType
    {
    ModelTypeUndefined              = 0, /* not defined */
    ModelTypeProjected              = 1, /* Projection Coordinate System         */
    ModelTypeGeographic             = 2, /* Geographic latitude-longitude System */
    ModelTypeGeocentric             = 3, /* Geocentric (X,Y,Z) Coordinate System */
    };

enum    PrimeMeridians
    {
    PM_Greenwich    = 8901,
    PM_Lisbon       = 8902,
    PM_Paris        = 8903,
    PM_Bogota       = 8904,
    PM_Madrid       = 8905,
    PM_Rome         = 8906,
    PM_Bern         = 8907,
    PM_Jakarta      = 8908,
    PM_Ferro        = 8909,
    PM_Brussels     = 8910,
    PM_Stockholm    = 8911,
    PM_Athens       = 8912,
    PM_Oslo         = 8913,
    };

enum    CoordTransCodes
    {
    CT_TransverseMercator               = 1,
    CT_TransvMercator_Modified_Alaska   = 2,
    CT_ObliqueMercator                  = 3,
    CT_ObliqueMercator_Laborde          = 4,
    CT_ObliqueMercator_Rosenmund        = 5,
    CT_ObliqueMercator_Spherical        = 6,
    CT_Mercator                         = 7,
    CT_LambertConfConic_2SP             = 8,
    CT_LambertConfConic_Helmert         = 9,
    CT_LambertAzimEqualArea             = 10,
    CT_AlbersEqualArea                  = 11,
    CT_AzimuthalEquidistant             = 12,
    CT_EquidistantConic                 = 13,
    CT_Stereographic                    = 14,
    CT_PolarStereographic               = 15,
    CT_ObliqueStereographic             = 16,
    CT_Equirectangular                  = 17,
    CT_CassiniSoldner                   = 18,
    CT_Gnomonic                         = 19,
    CT_MillerCylindrical                = 20,
    CT_Orthographic                     = 21,
    CT_Polyconic                        = 22,
    CT_Robinson                         = 23,
    CT_Sinusoidal                       = 24,
    CT_VanDerGrinten                    = 25,
    CT_NewZealandMapGrid                = 26,
    CT_TransvMercator_SouthOriented     = 27,
    };

enum VerticalCSCode
    {
    // All entries from 5000 to 5099 refer to non-Orthometric (ellipsoid) vertical datums
    // A set of geotiff keys can define a vertical CS even if no Geographic CS is defined.
    // Since a BaseGCS requires the definition of aqn horizontal Geographic Coordinate System and
    // allowing the vertical CS to refer to a different geodetic datum and ellipsoid would not make sense at all
    // For this reason we will interpret all values non-orthometric as plain ellipsoidal (refering to the geodetic datum)
    // regardless the ellipsoid fit or not.
    VertCS_Newlyn =  5101,
    VertCS_North_American_Vertical_Datum_1929 =  5102,
    VertCS_North_American_Vertical_Datum_1988 =  5103,
    VertCS_Yellow_Sea_1956 = 5104,
    VertCS_Baltic_Sea =  5105,
    VertCS_Caspian_Sea = 5106,
    };

CSDefinition            m_csDef;
CSDatumDef              m_csDatumDef;
CSEllipsoidDef          m_csEllipsoidDef;
GeoKeyModelType         m_modelType;
bool                    m_userDefinedGeoCS;
bool                    m_userDefinedProjectedCS;
bool                    m_haveEllipsoid;
bool                    m_haveDatum;
bool                    m_haveCS;
bool                    m_haveUserOriginLongitude;
bool                    m_haveUserOriginLatitude;
bool                    m_haveFalseEasting;
bool                    m_haveFalseNorthing;
int                     m_coordSys;
double                  m_angularUnitsToDegrees;
double                  m_azimuthUnitsToDegrees;
double                  m_linearUnitsToMeters;
VertDatumCode           m_verticalDatum;

#define UserDefinedKeyValue 32767
#define UnDefinedKeyValue   0            // GeoTIFF indicates value 0 is "undefined"

#define PROJ_COORD_TRANS_NAME 60

typedef struct ProjTransInCitation
{
    int32_t m_csCoordSys;
    char m_csName[PROJ_COORD_TRANS_NAME];
    char m_nameInCitation[PROJ_COORD_TRANS_NAME];
} ProjTransInCitation;

public:
GeoTiffKeyInterpreter()    {
    memset (&m_csDef,           0, sizeof(m_csDef));
    memset (&m_csDatumDef,      0, sizeof(m_csDatumDef));
    memset (&m_csEllipsoidDef,  0, sizeof(m_csEllipsoidDef));

    // initialize paper scale.
    m_csDef.map_scl             = 1.0;
    m_csDef.scl_red             = 1.0;
    m_angularUnitsToDegrees     = 1.0;
    m_azimuthUnitsToDegrees     = 1.0;
    m_linearUnitsToMeters       = 1.0;

    m_modelType                 = ModelTypeUndefined;
    m_coordSys                  = 0;
    m_userDefinedGeoCS          = false;
    m_userDefinedProjectedCS    = false;
    m_haveEllipsoid             = false;
    m_haveDatum                 = false;
    m_haveCS                    = false;

    m_haveUserOriginLongitude   = false;
    m_haveUserOriginLatitude    = false;
    m_haveFalseEasting          = false;
    m_haveFalseNorthing         = false;

    m_verticalDatum             = vdcFromDatum;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       Process
(
BaseGCSR                outGCS,
StatusInt              *warning,            // Warning. Function returns SUCCESS, but some warning desribed in ERRMSG and warning, passed back.
Utf8StringP                warningOrErrorMsg,  // Error message.
IGeoTiffKeysList const& geoTiffKeys,        // The GeoTiff key list
bool                    allowUnitsOverride   // Indicates if the presence of a unit can override GCS units.
)
    {
    if (NULL != warning)
        *warning = SUCCESS;

    // step through the GeoTiffKeys.
    StatusInt                           status = GEOCOORDERR_UnexpectedGeoTiffModelType;
    IGeoTiffKeysList::GeoKeyItem        geoKey;
    bool                                gotKey;
    int                                 iItem;

    // this will cause the type 66 to be saved with coordSysId set the same as projType.
    outGCS.m_coordSysId = 0;

    for (iItem=0, gotKey = geoTiffKeys.GetFirstKey (&geoKey); gotKey && iItem < 200; gotKey = geoTiffKeys.GetNextKey (&geoKey), iItem++)
        {
        switch (geoKey.KeyID)
            {
            case GTModelTypeGeoKey:
                if (IsFatalGeoTiffError (status = ProcessModelTypeKey (geoKey)))
                    return status;
                break;

            case GeographicTypeGeoKey:
                if (IsFatalGeoTiffError (status = ProcessGeographicTypeKey (geoKey)))
                    return status;
                break;

            case GeogCitationGeoKey:
                if (IsFatalGeoTiffError (status = ProcessGeographicCitationKey (geoKey)))
                    return status;
                break;

            case GeogGeodeticDatumGeoKey:
                if (IsFatalGeoTiffError (status = ProcessGeodeticDatumKey (geoKey)))
                    return status;
                break;

            case GeogPrimeMeridianGeoKey:
                if (IsFatalGeoTiffError (status = ProcessPrimeMeridianKey (geoKey)))
                    return status;
                break;

            case GeogLinearUnitsGeoKey:
                // I think the linear units keys for geographic coordinate systems affect only the user defined ellipse major and minor axes.
                if (IsFatalGeoTiffError (status = ProcessLinearUnitsKey (geoKey, false, true)))
                    return status;
                break;

            case GeogLinearUnitSizeGeoKey:
                // Even if GeogLinearUnitsGeoKey is not user-defined the Unit Size if specified (this should be an error)
                // will be applied
                if (IsFatalGeoTiffError (status = ProcessLinearUnitsSizeKey (geoKey, false, true)))
                    return status;
                break;

            case GeogAngularUnitsGeoKey:
                if (IsFatalGeoTiffError (status = ProcessAngularUnitsKey (geoKey, m_userDefinedGeoCS)))
                    return status;
                break;

            case GeogAngularUnitSizeGeoKey:
                if (IsFatalGeoTiffError (status = ProcessAngularUnitsSizeKey (geoKey, m_userDefinedGeoCS)))
                    return status;
                break;

            case GeogEllipsoidGeoKey:
                if (IsFatalGeoTiffError (status = ProcessEllipsoidKey (geoKey)))
                    return status;
                break;

            case GeogSemiMajorAxisGeoKey:
                if (IsFatalGeoTiffError (status = ProcessSemiMajorAxisKey (geoKey)))
                    return status;
                break;

            case GeogSemiMinorAxisGeoKey:
                if (IsFatalGeoTiffError (status = ProcessSemiMinorAxisKey (geoKey)))
                    return status;
                break;

            case GeogInvFlatteningGeoKey:
                if (IsFatalGeoTiffError (status = ProcessInvFlatteningKey (geoKey)))
                    return status;
                break;

            case GeogAzimuthUnitsGeoKey:
                if (IsFatalGeoTiffError (status = ProcessAzimuthUnitsKey (geoKey)))
                    return status;
                break;

            case GeogPrimeMeridianLongGeoKey:
                if (IsFatalGeoTiffError (status = ProcessPrimeMeridianLongitudeKey (geoKey)))
                    return status;
                break;

            case ProjectedCSTypeGeoKey:
            case ProjectedCSTypeGeoKeyLong:
                if (IsFatalGeoTiffError (status = ProcessProjectedCSTypeKey (geoKey)))
                    return status;
                break;

            case PCSCitationGeoKey:
                if (IsFatalGeoTiffError (status = ProcessPCSCitationKey (geoKey)))
                    return status;
                break;

            case ProjectionGeoKey:
                if (IsFatalGeoTiffError (status = ProcessProjectionKey (geoKey)))
                    return status;
                break;

            case ProjCoordTransGeoKey:
                if (IsFatalGeoTiffError (status = ProcessCoordTransKey (geoKey)))
                    return status;
                break;

            case ProjLinearUnitsGeoKey:

                if (IsFatalGeoTiffError (status = ProcessLinearUnitsKey (geoKey, true, allowUnitsOverride)))
                    return status;
                break;

            case ProjLinearUnitSizeGeoKey:
                // Even if GeogLinearUnitsGeoKey is not user-defined the Unit Size if specified (this should be an error)
                // will be applied
                if (IsFatalGeoTiffError (status = ProcessLinearUnitsSizeKey (geoKey, true, allowUnitsOverride)))
                    return status;
                break;

            case ProjStdParallel1GeoKey:
            case ProjStdParallel2GeoKey:
                if (IsFatalGeoTiffError (status = ProcessStandardParallelKey (geoKey, ProjStdParallel1GeoKey == geoKey.KeyID)))
                    return status;
                break;

            case ProjNatOriginLongGeoKey:
            case ProjNatOriginLatGeoKey:
                if (IsFatalGeoTiffError (status = ProcessOriginOrCenterLLKey (geoKey, ProjNatOriginLongGeoKey == geoKey.KeyID)))
                    return status;
                break;

            case ProjFalseEastingGeoKey:
            case ProjFalseNorthingGeoKey:
                if (IsFatalGeoTiffError (status = ProcessFalseENKey (geoKey, ProjFalseEastingGeoKey == geoKey.KeyID)))
                    return status;
                break;

            case ProjFalseOriginLongGeoKey:
            case ProjFalseOriginLatGeoKey:
                if (IsFatalGeoTiffError (status = ProcessOriginOrCenterLLKey (geoKey, ProjFalseOriginLongGeoKey == geoKey.KeyID)))
                    return status;
                break;

            case ProjFalseOriginEastingGeoKey:
            case ProjFalseOriginNorthingGeoKey:
                if (IsFatalGeoTiffError (status = ProcessFalseENKey (geoKey, ProjFalseOriginEastingGeoKey == geoKey.KeyID)))
                    return status;
                break;

            case ProjCenterLongGeoKey:
            case ProjCenterLatGeoKey:
                if (IsFatalGeoTiffError (status = ProcessOriginOrCenterLLKey (geoKey, ProjCenterLongGeoKey == geoKey.KeyID)))
                    return status;
                break;

            case ProjCenterEastingGeoKey:
            case ProjCenterNorthingGeoKey:
                if (IsFatalGeoTiffError (status = ProcessFalseENKey (geoKey, ProjCenterEastingGeoKey == geoKey.KeyID)))
                    return status;
                break;

            case ProjScaleAtNatOriginGeoKey:
                if (IsFatalGeoTiffError (status = ProcessScaleAtNatOriginKey (geoKey)))
                    return status;
                break;

            case ProjScaleAtCenterGeoKey:
                if (IsFatalGeoTiffError (status = ProcessScaleAtCenterKey (geoKey)))
                    return status;
                break;

            case ProjAzimuthAngleGeoKey:
                if (IsFatalGeoTiffError (status = ProcessAzimuthAngleKey (geoKey)))
                    return status;
                break;

            case ProjStraightVertPoleLongGeoKey:
                if (IsFatalGeoTiffError (status = ProcessStraightVertPoleLongKey (geoKey)))
                    return status;
                break;

            // I don't know what to do with these.
            case VerticalCSTypeGeoKey:
                if (IsFatalGeoTiffError (status = ProcessVerticalCSTypeKey (geoKey)))
                    return status;
                break;

            // The three following are simply ignored.
            case VerticalCitationGeoKey: // This is informative only
            case VerticalDatumGeoKey:    // missdefinition of standard ... may conflict with VerticalCSType
            case VerticalUnitsGeoKey:    // BaseGCS cannot have vertical units different than horizontal units (meters imposed for lat/long)
                break;
            }
        }

    // here we have gone through all of the keys, without error. We have to construct the coordinate system from
    // m_csDef, m_datumDef, and m_ellipsoidDef.
    if (!m_userDefinedGeoCS && !m_userDefinedProjectedCS)
        {
        if (!m_haveCS)
            return GEOCOORDERR_CoordSysSpecificationIncomplete;

        if (NULL == (outGCS.m_csParameters = CSMap::CScsloc1 (&m_csDef)))
            return cs_Error;
        }
    else
        {
        if (!m_haveEllipsoid)
            {
            if (!m_haveDatum)
                return GEOCOORDERR_CoordSysSpecificationIncomplete;

            // fill in the ellipsoid from the keyname in the datum definition.
            CSEllipsoidDef* ellipsoidDef;
            if (NULL == (ellipsoidDef = CSMap::CS_eldef (m_csDatumDef.ell_knm)))
                return cs_Error;

            m_csEllipsoidDef = *ellipsoidDef;
            m_haveEllipsoid  = true;
            CSMap::CS_free (ellipsoidDef);
            }

        //In the case of a projection model, now that the ellipsoid and datum
        //have been found, check that a projection has been at least specified
        if ( (m_userDefinedProjectedCS == true) && (0 == m_coordSys) )
            return GEOCOORDERR_CoordSysSpecificationIncomplete;

        // try to get the csParameters
        // It seems to me that CSCsloc2 could copy the datum and ellipse names from m_csDatumDef and m_csEllipsoidDef to m_csDef, but for some reason, it doesn't,
        //   and the CS_cschk function fails when they're not in there.
        if (m_haveDatum)
            CS_stncp (m_csDef.dat_knm, m_csDatumDef.key_nm, sizeof(m_csDef.dat_knm));
        CS_stncp (m_csDef.elp_knm, m_csEllipsoidDef.key_nm, sizeof(m_csDef.elp_knm));

        if (NULL == (outGCS.m_csParameters = CSMap::CScsloc2 (&m_csDef, &m_csDatumDef, &m_csEllipsoidDef)))
            return cs_Error;
        }

    // Now we set the vertical datum regardless GCS is user-defined or not.
    outGCS.SetVerticalDatumCode(m_verticalDatum);

    return SUCCESS;
    }

private:
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool                IsFatalGeoTiffError (StatusInt  status)
    {
    if (status == SUCCESS)
        return false;

    // Don't consider unnecessary parameter or redundant parameter an error.
    if ( (status == GEOCOORDERR_CoordParamNotNeededForTrans) || (status == GEOCOORDERR_CoordParamRedundant))
        {
        // catch during debugging
        BeAssert (true);
        return false;
        }

    return true;
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessModelTypeKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    m_modelType = (GeoKeyModelType) geoKey.KeyValue.LongVal;

    switch (m_modelType)
        {
        case ModelTypeProjected:
        case ModelTypeGeographic:
            break;

        // we don't support
        case ModelTypeGeocentric:
            BeAssert (false);
            return GEOCOORDERR_GeocentricNotSupported;

        default:
            BeAssert (false);
            return GEOCOORDERR_UnexpectedGeoTiffModelType;
        }
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessGeographicTypeKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    int     geoCode = geoKey.KeyValue.LongVal;
    BeAssert ( ((geoCode >= 4000) && (geoCode < 5000)) ||
             ((geoCode >= UserDefinedKeyValue) && (geoCode <= USHRT_MAX)) );

    // NOTE: The GeographicTypeGeoKey gives us a Datum or Ellipsoid, and a prime meridian.
    //       That's what you need for a LL coordinate system in CS_Map.
    char    coordSysName[128];
    if (geoCode < 5000)
        {
        enum EcsMapSt csMapSt;
        coordSysName[0] = '\0';

        csMapSt = csMapIdToNameC (csMapGeographicCSysKeyName,
                                  coordSysName,
                                  sizeof (coordSysName),
                                  csMapFlvrCsMap,
                                  csMapFlvrEpsg,
                                  static_cast<uint32_t>(geoCode));
        if (csMapSt != csMapOk)
            {
            // try a name based on the EPSG number
            snprintf (coordSysName, sizeof(coordSysName), "EPSG:%d", geoCode);
            }
        }
    else if ((UserDefinedKeyValue <= geoCode) && (USHRT_MAX >= geoCode))
        {
        // set up for user defined Geographic Coordinate System.
        // initialize for LatLong by looking up the "L" coordinate system.
        strncpy (coordSysName, "LL", _countof(coordSysName));
        m_userDefinedGeoCS = true;

        //Don't use a default Geographic coordinate system
        return SUCCESS;
        }

    CSDefinition* csDef;
    if (NULL == (csDef = CSMap::CS_csdef (coordSysName)))
        return cs_Error;
    //If the model type is projected, GeographicTypeGeoKey should be used only
    //to get the datum.
    if (m_modelType == ModelTypeProjected)
        {
        CSDatumDef* datumDef;
        if (NULL == (datumDef = CSMap::CS_dtdef (csDef->dat_knm)))
            {
            //Try with the ellipsoid name
            if (csDef->elp_knm[0] != 0)
                {
                CSEllipsoidDef* ellipsoidDef;
                if (NULL == (ellipsoidDef = CSMap::CS_eldef (csDef->elp_knm)))
                    return cs_Error;
                else
                    {
                    // copy and free the ellipsoid.
                    m_csEllipsoidDef = *ellipsoidDef;
                    m_haveEllipsoid  = true;

                    CSMap::CS_free (ellipsoidDef);
                    }
                }
            else
                {
                return cs_Error;
                }
            }
        else
            {
            // copy and free the datum.
            m_csDatumDef    = *datumDef;
            m_haveDatum     = true;
            CSMap::CS_free (datumDef);
            }
        }
    else
        {
        m_csDef     = *csDef;
        m_haveCS    = true;
        }

    CSMap::CS_free (csDef);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessGeographicCitationKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::ASCII == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    // if it's not a user defined ellipsoid, we have no use for the citation, since we're looking up the coordinate system.
    if (m_userDefinedGeoCS)
        {
        CS_stncp (m_csEllipsoidDef.source, geoKey.KeyValue.StringVal, sizeof(m_csEllipsoidDef.source));
        char MagicString[] = "IMAGINE GeoTIFF Support";

        if (strncmp(MagicString, geoKey.KeyValue.StringVal, strlen(MagicString)) == 0)
            {
            char        seps[]   = "\t\n\r";
            char*       citationCopy = new char[strlen(geoKey.KeyValue.StringVal) + 1];

            strncpy(citationCopy, geoKey.KeyValue.StringVal, strlen(geoKey.KeyValue.StringVal));
            citationCopy[strlen(geoKey.KeyValue.StringVal)] = '\0';

            char* line = strtok(citationCopy, seps);

            while (line != NULL)
                {
                // While there are tokens in "string"
                if (strstr(line, "Ellipsoid") != NULL)
                    {
                    char* value = strchr(line, '=');

                    if (value != NULL)
                        {
                        CSEllipsoidDef* ellipsoidDef;

                        //Names in the ellipsoid table have no white space.
                        stripWhite(++value);

                        if (NULL != (ellipsoidDef = CSMap::CS_eldef (value)))
                            {
                            // copy and free the datum.
                            m_csEllipsoidDef    = *ellipsoidDef;
                            m_haveEllipsoid     = true;
                            CSMap::CS_free (ellipsoidDef);
                            }
                        }
                    }
                else
                if (strstr(line, "Datum") != NULL)
                    {
                    char* value = strchr(line, '=');

                    if (value != NULL)
                        {
                        CSDatumDef* datumDef;
                        char        datumName[50];

                        //Trim any leading and trailing white space.
                        CS_trim(++value);

                        if (NULL == (datumDef = CSMap::CS_dtdef (value)))
                            {
#if defined (GEOCOORD_ENHANCEMENT)
                            if (CS_wktDatumLookUp(value, datumName))
                                {
                                datumDef = CSMap::CS_dtdef (datumName);
                                }
#endif
                            }

                        if (datumDef != NULL)
                            {
                            // copy and free the datum.
                            m_csDatumDef    = *datumDef;
                            m_haveDatum     = true;
                            CSMap::CS_free (datumDef);
                            }
                        }
                    }
                    // Get next token:
                    line = strtok(NULL, seps);
                }

            delete[] citationCopy;

            }
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessGeodeticDatumKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    int     geoCode = geoKey.KeyValue.LongVal;
    BeAssert ( ((geoCode >= 6000) && (geoCode < 7000)) || (geoCode == UserDefinedKeyValue) );

    // NOTE: Since the GeodeticDatumKey gives us only a Datum or Ellipsoid rather than a full coordinate
    //       system, that's all we can look up. There might be a prime meridian geoKey later?
    if (geoCode < 6100)
        {
        char        ellipsoidName[128];


        enum EcsMapSt csMapSt;
        ellipsoidName[0] = '\0';

        // We first try the csmap flavor
        csMapSt = csMapIdToNameC (csMapEllipsoidKeyName,
                                  ellipsoidName,
                                  sizeof (ellipsoidName),
                                  csMapFlvrCsMap,
                                  csMapFlvrEpsg,
                                  static_cast<uint32_t>(geoCode + 1000));
        if (csMapSt != csMapOk)
            {
            // Since it failed we try the Autodesk flavor as a lot of IDs were added from this source
            csMapSt = csMapIdToNameC (csMapEllipsoidKeyName,
                                      ellipsoidName,
                                      sizeof (ellipsoidName),
                                      csMapFlvrAutodesk,
                                      csMapFlvrEpsg,
                                      static_cast<uint32_t>(geoCode + 1000));
            }
        if (csMapSt != csMapOk)

            {
            // try a name base on the EPSG number
            snprintf (ellipsoidName, sizeof(ellipsoidName), "EPSG:%d", geoCode+1000);
            }

        CSEllipsoidDef* ellipsoidDef;
        if (NULL == (ellipsoidDef = CSMap::CS_eldef (ellipsoidName)))
            return cs_Error;

        m_csEllipsoidDef = *ellipsoidDef;
        m_haveEllipsoid  = true;
        CSMap::CS_free (ellipsoidDef);
        }
    if (geoCode < 7000)
        {
        char        datumName[128];

        enum EcsMapSt csMapSt;
        datumName[0] = '\0';

        // We first try the csmap flavor
        csMapSt = csMapIdToNameC (csMapDatumKeyName,
                                  datumName,
                                  sizeof (datumName),
                                  csMapFlvrCsMap,
                                  csMapFlvrEpsg,
                                  static_cast<uint32_t>(geoCode));
        if (csMapSt != csMapOk)
            {
            // Since it failed we try the Autodesk flavor as a lot of IDs were added from this source
            csMapSt = csMapIdToNameC (csMapDatumKeyName,
                                      datumName,
                                      sizeof (datumName),
                                      csMapFlvrAutodesk,
                                      csMapFlvrEpsg,
                                      static_cast<uint32_t>(geoCode));
            }

        if (csMapSt != csMapOk)
            {
            // try a name based on the EPSG number
            snprintf (datumName, sizeof(datumName), "EPSG:%d", geoCode);
            }

        CSDatumDef* datumDef;
        if (NULL == (datumDef = CSMap::CS_dtdef (datumName)))
            return cs_Error;

        // copy and free the datum.
        m_csDatumDef    = *datumDef;
        m_haveDatum     = true;
        CSMap::CS_free (datumDef);
        }
    else if (UserDefinedKeyValue == geoCode)
        {
        // set up for user defined Geographic Coordinate System
        m_userDefinedGeoCS = true;
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessPrimeMeridianKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    int     geoCode = geoKey.KeyValue.LongVal;
    BeAssert ( ((geoCode >= 8900) && (geoCode < 9000)) || (geoCode != UserDefinedKeyValue) );

    switch (geoCode)
        {
        case PM_Greenwich:
            m_csDef.org_lng = 0.0;
            break;
        case PM_Lisbon:
            m_csDef.org_lng = -9.0754862;
            break;
        case PM_Paris:
            m_csDef.org_lng = 2.337229167;
            break;
        case PM_Bogota:
            m_csDef.org_lng = -74.04513;
            break;
        case PM_Madrid:
            m_csDef.org_lng = -3.411658;
            break;
        case PM_Rome:
            m_csDef.org_lng = 12.27084;
            break;
        case PM_Bern:
            m_csDef.org_lng = 7.26225;
            break;
        case PM_Jakarta:
            m_csDef.org_lng = 106.482779;
            break;
        case PM_Ferro:
            m_csDef.org_lng = -17.4;
            break;
        case PM_Brussels:
            m_csDef.org_lng = 4.220471;
            break;
        case PM_Stockholm:
            m_csDef.org_lng = 18.03298;
            break;
        case PM_Athens:
            m_csDef.org_lng = 23.4258815;
            break;
        case PM_Oslo:
            m_csDef.org_lng = 10.43225;
            break;
        case UserDefinedKeyValue:
            // we'll expect a PrimeMeridianLongGeoKey then.
            break;
        default:
            return GEOCOORDERR_UnexpectedGeoTiffPrimeMeridian;
        }
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessPrimeMeridianLongitudeKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    double geoValue = geoKey.KeyValue.DoubleVal * m_angularUnitsToDegrees;
    m_csDef.org_lng = geoValue;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessEllipsoidKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    int     geoCode = geoKey.KeyValue.LongVal;
    BeAssert ( ((geoCode >= 7000) && (geoCode < 8000)) || (geoCode == UserDefinedKeyValue) );


    if (geoCode != UserDefinedKeyValue)
        {
        // look up the ellipsoid. Name will be "EPSG:%d".
        char    ellipsoidName[64];
        snprintf (ellipsoidName, sizeof(ellipsoidName), "EPSG:%d", geoCode);

        CSEllipsoidDef* ellipsoidDef;
        if (NULL == (ellipsoidDef = CSMap::CS_eldef (ellipsoidName)))
            return cs_Error;

        // copy and free the ellipsoid
        m_csEllipsoidDef = *ellipsoidDef;
        m_haveEllipsoid  = true;
        CSMap::CS_free (ellipsoidDef);
        }
    else
        {
        // set up for user defined Geographic Coordinate System
        m_userDefinedGeoCS = true;
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessLinearUnitsKey (IGeoTiffKeysList::GeoKeyItem& geoKey, bool projectedCS, bool allowUnitsOverride)
    {
    // Even though the allowUnitsOverride is false and the GCS user defined we will store the linear unit definiton
    // for the interpretation of the ellipsoid dimension yet we will not change the current CS definition unless it is
    // not a predefined GCS. (user defined GCS will have units applied)

    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    int     geoCode = geoKey.KeyValue.LongVal;
    BeAssert ( ((geoCode >= 9000) && (geoCode < 9100)) || (geoCode != UserDefinedKeyValue) );

    const struct cs_Unittab_  *pUnit;
    for (pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if ( (pUnit->type == cs_UTYP_LEN) && (geoCode == pUnit->epsgCode) )
            {
            // put the unit info into csDef. Probably all we need is the name.
            // In order to apply to the cs definition we expect the cs to be user defined
            // or that the unit override be allowed otherwise we use the units
            // directly related to the definition of the ProjectCSType key (EPSG code)
            if (projectedCS && (allowUnitsOverride || !m_haveCS || m_userDefinedProjectedCS))
                {
                // if the units are the same we just bypass
                if (CS_stricmp(pUnit->name, m_csDef.unit) == 0)
                    return SUCCESS;

                // convert the offsets to the new unit.
                double oldToNewUnitConvFactor = m_csDef.unit_scl / pUnit->factor;
                m_csDef.unit_scl = pUnit->factor;
                m_csDef.x_off *= oldToNewUnitConvFactor;
                m_csDef.y_off *= oldToNewUnitConvFactor;
                CS_stncp (m_csDef.unit, pUnit->name, sizeof(m_csDef.unit));

                // If the GCS is keyname based or has a keyname set ...
                if (strlen(m_csDef.key_nm) > 0)
                    {
                    // Change the keyname and description since the dictionary entry and changed GCS do not fit
                    // Remove keyname
                    CS_stncp (m_csDef.key_nm, "", DIM(m_csDef.key_nm));

                    // Append unit name at the end of description (which unfortunately often contain the unit name)
                    char  proposedDescription[1024];
                    snprintf (proposedDescription, sizeof(proposedDescription), "%s - %s", m_csDef.desc_nm, pUnit->name);

                    // make sure the description is not too long.
                    proposedDescription[63] = 0;
                    CS_stncp(m_csDef.desc_nm, proposedDescription, DIM(m_csDef.desc_nm));
                    }
                }
            m_linearUnitsToMeters = pUnit->factor;
            return SUCCESS;
            }
        }
    return GEOCOORDERR_UnrecognizedLinearUnit;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessLinearUnitsSizeKey (IGeoTiffKeysList::GeoKeyItem& geoKey, bool projectedCS, bool allowUnitsOverride)
    {
    // Even though the allowUnitsOverride is false and the GCS user defined we will store the linear unit definiton
    // for the interpretation of the ellipsoid dimension yet we will not change the current CS definition unless it is
    // not a predefined GCS. (user defined GCS will have units applied)

    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    double geoValue = geoKey.KeyValue.DoubleVal;
    m_csDef.unit_scl = geoValue;

    const struct cs_Unittab_  *pUnit;
    for (pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if ( (pUnit->type == cs_UTYP_LEN) && doubleSame (pUnit->factor, geoValue) )
            {
            // In order to apply to the cs definition we expect the cs to be user defined
            // or that the unit override be allowed otherwise we use the units
            // directly related to the definition of the ProjectCSType key (EPSG code)
            if (projectedCS && (allowUnitsOverride || !m_haveCS || m_userDefinedProjectedCS))
                {
                // convert the offsets to the new unit.
                double oldToNewUnitConvFactor = m_csDef.unit_scl / geoValue;
                m_csDef.unit_scl = geoValue;
                m_csDef.x_off *= oldToNewUnitConvFactor;
                m_csDef.y_off *= oldToNewUnitConvFactor;

                // put the unit info into csDef. Probably all we need is the name.
                CS_stncp (m_csDef.unit, pUnit->name, sizeof(m_csDef.unit));
                }
            m_linearUnitsToMeters = geoValue;
            return SUCCESS;
            }
        }

    return GEOCOORDERR_UnrecognizedLinearUnit;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessAngularUnitsKey (IGeoTiffKeysList::GeoKeyItem& geoKey, bool isGeographicCS)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    int     geoCode = geoKey.KeyValue.LongVal;
    BeAssert ( ((geoCode >= 9100) && (geoCode < 9200)) || (geoCode != UserDefinedKeyValue) );

    const struct cs_Unittab_  *pUnit;
    for (pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if ( (pUnit->type == cs_UTYP_ANG) && (geoCode == pUnit->epsgCode) )
            {
            m_angularUnitsToDegrees = pUnit->factor;

            // If it's a Geographic (Lat/Long) CS, put the unit name into the coordinate system unit name.
            if (isGeographicCS)
                CS_stncp (m_csDef.unit, pUnit->name, sizeof(m_csDef.unit));
            return SUCCESS;
            }
        }
    return GEOCOORDERR_UnrecognizedAngularUnit;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessAngularUnitsSizeKey (IGeoTiffKeysList::GeoKeyItem& geoKey, bool isGeographicCS)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    double geoValue = geoKey.KeyValue.DoubleVal;
    const struct cs_Unittab_  *pUnit;

    // according to the GeoTiff documentation, this is in radians, but CSMap works in degrees, so convert it.
    geoValue = BaseGCS::DegreesFromRadians (geoValue);

    for (pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if ( (pUnit->type == cs_UTYP_ANG) && doubleSame (geoValue, pUnit->factor) )
            {
            m_angularUnitsToDegrees = geoValue;
            if (isGeographicCS)
                {
                // If it's a Geographic (Lat/Long) CS, put the unit name into the coordinate system unit name.
                if (isGeographicCS)
                    CS_stncp (m_csDef.unit, pUnit->name, sizeof(m_csDef.unit));
                }
            return SUCCESS;
            }
        }
    return GEOCOORDERR_UnrecognizedAngularUnit;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessSemiMajorAxisKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    double geoValue = geoKey.KeyValue.DoubleVal * m_linearUnitsToMeters;

    // put value into the ellipse definition.
    m_csEllipsoidDef.e_rad = geoValue;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessSemiMinorAxisKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    double geoValue = geoKey.KeyValue.DoubleVal * m_linearUnitsToMeters;
    // put value into the ellipse definition.
    m_csEllipsoidDef.p_rad = geoValue;

    if (Ellipsoid::CalculateParameters (m_csEllipsoidDef.flat, m_csEllipsoidDef.ecent, m_csEllipsoidDef.e_rad, m_csEllipsoidDef.p_rad))
        m_haveEllipsoid = true;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessInvFlatteningKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    double geoValue = geoKey.KeyValue.DoubleVal;
    m_csEllipsoidDef.flat = 1.0 / geoValue;
    if (0 != m_csEllipsoidDef.e_rad)
        {
        m_csEllipsoidDef.p_rad  = m_csEllipsoidDef.e_rad * (1.0 - m_csEllipsoidDef.flat);
        Ellipsoid::CalculateParameters (m_csEllipsoidDef.flat, m_csEllipsoidDef.ecent, m_csEllipsoidDef.e_rad, m_csEllipsoidDef.p_rad);
        return SUCCESS;
        }
    else if (0 != m_csEllipsoidDef.p_rad)
        {
        m_csEllipsoidDef.e_rad  = m_csEllipsoidDef.p_rad / (1.0 - m_csEllipsoidDef.flat);
        if (Ellipsoid::CalculateParameters (m_csEllipsoidDef.flat, m_csEllipsoidDef.ecent, m_csEllipsoidDef.e_rad, m_csEllipsoidDef.p_rad))
            m_haveEllipsoid         = true;
        return SUCCESS;
        }
    else
        return GEOCOORDERR_BadEllipsoidDefinition;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessAzimuthUnitsKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    BeAssert ( (ModelTypeProjected == m_modelType) || (ModelTypeGeographic == m_modelType) );

    int     geoCode = geoKey.KeyValue.LongVal;
    BeAssert ( ((geoCode >= 9100) && (geoCode < 9200)) || (geoCode != UserDefinedKeyValue) );

    const struct cs_Unittab_  *pUnit;
    for (pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if ( (pUnit->type == cs_UTYP_ANG) && (geoCode == pUnit->epsgCode) )
            {
            m_azimuthUnitsToDegrees = pUnit->factor;
            return SUCCESS;
            }
        }
    return GEOCOORDERR_UnrecognizedAngularUnit;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessProjectedCSTypeKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    int     geoCode = geoKey.KeyValue.LongVal;


    // Code 0 is a GeoTIFF code for undefined yet the CSMAP lookup process uses code 0 for deprecated entries
    // using code 0 will simply return the first EPSG deprecated entry (which is usually PulkovoGK/CM-15E)
    // which is meaningless.
    if (UnDefinedKeyValue == geoCode)
        return SUCCESS;

    // If the code is between 1 and 32767 it may represent a predefined entry in the EPSG code.
    // Value 32767 is reserved for user defined GCS (not part of the EPSG database but defined specifically using
    // the other geokeys). Value 32768 and up represent proprietary values in which case it does not represent
    // a valid EPSG entry but the set of GeoKeys may be invalid or unusual.
    // Raster Manager uses value 32768 to define a georeference (transformation matrix) for the raster
    // but without any GCS definition.
    if (UserDefinedKeyValue > geoCode)
        {
        char    coordSysName[128];

        enum EcsMapSt csMapSt;
        coordSysName[0] = '\0';

        // Attention! The use of csMapProjGeoCSys instead of csMapGeographicCSysKeyName is intentional here
        // as we use this function to process geographic lat/long coordinate systems sometimes during GeoTIFF key generation
        // even if not stored in the ProjectedCSKey. Notice that it is historically likely users create
        // GeoTIFF files with a lat/long GCS identifier in the ProjectedGeoKey
        csMapSt = csMapIdToNameC (csMapProjGeoCSys,
                                  coordSysName,
                                  sizeof (coordSysName),
                                  csMapFlvrCsMap,
                                  csMapFlvrEpsg,
                                  static_cast<uint32_t>(geoCode));
        if (csMapSt != csMapOk)

            {
            // try a name based on the EPSG number
            snprintf (coordSysName, sizeof(coordSysName), "EPSG:%d", geoCode);
            }

        CSDefinition* csDef;
        if (NULL == (csDef = CSMap::CS_csdef (coordSysName)))
            {
            // we didn't find an EPSG Number the easy way, have to search for an entry that has epsgNbr field set to desired value.
            int         index;
            char        csKeyName[128];
            for (index = 0; (0 < CSMap::CS_csEnum (index, csKeyName, sizeof(csKeyName))); index++)
                {
                if (NULL != (csDef = CSMap::CS_csdef (csKeyName)))
                    {
                    if (geoCode == csDef->epsgNbr)
                        break; // We have it

                    CSMap::CS_free (csDef);
                    csDef = NULL;
                    }
                }

            // If we did not find then return immediately
            if (NULL == csDef)
                return cs_Error;
            }

        // copy and free
        m_csDef     = *csDef;
        m_haveCS    = true;
        CSMap::CS_free (csDef);
        }
    else
        {
        // set up for user defined Geographic Coordinate System.
        m_userDefinedProjectedCS = true;
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessPCSCitationKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::ASCII == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    static ProjTransInCitation projTransInCitation[] = {
        //From GCoord
        {COORDSYS_EKRT4, CS_EKRT4, "ECKERT IV"}                      ,
        {COORDSYS_BONNE, CS_BONNE, "BONNE"}                          ,
        {0, "", ""}
    };

    // if it's not a user defined projection, we have no use for the citation, since we're looking up the coordinate system.
    if (m_userDefinedProjectedCS)
        {
        CS_stncp (m_csDef.source, geoKey.KeyValue.StringVal, sizeof(m_csDef.source));

        bool isFound = FALSE;
        int  methIter = 0;

        while (!isFound && projTransInCitation[methIter].m_csCoordSys > 0)
            {
            if ((strlen (projTransInCitation[methIter].m_nameInCitation) < strlen(m_csDef.source)) &&
                0 == BeStringUtilities::Strnicmp (m_csDef.source, projTransInCitation[methIter].m_nameInCitation, strlen (projTransInCitation[methIter].m_nameInCitation)))
                {
                m_coordSys = projTransInCitation[methIter].m_csCoordSys;
                CS_stncp (m_csDef.prj_knm, projTransInCitation[methIter].m_csName, sizeof(m_csDef.prj_knm));
                return SUCCESS;
                }
            methIter++;
            }
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessProjectionKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);

    int geoValue      = geoKey.KeyValue.LongVal;

    // Imagepp was setting this dummy value (16001) in the past when ProjectionCS is User Defined.
    // It now set UserDefinedKeyValue.
    // In both cases, we want to accept these as valid since ArcGIS seems to required these values.
    if ((geoValue == UserDefinedKeyValue) || (geoValue == 16001))
        return SUCCESS;

    return GEOCOORDERR_CoordParamNotNeededForTrans;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessCoordTransKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    int         geoCode      = geoKey.KeyValue.LongVal;
    const char *csProjection = NULL;

    // look for CS_Map projection
    switch (geoCode)
        {
        case CT_TransverseMercator:
            csProjection = CS_TRMER;
            m_coordSys   = COORDSYS_TRMER;
            break;

        case CT_TransvMercator_Modified_Alaska:
            // we don't support this one.
            break;

        case CT_ObliqueMercator:
            csProjection = CS_OBLQ1;
            m_coordSys   = COORDSYS_OBLQ1;
            break;

        case CT_ObliqueMercator_Laborde:
            // we don't support this one.
            break;

        case CT_ObliqueMercator_Rosenmund:
            csProjection = CS_SWISS;
            m_coordSys   = COORDSYS_SWISS;
            break;

        case CT_ObliqueMercator_Spherical:
            // we don't support this one.
            break;

        case CT_Mercator: // It could be either Mercator with standard parallel or Mercator with scale reduction depending on the keys offered
            csProjection = CS_MRCSR;
            m_coordSys   = COORDSYS_MRCSR;
            break;

        case CT_LambertConfConic_2SP:
            csProjection = CS_LMBRT;
            m_coordSys   = COORDSYS_LMBRT;
            break;

        case CT_LambertConfConic_Helmert:
            csProjection = CS_LM1SP;
            m_coordSys   = COORDSYS_LM1SP;
            break;

        case CT_LambertAzimEqualArea:
            csProjection = CS_AZMEA;
            m_coordSys   = COORDSYS_AZMEA;
            break;

        case CT_AlbersEqualArea:
            csProjection = CS_ALBER;
            m_coordSys   = COORDSYS_ALBER;
            break;

        case CT_AzimuthalEquidistant:
            csProjection = CS_AZMED;
            m_coordSys   = COORDSYS_AZMED;
            break;

        case CT_EquidistantConic:
            csProjection = CS_EDCNC;
            m_coordSys   = COORDSYS_EDCNC;
            break;

        case CT_Stereographic:
            csProjection = CS_STERO;
            m_coordSys   = COORDSYS_STERO;
            break;

        case CT_PolarStereographic:
            csProjection = CS_PSTRO;
            m_coordSys   = COORDSYS_PSTRO;
            break;

        case CT_ObliqueStereographic:
            csProjection = CS_OSTRO;
            m_coordSys   = COORDSYS_OSTRO;
            break;

        case CT_Equirectangular:
            csProjection = CS_EDCYL;
            m_coordSys   = COORDSYS_EDCYL;
            break;

        case CT_CassiniSoldner:
            csProjection = CS_CSINI;
            m_coordSys   = COORDSYS_CSINI;
            break;

        case CT_Gnomonic:
            csProjection = CS_GNOMC;
            m_coordSys   = COORDSYS_GNOMC;
            break;

        case CT_MillerCylindrical:
            csProjection = CS_MILLR;
            m_coordSys   = COORDSYS_MILLR;
            break;

        case CT_Orthographic:
            csProjection = CS_ORTHO;
            m_coordSys   = COORDSYS_ORTHO;
            break;

        case CT_Polyconic:
            csProjection = CS_PLYCN;
            m_coordSys   = COORDSYS_PLYCN;
            break;

        case CT_Robinson:
            csProjection = CS_ROBIN;
            m_coordSys   = COORDSYS_ROBIN;
            break;

        case CT_Sinusoidal:
            csProjection = CS_SINUS;
            m_coordSys   = COORDSYS_SINUS;
            break;

        case CT_VanDerGrinten:
            csProjection = CS_VDGRN;
            m_coordSys   = COORDSYS_VDGRN;
            break;

        case CT_NewZealandMapGrid:
            csProjection = CS_NZLND;
            m_coordSys   = COORDSYS_NZLND;
            break;

        case CT_TransvMercator_SouthOriented:
            csProjection = CS_SOTRM;
            m_coordSys   = COORDSYS_SOTRM;
            break;

        //The coordinate transformation might have been found in the PCSCitationGeoKey's string.
        case UserDefinedKeyValue:
            return SUCCESS;
        }

    if (NULL != csProjection)
        {
        CS_stncp (m_csDef.prj_knm, csProjection, sizeof(m_csDef.prj_knm));
        return SUCCESS;
        }

    return GEOCOORDERR_CoordTransNotSupported;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessStandardParallelKey (IGeoTiffKeysList::GeoKeyItem& geoKey, bool isFirst)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    double geoValue = geoKey.KeyValue.DoubleVal * m_angularUnitsToDegrees;

    switch (m_coordSys)
        {
        case COORDSYS_LMBRT:
        case COORDSYS_ALBER:
        case COORDSYS_EDCNC:
            if (isFirst)
                m_csDef.prj_prm1 = geoValue;
            else
                m_csDef.prj_prm2 = geoValue;
            return SUCCESS;

        case COORDSYS_EDCYL:
            // need only one standard parallel
            if (isFirst)
                {
                m_csDef.prj_prm1 = geoValue;
                return SUCCESS;
                }
            break;
        case COORDSYS_MRCAT:
            if (isFirst)
                {
                m_csDef.prj_prm2 = geoValue;
                return SUCCESS;
                }
            break;
        case COORDSYS_MRCSR:
            if (isFirst)
                {
                // If we get there it is because we have a standard parallel specified which changes the nature
                // of the mercator projection to Mercator with Standard parallel ... we change the method type
                m_coordSys   = COORDSYS_MRCAT;
                CS_stncp (m_csDef.prj_knm, CS_MRCAT, sizeof(m_csDef.prj_knm));
                m_csDef.prj_prm2 = geoValue;
                return SUCCESS;
                }
            break;

        case COORDSYS_TRMER:
        case COORDSYS_OBLQ1:
        case COORDSYS_LM1SP:
        case COORDSYS_AZMEA:
        case COORDSYS_AZMED:
        case COORDSYS_STERO:
        case COORDSYS_OSTRO:
        case COORDSYS_PSTRO:
        case COORDSYS_CSINI:
        case COORDSYS_GNOMC:
        case COORDSYS_MILLR:
        case COORDSYS_ORTHO:
        case COORDSYS_PLYCN:
        case COORDSYS_ROBIN:
        case COORDSYS_SINUS:
        case COORDSYS_VDGRN:
        case COORDSYS_NZLND:
        case COORDSYS_SOTRM:
            break;
        }
    return GEOCOORDERR_CoordParamNotNeededForTrans;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessOriginOrCenterLLKey (IGeoTiffKeysList::GeoKeyItem& geoKey, bool isLongitude)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    // if a previous key specifed the origin longitude or latitude, simply ignore a repeated attempt to set it.
    if (isLongitude && m_haveUserOriginLongitude)
        return GEOCOORDERR_CoordParamRedundant;
    else if (!isLongitude && m_haveUserOriginLatitude)
        return GEOCOORDERR_CoordParamRedundant;

    double geoValue = geoKey.KeyValue.DoubleVal * m_angularUnitsToDegrees;

    switch (m_coordSys)
        {
        case COORDSYS_ALBER:
        case COORDSYS_AZMEA:
        case COORDSYS_AZMED:
        case COORDSYS_CSINI:
        case COORDSYS_EDCNC:
        case COORDSYS_EDCYL:
        case COORDSYS_GNOMC:
        case COORDSYS_LM1SP:
        case COORDSYS_LMBRT:
        case COORDSYS_NZLND:
        case COORDSYS_ORTHO:
        case COORDSYS_STERO:
        case COORDSYS_OSTRO:
        case COORDSYS_PSTRO:
        case COORDSYS_SWISS:
        //Found in the PCSCitationGeoKey
        case COORDSYS_BONNE:
            if (isLongitude)
                {
                m_haveUserOriginLongitude = true;
                m_csDef.org_lng = geoValue;
                }
            else
                {
                m_haveUserOriginLatitude = true;
                m_csDef.org_lat = geoValue;
                }
            return SUCCESS;

        case COORDSYS_TRMER:
        case COORDSYS_SOTRM:
        case COORDSYS_MILLR:

            if (isLongitude)
                {
                m_haveUserOriginLongitude = true;
                m_csDef.prj_prm1 = geoValue;
                }
             else
                {
                m_haveUserOriginLatitude = true;
                m_csDef.org_lat = geoValue;
                }
            return SUCCESS;
        case COORDSYS_MRCSR:
            if (isLongitude)
                {

                m_haveUserOriginLongitude = true;
                m_csDef.prj_prm1 = geoValue;
                }
            else
                {    // If we get there it is because we have a standard parallel specified which changes the nature
                     // of the mercator projection to Mercator with Standard parallel ... we change the method type
                m_coordSys   = COORDSYS_MRCAT;
                CS_stncp (m_csDef.prj_knm, CS_MRCAT, sizeof(m_csDef.prj_knm));
                m_haveUserOriginLatitude = true;
                m_csDef.prj_prm2 = geoValue;
                }
            return SUCCESS;

        case COORDSYS_OBLQ1:
        case COORDSYS_MRCAT:
            if (isLongitude)
                {
                m_haveUserOriginLongitude = true;
                m_csDef.prj_prm1 = geoValue;
                }
            else
                {
                m_haveUserOriginLatitude = true;
                m_csDef.prj_prm2 = geoValue;
                }
            return SUCCESS;

        case COORDSYS_PLYCN:
            if (isLongitude)
                {
                m_haveUserOriginLongitude = true;
                m_csDef.prj_prm1 = geoValue;
                }
            else
                {
                m_haveUserOriginLatitude = true;
                m_csDef.org_lat  = geoValue;
                }
            return SUCCESS;

        // these take only org_lng, not org_lat.
        case COORDSYS_ROBIN:
        case COORDSYS_SINUS:
        case COORDSYS_VDGRN:
        //Found in the PCSCitationGeoKey
        case COORDSYS_EKRT4:
            if (isLongitude)
                {
                m_haveUserOriginLongitude = true;
                m_csDef.org_lng  = geoValue;
                }
            return SUCCESS;
        }

    return GEOCOORDERR_CoordParamNotNeededForTrans;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessFalseENKey (IGeoTiffKeysList::GeoKeyItem& geoKey, bool isEasting)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    if (isEasting && m_haveFalseEasting)
        return GEOCOORDERR_CoordParamRedundant;
    else if (!isEasting && m_haveFalseNorthing)
        return GEOCOORDERR_CoordParamRedundant;

    double geoValue = geoKey.KeyValue.DoubleVal;

    if (isEasting)
        {
        m_haveFalseEasting  = true;
        m_csDef.x_off       = geoValue;
        }
    else
        {
        m_haveFalseNorthing = true;
        m_csDef.y_off       = geoValue;
        }

    // this is following what the old geocoordinate library did for the ProjCenterEasting/Northing key (check near zero for MRCSR). Not sure where it came from.
    if (COORDSYS_MRCSR == m_coordSys)
        {
        if (fabs (geoValue) >= 1e-6)
            return GEOCOORDERR_ProjectionParamNotSupported;
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessScaleAtNatOriginKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    double geoValue = geoKey.KeyValue.DoubleVal;

    // always treat this as the scale reduction.
    m_csDef.scl_red = geoValue;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessScaleAtCenterKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    double geoValue = geoKey.KeyValue.DoubleVal;

    // always treat this as the scale reduction.
    m_csDef.scl_red = geoValue;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessAzimuthAngleKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    double geoValue = geoKey.KeyValue.DoubleVal * m_azimuthUnitsToDegrees;

    switch (m_coordSys)
        {
        case COORDSYS_OSTRO:
        case COORDSYS_STERO:
        case COORDSYS_PSTRO:        // I don't think the azimuth angle is used for PSTRO.
        case COORDSYS_AZMED:
        case COORDSYS_AZMEA:
            m_csDef.prj_prm1 = geoValue;
            return SUCCESS;

        case COORDSYS_OBLQ1:
            m_csDef.prj_prm3 = geoValue;
            return SUCCESS;

        // none of these need an azimuth.
        case COORDSYS_TRMER:
        case COORDSYS_MRCSR:
        case COORDSYS_LMBRT:
        case COORDSYS_LM1SP:
        case COORDSYS_ALBER:
        case COORDSYS_EDCNC:
        case COORDSYS_EDCYL:
        case COORDSYS_CSINI:
        case COORDSYS_GNOMC:
        case COORDSYS_MILLR:
        case COORDSYS_ORTHO:
        case COORDSYS_PLYCN:
        case COORDSYS_ROBIN:
        case COORDSYS_SINUS:
        case COORDSYS_VDGRN:
        case COORDSYS_NZLND:
        case COORDSYS_SOTRM:
            break;
        }
    return GEOCOORDERR_CoordParamNotNeededForTrans;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessStraightVertPoleLongKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::DOUBLE == geoKey.KeyDataType);
    BeAssert (ModelTypeProjected == m_modelType);

    double geoValue = geoKey.KeyValue.DoubleVal * m_angularUnitsToDegrees;

    switch (m_coordSys)
        {
        case COORDSYS_PSTRO:
            m_csDef.org_lng = geoValue;
            return SUCCESS;

        // none of these need a vert pole longitude key.
        case COORDSYS_OSTRO:
        case COORDSYS_OBLQ1:
        case COORDSYS_AZMED:
        case COORDSYS_AZMEA:
        case COORDSYS_TRMER:
        case COORDSYS_MRCSR:
        case COORDSYS_LMBRT:
        case COORDSYS_LM1SP:
        case COORDSYS_ALBER:
        case COORDSYS_EDCNC:
        case COORDSYS_EDCYL:
        case COORDSYS_CSINI:
        case COORDSYS_GNOMC:
        case COORDSYS_MILLR:
        case COORDSYS_ORTHO:
        case COORDSYS_PLYCN:
        case COORDSYS_ROBIN:
        case COORDSYS_SINUS:
        case COORDSYS_VDGRN:
        case COORDSYS_NZLND:
        case COORDSYS_SOTRM:
            break;
        }
    return GEOCOORDERR_CoordParamNotNeededForTrans;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       ProcessVerticalCSTypeKey (IGeoTiffKeysList::GeoKeyItem& geoKey)
    {
    BeAssert (IGeoTiffKeysList::LONG == geoKey.KeyDataType);

    long verticalCSCode = geoKey.KeyValue.LongVal;

	// Values under 5100 are based on ellipsoid (From Datum)
    m_verticalDatum = vdcFromDatum;
    if (verticalCSCode > 5099)
        {
        if (VerticalCSCode::VertCS_North_American_Vertical_Datum_1929 == verticalCSCode)
            m_verticalDatum = vdcNGVD29;
        else if(VerticalCSCode::VertCS_North_American_Vertical_Datum_1988 == verticalCSCode)
            m_verticalDatum = vdcNAVD88;
        else
            m_verticalDatum = vdcGeoid; // All other values over 5100 is a geoid vertical datum
        }

    return SUCCESS;
    }
};

/*=================================================================================**//**
*
* GeoTiffKey creator class.
*
+===============+===============+===============+===============+===============+======*/
struct GeoTiffKeyCreator
{
private:
BaseGCSCR           m_inGCS;
IGeoTiffKeysList&   m_geoTiffKeys;

public:
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoTiffKeyCreator
(
BaseGCSCR               inGCS,
IGeoTiffKeysList&       geoTiffKeys         // The GeoTiff key list
) : m_inGCS (inGCS), m_geoTiffKeys (geoTiffKeys)
    {
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       SaveGCS
(
)
    {
    if (NULL == m_inGCS.m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    bool isGeographic = (cs_PRJCOD_UNITY == m_inGCS.m_csParameters->prj_code);
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GTModelTypeGeoKey, (uint32_t) (isGeographic ? GeoTiffKeyInterpreter::ModelTypeGeographic : GeoTiffKeyInterpreter::ModelTypeProjected));

    // if the coordinate system has an EPSG code, then we can use that.
    int     epsgCode = m_inGCS.GetEPSGCode();
    if (isGeographic)
        {
        // BeAssert ( (epsgCode >= 4000) && (epsgCode <= 4999) );
        // There are some EPSG LL coordinate systems in our coordsys.asc (e.g., 104107) that are outside of the range, but might match. We used to BeAssert and return error,
        // but I changed it to just ignore them.
        if ( (epsgCode < 4000) || (epsgCode > 4999) )
            epsgCode = 0;
        }

    unsigned short CoordSysTypeKeyID;

    if (isGeographic)
        {
        CoordSysTypeKeyID = GeoTiffKeyInterpreter::GeographicTypeGeoKey;
        }
    else
        {
        // use the private key when the EPSG code is greater than 65535 since,
        // according to the GeoTIFF specification, the value of the key
        // ProjectedCSTypeGeoKey cannot be greater than 65535.
        if (epsgCode > 65535)
            {
            CoordSysTypeKeyID = GeoTiffKeyInterpreter::ProjectedCSTypeGeoKeyLong;
            }
        else
            {
            CoordSysTypeKeyID = GeoTiffKeyInterpreter::ProjectedCSTypeGeoKey;
            }
        }

    // add the appropriate coordinate system type key. Either the EPSG code, or "User Defined".
    m_geoTiffKeys.AddKey (CoordSysTypeKeyID,
                          (uint32_t) ((0 != epsgCode) ? epsgCode : UserDefinedKeyValue));
    if (0 != epsgCode)
        {
        IGeoTiffKeysList::GeoKeyItem projectedCSType;
        projectedCSType.KeyDataType      = IGeoTiffKeysList::LONG;
        projectedCSType.KeyValue.LongVal = epsgCode;

        GeoTiffKeyInterpreter geoTiffKeyInterpreter;

        geoTiffKeyInterpreter.m_modelType = GeoTiffKeyInterpreter::ModelTypeProjected;
        geoTiffKeyInterpreter.ProcessProjectedCSTypeKey (projectedCSType);

        // add the ProjLinearUnitsGeoKey if the unit of the CGS is different than the unit of the
        // coordinate system defined by the GCS EPSG code.
        if (geoTiffKeyInterpreter.m_csDef.unit_scl != m_inGCS.m_csParameters->csdef.unit_scl)
            SaveProjLinearUnitsKey();

        return SUCCESS;
        }

    // here we have a coordinate system we have to represent as a User Defined CS.
    if (isGeographic)
        return SaveGeographicUserDefinition ();
    else
        return SaveProjectedUserDefinition ();
    return SUCCESS;
    }

private:
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       SaveGeographicUserDefinition
(
)
    {
    // we have to be able to find a datum.
    int epsgDatumCode;
    int epsgEllipsoidCode;

    if (0 != (epsgDatumCode = m_inGCS.GetEPSGDatumCode()))
        {
        int     offset;

        // GeogGeodeticDatumGeoKey
        // ellipsoid only must be stored in the range 6000-6200, but the EPSG designations are 7000-7200.
        // Those numbers are also EPSG datum codes, so offset them by -1000 before storing..
        if ( (epsgDatumCode >= 7000) && (epsgDatumCode < 7200) )
            offset = -1000;
        else
            offset = 0;
        m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GeogGeodeticDatumGeoKey, (uint32_t) (epsgDatumCode + offset));
        // complete the definition with the prime meridian
        SavePrimeMeridian ();
        }
    else if (0 != (epsgEllipsoidCode = m_inGCS.GetEPSGEllipsoidCode()))
        {
        // Prime Meridian stored before Ellipsoid code
        SavePrimeMeridian ();

        // I don'think this is any different than storing the Datum code that refers only to the Ellipsoid in the Datum case above.
        m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GeogEllipsoidGeoKey, (uint32_t) epsgEllipsoidCode);
        }
    else
        {
        // Prime Meridian stored before Ellipsoid definition
        SavePrimeMeridian ();
        // set geographic linear units to meters.
        m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GeogLinearUnitsGeoKey, (uint32_t) 9001);
        m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GeogSemiMajorAxisGeoKey, m_inGCS.m_csParameters->datum.e_rad);
        m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GeogSemiMinorAxisGeoKey, m_inGCS.m_csParameters->datum.p_rad);
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       SavePrimeMeridian
(
)
    {
    // first see if we can get a EPSG code.
    double  primeMeridian = m_inGCS.m_csParameters->csdef.org_lng;
    int     epsgCode = 0;

    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GeogAngularUnitsGeoKey, (uint32_t)9102);

    if (doubleSame (primeMeridian, 0.0))
        epsgCode = GeoTiffKeyInterpreter::PM_Greenwich;
    else if (doubleSame (primeMeridian, -9.0754862))
        epsgCode =  GeoTiffKeyInterpreter::PM_Lisbon;
    else if (doubleSame (primeMeridian, 2.337229167))
        epsgCode =  GeoTiffKeyInterpreter::PM_Paris;
    else if (doubleSame (primeMeridian, -74.04513))
        epsgCode =  GeoTiffKeyInterpreter::PM_Bogota;
    else if (doubleSame (primeMeridian, -3.411658))
        epsgCode =  GeoTiffKeyInterpreter::PM_Madrid;
    else if (doubleSame (primeMeridian, 12.27084))
        epsgCode =  GeoTiffKeyInterpreter::PM_Rome;
    else if (doubleSame (primeMeridian, 7.26225))
        epsgCode =  GeoTiffKeyInterpreter::PM_Bern;
    else if (doubleSame (primeMeridian, 106.482779))
        epsgCode =  GeoTiffKeyInterpreter::PM_Jakarta;
    else if (doubleSame (primeMeridian, -17.4))
        epsgCode =  GeoTiffKeyInterpreter::PM_Ferro;
    else if (doubleSame (primeMeridian, 4.220471))
        epsgCode =  GeoTiffKeyInterpreter::PM_Brussels;
    else if (doubleSame (primeMeridian, 18.03298))
        epsgCode =  GeoTiffKeyInterpreter::PM_Stockholm;
    else if (doubleSame (primeMeridian, 23.4258815))
        epsgCode =  GeoTiffKeyInterpreter::PM_Athens;
    else if (doubleSame (primeMeridian, 10.43225))
        epsgCode =  GeoTiffKeyInterpreter::PM_Oslo;

    if (0 != epsgCode)
        {
        m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GeogPrimeMeridianGeoKey, (uint32_t) epsgCode);
        return SUCCESS;
        }

    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GeogPrimeMeridianLongGeoKey, primeMeridian);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       SaveProjectedUserDefinition
(
)
    {
    // check to see whether the projection we have can be saved to EPSG.
    const CSDefinition*     csDef  = &m_inGCS.m_csParameters->csdef;
    StatusInt               status;

    if (SUCCESS != (status = SaveGeographicUserDefinition ()))
        return status;

    SaveProjLinearUnitsKey();

    SaveFalseENKeys();

    switch (m_inGCS.m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMER:
        case cs_PRJCOD_TRMERBF: // We save the BF variation as plain TRMER as it is a problem of application in computation ... the projection principle of the
                                // method is preserved. In any case this projection method is unknown by GeoTIFF so instead of discaring it we
                                // simplify it
            {
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_TransverseMercator);
            SaveNatOriginKeys (csDef->prj_prm1, csDef->org_lat);
            SaveScaleReductionKey();
            break;
            }
        case cs_PRJCOD_HOM1XY:
            {
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_ObliqueMercator);
            SaveFalseENKeys();
            SaveCenterKeys (csDef->prj_prm1, csDef->prj_prm2);
            SaveScaleReductionKey();
            SaveAzimuthAngleKey (csDef->prj_prm3);
            break;
            }
        case cs_PRJCOD_MRCAT:
        case cs_PRJCOD_MRCATK:
            {
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_Mercator);
            SaveStandardParallelKeys (csDef->prj_prm2, 0.0, false);
            SaveCenterLongKey (csDef->prj_prm1);    // not sure whether we need CenterLongitude or NatOriginLong key, save both.
            SaveNatOriginLongKey (csDef->prj_prm1);
            if (cs_PRJCOD_MRCATK == m_inGCS.m_csParameters->prj_code)
                SaveScaleReductionKey();
            break;
            }
        case cs_PRJCOD_LM2SP:
            {
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_LambertConfConic_2SP);
            SaveStandardParallelKeys (csDef->prj_prm1, csDef->prj_prm2, true);
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            break;
            }
        case cs_PRJCOD_LM1SP:
            {
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_LambertConfConic_Helmert);
            break;
            }
        case cs_PRJCOD_AZMEA:
            {
            SaveAzimuthAngleKey (csDef->prj_prm1);
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_LambertAzimEqualArea);
            break;
            }
        case cs_PRJCOD_ALBER:
            {
            SaveStandardParallelKeys (csDef->prj_prm1, csDef->prj_prm2, true);
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_AlbersEqualArea);
            break;
            }
        case cs_PRJCOD_AZMED:
            {
            SaveAzimuthAngleKey (csDef->prj_prm1);
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_AzimuthalEquidistant);
            break;
            }
        case cs_PRJCOD_EDCNC:
            {
            SaveStandardParallelKeys (csDef->prj_prm1, csDef->prj_prm2, true);
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_EquidistantConic);
            break;
            }
        case cs_PRJCOD_SSTRO:
            {
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_Stereographic);
            SaveAzimuthAngleKey (csDef->prj_prm3);
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            SaveScaleReductionKey();
            break;
            }
        case cs_PRJCOD_PSTRO:
            {
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_PolarStereographic);
            SaveAzimuthAngleKey (csDef->prj_prm3);
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            SaveScaleReductionKey();
            break;
            }
        case cs_PRJCOD_OSTRO:
            {
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_ObliqueStereographic);
            SaveAzimuthAngleKey (csDef->prj_prm3);
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            SaveScaleReductionKey();
            break;
            }
        case cs_PRJCOD_EDCYL:
            {
            SaveStandardParallelKeys (csDef->org_lat, 0.0, false);
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_Equirectangular);
            }
        case cs_PRJCOD_CSINI:
            {
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_CassiniSoldner);
            break;
            }
        case cs_PRJCOD_GNOMC:
            {
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_Gnomonic);
            break;
            }
        case cs_PRJCOD_MILLR:
            {
            SaveCenterLongKey (csDef->prj_prm1);    // not sure whether we need CenterLongitude or NatOriginLong key, save both.
            SaveNatOriginLongKey (csDef->prj_prm1);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_MillerCylindrical);
            break;
            }
        case cs_PRJCOD_ORTHO:
            {
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_Orthographic);
            break;
            }
        case cs_PRJCOD_PLYCN:
            {
            SaveCenterLongKey (csDef->prj_prm1);    // not sure whether we need CenterLongitude or NatOriginLong key, save both.
            SaveNatOriginLongKey (csDef->prj_prm1);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_Polyconic);
            break;
            }
        case cs_PRJCOD_ROBIN:
            {
            SaveNatOriginLongKey (csDef->org_lng);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_Robinson);
            break;
            }
        case cs_PRJCOD_SINUS:
            {
            SaveNatOriginLongKey (csDef->org_lng);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_Sinusoidal);
            break;
            }
        case cs_PRJCOD_VDGRN:
            {
            SaveNatOriginLongKey (csDef->org_lng);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_VanDerGrinten);
            break;
            }
        case cs_PRJCOD_NZLND:
            {
            SaveNatOriginKeys (csDef->org_lng, csDef->org_lat);
            SaveScaleReductionKey();
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_NewZealandMapGrid);
            break;
            }
        case cs_PRJCOD_SOTRM:
            {
            SaveNatOriginKeys (csDef->prj_prm1, csDef->org_lat);
            m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCoordTransGeoKey, (uint32_t)GeoTiffKeyInterpreter::CT_TransvMercator_SouthOriented);
            break;
            }
        default:
            {
            return GEOCOORDERR_CantSaveGCS;
            }
        }
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       SaveProjLinearUnitsKey
(
)
    {
    // find the units key that's appropriate
    const struct cs_Unittab_  *pUnit;
    for (pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        // find the units we're using.
        if ( (pUnit->type == cs_UTYP_LEN) && (0 == BeStringUtilities::Stricmp (m_inGCS.m_csParameters->csdef.unit, pUnit->name)))
            {
            if (0 != pUnit->epsgCode)
                {
                m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjLinearUnitsGeoKey, (uint32_t) pUnit->epsgCode);
                return SUCCESS;
                }
            else
                {
                break;
                }
            }
        }

    if (pUnit->type != cs_UTYP_END)
        {
        // did not find our units, or unit did not have EPSG code. Have to use the UnitSize key
        m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjLinearUnitSizeGeoKey, pUnit->factor);
        }

    return GEOCOORDERR_CantSaveGCS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            SaveFalseENKeys
(
)
    {
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjFalseEastingGeoKey, m_inGCS.m_csParameters->csdef.x_off);
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjFalseNorthingGeoKey, m_inGCS.m_csParameters->csdef.y_off);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            SaveNatOriginKeys
(
double  longitude,
double  latitude
)
    {
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjNatOriginLongGeoKey, longitude);
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjNatOriginLatGeoKey, latitude);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            SaveNatOriginLongKey
(
double  value
)
    {
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjNatOriginLongGeoKey, value);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            SaveCenterKeys
(
double  longitude,
double  latitude
)
    {
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCenterLongGeoKey, longitude);
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCenterLatGeoKey, latitude);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            SaveCenterLongKey
(
double value
)
    {
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjCenterLongGeoKey, value);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            SaveScaleReductionKey
(
)
    {
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjScaleAtNatOriginGeoKey, m_inGCS.m_csParameters->csdef.scl_red);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            SaveStandardParallelKeys
(
double  parallel1,
double  parallel2,
bool    saveBoth
)
    {
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjStdParallel1GeoKey, parallel1);
    if (saveBoth)
        m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjStdParallel2GeoKey, parallel2);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            SaveAzimuthAngleKey
(
double  value
)
    {
    // save the GeoAzimuthUnitsKey as degrees
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::GeogAzimuthUnitsGeoKey, (uint32_t)9102);
    m_geoTiffKeys.AddKey (GeoTiffKeyInterpreter::ProjAzimuthAngleGeoKey, value);
    }

};

typedef struct VerticalDatumConverter const*        VerticalDatumConverterCP;
typedef struct VerticalDatumConverter *             VerticalDatumConverterP;
typedef struct VerticalDatumConverter&              VerticalDatumConverterR;
typedef struct VerticalDatumConverter const&        VerticalDatumConverterCR;

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
struct VerticalDatumConverter
{
private:
    bool            m_inputLatLongInNAD27;      // which latLongs are considered to be in NAD27.
    bool            m_fromNGVD29toNAVD88;       // direction
    VertDatumCode   m_fromVDC;
    VertDatumCode   m_toVDC;

public:

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VerticalDatumConverter (bool inputIsInNAD27, VertDatumCode inputVdc, VertDatumCode outputVdc)
    {
    // Datums should be different except if both are Geoid... FINALLY EVEN IF SAME DATUM THE CONVERTER MAY BE NEEDED TO DISCARD
    // ELLIPSOID CHANGE
    // BeAssert (inputVdc != outputVdc || inputVdc == vdcGeoid);

    // Net vertical datum cannot be vdcFromDatum
    BeAssert(inputVdc != vdcFromDatum);
    BeAssert(outputVdc != vdcFromDatum);

    m_fromVDC = inputVdc;
    m_toVDC = outputVdc;

    // These two parameters are only used if NAVD88 to/from NGVD29 is to be performed.
    m_inputLatLongInNAD27 = inputIsInNAD27;
    m_fromNGVD29toNAVD88  = (vdcNGVD29 == inputVdc);
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VerticalDatumConverter
(
DatumCR     from,
DatumCR     to,
VertDatumCode inputVdc,
VertDatumCode outputVdc
)
    {
    // Datums should be different except if both are Geoid... FINALLY EVEN IF SAME DATUM THE CONVERTER MAY BE NEEDED TO DISCARD
    // ELLIPSOID CHANGE
    // BeAssert (inputVdc != outputVdc || inputVdc == vdcGeoid);

    // Net vertical datum cannot be vdcFromDatum
    BeAssert(inputVdc != vdcFromDatum);
    BeAssert(outputVdc != vdcFromDatum);

    m_fromVDC = inputVdc;
    m_toVDC = outputVdc;

    // These two parameters are only used if NAVD88 to/from NGVD29 is to be performed.
    m_inputLatLongInNAD27 = from.IsNAD27();
    m_fromNGVD29toNAVD88  = (vdcNGVD29 == inputVdc);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
~VerticalDatumConverter ()
    {
    if (!BaseGCS::IsLibraryInitialized())
        return;

    CSvrtconCls();
    CS_geoidCls();
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   ConvertElevation
(
GeoPointR   outLatLong,
GeoPointCR  inLatLong
)
    {
    double  elevationDelta;

    if (!BaseGCS::IsLibraryInitialized())
        return GEOCOORDERR_GeoCoordNotInitialized;

    // The process of datum conversion can be complex here depending on the set of in/out
    // vertical datums. Note that the vdcFromDatum value indicates that the ellipsoidal height is
    // used. This height is related to the horizontal datum and conversion may be necessary
    // using CSMAP prior to application of the vertical datum.
    // All other vertical datums supported are Geoid based (orthometric)
    // Here is a map of sequence to be applied
    // Note that vdcFromDatum has been converted to the proper interprtation at this time.
    //      VERT1             VERT2
    //   vdcLocalEllipsoid    vdcEllipsoid      - Case 0A - CSMAP should take care of vertical elevation changes.
    //   vdcLocalEllipsoid    vdcLocalEllipsoid - Case 0B - CSMAP should take care of vertical elevation changes.
    //   vdcLocalEllipsoid    vdcGeoid          - Case 0C - First ellipsoidal height change must be applied by CSMAP then Geoid value at location added to result.
    //   vdcLocalEllipsoid    vdcNAVD88         - Case 0D - Process as if NAVD88 was Geoid
    //   vdcLocalEllipsoid    vdcNGVD29         - Case 0E - Triple conversion ... from Local Ellipsoid to NAD83 (performed by CSMAP) then to NAVD88 then to NGVD29
    //   vdcEllipsoid         vdcEllipsoid      - Case 1 - Discard ellipsoid change if any No elevation changes ... both datum are WGS84 or coincident.
    //   vdcEllipsoid         vdcNAVD88         - Case 2 - Discard ellipsoid change if any Process as if NAVD88 was Geoid
    //   vdcEllipsoid         vdcNGVD29         - Case 3 - Discard ellipsoid change if any Dual conversion ... from Ellipsoid to NAVD88 then to NGVD29
    //   vdcEllipsoid         vdcGeoid          - Case 4 - Discard ellipsoid change if any Geoid Separation value at location added to result.
    //   vdcNAVD88            vdcNGVD29         - Case 5 - Discard ellipsoid change if any Normal VERTCON application.
    //   vdcNAVD88            vdcGeoid          - Case 6 - Discard ellipsoid change if any (NAVD88 is considered Geoid)
    //   vdcNGVD29            vdcGeoid          - Case 7 - Discard ellipsoid change if anyProcess as if target was NAVD88

    // vdcGeoid    vdcGeoid - Case 8 - No change
    // vdcNGVD29 vdcNGVD29    Case 9 - Discard ellipsoid change if any. No change from NGVD29 to NGVD29.
    // vdcNGVD88 vdcNAVD88    Case 10 - Discard ellipsoid change if any. No change from NAVD88 to NAVD88.

    // Case 0A
    if ((vdcLocalEllipsoid == m_fromVDC && vdcEllipsoid == m_toVDC) || (vdcEllipsoid == m_fromVDC && vdcLocalEllipsoid == m_toVDC))
        {
        // Change already done
        return SUCCESS;
        }

    // Case 0B
    if (vdcLocalEllipsoid == m_fromVDC && vdcLocalEllipsoid == m_toVDC)
        {
        // Change already done
        return SUCCESS;
        }

    // If both datums are still equal then we have case 1, 8, 9 or 10 in which case there are no elevation change and we remove any done.
    if (m_fromVDC == m_toVDC)
        {
        // We remove the ellipsoid height change
        outLatLong.elevation = inLatLong.elevation;
        return SUCCESS;
        }

    // Case 6
    if ((vdcGeoid == m_fromVDC && vdcNAVD88 == m_toVDC) || (vdcNAVD88 == m_fromVDC && vdcGeoid == m_toVDC))
        {
        // We remove the ellipsoid height change
        outLatLong.elevation = inLatLong.elevation;
        return SUCCESS;
        }

    // If we have NGVD29 conversion (Case 0E-direct, 3A, 5A and 7A)
    if (m_toVDC == vdcNGVD29)
        {
        if (m_fromVDC == vdcEllipsoid)
            outLatLong.elevation = inLatLong.elevation; // We remove the ellipsoid height change for 3A only

        // Case 3A and 0E-direct
        if ((m_fromVDC == vdcEllipsoid) || (m_fromVDC == vdcLocalEllipsoid))
            {
            // We first need to convert from Ellipsoid to Geoid
            if (0 == CS_geoidHgt((const double *) &inLatLong, &elevationDelta))
                outLatLong.elevation -= elevationDelta;
            else
                return GEOCOORDERR_VerticalDatumConversion;

            // Then convert to NGVD29
            if (0 == CSvrtcon29To88 (&elevationDelta, (const double *) &outLatLong))
                {
                outLatLong.elevation -= elevationDelta;
                return SUCCESS;
                }

            // Something went wrong in VERTCON application
            return GEOCOORDERR_VerticalDatumConversion;
            }

        // Case 5A and 7A (assumed same)
        if (m_fromVDC == vdcNAVD88 || m_fromVDC == vdcGeoid)
            {
            // Then convert to NGVD29
            if (0 == CSvrtcon29To88 (&elevationDelta, (const double *) &outLatLong))
                {
                // Notice that ellipsoidal elevation changes are discarded in this case since the datum pair fully specifies the
                // elevation delta to be applied.
                outLatLong.elevation = inLatLong.elevation - elevationDelta;
                return SUCCESS;
                }

            // Something went wrong in VERTCON application
            return GEOCOORDERR_VerticalDatumConversion;
            }
        else
            return GEOCOORDERR_VerticalDatumConversion; // From datum unknow ... not implemented.
        }


    // If we have NGVD29 conversion (Case 0E-inverse, 3B, 5B and 7B)
    if (m_fromVDC == vdcNGVD29)
        {
        // Case 3B
        if (m_toVDC == vdcEllipsoid)
            outLatLong.elevation = inLatLong.elevation; // We remove the ellipsoid height change for 3B only

        // Case 3B and 0E-inverse
        if ((m_toVDC == vdcEllipsoid) || (m_toVDC == vdcLocalEllipsoid))

            {
            // Then first convert to NAVD88
            if (0 == CSvrtcon29To88 (&elevationDelta, (const double *) &inLatLong))
                {
                outLatLong.elevation += elevationDelta;
                }
            else
                {
                // Something went wrong in VERTCON application
                return GEOCOORDERR_VerticalDatumConversion;
                }

            // Then we convert to Ellipsoid
            if (0 == CS_geoidHgt((const double *) &outLatLong, &elevationDelta))
                outLatLong.elevation += elevationDelta;
            else
                return GEOCOORDERR_VerticalDatumConversion;

            return SUCCESS;
            }

        // Case 5B and 7B (assumed same)
        if (m_toVDC == vdcNAVD88 || m_toVDC == vdcGeoid)
            {
            // Then convert to NGVD29
            if (0 == CSvrtcon29To88 (&elevationDelta, (const double *) &inLatLong))
                {
                // Notice that ellipsoidal elevation changes are discarded in this case since the datum pair fully specifies the
                // elevation delta to be applied.
                outLatLong.elevation = inLatLong.elevation + elevationDelta;
                return SUCCESS;
                }

            // Something went wrong in VERTCON application
            return GEOCOORDERR_VerticalDatumConversion;
            }
        else
            return GEOCOORDERR_VerticalDatumConversion; // To datum unknown ... not implemented.
        }


    // Case 2 and 4
    if (vdcEllipsoid == m_toVDC || vdcEllipsoid == m_fromVDC)
        {
        // One is ellipsoid but other must be NAVD88 or Geoid ... else we have an unknown datum code.
        BeAssert ((vdcEllipsoid == m_toVDC && ((vdcNAVD88 == m_fromVDC) || (vdcGeoid == m_fromVDC))) ||
                  (vdcEllipsoid == m_fromVDC && ((vdcNAVD88 == m_toVDC) || (vdcGeoid == m_toVDC))));

        // The ellipsoidal height diff is discarded if any.
        outLatLong.elevation = inLatLong.elevation;

        if (m_fromVDC == vdcGeoid || m_fromVDC == vdcNAVD88)
            {
            if (0 == CS_geoidHgt((const double *) &inLatLong, &elevationDelta))
                outLatLong.elevation += elevationDelta;
            else
                return GEOCOORDERR_VerticalDatumConversion;
            }

        if (m_toVDC == vdcGeoid || m_toVDC == vdcNAVD88)
            {
            if (0 == CS_geoidHgt((const double *) &outLatLong, &elevationDelta))
                outLatLong.elevation -= elevationDelta;
            else
                return GEOCOORDERR_VerticalDatumConversion;
            }

        return SUCCESS;
        }

    // Case 0C and 0D
    if (vdcLocalEllipsoid == m_toVDC || vdcLocalEllipsoid == m_fromVDC)
        {
        // One is ellipsoid but other must be NAVD88 or Geoid ... else we have an unknown datum code.
        BeAssert ((vdcLocalEllipsoid == m_toVDC && ((vdcNAVD88 == m_fromVDC) || (vdcGeoid == m_fromVDC))) ||
                  (vdcLocalEllipsoid == m_fromVDC && ((vdcNAVD88 == m_toVDC) || (vdcGeoid == m_toVDC))));

        // The ellipsoidal height diff is already applied but additions and substraction are commutative so we do not care
        // about the order of application given we use the proper lat/long combination.
        // In every case the output point should already have a meaningful elevation to correct.
        if (m_fromVDC == vdcGeoid || m_fromVDC == vdcNAVD88)
            {
            if (0 == CS_geoidHgt((const double *) &inLatLong, &elevationDelta))
                outLatLong.elevation += elevationDelta;
            else
                return GEOCOORDERR_VerticalDatumConversion;
            }

        if (m_toVDC == vdcGeoid || m_toVDC == vdcNAVD88)
            {
            if (0 == CS_geoidHgt((const double *) &outLatLong, &elevationDelta))
                outLatLong.elevation -= elevationDelta;
            else
                return GEOCOORDERR_VerticalDatumConversion;
            }

        return SUCCESS;
        }

    // If we get here then there is a vertical datum code we do not know about.
    return GEOCOORDERR_VerticalDatumConversion;
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   IsNullTransform () const
    {
    if (!BaseGCS::IsLibraryInitialized())
        return false;

    // See description of cases in method ConvertElevation()

    // Cases 1, 8, 9, 10 and all other case where vertical datums are equal ...
    // If both datums are still and local ellipsoid (Case 0B) the elevation change has already been taken into account and the
    // elevation datum converter is NULL. This does not imply that there is no elevation change. Just that those are included in the
    // normal datum convertion process and it is for this part to declare null or not.
    if (m_fromVDC == m_toVDC)
        return true;

    // Case 0A (change not performed by Vertical Datum Converter but by CSMAP so not taken into account)
    if ((vdcLocalEllipsoid == m_fromVDC && vdcEllipsoid == m_toVDC) || (vdcEllipsoid == m_fromVDC && vdcLocalEllipsoid == m_toVDC))
        return true;

    // Case 6 (geoid and NAVD88 are considered coincident even though not equal)
    if ((vdcGeoid == m_fromVDC && vdcNAVD88 == m_toVDC) || (vdcNAVD88 == m_fromVDC && vdcGeoid == m_toVDC))
        return true;

    // All other cases Case 0C, 0D, 0E, 2, 3A, 3B, 5A, 5B, 7A, 7B and 4
    return false;
    };

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   IsEquivalent (VerticalDatumConverterCR compareTo) const
    {
    if (!BaseGCS::IsLibraryInitialized())
        return false;

    // If both are null then they are equal
    if (IsNullTransform() && compareTo.IsNullTransform())
        return true;

    // If both source and target are identical then they are equal
    if (m_fromVDC == compareTo.m_fromVDC && m_toVDC == compareTo.m_toVDC)
        return true;

    // Geoid and NAVD88 are considered coincident
    // From is Geoid/NAVD88 and To is equal
    if ((vdcGeoid == m_fromVDC || vdcNAVD88 == m_fromVDC) &&
        (vdcGeoid == compareTo.m_fromVDC || vdcNAVD88 == compareTo.m_fromVDC) &&
        (m_toVDC == compareTo.m_toVDC))
        return true;

    // To is Geoid/NAVD88 and From is equal
    if ((vdcGeoid == m_toVDC || vdcNAVD88 == m_toVDC) &&
        (vdcGeoid == compareTo.m_toVDC || vdcNAVD88 == compareTo.m_toVDC) &&
        (m_fromVDC == compareTo.m_fromVDC))
        return true;

    // From and To are both Geoid/NAVD88 (This should already been processed as Null transforms but just to be fully covered)
    if ((vdcGeoid == m_fromVDC || vdcNAVD88 == m_fromVDC) &&
        (vdcGeoid == compareTo.m_fromVDC || vdcNAVD88 == compareTo.m_fromVDC) &&
        (vdcGeoid == m_toVDC || vdcNAVD88 == m_toVDC) &&
        (vdcGeoid == compareTo.m_toVDC || vdcNAVD88 == compareTo.m_toVDC))
        return true;

    return false;
    };

/*---------------------------------------------------------------------------------**//**
* Indicates if a datum elevation change is required in csmap.
* If either is vdcLocalEllipsoid then the change will be needed.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   NeedsDatumElevationChange() const
    {
    return ((vdcLocalEllipsoid == m_fromVDC) || (vdcLocalEllipsoid == m_toVDC));
    }

};

/*=================================================================================**//**
*
* The static variable and these 3 static functions are uniquely intended for use
* for the user override geodetic transform compilation process part of the Initialize
* process.
*
* The three methods enable opening, closing and writing to the error log file.
*
+===============+===============+===============+===============+===============+======*/

static FILE* s_errorLogFile;
static AString s_errorLogFileName;
// Dummy function required for error management of GX compilation during initialization.
int GeodeticCompilationErrorLog (char *mesg)
    {
    // Create/Recreate file the first time.
    if (NULL == s_errorLogFile)
        {
        s_errorLogFile = fopen(s_errorLogFileName.c_str(), "w");
        }

    if (s_errorLogFile != NULL)
        fprintf(s_errorLogFile, "%s\n", mesg);

    return SUCCESS;
    }

// Dummy function required for error management of GX compilation during initialization.
int GeodeticCompilationErrorOpen (BeFileNameCR errorLogFileName)
    {
	s_errorLogFileName = AString (errorLogFileName.c_str());

	return 0;
    }

// Dummy function required for error management of GX compilation during initialization.
int GeodeticCompilationErrorClose ()
    {
    if (s_errorLogFile != NULL)
        fclose(s_errorLogFile);

    return SUCCESS;
    }

static Utf8String toAssetName(Utf8CP filename) {
    if (0 != strncmp(filename, s_assetsDirPrefix.c_str(), s_assetsDirPrefix.length()))
        return filename;

    filename += s_assetsDirPrefix.length();
    // csmap sometimes adds "/./" to the path, strip off the "/." part
    if (*filename ==  cs_DirsepC && *(filename+1) == '.')
        filename += 2;

    return s_assetsDir + filename;
}

struct WorkspaceDb;
DEFINE_REF_COUNTED_PTR(WorkspaceDb);
static std::list<WorkspaceDbPtr> s_workspaceDbs;
struct WorkspaceRow {
    int64_t rowId;
    Db* db;
};

/** A gcs WorkspaceDb to be opened, if needed */
struct WorkspaceDb : RefCountedBase, NonCopyableClass {
    int m_priority;
    Db* m_db = nullptr;
    Utf8String m_dbName;
    CloudContainerP m_container;

    bool operator==(WorkspaceDb const& other) const { return m_container == other.m_container && m_dbName.Equals(other.m_dbName); }
    void Close() {
        if (m_db != nullptr) {
            delete m_db;
            m_db = nullptr;
        }
    }
    Db* GetDb() {
        if (m_db == nullptr) {
            m_db = new Db();
            auto openParams = Db::OpenParams(Db::OpenMode::Readonly);
            openParams.SetImmutable(); // so no locks will be held on workspace files. Otherwise iOS complains when we are suspended
            auto openName = openParams.SetFromContainer(m_dbName.c_str(), m_container);
            m_db->OpenBeSQLiteDb(openName.c_str(), openParams);
        }
        return m_db->IsDbOpen() ? m_db : nullptr;
    }
    WorkspaceDb(int priority, Utf8StringCR dbName, CloudContainerP container) : m_priority(priority), m_dbName(dbName), m_container(container) {
        if (m_container) {
            // set up a listener for the container being disconnected and remove this entry (closes Db)
            m_container->m_onDisconnect.AddOnce([&](CloudContainerP) {
                s_workspaceDbs.remove_if([&](WorkspaceDbPtr const& other) { return other.get() == this; });
            });
        }
    }
    ~WorkspaceDb() { Close(); }
};

//=======================================================================================
// A GCS resource found in one of the active GCS workspace files.
// @bsiclass
//=======================================================================================
struct WorkspaceResource : _csFile {
    BlobIO m_data;
    int64_t m_offset = 0;

    DbResult Init(WorkspaceRow row) {
        return m_data.Open(*row.db, "blobs", "value", row.rowId, false);
    }
    virtual size_t read(void* buffer, size_t size, size_t count) override {
        int readSize = (int)(size * count);
        if (BE_SQLITE_OK != m_data.Read(buffer, readSize, (int)m_offset))
            return 0;
        m_offset += readSize;
        return count;
    }
    virtual int seek(int64_t offset, int origin) override {
        switch (origin) {
        case SEEK_END:
            m_offset = fileSize();
            break;
        case SEEK_CUR:
            m_offset += offset;
            break;
        default:
            m_offset = offset;
        }
        return 0;
    }
    virtual int getc() override {
        size_t size = 1;
        char c;
        size = read(&c, size, 1);
        return size == 1 ? c : EOF;
    }
    virtual char* gets(char* s, int n) override {
        int ch;
        char* p = s;
        while ((ch = getc()) != '\n' && ch != EOF)
            *s++ = (char)ch;

        *s = '\0';
        return (ch == EOF && p == s) ? nullptr : p;
    }
    size_t fileSize() { return m_data.GetNumBytes(); }
    virtual int64_t tell() override { return m_offset; }
    virtual int close() override {
        m_data.Close();
        return 0;
    }
    virtual int setvbuf(char* buffer, int mode, size_t size) override { return 0; }
    virtual int eof() override { return m_offset >= (int)fileSize(); }
    virtual int error() override { return 0; }
    int readonly() {
        BeAssert(false && "workspaces are always readonly");
        return 0;
    }
    virtual int flush() override { return readonly(); }
    virtual int putc(int character) override { return readonly(); }
    virtual int puts(const char* str) override { return readonly(); }
    virtual size_t write(const void* ptr, size_t size, size_t count) override { return readonly(); }
    virtual int truncate(long writePosition) override { return readonly(); }
    virtual int printf(Utf8CP format...) override { return readonly(); }
};

static bool s_loadLocalFiles = true;
void BaseGCS::EnableLocalGcsFiles(bool yesNo) { s_loadLocalFiles = yesNo; }

//=======================================================================================
// static methods for finding resources in the list of GCS resource files.
// @bsiclass
//=======================================================================================
struct GeoCoordWorkspaces {
    static Utf8String ToUnixName(Utf8CP resourceName) {
        Utf8String unixName(resourceName);
        size_t location;
        while ((location = unixName.find("\\")) != std::string::npos)
            unixName.replace(location, 1, "/");
        return unixName;
    }

    static WorkspaceResource* FindResource(Utf8CP path) {
        auto row = GetRow(path);
        if (0 != row.rowId) {
            auto resource = new WorkspaceResource();
            auto rc = resource->Init(row);
            if (BE_SQLITE_OK == rc) {
                Logging::LogMessageV("GeoCoord", LOG_INFO, "Successfully loaded GCS file %s from workspace %s", path, row.db->GetDbFileName());
                return resource;
            }
            Logging::LogMessageV("GeoCoord", LOG_ERROR, "Unable to read data for GCS file %s from workspace %s, rc=%d", path, row.db->GetDbFileName(), rc);
            delete resource; // weren't able to read from row.
        }
        if (s_loadLocalFiles)
            Logging::LogMessageV("GeoCoord", LOG_INFO, "Unable to find GCS file %s in any workspace, trying local file", path);
        else
            Logging::LogMessageV("GeoCoord", LOG_WARNING, "Unable to find GCS file %s in any workspace", path);
        return nullptr;
    }

    // get the row for a resource for csmap by pathname. Path will include the "assets" prefix.
    static WorkspaceRow GetRow(Utf8CP path) {
        WorkspaceRow blank = {0, nullptr};
        if (0 != strncmp(path, s_assetsDirPrefix.c_str(), s_assetsDirPrefix.length()))
            return blank;

        // strip leading "assets" and leading "/", "\", or "."s
        path += s_assetsDirPrefix.length();
        if (*path == 0)
            return blank;

        while (*path == '.' || *path == '/' || *path == '\\')
            ++path;

        auto resourceName = ToUnixName(path);
        for (auto& entry : s_workspaceDbs) {
            auto db = entry->GetDb();
            if (nullptr == db)
                continue;
            Statement stmt;
            stmt.Prepare(*db, "SELECT rowid FROM blobs WHERE id=? COLLATE NOCASE");
            stmt.BindText(1, resourceName.c_str(), Statement::MakeCopy::No);
            DbResult rc = stmt.Step();
            if (rc == BE_SQLITE_ROW)
                return {stmt.GetValueInt64(0), entry->m_db};
        }
        return blank;
    }
};

/** Add a new entry to the list of gcs WorkspaceDbs */
bool BaseGCS::AddWorkspaceDb(Utf8String dbName, CloudContainerP container, int priority) {
    WorkspaceDbPtr newDb = new WorkspaceDb(priority, dbName, container);
    for (auto& entry : s_workspaceDbs) {
        if (*entry == *newDb)
            return false; // already have this db, releases ptr
    }

    for (auto it=s_workspaceDbs.begin(); it != s_workspaceDbs.end(); ++it) {
        if (priority > (*it)->m_priority) {
            s_workspaceDbs.emplace(it, newDb);
            return true;
        }
    }
    s_workspaceDbs.emplace_back(newDb);
    return true;
}

static bool s_geoCoordInitialized = false;

/*=================================================================================**//**
* Geographic Coordinate System class.
+===============+===============+===============+===============+===============+======*/
StatusInt BaseGCS::Initialize(Utf8CP dataDirectory) {
    if (s_geoCoordInitialized)
        return SUCCESS;

    ::CS_csfnm("coordsys.dty");
    ::CS_dtfnm("datum.dty");
    ::CS_elfnm("ellipsoid.dty");
    ::CS_gxfnm("GeodeticTransform.dty");
    ::CS_gpfnm("GeodeticPath.dty");
    ::CS_altdr(s_assetsDirPrefix.c_str());
    s_assetsDir = dataDirectory;
    if(getenv("GEOCOORD_DIR")){
        s_assetsDir = getenv("GEOCOORD_DIR");
    }

#if defined (BENTLEY_WIN32)||defined (BENTLEY_WINRT)
    if (s_assetsDir.StartsWith("\\\\?\\")) // fopen doesn't work correctly with long path prefix on Windows
        s_assetsDir = s_assetsDir.substr(4);
#endif

    BeFileName baseDbName(s_assetsDir);
    baseDbName.AppendToPath(L"base.itwin-workspace");
    AddWorkspaceDb(baseDbName.GetNameUtf8(), nullptr, 0);

    s_geoCoordInitialized = true;
    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
 @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::Shutdown() {
    s_workspaceDbs.clear();

    if (nullptr != cs_Ostn15Ptr)
        {
        CSdeleteOstn15(cs_Ostn15Ptr);
        cs_Ostn15Ptr = nullptr;
        }

    if (nullptr != cs_Ostn02Ptr)
        {
        CSdeleteOstn02(cs_Ostn02Ptr);
        cs_Ostn02Ptr = nullptr;
        }

    if (nullptr != cs_Ostn97Ptr)
        {
        CSdeleteOstn97(cs_Ostn97Ptr);
        cs_Ostn97Ptr = nullptr;
        }

    s_geoCoordInitialized = false;
}

/*=================================================================================**//**
* static method that returns true if the library was initialized and false otherwise
+===============+===============+===============+===============+===============+======*/
bool BaseGCS::IsLibraryInitialized ()    {
    return s_geoCoordInitialized;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool BaseGCS::InitializeBaseGcsECEF()
    {
    if ((s_LL84GCS.get() == nullptr) || !s_LL84GCS->IsValid())
        s_LL84GCS = CreateGCS("LL84");

    return s_LL84GCS.IsValid();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::BaseGCS() { Init();}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::BaseGCS(Utf8CP coordinateSystemName) {
    Init();

    if (!IsLibraryInitialized()) {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return;
    }

    if (NULL == (m_csParameters = CSMap::CS_csloc(coordinateSystemName)))
        m_csError = cs_Error;
    else
        m_coordSysId = COORDSYS_KEYNM; // since we looked it up, we put COORDSYS_KEYNM as the coordsys in the type 66 element.
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::BaseGCS
(
CSParameters&   csParameters,
int32_t         coordinateSystemId,
CSGeodeticTransformDef const* geodeticTransform
)
    {
    Init();

    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return;
        }

    m_csParameters  = &csParameters;
    m_coordSysId    = coordinateSystemId;

    if (NULL != geodeticTransform)
        {
        // it represents a custom datum and should be set.
        m_datum = const_cast<DatumP>(Datum::CreateDatum(m_csParameters->datum, geodeticTransform));
        m_customDatum = true;
        }

    if (NULL == m_csParameters)
        m_csError = GEOCOORDERR_InvalidCoordSys;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::BaseGCS (BaseGCSCR source)
    {
    Init();

    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return;
        }

    BeAssert ( NULL != source.m_csParameters );

    // copy the parameters structure.
    if (NULL != source.m_csParameters)
        {
        m_csParameters = (CSParameters *) CS_malc (sizeof (CSParameters));
        memcpy (m_csParameters, source.m_csParameters, sizeof (CSParameters));
        }

    if (nullptr != source.m_datum && source.m_customDatum)
        {
        m_datum = source.m_datum->Clone();
        m_customDatum = true;
        }

    m_coordSysId         = source.m_coordSysId;
    m_verticalDatum      = source.m_verticalDatum;
    m_reprojectElevation = source.m_reprojectElevation;
    m_verticalDatum      = source.m_verticalDatum;

    if (source.m_localTransformer.IsValid())
        m_localTransformer  = source.m_localTransformer->Copy();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::Init() {
    InitHorizontal();

    m_reprojectElevation = true;
    m_verticalDatum = vdcFromDatum;

    m_localTransformer = nullptr;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::InitHorizontal() {

    m_csParameters                  = NULL;
    m_datum                         = NULL;
    m_customDatum                   = false;

    m_csError                       = 0;
    m_datumConverter                = NULL;
    m_targetGCS                     = NULL;
    m_coordSysId                    = 0;
    m_canEdit                       = false;

    m_nameString                    = NULL;
    m_descriptionString             = NULL;
    m_projectionString              = NULL;
    m_datumNameString               = NULL;
    m_datumDescriptionString        = NULL;
    m_ellipsoidNameString           = NULL;
    m_ellipsoidDescriptionString    = NULL;

    m_originalWKT                   = NULL;
    m_originalGeoKeys               = NULL;
    m_modified                      = false;
    m_foundEPSGCode                 = 0;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::Clear() {

    if (m_targetGCS != NULL)
        {
        m_targetGCS->UnRegisterIsADestinationOf(*this);
        m_targetGCS = NULL;
        }

    if (NULL != m_datumConverter)
        {
        m_datumConverter->Destroy();
        m_datumConverter = NULL;
        }

    if (m_datum != nullptr)
        {
        m_datum->Destroy();
        m_datum = nullptr;
        }

    // Clear the link between other BaseGCS to this one used as a cached targets
    for (size_t i = 0 ; i < m_listOfPointingGCS.size() ; i++)
        m_listOfPointingGCS[i]->ClearCache();

    m_listOfPointingGCS.clear();

    CSMAP_FREE_AND_CLEAR (m_csParameters);

    DELETE_AND_CLEAR (m_nameString);
    DELETE_AND_CLEAR (m_descriptionString);
    DELETE_AND_CLEAR (m_projectionString);
    DELETE_AND_CLEAR (m_datumNameString);
    DELETE_AND_CLEAR (m_datumDescriptionString);
    DELETE_AND_CLEAR (m_ellipsoidNameString);
    DELETE_AND_CLEAR (m_ellipsoidDescriptionString);

    DELETE_AND_CLEAR (m_originalWKT);
    DELETE_AND_CLEAR (m_originalGeoKeys);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::AllocateClean() {

    Clear();

    InitHorizontal();

    // Create a valid m_csParameters then clear important fields
    if (NULL == m_csParameters) {
        m_csParameters = (CSParameters*)CS_malc(sizeof(CSParameters));
        memset(m_csParameters, 0, sizeof(CSParameters));
    }

    SetName("");
    SetDescription("");
    SetSource("");
    SetProjectionCode(pcvUnity);
    CSMap::CS_stncp(m_csParameters->csdef.unit, "Degree", _countof(m_csParameters->csdef.unit));

    // Wipe the group name for future definition complete
    m_csParameters->csdef.group[0] = '\0';
    // Wipe min / max so they can be computed
    m_csParameters->csdef.ll_min[LNG] = 0.0;
    m_csParameters->csdef.ll_min[LAT] = 0.0;
    m_csParameters->csdef.ll_max[LNG] = 0.0;
    m_csParameters->csdef.ll_max[LAT] = 0.0;
    m_csParameters->csdef.xy_min[XX] = 0.0;
    m_csParameters->csdef.xy_min[YY] = 0.0;
    m_csParameters->csdef.xy_max[XX] = 0.0;
    m_csParameters->csdef.xy_max[YY] = 0.0;
    m_csParameters->csdef.epsgNbr = 0;
    m_csParameters->csdef.unit_scl = 1.0;
    m_csParameters->csdef.map_scl = 1.0;
    m_csParameters->csdef.scale = 1.0;
    m_csParameters->csdef.prj_prm1 = 0.0;
    m_csParameters->csdef.prj_prm2 = 0.0;
    m_csParameters->csdef.prj_prm3 = 0.0;
    m_csParameters->csdef.prj_prm4 = 0.0;
    m_csParameters->csdef.prj_prm5 = 0.0;
    m_csParameters->csdef.prj_prm6 = 0.0;
    m_csParameters->csdef.prj_prm7 = 0.0;
    m_csParameters->csdef.prj_prm8 = 0.0;
    m_csParameters->csdef.prj_prm9 = 0.0;
    m_csParameters->csdef.prj_prm10 = 0.0;
    m_csParameters->csdef.prj_prm11 = 0.0;
    m_csParameters->csdef.prj_prm12 = 0.0;
    m_csParameters->csdef.prj_prm13 = 0.0;
    m_csParameters->csdef.prj_prm14 = 0.0;
    m_csParameters->csdef.prj_prm15 = 0.0;
    m_csParameters->csdef.prj_prm16 = 0.0;
    m_csParameters->csdef.prj_prm17 = 0.0;
    m_csParameters->csdef.prj_prm18 = 0.0;
    m_csParameters->csdef.prj_prm19 = 0.0;
    m_csParameters->csdef.prj_prm20 = 0.0;
    m_csParameters->csdef.prj_prm21 = 0.0;
    m_csParameters->csdef.prj_prm22 = 0.0;
    m_csParameters->csdef.prj_prm23 = 0.0;
    m_csParameters->csdef.prj_prm24 = 0.0;
    m_csParameters->csdef.quad = 1;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::SetFromCSName(Utf8CP coordinateSystemKeyName) {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return m_csError;
        }

    m_csError       = 0;
    Clear();
    SetModified(true);

    if (NULL == (m_csParameters = CSMap::CS_csloc (coordinateSystemKeyName)))
        m_csError = cs_Error;

    return m_csError;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCSPtr BaseGCS::CreateGCS() {
    return new BaseGCS();
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCSPtr BaseGCS::CreateGCS(Utf8CP coordinateSystemKeyName) {
    return new BaseGCS (coordinateSystemKeyName);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCSPtr BaseGCS::CreateGCS(CSParameters const& csParameters, int32_t coordSysId, CSGeodeticTransformDef* geodeticTransform) {
    // copy the csParameters because the original might not have been allocated by CS_malc.
    CSParameters* copied = (CSParameters *) CS_malc (sizeof (CSParameters));
    *copied = csParameters;
    return new BaseGCS (*copied, coordSysId, geodeticTransform);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCSPtr      BaseGCS::CreateGCS
(
CSParameters const& csParameters,
int32_t             coordSysId
)
    {
    return CreateGCS (csParameters, coordSysId, NULL);
    }
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCSPtr BaseGCS::CreateGCS (BaseGCSCR baseGcs)
    {
    return new BaseGCS(baseGcs);
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::InitAzimuthalEqualArea
(
Utf8StringP             errorMsg,
Utf8CP                  datumName,
Utf8CP                  unitName,
double                  originLongitude,
double                  originLatitude,
double                  azimuthAngle,
double                  scale,              // this argument is ignored!
double                  falseEasting,
double                  falseNorthing,
int                     quadrant
)
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return m_csError;
        }

    Clear();
    InitHorizontal();
    SetModified(true);

    CSDefinition        csDef;
    memset (&csDef, 0, sizeof(csDef));

    CSMap::CS_stncp (csDef.prj_knm, CS_AZMEA, DIM(csDef.prj_knm));
    CSMap::CS_stncp (csDef.unit, unitName, DIM(csDef.unit));
    CSMap::CS_stncp (csDef.dat_knm, datumName, DIM(csDef.dat_knm));

    csDef.prj_prm1  = azimuthAngle;
    csDef.org_lng   = originLongitude;
    csDef.org_lat   = originLatitude;
    // Note: We do not allow CSMap to handle scale, the scale argument is ignored.
    csDef.map_scl   = 1.0;
    csDef.x_off     = falseEasting;
    csDef.y_off     = falseNorthing;
    csDef.quad      = (short) quadrant;

    if (NULL == (m_csParameters = CSMap::CScsloc1 (&csDef)))
        {
        if (NULL != errorMsg)
            {
            char    csErrorMsg[512];
            CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
            *errorMsg = csErrorMsg;
            BeAssert (false);
            }
        m_csError = cs_Error;
        return cs_Error;
        }

    // Clear out the error that may have come from a previous init attempt
    m_csError = 0;

    m_coordSysId = COORDSYS_AZMEA;

    SetModified(false);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::InitTransverseMercator
(
Utf8StringP             errorMsg,
Utf8CP                  datumName,
Utf8CP                  unitName,
double                  centralMeridian,
double                  originLatitude,
double                  scale,
double                  falseEasting,
double                  falseNorthing,
int                     quadrant
)
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return m_csError;
        }

    Clear();
    InitHorizontal();
    SetModified(true);

    CSDefinition        csDef;
    memset (&csDef, 0, sizeof(csDef));

    CSMap::CS_stncp (csDef.prj_knm, CS_TRMER, DIM(csDef.prj_knm));
    CSMap::CS_stncp (csDef.unit, unitName, DIM(csDef.unit));
    CSMap::CS_stncp (csDef.dat_knm, datumName, DIM(csDef.dat_knm));

    // csDef.prj_prm1  =;
    csDef.org_lat   = originLatitude;
    csDef.prj_prm1  = centralMeridian;
    csDef.scl_red   = scale;
    csDef.map_scl   = 1.0;
    csDef.x_off     = falseEasting;
    csDef.y_off     = falseNorthing;
    csDef.quad      = (short) quadrant;

    if (NULL == (m_csParameters = CSMap::CScsloc1 (&csDef)))
        {
        if (NULL != errorMsg)
            {
            char    csErrorMsg[512];
            CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
            *errorMsg = csErrorMsg;
            BeAssert (false);
            }
        m_csError = cs_Error;
        return cs_Error;
        }

    m_coordSysId = COORDSYS_TRMER;

    SetModified(false);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::InitLatLong
(
Utf8StringP             errorMsg,
Utf8CP                  datumName,          // Datum
Utf8CP                  ellipseName,        // only if datum is NULL.
Utf8CP                  unitName,           // usually "DEGREE"
double                  originLongitude,    // displacement from Greenwich
double                  originLatitude      // displacement from Greenwich
)
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return m_csError;
        }

    Clear();
    InitHorizontal();
    SetModified(true);

    CSDefinition        csDef;
    memset (&csDef, 0, sizeof(csDef));

    CSMap::CS_stncp (csDef.prj_knm, CS_UNITY, DIM(csDef.prj_knm));
    CSMap::CS_stncp (csDef.unit, unitName, DIM(csDef.unit));
    if (NULL != datumName)
        CSMap::CS_stncp (csDef.dat_knm, datumName, DIM(csDef.dat_knm));
    if (NULL != ellipseName)
        CSMap::CS_stncp (csDef.elp_knm, ellipseName, DIM(csDef.elp_knm));

    csDef.org_lng   = originLongitude;
    csDef.org_lat   = originLatitude;

    if (NULL == (m_csParameters = CSMap::CScsloc1 (&csDef)))
        {
        if (NULL != errorMsg)
            {
            char    csErrorMsg[512];
            CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
            *errorMsg = csErrorMsg;
            BeAssert (false);
            }
        m_csError = cs_Error;
        return cs_Error;
        }

    m_coordSysId = COORDSYS_UNITY;

    SetModified(false);

    return SUCCESS;
    }

/* TODO We may need this someday soon
struct JsonStatus
{
    JsonStatus(StatusInt s)
        :status(s)
    {
    }
    Utf8String properyName;
    Utf8String message;
    StatusInt status;

    bool Failed() { return SUCCESS != status; }
};

template<typename Functor>
JsonStatus GetAndSet(JsonValueCR value, Utf8CP name, Functor functor)
{
    StatusInt result = SUCCESS;

    if (value[name].isNull())
        return JsonStatus(GEOCOORDERR_MissingPropertyOrParameter); // false;// MissingProperty(name);

    if (SUCCESS != (result = functor(value[name].asDouble())))
        return JsonStatus(result); //BadProperty(name, result);

    return JsonStatus(SUCCESS);
}*/

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::FromJson(BeJsConst jsonValue, Utf8StringR errorMessage) {
    StatusInt result = SUCCESS;

    // Horizontal portion is mandatory
    if (jsonValue["horizontalCRS"].isNull()) {
        errorMessage = "Missing horizontalCRS property which is mandatory";
        return GEOCOORDERR_MissingPropertyOrParameter;
    }

    if (SUCCESS != (result = FromHorizontalJson(jsonValue["horizontalCRS"], errorMessage)))
        return result;

    if (!jsonValue["verticalCRS"].isNull() && (SUCCESS != (result = FromVerticalJson(jsonValue["verticalCRS"], errorMessage))))
        return result;

    if (!jsonValue["additionalTransform"].isNull() && (SUCCESS != (result = FromLocalTransformerJson(jsonValue["additionalTransform"], errorMessage))))
        return result;

    return result;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::ToJson(BeJsValue jsonValue, bool expandDatum) const {
    if (!IsLibraryInitialized())
        return GEOCOORDERR_GeoCoordNotInitialized;

    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    StatusInt result = SUCCESS;

    if (SUCCESS != (result = ToHorizontalJson(jsonValue["horizontalCRS"], expandDatum)))
        return result;

    if (SUCCESS != (result = ToVerticalJson(jsonValue["verticalCRS"])))
        return result;

    // Only add the additional transform portion is one is present
    if (GetLocalTransformer() != nullptr) {
        if (SUCCESS != (result = ToLocalTransformerJson(jsonValue["additionalTransform"])))
            return result;
    }

    return result;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::FromHorizontalJson(BeJsConst jsonValue, Utf8StringR errorMessage) {
    StatusInt result = SUCCESS;
    int epsgCode = 0;

    // Error processing lambda definitions
    auto BadProperty = [&errorMessage](Utf8CP name, StatusInt status = GEOCOORDERR_BadArg) {
        errorMessage.Sprintf("'%s' is invalid", name);
        return status;
    };

    auto BadArg = [&errorMessage](Utf8CP message) {
        errorMessage = message;
        return GEOCOORDERR_BadArg;
    };

    auto MissingProperty = [&errorMessage](Utf8CP name) {
        errorMessage.Sprintf("'%s' is missing", name);
        return GEOCOORDERR_MissingPropertyOrParameter;
    };

    auto SetProperty = [&result, MissingProperty, BadProperty](BeJsConst value, Utf8CP name, auto functor) {
        if (value[name].isNull())
            return result = MissingProperty(name);

        if (SUCCESS != (result = functor(value[name].asDouble())))
            return result = BadProperty(name, result);

        return result = SUCCESS;
    };

    if (!IsLibraryInitialized())
        return GEOCOORDERR_GeoCoordNotInitialized;

    // Indicate is modified ... this clears all cache parameters.
    SetModified(true);

    // TODO name property would contain the name for user-defined GCS, Datum, Ellipsoid
    // if (!jsonValue["name"].isNull())
    //     m_label = jsonValue["name"].asString();

    // We first try using the keyname
    // If we were sucessful then we do not we validate the definition is similar.
    if (!jsonValue["id"].isNull() && (SUCCESS == SetFromCSName(jsonValue["id"].asString().c_str())))
        {
        // Even if we are all set with the keyname the description may have been overriden (PP behavior)
        if (!jsonValue["description"].isNull())
            SetDescription(jsonValue["description"].asString().c_str());

        return SUCCESS;
        }

    AllocateClean();

    // Now we have a clean slate and we parse the json
    Utf8String name;
    if (!jsonValue["id"].isNull())
        name = jsonValue["id"].asString();

    SetName(name.c_str());

    if (!jsonValue["description"].isNull())
        SetDescription(jsonValue["description"].asString().c_str());

    if (!jsonValue["source"].isNull())
        SetSource(jsonValue["source"].asString().c_str());

    if (!jsonValue["deprecated"].isNull() && (jsonValue["deprecated"].asBool() == true))
        SetGroup("LEGACY");
    else
        SetGroup("NONE");

    if (!jsonValue["epsg"].isNull())
        {
        if (!jsonValue["epsg"].isNumeric())
            return BadProperty("epsg");

        epsgCode = jsonValue["epsg"].asInt();
        if (0 > epsgCode || 32767 < epsgCode)
            return BadProperty("epsg");

        SetStoredEPSGCode((short)epsgCode);
        }

    int datumCode = Datum::NO_DATUM_CODE;

    if (!jsonValue["datumId"].isNull())
        datumCode = FindDatumIndex(jsonValue["datumId"].asString().c_str());

    // If there is no datum found try full datum definition
    if ((datumCode < 0) && !jsonValue["datum"].isNull())
        {
        auto theDatum = jsonValue["datum"];

        if (!theDatum["id"].isNull())
            datumCode = FindDatumIndex(theDatum["id"].asString().c_str());

        if (datumCode < 0)
            {
            // Last chance is for the datum to be fully custom
            DatumP customDatum = Datum::CreateDatum();
            if (SUCCESS != (result = customDatum->FromJson(theDatum, errorMessage)))
                {
                // Could not obtain a custom made datum ...
                customDatum->Destroy();
                return BadProperty("datum");
                }

            // Set the self-defined fully custom datum
            datumCode = Datum::CUSTOM_DATUM_CODE; // Indicates a self defined datum
            SetDatum(customDatum);
            }
        else
            SetDatumCode(datumCode);
        }
    else
        SetDatumCode(datumCode);

    // if datum code is Datum::NO_DATUM_CODE then it is a non-datum or an unknown datum
    if (Datum::NO_DATUM_CODE == datumCode)
        {
        int ellipsoidCode = -1;

        if (!jsonValue["ellipsoidId"].isNull())
            {
            ellipsoidCode = FindEllipsoidIndex(jsonValue["ellipsoidId"].asString().c_str());
            }


        if ((ellipsoidCode < 0) && !jsonValue["ellipsoid"].isNull())
            {
            auto theEllipsoid = jsonValue["ellipsoid"];

            if (!theEllipsoid["name"].isNull())
                ellipsoidCode = FindEllipsoidIndex(theEllipsoid["name"].asString().c_str());
            }

        if (ellipsoidCode < 0)
            {
            // Major missing props ... try solving GCS using EPSG code
            if (0 < epsgCode && 32767 > epsgCode)
                {
                if (SUCCESS == this->InitFromEPSGCode(NULL, NULL, epsgCode))
                    {
                    SetStoredEPSGCode((short)epsgCode);
                    return (StatusInt)SUCCESS;
                    }
                }

            return BadProperty("ellipsoid"); // Ellipsoid not found ... we have got to have a minimum information!
            }

        // TODO Do we support self-defined GCS that do not use a datum but a self defined ellipsoid?
        SetDatumCode(Datum::NO_DATUM_CODE);
        SetEllipsoidCode(ellipsoidCode);
        }

    // Set units
    if (jsonValue["unit"].isNull())
        {
        // Major missing props ... try solving GCS using EPSG code
        if (0 < epsgCode && 32767 > epsgCode)
            {
            if (SUCCESS == this->InitFromEPSGCode(NULL, NULL, epsgCode))
                {
                SetStoredEPSGCode((short)epsgCode);
                return (StatusInt)SUCCESS;
                }
            }
        return MissingProperty("unit");
        }

    Utf8String unitString = jsonValue["unit"].asString();

    Utf8String csmapUnitString;

    if (unitString == "Meter")
        csmapUnitString = "meter";
    else if (unitString == "USSurveyFoot")
        csmapUnitString = "foot";
    else if (unitString == "InternationalFoot")
        csmapUnitString = "ifoot";
    else if (unitString == "Degree")
        csmapUnitString = "degree";
    else
        return BadProperty("unit");

    GeoCoordinates::UnitEnumerator* unitEnumerator = new GeoCoordinates::UnitEnumerator();
    GeoCoordinates::UnitCP currentUnit;
    int currentUnitCode = 0;
    int foundUnitCode = -1;
    bool unitSet = false;
    double unitFactor = 1.0;
    while ((foundUnitCode < 0) && (unitEnumerator->MoveNext()))
        {
        currentUnit = unitEnumerator->GetCurrent();

        // CSMAP stores in all kind of case combination so case insensitive is required
        if (0 == BeStringUtilities::Stricmp(currentUnit->GetName(), csmapUnitString.c_str()))
            {
            SetUnitCode(currentUnitCode);
            unitFactor = currentUnit->GetConversionFactor();
            unitSet = true;
            currentUnit->Destroy();
            break;
            }

        currentUnit->Destroy();

        currentUnitCode++;
        }

    unitEnumerator->Destroy();

    if (!unitSet)
        return BadProperty("unit");

    // Projection section
    auto projectionVal = jsonValue["projection"];

    if (projectionVal.isNull())
        {
        // Major missing props ... try solving GCS using EPSG code
        if (0 < epsgCode && 32767 > epsgCode)
            {
            if (SUCCESS == this->InitFromEPSGCode(NULL, NULL, epsgCode))
                {
                SetStoredEPSGCode((short)epsgCode);
                return (StatusInt)SUCCESS;
                }
            }
        return MissingProperty("projection");
        }

    if (projectionVal["method"].isNull())
        return MissingProperty("method");

    // Projection value error management lambda
    auto SetProjectionValue = [&projectionVal, SetProperty](Utf8CP name, auto functor)
        {
        return SetProperty(projectionVal, name, [functor](double v) {return functor(v); });
        };

    Utf8String projectionMethod = projectionVal["method"].asString();

    if (projectionMethod == "None")
        {
        SetProjectionCode(GeoCoordinates::BaseGCS::pcvUnity);
        }
    else if (projectionMethod == "TransverseMercator")
        {
        SetProjectionCode(pcvTotalTransverseMercatorBF);

        if (SUCCESS != SetProjectionValue("centralMeridian", [this](double v) {return SetCentralMeridian(v);}) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v);}) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }))
            return result;
        }
    else if (projectionMethod == "AlbersEqualArea")
        {
        SetProjectionCode(pcvAlbersEqualArea);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel1", [this](double v) {return SetStandardParallel1(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel2", [this](double v) {return SetStandardParallel2(v); }))
            return result;
        }
    else if (projectionMethod == "MercatorStandardParallel")
        {
        SetProjectionCode(pcvMercator);

        if (SUCCESS != SetProjectionValue("centralMeridian", [this](double v) {return SetCentralMeridian(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel", [this](double v) {return SetStandardParallel1(v); }))
            return result;
        }
    else if (projectionMethod == "MercatorScale")
        {
        SetProjectionCode(pcvMercatorScaleReduction);

        if (SUCCESS != SetProjectionValue("centralMeridian", [this](double v) {return SetCentralMeridian(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }))
            return result;
        }
    else if (projectionMethod == "UniversalTransverseMercator")
        {
        SetProjectionCode(pcvTotalUniversalTransverseMercator);

        if (projectionVal["zoneNumber"].isNull())
            return MissingProperty("zoneNumber");

        if (SUCCESS != (result = SetUTMZone(projectionVal["zoneNumber"].asInt())))
            return BadProperty("zoneNumber", result);

        if (projectionVal["hemisphere"].isNull())
            return MissingProperty("hemisphere");

        if (projectionVal["hemisphere"].asString() == "North")
            SetHemisphere(1);
        else if (projectionVal["hemisphere"].asString() == "South")
            SetHemisphere(-1);
        else
            return BadProperty("hemisphere");

        // Sanity check (should not have false easting or false northing)
        if (!projectionVal["falseEasting"].isNull() || !projectionVal["falseNorthing"].isNull())
            return BadArg("'falseEasting' and 'falseNorthing' should not exist");
        }
    else if (projectionMethod == "SouthOrientedTransverseMercator")
        {
        SetProjectionCode(pcvSouthOrientedTransverseMercator);

        if (SUCCESS != SetProjectionValue("centralMeridian", [this](double v) {return SetCentralMeridian(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }))
            return result;
        }
    else if (projectionMethod == "LambertConformalConicOneParallel")
        {
        SetProjectionCode(pcvLambertConformalConicOneParallel);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }))
            return result;
        }
    else if (projectionMethod == "LambertConformalConicTwoParallels")
        {
        SetProjectionCode(pcvLambertConformalConicTwoParallel);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel1", [this](double v) {return SetStandardParallel1(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel2", [this](double v) {return SetStandardParallel2(v); }))
            return result;
        }
    else if (projectionMethod == "LambertConformalConicBelgium")
        {
        SetProjectionCode(pcvLambertConformalConicBelgian);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel1", [this](double v) {return SetStandardParallel1(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel2", [this](double v) {return SetStandardParallel2(v); }))
            return result;
        }
    else if (projectionMethod == "LambertConformalConicWisconsin")
        {
        SetProjectionCode(pcvLambertConformalConicWisconsin);

        // Geoid separation is always in meters but it is in the GCS units in JSON
        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel1", [this](double v) {return SetStandardParallel1(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel2", [this](double v) {return SetStandardParallel2(v); }) ||
            SUCCESS != SetProjectionValue("elevationAboveGeoid", [this](double v) {return SetElevationAboveGeoid(v); }))
            return result;

        if (projectionVal["geoidSeparation"].isNull())
            return MissingProperty("geoidSeparation");

        double geoidSeparation = projectionVal["geoidSeparation"].asDouble();

        if (SUCCESS != (result = SetGeoidSeparation(geoidSeparation * unitFactor)))
            return BadProperty("geoidSeparation", result);
        }
    else if (projectionMethod == "TransverseMercatorWisconsin")
        {
        SetProjectionCode(pcvTransverseMercatorWisconsin);

        // Geoid separation is always in meters but it is in the GCS units in JSON
        if (SUCCESS != SetProjectionValue("centralMeridian", [this](double v) {return SetCentralMeridian(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }) ||
            SUCCESS != SetProjectionValue("elevationAboveGeoid", [this](double v) {return SetElevationAboveGeoid(v); }))
            return result;

        if (projectionVal["geoidSeparation"].isNull())
            return MissingProperty("geoidSeparation");

        double geoidSeparation = projectionVal["geoidSeparation"].asDouble();

        if (SUCCESS != (result = SetGeoidSeparation(geoidSeparation * unitFactor)))
            return BadProperty("geoidSeparation", result);
        }
    else if (projectionMethod == "LambertConformalConicMinnesota")
        {
        SetProjectionCode(pcvLambertConformalConicMinnesota);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel1", [this](double v) {return SetStandardParallel1(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel2", [this](double v) {return SetStandardParallel2(v); }) ||
            SUCCESS != SetProjectionValue("elevationAboveGeoid", [this](double v) {return SetElevationAboveGeoid(v); }))
            return result;
        }
    else if (projectionMethod == "TransverseMercatorMinnesota")
        {
        SetProjectionCode(pcvTransverseMercatorMinnesota);

        if (SUCCESS != SetProjectionValue("centralMeridian", [this](double v) {return SetCentralMeridian(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }) ||
            SUCCESS != SetProjectionValue("elevationAboveGeoid", [this](double v) {return SetElevationAboveGeoid(v); }))
            return result;
        }
    else if (projectionMethod == "ObliqueMercatorMinnesota")
        {
        SetProjectionCode(pcvObliqueMercatorMinnesota);

        if (SUCCESS != SetProjectionValue("centralPointLongitude", [this](double v) {return SetCentralPointLongitude(v); }) ||
            SUCCESS != SetProjectionValue("centralPointLatitude", [this](double v) {return SetCentralPointLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }) ||
            SUCCESS != SetProjectionValue("azimuth", [this](double v) {return SetAzimuth(v); }) ||
            SUCCESS != SetProjectionValue("elevationAboveGeoid", [this](double v) {return SetElevationAboveGeoid(v); }))
            return result;
        }
    else if (projectionMethod == "LambertConformalConicMichigan")
        {
        SetProjectionCode(pcvLambertMichigan);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel1", [this](double v) {return SetStandardParallel1(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel2", [this](double v) {return SetStandardParallel2(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetEllipsoidScaleFactor(v); }))
            return result;
        }
    else if (projectionMethod == "NewZealandNationalGrid")
        {
        SetProjectionCode(pcvNewZealandNationalGrid);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }))
            return result;
        }
    else if (projectionMethod == "ObliqueMercator1")
        {
        SetProjectionCode(pcvHotineObliqueMercator1XY);

        if (SUCCESS != SetProjectionValue("centralPointLongitude", [this](double v) {return SetCentralPointLongitude(v); }) ||
            SUCCESS != SetProjectionValue("centralPointLatitude", [this](double v) {return SetCentralPointLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }) ||
            SUCCESS != SetProjectionValue("azimuth", [this](double v) {return SetAzimuth(v); }))
            return result;
        }
    else if (projectionMethod == "ObliqueMercator2")
        {
        SetProjectionCode(pcvHotineObliqueMercator2XY);

        if (SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("point1Longitude", [this](double v) {return SetPoint1Longitude(v); }) ||
            SUCCESS != SetProjectionValue("point1Latitude", [this](double v) {return SetPoint1Latitude(v); }) ||
            SUCCESS != SetProjectionValue("point2Longitude", [this](double v) {return SetPoint2Longitude(v); }) ||
            SUCCESS != SetProjectionValue("point2Latitude", [this](double v) {return SetPoint2Latitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }))
            return result;
        }
    else if (projectionMethod == "TransverseMercatorOSTN97")
        SetProjectionCode(pcvTransverseMercatorOstn97);
    else if (projectionMethod == "TransverseMercatorOSTN02")
        SetProjectionCode(pcvTransverseMercatorOstn02);
    else if (projectionMethod == "TransverseMercatorOSTN15")
        SetProjectionCode(pcvTransverseMercatorOstn15);
    else if (projectionMethod == "TransverseMercatorAffine")
        {
        SetProjectionCode(pcvTransverseMercatorAffinePostProcess);

        if (SUCCESS != SetProjectionValue("centralMeridian", [this](double v) {return SetCentralMeridian(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }))
            return result;

        double A0, A1, A2, B0, B1, B2;
        if (projectionVal["affine"].isNull())
            return MissingProperty("affine");

        auto affineVal = projectionVal["affine"];

        if(affineVal["translationX"].isNull() || affineVal["a1"].isNull()|| affineVal["a2"].isNull()||
           affineVal["translationY"].isNull()|| affineVal["b1"].isNull()|| affineVal["b2"].isNull())
            return MissingProperty("translationX, a1, a2, translationY, b1, b2");

        A0 = affineVal["translationX"].asDouble();
        A1 = affineVal["a1"].asDouble();
        A2 = affineVal["a2"].asDouble();
        B0 = affineVal["translationY"].asDouble();
        B1 = affineVal["b1"].asDouble();
        B2 = affineVal["b2"].asDouble();
        if (SUCCESS != (result = SetAffineParameters(A0, A1, A2, B0, B1, B2)))
            return BadProperty("translationX, a1, a2, translationY, b1, b2", result);
        }
    else if (projectionMethod == "LambertConformalConicAffine")
        {
        SetProjectionCode(pcvLambertConformalConicAffinePostProcess);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel1", [this](double v) {return SetStandardParallel1(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel2", [this](double v) {return SetStandardParallel2(v); }))
            return result;

        double A0, A1, A2, B0, B1, B2;
        if (projectionVal["affine"].isNull())
            return MissingProperty("affine");

        auto affineVal = projectionVal["affine"];

        if(affineVal["translationX"].isNull() || affineVal["a1"].isNull()|| affineVal["a2"].isNull()||
           affineVal["translationY"].isNull()|| affineVal["b1"].isNull()|| affineVal["b2"].isNull())
            return MissingProperty("translationX, a1, a2, translationY, b1, b2");

        A0 = affineVal["translationX"].asDouble();
        A1 = affineVal["a1"].asDouble();
        A2 = affineVal["a2"].asDouble();
        B0 = affineVal["translationY"].asDouble();
        B1 = affineVal["b1"].asDouble();
        B2 = affineVal["b2"].asDouble();
        if (SUCCESS != (result = SetAffineParameters(A0, A1, A2, B0, B1, B2)))
            return BadProperty("translationX, a1, a2, translationY, b1, b2", result);
        }
    else if (projectionMethod == "Krovak")
        {
        SetProjectionCode(pcvCzechKrovak);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel", [this](double v) {return SetStandardParallel1(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }) ||
            SUCCESS != SetProjectionValue("point1Latitude", [this](double v) {return SetPoint1Latitude(v); }) ||
            SUCCESS != SetProjectionValue("point1Longitude", [this](double v) {return SetPoint1Longitude(v); }))
            return result;
        }
    else if (projectionMethod == "KrovakModified")
        {
        SetProjectionCode(pcvCzechKrovakModified);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel", [this](double v) {return SetStandardParallel1(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }) ||
            SUCCESS != SetProjectionValue("point1Latitude", [this](double v) {return SetPoint1Latitude(v); }) ||
            SUCCESS != SetProjectionValue("point1Longitude", [this](double v) {return SetPoint1Longitude(v); }))
            return result;
        }
    else if (projectionMethod == "ObliqueCylindricalSwiss")
        {
        SetProjectionCode(pcvObliqueCylindricalSwiss);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }))
            return result;
        }
    else if (projectionMethod == "TransverseMercatorDenmarkSystem34")
        {
        SetProjectionCode(pcvTransverseMercatorDenmarkSys34);

        if (projectionVal["danishSystem34Region"].isNull())
            return MissingProperty("danishSystem34Region");

        if (SUCCESS != (result = SetDanishSys34Region(GetDanishSys34RegionCodeFromString(projectionVal["danishSystem34Region"].asString()))))
            return BadProperty("danishSystem34Region", result);
        }
   else if (projectionMethod == "TransverseMercatorDenmarkSystem3499")
        {
        SetProjectionCode(pcvTransverseMercatorDenmarkSys3499);

        if (projectionVal["danishSystem34Region"].isNull())
            return MissingProperty("danishSystem34Region");

        if (SUCCESS != (result = SetDanishSys34Region(GetDanishSys34RegionCodeFromString(projectionVal["danishSystem34Region"].asString()))))
            return BadProperty("danishSystem34Region", result);
        }
    else if (projectionMethod == "TransverseMercatorDenmarkSystem3401")
        {
        SetProjectionCode(pcvTransverseMercatorDenmarkSys3401);

        if (projectionVal["danishSystem34Region"].isNull())
            return MissingProperty("danishSystem34Region");

        if (SUCCESS != (result = SetDanishSys34Region(GetDanishSys34RegionCodeFromString(projectionVal["danishSystem34Region"].asString()))))
            return BadProperty("danishSystem34Region", result);
        }
    else if (projectionMethod == "Cassini")
        {
        SetProjectionCode(pcvCassini);

        if (SUCCESS != SetProjectionValue("centralMeridian", [this](double v) {return SetCentralMeridian(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }))
            return result;
        }
    else if (projectionMethod == "AzimuthalEqualArea")
        {
        SetProjectionCode(pcvLambertEqualAreaAzimuthal);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("azimuth", [this](double v) {return SetAzimuth(v); }))
            return result;
        }
    else if (projectionMethod == "ObliqueStereographic")
        {
        SetProjectionCode(pcvObliqueStereographic);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }))
            return result;
        }
    else if (projectionMethod == "Sinusoidal")
        {
        SetProjectionCode(pcvSinusoidal);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }))
            return result;
        }
    else if (projectionMethod == "VanDerGrinten")
        {
        SetProjectionCode(pcvVanderGrinten);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }))
            return result;
        }
    else if (projectionMethod == "Bonne")
        {
        SetProjectionCode(pcvBonne);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }))
            return result;
        }
    else if (projectionMethod == "Mollweide")
        {
        SetProjectionCode(pcvMollweide);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }))
            return result;
        }
    else if (projectionMethod == "EckertIV")
        {
        SetProjectionCode(pcvEckertIV);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }))
            return result;
        }
    else if (projectionMethod == "EckertVI")
        {
        SetProjectionCode(pcvEckertVI);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }))
            return result;
        }
    else if (projectionMethod == "GoodeHomolosine")
        {
        SetProjectionCode(pcvGoodeHomolosine);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }))
            return result;
        }
    else if (projectionMethod == "Robinson")
        {
        SetProjectionCode(pcvRobinsonCylindrical);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }))
            return result;
        }
    else if (projectionMethod == "PlateCarree")
        {
        SetProjectionCode(pcvPlateCarree);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }))
            return result;
        }
    else if (projectionMethod == "MillerCylindrical")
        {
        SetProjectionCode(pcvMillerCylindrical);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }))
            return result;
        }
    else if (projectionMethod == "WinkelTripel")
        {
        SetProjectionCode(pcvWinkelTripel);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel", [this](double v) {return SetStandardParallel1(v); }))
            return result;
        }
    else if (projectionMethod == "RectifiedSkewOrthomorphicCentered")
        {
        SetProjectionCode(pcvRectifiedSkewOrthomorphicCentered);

        if (SUCCESS != SetProjectionValue("centralPointLongitude", [this](double v) {return SetCentralPointLongitude(v); }) ||
            SUCCESS != SetProjectionValue("centralPointLatitude", [this](double v) {return SetCentralPointLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }) ||
            SUCCESS != SetProjectionValue("azimuth", [this](double v) {return SetAzimuth(v); }))
            return result;
        }
    else if (projectionMethod == "RectifiedSkewOrthomorphicOrigin")
        {
        SetProjectionCode(pcvRectifiedSkewOrthomorphicOrigin);

        if (SUCCESS != SetProjectionValue("centralPointLongitude", [this](double v) {return SetCentralPointLongitude(v); }) ||
            SUCCESS != SetProjectionValue("centralPointLatitude", [this](double v) {return SetCentralPointLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }) ||
            SUCCESS != SetProjectionValue("azimuth", [this](double v) {return SetAzimuth(v); }))
            return result;
        }
    else if (projectionMethod == "ObliqueCylindricalHungary")
        {
        SetProjectionCode(pcvObliqueCylindricalHungary);

        if (SUCCESS != SetProjectionValue("centralPointLongitude", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("centralPointLatitude", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("scaleFactor", [this](double v) {return SetScaleReduction(v); }) ||
            SUCCESS != SetProjectionValue("standardParallel", [this](double v) {return SetStandardParallel1(v); }))
            return result;
        }
    else if (projectionMethod == "Orthographic")
        {
        SetProjectionCode(pcvOrthographic);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }))
            return result;
        }
    else if (projectionMethod == "AmericanPolyconic")
        {
        SetProjectionCode(pcvAmericanPolyconic);

        if (SUCCESS != SetProjectionValue("centralMeridian", [this](double v) {return SetCentralMeridian(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }))
            return result;
        }
    else if (projectionMethod == "LambertEquidistantAzimuthal")
        {
        SetProjectionCode(pcvLambertEquidistantAzimuthal);

        if (SUCCESS != SetProjectionValue("longitudeOfOrigin", [this](double v) {return SetOriginLongitude(v); }) ||
            SUCCESS != SetProjectionValue("latitudeOfOrigin", [this](double v) {return SetOriginLatitude(v); }) ||
            SUCCESS != SetProjectionValue("azimuth", [this](double v) {return SetAzimuth(v); }))
            return result;
        }

    // The following projection methods do not have json representations but most are either obsolete or non-earth
    // or they are specific cases of methods but based on a sphere definition we do not want.
    // pcvRectifiedSkewOrthomorphic
    // pcvModifiedPolyconic
    // pcvEquidistantConic
    // pcvModifiedStereographic
    // pcvGnomonic
    // pcvEquidistantCylindrical
    // pcvEqualAreaAuthalicNormal
    // pcvEqualAreaAuthalicTransverse
    // pcvBipolarObliqueConformalConic
    // pcvPolarStereographic
    // pcvSnyderObliqueStereographic
    // pcvCzechKrovakObsolete
    // pcvObliqueConformalConic
    // pcvCzechKrovak95
    // pcvCzechKrovak95Obsolete
    // pcvNonEarth
    // pcvAzimuthalEquidistantElevatedEllipsoid
    // pcvNonEarthScaleRotation
    // pcvEquidistantCylindricalEllipsoid
    // pcvPopularVisualizationPseudoMercator

    // All projections have false easting and northing (except none and UTM)
    if (projectionMethod != "None" &&  projectionMethod != "UniversalTransverseMercator")
        {
        if (SUCCESS != SetProjectionValue("falseEasting", [this](double v) {return SetFalseEasting(v); }) ||
            SUCCESS != SetProjectionValue("falseNorthing", [this](double v) {return SetFalseNorthing(v); }))
            return result;
        }

    if (!jsonValue["extent"].isNull())
        {
        auto areaValue = jsonValue["extent"];
        if(areaValue["southWest"].isNull())
            return MissingProperty("extent southWest");
        if(areaValue["northEast"].isNull())
            return MissingProperty("extent northEast");
        if(areaValue["southWest"]["latitude"].isNull())
            return MissingProperty("extent southWest latitude");
        if(areaValue["southWest"]["longitude"].isNull())
            return MissingProperty("extent southWest longitude");
        if(areaValue["northEast"]["latitude"].isNull())
            return MissingProperty("extent northEast longitude");
        if(areaValue["northEast"]["longitude"].isNull())
            return MissingProperty("extent northEast longitude");

        double southWestLat = areaValue["southWest"]["latitude"].asDouble();
        double southWestLong = areaValue["southWest"]["longitude"].asDouble();
        double northEastLat = areaValue["northEast"]["latitude"].asDouble();
        double northEastLong = areaValue["northEast"]["longitude"].asDouble();

        if ((southWestLat > northEastLat) ||
            (southWestLat < -90.0) || (northEastLat > 90.0) || (southWestLong < -270.0) || (northEastLong > 270.0))
            return BadProperty("extent southWest/northEast latitude/longitude");

        SetMinimumLatitude(southWestLat);
        SetMaximumLatitude(northEastLat);

        // TODO: Normalize longitude for csmap convention once they are understood
        SetMinimumLongitude(southWestLong);
        SetMaximumLongitude(northEastLong);
        }

    StatusInt stat = DefinitionComplete();

    // Final fallback. EPSG code is specified and the rest of definition is incomplete
    if (SUCCESS != stat)
        {
        // GCS Can be set uniquely using the EPSG code
        // We initialize using the EPSG code. Note that there may be multiple variants and
        // This will result in an unpredictible definition if there are many.
        // For this reason after setting using the code we will continue parsing to correct data if it is provided.
        if (0 < epsgCode && 32767 > epsgCode)
            {
            if (SUCCESS == this->InitFromEPSGCode(NULL, NULL, epsgCode))
                {
                SetStoredEPSGCode((short)epsgCode);
                return (StatusInt)SUCCESS;
                }
            }
        }

    return stat;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::ToHorizontalJson(BeJsValue jsonValue, bool expandDatum) const
    {
    if (!IsLibraryInitialized())
        return GEOCOORDERR_GeoCoordNotInitialized;

    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    Utf8String sourceString;

    // TODO name property would contain the name for user-defined GCS, Datum, Ellipsoid
    // if (m_label.size() > 0)
    //    jsonValue["name"] = Utf8String(m_label.c_str());

    jsonValue["id"] = Utf8String(GetName());
    jsonValue["description"] = Utf8String(GetDescription());
    jsonValue["source"] = Utf8String(GetSource(sourceString));
    int theEPSGCode = GetStoredEPSGCode();
    if (theEPSGCode > 0)
        jsonValue["epsg"] = theEPSGCode;

    if (IsDeprecated())   // Default is false
        jsonValue["deprecated"] = true;

    // TODO We currently only support normal quadrant ...
    int quadrant = GetQuadrant();
    if (quadrant < 0 || quadrant > 1)
        return ERROR;

    DatumCP theDatum = nullptr;
    if (Utf8String(GetDatumName()) != "")
        theDatum = GetDatum();

    if (theDatum != nullptr && theDatum->IsValid())
        {
        jsonValue["datumId"] = Utf8String(theDatum->GetName());
        BeJsValue datumValue(jsonValue["datum"]);
        if (SUCCESS != theDatum->ToJson(datumValue, expandDatum))  // Here we expand ellipsoid also if requested
            {
            return ERROR;
            }

        // The datum json is always generated whether we need it or not ...
        // we do not want GCS convertible to json if their datum is not convertible to json.
        if (!expandDatum)
            jsonValue.removeMember("datum");
        }
    else
        {
        // No datum it is thus an ellipsoid based GCS in this case we add the ellipsoidid instead
        EllipsoidCP theEllipsoid = Ellipsoid::CreateEllipsoid(GetEllipsoidName());
        if (theEllipsoid == nullptr)
            return ERROR;

        jsonValue["ellipsoidId"] = Utf8String(theEllipsoid->GetName());

        // If datum expansion was requested then we expand the ellipsoid
        if (expandDatum)
            {
            BeJsValue ellipsoidVal(jsonValue["ellipsoid"]);
            if (SUCCESS != theEllipsoid->ToJson(ellipsoidVal))
                {
                theEllipsoid->Destroy();
                return ERROR;
                }
            }

        theEllipsoid->Destroy();
        }

    // CSMAP units are, for an unknown reason, completely inconsistent having any number
    // of case combination ... we normalize
    Utf8String unitString;
    if (0 == BeStringUtilities::Stricmp (m_csParameters->csdef.unit, "Meter"))
        unitString = "Meter";
    else if (0 == BeStringUtilities::Stricmp (m_csParameters->csdef.unit, "Foot"))
        unitString = "USSurveyFoot";
    else if (0 == BeStringUtilities::Stricmp (m_csParameters->csdef.unit, "ifoot"))
        unitString = "InternationalFoot";
    else if (0 == BeStringUtilities::Stricmp (m_csParameters->csdef.unit, "Degree"))
        unitString = "Degree";
    // TODO Do we really support grads? Doubtful still old French GCS (probably now unused) still use this unit
    //else if (0 == BeStringUtilities::Stricmp (m_csParameters->csdef.unit, "Grad"))
    //    unitString = "Grad";
    else
        return ERROR; // Currently the Json format only supports the previous units.

    jsonValue["unit"] = unitString;

    // Projections
    BeJsValue projectionVal(jsonValue["projection"]);
    projectionVal.toObject();
    switch (GetProjectionCode())
        {
        case GeoCoordinates::BaseGCS::pcvUnity:
            {
            projectionVal["method"] = "None";
            // We only support Greenwich prime meridian
            if (!doubleSame(0.0, GetOriginLongitude()))
                return ERROR;
            break;
            }

        case GeoCoordinates::BaseGCS::pcvTransverseMercator:
        case GeoCoordinates::BaseGCS::pcvTotalTransverseMercatorBF:
        case GeoCoordinates::BaseGCS::pcvSnyderTransverseMercator:
        case GeoCoordinates::BaseGCS::pcvTransverseMercatorKruger:
            {
            projectionVal["method"] = "TransverseMercator";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvGaussKrugerTranverseMercator:
            {
            projectionVal["method"] = "TransverseMercator";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["scaleFactor"] = 1.0;
            break;
            }

        case GeoCoordinates::BaseGCS::pcvAlbersEqualArea:
            {
            projectionVal["method"] = "AlbersEqualArea";

            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["standardParallel1"] = GetStandardParallel1();
            projectionVal["standardParallel2"] = GetStandardParallel2();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvMercator:
            {
            projectionVal["method"] = "MercatorStandardParallel";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["standardParallel"] = GetStandardParallel1();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvMercatorScaleReduction:
            {
            projectionVal["method"] = "MercatorScale";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["scaleFactor"] = GetScaleReduction();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvTotalUniversalTransverseMercator:
        case GeoCoordinates::BaseGCS::pcvUniversalTransverseMercator:
            {
            projectionVal["method"] = "UniversalTransverseMercator";
            projectionVal["zoneNumber"] = GetUTMZone();
            projectionVal["hemisphere"] = (GetHemisphere() >= 0 ? "North" : "South");
            break;
            }

        case GeoCoordinates::BaseGCS::pcvSouthOrientedTransverseMercator:
            {
            projectionVal["method"] = "SouthOrientedTransverseMercator";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvLambertConformalConicOneParallel:
        case GeoCoordinates::BaseGCS::pcvLambertTangential:
            {
            projectionVal["method"] = "LambertConformalConicOneParallel";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvLambertConformalConicTwoParallel:
            {
            projectionVal["method"] = "LambertConformalConicTwoParallels";

            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["standardParallel1"] = GetStandardParallel1();
            projectionVal["standardParallel2"] = GetStandardParallel2();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvLambertConformalConicBelgian:
            {
            projectionVal["method"] = "LambertConformalConicBelgium";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["standardParallel1"] = GetStandardParallel1();
            projectionVal["standardParallel2"] = GetStandardParallel2();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvLambertConformalConicWisconsin:
            {
            projectionVal["method"] = "LambertConformalConicWisconsin";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["standardParallel1"] = GetStandardParallel1();
            projectionVal["standardParallel2"] = GetStandardParallel2();
            projectionVal["elevationAboveGeoid"] = GetElevationAboveGeoid();
            // Geoid separation is always in meters but we want to be coherent with GCS units.
            projectionVal["geoidSeparation"] = GetGeoidSeparation() * UnitsFromMeters();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvTransverseMercatorWisconsin:
            {
            projectionVal["method"] = "TransverseMercatorWisconsin";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            projectionVal["elevationAboveGeoid"] = GetElevationAboveGeoid();
            // Geoid separation is always in meters but we want to be coherent with GCS units.
            projectionVal["geoidSeparation"] = GetGeoidSeparation() * UnitsFromMeters();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvLambertConformalConicMinnesota:
            {
            projectionVal["method"] = "LambertConformalConicMinnesota";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["standardParallel1"] = GetStandardParallel1();
            projectionVal["standardParallel2"] = GetStandardParallel2();
            projectionVal["elevationAboveGeoid"] = GetElevationAboveGeoid();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvTransverseMercatorMinnesota:
            {
            projectionVal["method"] = "TransverseMercatorMinnesota";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            projectionVal["elevationAboveGeoid"] = GetElevationAboveGeoid();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvObliqueMercatorMinnesota:
            {
            projectionVal["method"] = "ObliqueMercatorMinnesota";
            projectionVal["centralPointLongitude"] = GetCentralPointLongitude();
            projectionVal["centralPointLatitude"] = GetCentralPointLatitude();
            projectionVal["scaleFactor"] = 1.0;
            projectionVal["azimuth"] = GetAzimuth();
            projectionVal["elevationAboveGeoid"] = GetElevationAboveGeoid();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvLambertMichigan:
            {
            projectionVal["method"] = "LambertConformalConicMichigan";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["standardParallel1"] = GetStandardParallel1();
            projectionVal["standardParallel2"] = GetStandardParallel2();
            projectionVal["scaleFactor"] = GetEllipsoidScaleFactor();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvNewZealandNationalGrid:
            {
            projectionVal["method"] = "NewZealandNationalGrid";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvHotineObliqueMercator:
        case GeoCoordinates::BaseGCS::pcvHotineObliqueMercator1UV:
        case GeoCoordinates::BaseGCS::pcvHotineObliqueMercator1XY:
            {
            projectionVal["method"] = "ObliqueMercator1";
            projectionVal["centralPointLongitude"] = GetCentralPointLongitude();
            projectionVal["centralPointLatitude"] = GetCentralPointLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            projectionVal["azimuth"] = GetAzimuth();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvHotineObliqueMercator2UV:
        case GeoCoordinates::BaseGCS::pcvHotineObliqueMercator2XY:
            {
            projectionVal["method"] = "ObliqueMercator2";
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["point1Longitude"] = GetPoint1Longitude();
            projectionVal["point1Latitude"] = GetPoint1Latitude();
            projectionVal["point2Longitude"] = GetPoint2Longitude();
            projectionVal["point2Latitude"] = GetPoint2Latitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvTransverseMercatorOstn97:
            projectionVal["method"] = "TransverseMercatorOSTN97";
            break;

        case GeoCoordinates::BaseGCS::pcvTransverseMercatorOstn02:
            projectionVal["method"] = "TransverseMercatorOSTN02";
            break;

        case GeoCoordinates::BaseGCS::pcvTransverseMercatorOstn15:
            projectionVal["method"] = "TransverseMercatorOSTN15";
            break;

        case GeoCoordinates::BaseGCS::pcvTransverseMercatorAffinePostProcess:
            {
            projectionVal["method"] = "TransverseMercatorAffine";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();

            double A0 = 0.0, A1 = 0.0, A2 = 0.0, B0 = 0.0, B1 = 0.0, B2 = 0.0;
            GetAffineParameters(&A0, &A1, &A2, &B0, &B1, &B2);
            BeJsValue affineVal(projectionVal["affine"]);
            affineVal["translationX"] = A0;
            affineVal["a1"] = A1;
            affineVal["a2"] = A2;
            affineVal["translationY"] = B0;
            affineVal["b1"] = B1;
            affineVal["b2"] = B2;
            break;
            }

        case GeoCoordinates::BaseGCS::pcvLambertConformalConicAffinePostProcess:
            {
            projectionVal["method"] = "LambertConformalConicAffine";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["standardParallel1"] = GetStandardParallel1();
            projectionVal["standardParallel2"] = GetStandardParallel2();

            double A0 = 0.0, A1 = 0.0, A2 = 0.0, B0 = 0.0, B1 = 0.0, B2 = 0.0;
            GetAffineParameters(&A0, &A1, &A2, &B0, &B1, &B2);
            BeJsValue affineVal(projectionVal["affine"]);
            affineVal["translationX"] = A0;
            affineVal["a1"] = A1;
            affineVal["a2"] = A2;
            affineVal["translationY"] = B0;
            affineVal["b1"] = B1;
            affineVal["b2"] = B2;

            break;
            }

        case GeoCoordinates::BaseGCS::pcvCzechKrovak:
            {
            projectionVal["method"] = "Krovak";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["standardParallel"] = GetStandardParallel1();
            projectionVal["scaleFactor"] = GetScaleReduction();
            projectionVal["point1Latitude"] = GetPoint1Latitude();
            projectionVal["point1Longitude"] = GetPoint1Longitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvCzechKrovakModified:
            {
            projectionVal["method"] = "KrovakModified";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["standardParallel"] = GetStandardParallel1();
            projectionVal["scaleFactor"] = GetScaleReduction();
            projectionVal["point1Latitude"] = GetPoint1Latitude();
            projectionVal["point1Longitude"] = GetPoint1Longitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvObliqueCylindricalSwiss:
            {
            projectionVal["method"] = "ObliqueCylindricalSwiss";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvTransverseMercatorDenmarkSys34:
            {
            projectionVal["method"] = "TransverseMercatorDenmarkSystem34";
            projectionVal["danishSystem34Region"] = GetDanishSys34RegionStringFromCode(GetDanishSys34Region()).c_str();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvTransverseMercatorDenmarkSys3499:
            {
            projectionVal["method"] = "TransverseMercatorDenmarkSystem3499";
            projectionVal["danishSystem34Region"] = GetDanishSys34RegionStringFromCode(GetDanishSys34Region()).c_str();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvTransverseMercatorDenmarkSys3401:
            {
            projectionVal["method"] = "TransverseMercatorDenmarkSystem3401";
            projectionVal["danishSystem34Region"] = GetDanishSys34RegionStringFromCode(GetDanishSys34Region()).c_str();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvCassini:
            {
            projectionVal["method"] = "Cassini";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvLambertEqualAreaAzimuthal:
            {
            projectionVal["method"] = "AzimuthalEqualArea";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["azimuth"] = GetAzimuth();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvObliqueStereographic:
            {
            projectionVal["method"] = "ObliqueStereographic";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvSinusoidal:
            {
            projectionVal["method"] = "Sinusoidal";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvVanderGrinten:
            {
            projectionVal["method"] = "VanDerGrinten";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvBonne:
            {
            projectionVal["method"] = "Bonne";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvMollweide:
            {
            projectionVal["method"] = "Mollweide";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvEckertIV:
            {
            projectionVal["method"] = "EckertIV";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvEckertVI:
            {
            projectionVal["method"] = "EckertVI";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvGoodeHomolosine:
            {
            projectionVal["method"] = "GoodeHomolosine";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvRobinsonCylindrical:
            {
            projectionVal["method"] = "Robinson";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvPlateCarree:
            {
            projectionVal["method"] = "PlateCarree";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvMillerCylindrical:
            {
            projectionVal["method"] = "MillerCylindrical";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvWinkelTripel:
            {
            projectionVal["method"] = "WinkelTripel";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["standardParallel"] = GetStandardParallel1();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvRectifiedSkewOrthomorphicCentered:
            {
            projectionVal["method"] = "RectifiedSkewOrthomorphicCentered";
            projectionVal["centralPointLongitude"] = GetCentralPointLongitude();
            projectionVal["centralPointLatitude"] = GetCentralPointLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            projectionVal["azimuth"] = GetAzimuth();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvRectifiedSkewOrthomorphicOrigin:
            {
            projectionVal["method"] = "RectifiedSkewOrthomorphicOrigin";
            projectionVal["centralPointLongitude"] = GetCentralPointLongitude();
            projectionVal["centralPointLatitude"] = GetCentralPointLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            projectionVal["azimuth"] = GetAzimuth();

            break;
            }

        case GeoCoordinates::BaseGCS::pcvObliqueCylindricalHungary:
            {
            projectionVal["method"] = "ObliqueCylindricalHungary";
            projectionVal["centralPointLongitude"] = GetOriginLongitude();
            projectionVal["centralPointLatitude"] = GetOriginLatitude();
            projectionVal["scaleFactor"] = GetScaleReduction();
            projectionVal["standardParallel"] = GetStandardParallel1();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvOrthographic:
            {
            projectionVal["method"] = "Orthographic";

            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvAmericanPolyconic:
            {
            projectionVal["method"] = "AmericanPolyconic";
            projectionVal["centralMeridian"] = GetCentralMeridian();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            break;
            }

        case GeoCoordinates::BaseGCS::pcvLambertEquidistantAzimuthal:
            {
            projectionVal["method"] = "LambertEquidistantAzimuthal";
            projectionVal["longitudeOfOrigin"] = GetOriginLongitude();
            projectionVal["latitudeOfOrigin"] = GetOriginLatitude();
            projectionVal["azimuth"] = GetAzimuth();
            break;
            }

        // The following projection method have no Json representation
        case GeoCoordinates::BaseGCS::pcvModifiedPolyconic:
        case GeoCoordinates::BaseGCS::pcvEquidistantConic:
        case GeoCoordinates::BaseGCS::pcvModifiedStereographic:
        case GeoCoordinates::BaseGCS::pcvGnomonic:
        case GeoCoordinates::BaseGCS::pcvEquidistantCylindrical:
        case GeoCoordinates::BaseGCS::pcvEqualAreaAuthalicNormal:
        case GeoCoordinates::BaseGCS::pcvEqualAreaAuthalicTransverse:
        case GeoCoordinates::BaseGCS::pcvBipolarObliqueConformalConic:
        case GeoCoordinates::BaseGCS::pcvPolarStereographic:
        case GeoCoordinates::BaseGCS::pcvSnyderObliqueStereographic:
        case GeoCoordinates::BaseGCS::pcvCzechKrovakObsolete:
        case GeoCoordinates::BaseGCS::pcvObliqueConformalConic:
        case GeoCoordinates::BaseGCS::pcvCzechKrovak95:
        case GeoCoordinates::BaseGCS::pcvCzechKrovak95Obsolete:
        case GeoCoordinates::BaseGCS::pcvPolarStereographicStandardLatitude:
        case GeoCoordinates::BaseGCS::pcvNonEarth:
        case GeoCoordinates::BaseGCS::pcvAzimuthalEquidistantElevatedEllipsoid:
        case GeoCoordinates::BaseGCS::pcvNonEarthScaleRotation:
        case GeoCoordinates::BaseGCS::pcvEquidistantCylindricalEllipsoid:
        case GeoCoordinates::BaseGCS::pcvPopularVisualizationPseudoMercator:
            return ERROR;

        default:
            return ERROR; // If we get there then a new projection method has been introduced.

    }

    // All projections except none and UTM have false easting and northing
    if (GetProjectionCode() != GeoCoordinates::BaseGCS::pcvUnity &&
        GetProjectionCode() != GeoCoordinates::BaseGCS::pcvTotalUniversalTransverseMercator &&
        GetProjectionCode() != GeoCoordinates::BaseGCS::pcvUniversalTransverseMercator)
        {
        projectionVal["falseEasting"] = GetFalseEasting();
        projectionVal["falseNorthing"] = GetFalseNorthing();
        }

    // Provide extent (if defined)
    if (GetMinimumLongitude() < GetMaximumLongitude() && GetMinimumLatitude() < GetMaximumLatitude())
        {
        BeJsValue extent(jsonValue["extent"]);
        extent.toObject();
        BeJsValue southWestPoint(extent["southWest"]);
        southWestPoint["latitude"] = GetMinimumLatitude();
        southWestPoint["longitude"] = GetMinimumLongitude();

        BeJsValue northEastPoint(extent["northEast"]);
        northEastPoint["latitude"] = GetMaximumLatitude();
        northEastPoint["longitude"] = GetMaximumLongitude();
        }

    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::FromVerticalJson(BeJsConst jsonValue, Utf8StringR errorMessage) {
    // Error processing lambda definitions
    auto MissingProperty = [&errorMessage](Utf8CP name) {
        errorMessage.Sprintf("'%s' is missing", name);
        return GEOCOORDERR_MissingPropertyOrParameter;
    };

    if (!IsLibraryInitialized())
        return GEOCOORDERR_GeoCoordNotInitialized;

    // Indicate is modified ... this clears all cache parameters.
    SetModified(true);

    // The vertical portion cannot be set on an invalid horizontally defined GCS
    if (NULL == m_csParameters) {
        errorMessage = "BaseGCS is invalid (uninitialized)";
        return GEOCOORDERR_InvalidCoordSys;
    }

    if (jsonValue["id"].isNull())
        return MissingProperty("id");

    Utf8String verticalDatumString = jsonValue["id"].asString();

    VertDatumCode vertCode = vdcFromDatum;
    if ((0 == verticalDatumString.CompareToI("NGVD29")) && (IsNAD27() || IsNAD83()))
        vertCode = vdcNGVD29;
    else if ((0 == verticalDatumString.CompareToI("NAVD88")) && (IsNAD27() || IsNAD83()))
        vertCode = vdcNAVD88;
    else if (0 == verticalDatumString.CompareToI("GEOID"))
        vertCode = vdcGeoid;
    else if (0 == verticalDatumString.CompareToI("ELLIPSOID"))
        vertCode = vdcEllipsoid;
    else if (0 == verticalDatumString.CompareToI("LOCAL_ELLIPSOID") && !HasWGS84CoincidentDatum())
        vertCode = vdcLocalEllipsoid;
    else
        {
        errorMessage = "Invalid id. Must be one of NGVD29, NAVD88 (if horizontal datum is NAD27 or NAD83) or ELLIPSOID or GEOID.";
        return GEOCOORDERR_BadArg;
        }

    return SetVerticalDatumCode(vertCode);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::ToVerticalJson(BeJsValue jsonValue) const {
    if (!IsLibraryInitialized())
        return GEOCOORDERR_GeoCoordNotInitialized;

    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    jsonValue["id"] = Utf8String(VerticalDatumKeyFromGCS(*this));

    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::FromLocalTransformerJson(BeJsConst jsonValue, Utf8StringR errorMessage) {
    m_localTransformer = LocalTransformer::CreateLocalTransformerFromJson(jsonValue, errorMessage);

    return ((m_localTransformer != nullptr) ? SUCCESS : ERROR);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::ToLocalTransformerJson(BeJsValue jsonValue) const {
    if (!IsLibraryInitialized())
        return GEOCOORDERR_GeoCoordNotInitialized;

    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    if (m_localTransformer.IsValid())
        return m_localTransformer->ToJson(jsonValue, true);

    return SUCCESS; // If we get there it simply means there was no transformer so we add nothing
}

/*---------------------------------------------------------------------------------**//**
* CartesianFromCartesian - Converts from the Cartesian representation of a GCS to
* the Cartesian of the target.
* @return
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus BaseGCS::CartesianFromCartesian(DPoint3dR outCartesian, DPoint3dCR inCartesian, BaseGCSCR targetGCS) const
    {
    ReprojectStatus status = REPROJECT_Success;

    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return (ReprojectStatus)m_csError;
        }

	if (NULL == m_csParameters)
		return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

	if (NULL == targetGCS.m_csParameters)
		return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;


    ReprojectStatus   stat1;
    ReprojectStatus   stat2;
    ReprojectStatus   stat3;

    GeoPoint inLatLong;
    stat1 = LatLongFromCartesian (inLatLong, inCartesian);

    GeoPoint outLatLong;
    stat2 = LatLongFromLatLong(outLatLong, inLatLong, targetGCS);

    stat3 = targetGCS.CartesianFromLatLong(outCartesian, outLatLong);

    if (REPROJECT_Success == status)
        {
        // Status returns hardest error found in the three error statuses
        // The hardest error is the first one encountered that is not a warning (value 1 [REPROJECT_CSMAPERR_OutOfUsefulRange])
        if (REPROJECT_Success != stat1)
            status = stat1;
        if ((REPROJECT_Success != stat2) && ((REPROJECT_Success == status) || (REPROJECT_CSMAPERR_OutOfUsefulRange == status) || (REPROJECT_CSMAPERR_VerticalDatumConversionError == status))) // If stat2 has error and status not already hard error
            {
            if (0 > stat2) // If stat2 is negative ... this is the one ...
                status = stat2;
            else  // Both are positive (status may be REPROJECT_Success) we use the highest value which is either warning or error
                status = (stat2 > status ? stat2 : status);
            }
        if ((REPROJECT_Success != stat3) && ((REPROJECT_Success == status) || (REPROJECT_CSMAPERR_OutOfUsefulRange == status) || (REPROJECT_CSMAPERR_VerticalDatumConversionError == status))) // If stat3 has error and status not already hard error
            {
            if (0 > stat3) // If stat3 is negative ... this is the one ...
                status = stat3;
            else  // Both are positive (status may be SUCCESS) we use the highest value
                status = (stat3 > status ? stat3 : status);
            }
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* Derived from CartesianFromCartesian
* CartesianFromECEF - Converts from ECEF to the Cartesian of the target.
* @return
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
/* static */
ReprojectStatus BaseGCS::CartesianFromECEF(DPoint3dR outCartesian, DPoint3dCR inECEF, BaseGCSCR targetGCS)
    {
    ReprojectStatus status = REPROJECT_Success;

    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        return (ReprojectStatus)GEOCOORDERR_GeoCoordNotInitialized;

    // Ensure ECEF GCS is initialized
    if (!InitializeBaseGcsECEF())
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    if (NULL == targetGCS.m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;


    ReprojectStatus   stat1;
    ReprojectStatus   stat2;
    ReprojectStatus   stat3;

    GeoPoint inLatLong;
    stat1 = s_LL84GCS->LatLongFromXYZ(inLatLong, inECEF);

    GeoPoint outLatLong;
    stat2 = s_LL84GCS->LatLongFromLatLong(outLatLong, inLatLong, targetGCS);

    stat3 = targetGCS.CartesianFromLatLong(outCartesian, outLatLong);

    if (REPROJECT_Success == status)
        {
        // Status returns hardest error found in the three error statuses
        // The hardest error is the first one encountered that is not a warning (value 1 [REPROJECT_CSMAPERR_OutOfUsefulRange])
        if (REPROJECT_Success != stat1)
            status = stat1;
        if ((REPROJECT_Success != stat2) && ((REPROJECT_Success == status) || (REPROJECT_CSMAPERR_OutOfUsefulRange == status) || (REPROJECT_CSMAPERR_VerticalDatumConversionError == status))) // If stat2 has error and status not already hard error
            {
            if (0 > stat2) // If stat2 is negative ... this is the one ...
                status = stat2;
            else  // Both are positive (status may be REPROJECT_Success) we use the highest value which is either warning or error
                status = (stat2 > status ? stat2 : status);
            }
        if ((REPROJECT_Success != stat3) && ((REPROJECT_Success == status) || (REPROJECT_CSMAPERR_OutOfUsefulRange == status) || (REPROJECT_CSMAPERR_VerticalDatumConversionError == status))) // If stat3 has error and status not already hard error
            {
            if (0 > stat3) // If stat3 is negative ... this is the one ...
                status = stat3;
            else  // Both are positive (status may be SUCCESS) we use the highest value
                status = (stat3 > status ? stat3 : status);
            }
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* CartesianFromCartesian - Converts from the Cartesian representation of a GCS to ECEF
* @return
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus  BaseGCS::ECEFFromCartesian(DPoint3dR outECEF, DPoint3dCR inCartesian) const
    {
    ReprojectStatus status = REPROJECT_Success;

    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return (ReprojectStatus)m_csError;
        }

    // Ensure ECEF GCS is initialized
    if (!InitializeBaseGcsECEF())
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    if (NULL == m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    ReprojectStatus   stat1;
    ReprojectStatus   stat2;
    ReprojectStatus   stat3;

    GeoPoint inLatLong;
    stat1 = LatLongFromCartesian(inLatLong, inCartesian);

    GeoPoint outLatLong;
    stat2 = LatLongFromLatLong(outLatLong, inLatLong, *s_LL84GCS);

    stat3 = s_LL84GCS->XYZFromLatLong(outECEF, outLatLong);

    if (REPROJECT_Success == status)
        {
        // Status returns hardest error found in the three error statuses
        // The hardest error is the first one encountered that is not a warning (value 1 [REPROJECT_CSMAPERR_OutOfUsefulRange])
        if (REPROJECT_Success != stat1)
            status = stat1;
        if ((REPROJECT_Success != stat2) && ((REPROJECT_Success == status) || (REPROJECT_CSMAPERR_OutOfUsefulRange == status) || (REPROJECT_CSMAPERR_VerticalDatumConversionError == status))) // If stat2 has error and status not already hard error
            {
            if (0 > stat2) // If stat2 is negative ... this is the one ...
                status = stat2;
            else  // Both are positive (status may be REPROJECT_Success) we use the highest value which is either warning or error
                status = (stat2 > status ? stat2 : status);
            }
        if ((REPROJECT_Success != stat3) && ((REPROJECT_Success == status) || (REPROJECT_CSMAPERR_OutOfUsefulRange == status) || (REPROJECT_CSMAPERR_VerticalDatumConversionError == status))) // If stat3 has error and status not already hard error
            {
            if (0 > stat3) // If stat3 is negative ... this is the one ...
                status = stat3;
            else  // Both are positive (status may be SUCCESS) we use the highest value
                status = (stat3 > status ? stat3 : status);
            }
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* Derived from DgnGCS::GetLocalTransform
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus       BaseGCS::GetLinearTransform
(
    TransformP              outTransform,       // <= the transform effective at the point elementOrigin in source coordinates
    DRange3dCR              extent,             // => the extent in source GCS coordinate to use to find the transform.
    BaseGCSCR               targetGCS,          // => target coordinate system
    double*                 maxError,           // => If provided receives the max error observed over the extent
    double*                 meanError           // => If provided receives the mean error observed over the extent
) const
    {

    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return (ReprojectStatus)m_csError;
        }

    if (NULL == m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    if (NULL == targetGCS.m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    if (extent.IsEmpty() || extent.IsNull())
        return REPROJECT_BadArgument;

    // If input and output GCS are identical this gets rid of computational errors and returns immediately
    if (IsEqual(targetGCS))
        {
        outTransform->InitIdentity();

        if (maxError != nullptr)
            *maxError = 0.0;

        if (meanError != nullptr)
            *meanError = 0.0;

        return REPROJECT_Success;
        }

    const double linearTolerance = 0.01;
    double tolerance = linearTolerance;

    if (!IsProjected())
        tolerance = 0.0000001; // Tolerance for longitude/latitude GCS in degrees

    // Extent must be large enough so we can effectively compute coordinate differences
    // since the geocoord engine will stop calculations when 0.001 per iteration is reached.
    if (extent.XLength() < tolerance || extent.YLength() < tolerance || extent.ZLength() < linearTolerance) // Z allways uses linear tolerance
        return REPROJECT_BadArgument;

    Transform   frameA, frameB, frameAInverse;
    DPoint3d    points[4];


    DPoint3d elementOrigin;

    elementOrigin.Init(((extent.low.x + extent.high.x) / 2.0),
                       ((extent.low.y + extent.high.y) / 2.0),
                       ((extent.low.z + extent.high.z) / 2.0));

    points[0] = elementOrigin;
    points[1].Init(elementOrigin.x + 1.0, elementOrigin.y, elementOrigin.z) ;
    points[2].Init(elementOrigin.x, elementOrigin.y + 1.0, elementOrigin.z) ;
    points[3].Init(elementOrigin.x, elementOrigin.y, elementOrigin.z + 1.0) ;

    DPoint3d transformedPoints[4];

    // Transform the points
    ReprojectStatus status = REPROJECT_Success;
    for (size_t i = 0 ; i < 4 ; i++)
        {
        ReprojectStatus currentStatus = CartesianFromCartesian(transformedPoints[i], points[i], targetGCS);

        if (REPROJECT_Success == status) // No warning previously occured ...
            status = currentStatus;
        else if ((REPROJECT_Success != currentStatus) && (status != REPROJECT_CSMAPERR_VerticalDatumConversionError))
            status = currentStatus; // We keep vertical datum error which is a little 'harder' than out of user domain

        // Check for hard error and stop if there is one
        if ((REPROJECT_Success != status) && (REPROJECT_CSMAPERR_OutOfUsefulRange != currentStatus) && (REPROJECT_CSMAPERR_VerticalDatumConversionError != currentStatus) )
            return status; // Hard error ... we exit method immediately
        }

    frameA.InitFrom4Points (points[0], points[1], points[2], points[3]);
    frameAInverse.InverseOf (frameA);

    frameB.InitFrom4Points (transformedPoints[0], transformedPoints[1], transformedPoints[2], transformedPoints[3]);

    outTransform->InitProduct(frameB, frameAInverse);

    if ((meanError != nullptr) || (maxError != nullptr))
        {
        ReprojectStatus analysisStatus = REPROJECT_Success;

        if (maxError != nullptr)
            *maxError = 0.0;

        double totalError = 0.0;
        double numberOfSamples = 0;
        // Error analysis is requested ...
        double xStep = (extent.high.x - extent.low.x) / 4.0;
        for (double currentX = extent.low.x ; currentX <= extent.high.x + (xStep * 0.00000001) ; currentX += xStep) // The epsilon insures we process the high value
            {
            double yStep = (extent.high.y - extent.low.y) / 4.0;
            for (double currentY = extent.low.y ; currentY <= extent.high.y + (yStep * 0.00000001); currentY += yStep) // The epsilon insures we process the high value
                {
                DPoint3d inCartesian;
                DPoint3d outCartesianGCS;
                inCartesian.Init(currentX, currentY, elementOrigin.z);

                // Transform normally
                analysisStatus = CartesianFromCartesian(outCartesianGCS, inCartesian, targetGCS);

                if ((REPROJECT_Success == analysisStatus) || (REPROJECT_CSMAPERR_OutOfUsefulRange == status) || (REPROJECT_CSMAPERR_VerticalDatumConversionError == status) )
                    {
                    // Not a hard error ... we use.

                    // Transform using produced transform
                    DPoint3d outCartesianTRF;
                    outTransform->Multiply(outCartesianTRF, inCartesian);

                    // Compute difference and cumulate
                    double diffX = outCartesianGCS.x - outCartesianTRF.x;
                    double diffY = outCartesianGCS.y - outCartesianTRF.y;
                    double diffZ = outCartesianGCS.z - outCartesianTRF.z;
                    double currentError = sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);

                    if ((maxError != nullptr) && (*maxError < currentError))
                        *maxError = currentError;

                    totalError += currentError;
                    numberOfSamples++;
                    }
                }
            }

        // Compute mean error from total error
        if ((meanError != nullptr) && (numberOfSamples >= 1))
            *meanError = totalError / numberOfSamples;
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* Derived from BaseGCS::GetLinearTransform
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
/* static */
ReprojectStatus       BaseGCS::GetLinearTransformECEF
(
    TransformP              outTransform,       // <= the transform effective at the point elementOrigin in source coordinates
    DRange3dCR              extentECEF,         // => the extent in ECEF coordinate to use to find the transform.
    BaseGCSCR               targetGCS,          // => target coordinate system
    double*                 maxError,           // => If provided receives the max error observed over the extent
    double*                 meanError           // => If provided receives the mean error observed over the extent
)
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        return  (ReprojectStatus)GEOCOORDERR_GeoCoordNotInitialized;

    // Ensure ECEF GCS is initialized
    if (!InitializeBaseGcsECEF())
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    if (NULL == targetGCS.m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    if (extentECEF.IsEmpty() || extentECEF.IsNull())
        return REPROJECT_BadArgument;

    const double linearTolerance = 0.01; // ECEF tolerance always meter

    // Extent must be large enough so we can effectively compute coordinate differences
    // since the geocoord engine will stop calculations when 0.001 per iteration is reached.
    if (extentECEF.XLength() < linearTolerance || extentECEF.YLength() < linearTolerance || extentECEF.ZLength() < linearTolerance) // Z allways uses linear tolerance
        return REPROJECT_BadArgument;

    Transform   frameA, frameB, frameAInverse;
    DPoint3d    points[4];

    DPoint3d elementOrigin;

    elementOrigin.Init((( extentECEF.low.x + extentECEF.high.x) / 2.0),
                        ((extentECEF.low.y + extentECEF.high.y) / 2.0),
                        ((extentECEF.low.z + extentECEF.high.z) / 2.0));

    points[0] = elementOrigin;
    points[1].Init(elementOrigin.x + 1.0, elementOrigin.y, elementOrigin.z);
    points[2].Init(elementOrigin.x, elementOrigin.y + 1.0, elementOrigin.z);
    points[3].Init(elementOrigin.x, elementOrigin.y, elementOrigin.z + 1.0);

    DPoint3d transformedPoints[4];

    // Transform the points
    ReprojectStatus status = REPROJECT_Success;
    for (size_t i = 0; i < 4; i++)
        {
        ReprojectStatus currentStatus = CartesianFromECEF(transformedPoints[i], points[i], targetGCS);

        if (REPROJECT_Success == status) // No warning previously occured ...
            status = currentStatus;
        else if ((REPROJECT_Success != currentStatus) && (status != REPROJECT_CSMAPERR_VerticalDatumConversionError))
            status = currentStatus; // We keep vertical datum error which is a little 'harder' than out of user domain

        // Check for hard error and stop if there is one
        if ((REPROJECT_Success != status) && (REPROJECT_CSMAPERR_OutOfUsefulRange != currentStatus) && (REPROJECT_CSMAPERR_VerticalDatumConversionError != currentStatus) )
            return status; // Hard error ... we exit method immediately
        }

    frameA.InitFrom4Points(points[0], points[1], points[2], points[3]);
    frameAInverse.InverseOf(frameA);

    frameB.InitFrom4Points(transformedPoints[0], transformedPoints[1], transformedPoints[2], transformedPoints[3]);

    outTransform->InitProduct(frameB, frameAInverse);

    if ((meanError != nullptr) || (maxError != nullptr))
        {
        ReprojectStatus analysisStatus = REPROJECT_Success;

        if (maxError != nullptr)
            *maxError = 0.0;

        double totalError = 0.0;
        double numberOfSamples = 0;
        // Error analysis is requested ...
        double xStep = (extentECEF.high.x - extentECEF.low.x ) / 4.0;
        for (double currentX = extentECEF.low.x; currentX <= extentECEF.high.x + (xStep * 0.00000001); currentX += xStep) // The epsilon insures we process the high value
            {
            double yStep = (extentECEF.high.y - extentECEF.low.y) / 4.0;
            for (double currentY = extentECEF.low.y; currentY <= extentECEF.high.y + (yStep * 0.00000001); currentY += yStep) // The epsilon insures we process the high value
                {
                DPoint3d inECEF;
                DPoint3d outCartesianGCS;
                inECEF.Init(currentX, currentY, elementOrigin.z);

                // Transform normally
                analysisStatus = CartesianFromECEF(outCartesianGCS, inECEF, targetGCS);

                if ((REPROJECT_Success == analysisStatus) || (REPROJECT_CSMAPERR_OutOfUsefulRange == status) || (REPROJECT_CSMAPERR_VerticalDatumConversionError == status))
                    {
                    // Not a hard error ... we use.

                    // Transform using produced transform
                    DPoint3d outCartesianTRF;
                    outTransform->Multiply(outCartesianTRF, inECEF);

                    // Compute difference and cumulate
                    double diffX = outCartesianGCS.x - outCartesianTRF.x;
                    double diffY = outCartesianGCS.y - outCartesianTRF.y;
                    double diffZ = outCartesianGCS.z - outCartesianTRF.z;
                    double currentError = sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);

                    if ((maxError != nullptr) && (*maxError < currentError))
                        *maxError = currentError;

                    totalError += currentError;
                    numberOfSamples++;
                    }
                }
            }

        // Compute mean error from total error
        if ((meanError != nullptr) && (numberOfSamples >= 1))
            *meanError = totalError / numberOfSamples;
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* Derived from BaseGCS::GetLinearTransform
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus       BaseGCS::GetLinearTransformToECEF
(
    TransformP              outTransform,
    DRange3dCR              extent,
    double*                 maxError,
    double*                 meanError
) const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return (ReprojectStatus)m_csError;
        }

    // Ensure ECEF GCS is initialized
    if (!InitializeBaseGcsECEF())
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    if (NULL == m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    if (extent.IsEmpty() || extent.IsNull())
        return REPROJECT_BadArgument;

    const double linearTolerance = 0.01;
    double tolerance = linearTolerance;

    if (!IsProjected())
        tolerance = 0.0000001; // Tolerance for longitude/latitude GCS in degrees

    // Extent must be large enough so we can effectively compute coordinate differences
    // since the geocoord engine will stop calculations when 0.001 per iteration is reached.
    if (extent.XLength() < tolerance || extent.YLength() < tolerance || extent.ZLength() < linearTolerance) // Z allways uses linear tolerance
        return REPROJECT_BadArgument;

    Transform   frameA, frameB, frameAInverse;
    DPoint3d    points[4];

    DPoint3d elementOrigin;

    elementOrigin.Init(((   extent.low.x + extent.high.x) / 2.0),
                          ((extent.low.y + extent.high.y) / 2.0),
                          ((extent.low.z + extent.high.z) / 2.0));

    points[0] = elementOrigin;
    points[1].Init(elementOrigin.x + 1.0, elementOrigin.y, elementOrigin.z);
    points[2].Init(elementOrigin.x, elementOrigin.y + 1.0, elementOrigin.z);
    points[3].Init(elementOrigin.x, elementOrigin.y, elementOrigin.z + 1.0);

    DPoint3d transformedPoints[4];

    // Transform the points
    ReprojectStatus status = REPROJECT_Success;
    for (size_t i = 0; i < 4; i++)
        {
        ReprojectStatus currentStatus = ECEFFromCartesian(transformedPoints[i], points[i]);

        if (REPROJECT_Success == status) // No warning previously occured ...
            status = currentStatus;
        else if ((REPROJECT_Success != currentStatus) && (status != REPROJECT_CSMAPERR_VerticalDatumConversionError))
            status = currentStatus; // We keep vertical datum error which is a little 'harder' than out of user domain

        // Check for hard error and stop if there is one
        if ((REPROJECT_Success != status) && (REPROJECT_CSMAPERR_OutOfUsefulRange != currentStatus) && (REPROJECT_CSMAPERR_VerticalDatumConversionError != currentStatus) )
            return status; // Hard error ... we exit method immediately
        }

    frameA.InitFrom4Points(points[0], points[1], points[2], points[3]);
    frameAInverse.InverseOf(frameA);

    frameB.InitFrom4Points(transformedPoints[0], transformedPoints[1], transformedPoints[2], transformedPoints[3]);

    outTransform->InitProduct(frameB, frameAInverse);

    if ((meanError != nullptr) || (maxError != nullptr))
        {
        ReprojectStatus analysisStatus = REPROJECT_Success;

        if (maxError != nullptr)
            *maxError = 0.0;

        double totalError = 0.0;
        double numberOfSamples = 0;
        // Error analysis is requested ...

        double xStep = (extent.high.x - extent.low.x) / 4.0;
        for (double currentX = extent.low.x; currentX <= extent.high.x + (xStep * 0.00000001); currentX += xStep)
            {
            double yStep = (extent.high.y - extent.low.y) / 4.0;
            for (double currentY = extent.low.y; currentY <= extent.high.y + (yStep * 0.00000001); currentY += yStep)
                {
                DPoint3d inCartesian;
                DPoint3d outECEF;
                inCartesian.Init(currentX, currentY, elementOrigin.z);

                // Transform normally
                analysisStatus = ECEFFromCartesian(outECEF, inCartesian);

                if ((REPROJECT_Success == analysisStatus) || (REPROJECT_CSMAPERR_OutOfUsefulRange == status) || (REPROJECT_CSMAPERR_VerticalDatumConversionError == status))
                    {
                    // Not a hard error ... we use.

                    // Transform using produced transform
                    DPoint3d outECEFTRF;
                    outTransform->Multiply(outECEFTRF, inCartesian);

                    // Compute difference and cumulate
                    double diffX = outECEF.x - outECEFTRF.x;
                    double diffY = outECEF.y - outECEFTRF.y;
                    double diffZ = outECEF.z - outECEFTRF.z;
                    double currentError = sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);

                    if ((maxError != nullptr) && (*maxError < currentError))
                        *maxError = currentError;

                    totalError += currentError;
                    numberOfSamples++;
                    }
                }
            }

        // Compute mean error from total error
        if ((meanError != nullptr) && (numberOfSamples >= 1))
            *meanError = totalError / numberOfSamples;
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::InitFromWellKnownText
(
StatusInt              *warning,            // Warning. Function returns SUCCESS, but some warning desribed in ERRMSG and warning, passed back.
Utf8StringP             warningOrErrorMsg,  // Error message.
WktFlavor               wktFlavor,          // The WKT Flavor.
Utf8CP                  wellKnownText       // The Well Known Text specifying the coordinate system.
)
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return GEOCOORDERR_GeoCoordNotInitialized;
        }

    AllocateClean();

    SetModified(true);

    if (NULL != warning)
        *warning = SUCCESS;

    GeoCoordParseStatus parseStatus = GeoCoordParse_Error;

    SRSWKTParser theWKTParser;
    parseStatus = theWKTParser.Process (*this, wellKnownText);

    StatusInt status = SUCCESS;
    if (GeoCoordParse_Success != parseStatus)
        status = ERROR;

    if ((GeoCoordParse_Success == parseStatus) && (IsValid()))
        {
        // Clear error in case it occured before
        m_csError = 0;
        if (warningOrErrorMsg)
            warningOrErrorMsg->clear();
        }
    else
        {
        CSDefinition        csDef;
        CSDatumDef          csDatumDef;
        CSEllipsoidDef      csEllipsoidDef;

        int csmapStatus = CSMap::CS_wktToCsEx (&csDef, &csDatumDef, &csEllipsoidDef, wktFlavor, wellKnownText);

        // Bursa Wolf implementation is flawed as forward/inverse drift significantly.
        // As 7 param is the generalized and precise version this is what we use.
        // No WKT should be interpreted as Bursa-Wolfe.
        if (csDatumDef.to84_via == cs_DTCTYP_BURS)
            csDatumDef.to84_via = cs_DTCTYP_7PARM;

        if (SUCCESS != csmapStatus)
            {
            if (NULL != warningOrErrorMsg)
                {
                char    csErrorMsg[512];
                CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
                *warningOrErrorMsg = csErrorMsg;
                }
            // process warnings.
            if ((csmapStatus & ~(StatusInt)(cs_EL2WKT_NMTRUNC | cs_DT2WKT_NMTRUNC | cs_CS2WKT_NMTRUNC | cs_DT2WKT_DTDEF | cs_DT2WKT_NODEF)) == 0)
                {
                if (NULL != warning)
                    *warning = csmapStatus;
                status = SUCCESS;
                }
            else
                m_csError = cs_Error;
            }

        // We impose that the datum be known in the dictionary ... something the WKT parser does not require
        // If the datum is not part of dictionary then we set the return status to ERROR and the process will get caught
        // by the fallback solution.
        CSDatumDef* datumFromDico = NULL;
        if (NULL != (datumFromDico = CSMap::CS_dtdef (csDatumDef.key_nm)))
            {
            CSMap::CS_free (datumFromDico);

            if (NULL == (m_csParameters = CSMap::CScsloc2 (&csDef, &csDatumDef, &csEllipsoidDef)))
                {
                if (NULL != warningOrErrorMsg)
                    {
                    char    csErrorMsg[512];
                    CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
                    *warningOrErrorMsg = csErrorMsg;
                    }
                m_csError = cs_Error;
                }
            else
                {
                // Clear error in case it occured before
                status = SUCCESS;
                m_csError = 0;
                if (warningOrErrorMsg)
                    warningOrErrorMsg->clear();
                }
            }
        }

    // Although the parser supports LOCAL_CS we do not want to support it in BaseGCS.
    if (GetProjectionCode() == BaseGCS::pcvNonEarth)
        {
        // This must be done in case of error since the parser allocates the structure but cannot destroy it
        CSMAP_FREE_AND_CLEAR(m_csParameters);
        status = ERROR;
        }

    // this will cause the type 66 to be saved with coordSysId set the same as projType.
    m_coordSysId = 0;

    // Even if invalid it is indicated as unmodified.
    SetModified(false);

    // Save the original WKT in case the user wants it back
    if (IsValid() && (SUCCESS == status))
        {
        DELETE_AND_CLEAR (m_originalWKT);
        m_originalWKT = new Utf8String(wellKnownText);
        }

    return status;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus       BaseGCS::InitFromWellKnownText
(
    StatusInt              *warning,            // Warning. Function returns SUCCESS, but some warning desribed in ERRMSG and warning, passed back.
    Utf8StringP             warningOrErrorMsg,  // Error message.
    Utf8CP                  wellKnownText       // The Well Known Text specifying the coordinate system.
)
{
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GeoCoordParse_GeoCoordNotInitialized;
        return GeoCoordParse_GeoCoordNotInitialized;
        }

    AllocateClean();

    SetModified(true);

    if (NULL != warning)
        *warning = SUCCESS;

    GeoCoordParseStatus status = GeoCoordParse_Error;

    SRSWKTParser theWKTParser;
    status = theWKTParser.Process (*this, wellKnownText);

    if ((GeoCoordParse_Success == status) && (IsValid()))
        {
        // Clear error in case it occured before
        m_csError = 0;
        if (warningOrErrorMsg)
            warningOrErrorMsg->clear();
        }
    else
        {
        CSDefinition        csDef;
        CSDatumDef          csDatumDef;
        CSEllipsoidDef      csEllipsoidDef;

        int csmapStatus = CSMap::CS_wktToCsEx (&csDef, &csDatumDef, &csEllipsoidDef, wktFlavorAutodesk, wellKnownText);

        // Bursa Wolf implementation is flawed as forward/inverse drift significantly.
        // As 7 param is the generalized and precise version this is what we use.
        // No WKT should be interpreted as Bursa-Wolfe.
        if (csDatumDef.to84_via == cs_DTCTYP_BURS)
            csDatumDef.to84_via = cs_DTCTYP_7PARM;

        if (SUCCESS != csmapStatus)
            {
            if (NULL != warningOrErrorMsg)
                {
                char    csErrorMsg[512];
                CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
                *warningOrErrorMsg = csErrorMsg;
                }
            // process warnings.
            if ((csmapStatus & ~(StatusInt)(cs_EL2WKT_NMTRUNC | cs_DT2WKT_NMTRUNC | cs_CS2WKT_NMTRUNC | cs_DT2WKT_DTDEF | cs_DT2WKT_NODEF)) == 0)
                {
                if (NULL != warning)
                    *warning = csmapStatus;
                status = GeoCoordParse_Success;
                }
            else
                m_csError = cs_Error;
            }

        // We impose that the datum be known in the dictionary ... something the WKT parser does not require
        // If the datum is not part of dictionary then we set the return status to ERROR and the process will get caught
        // by the fallback solution.
        CSDatumDef* datumFromDico = NULL;
        if (NULL != (datumFromDico = CSMap::CS_dtdef (csDatumDef.key_nm)))
            {
            CSMap::CS_free (datumFromDico);

            CSMAP_FREE_AND_CLEAR(m_csParameters);

            if (NULL == (m_csParameters = CSMap::CScsloc2 (&csDef, &csDatumDef, &csEllipsoidDef)))
                {
                if (NULL != warningOrErrorMsg)
                    {
                    char    csErrorMsg[512];
                    CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
                    *warningOrErrorMsg = csErrorMsg;
                    }
                m_csError = cs_Error;
                }
            else
                {
                // Clear error in case it occured before
                status = GeoCoordParse_Success;
                m_csError = 0;
                if (warningOrErrorMsg)
                    warningOrErrorMsg->clear();
                }
            }
        }

    // Although the parser supports LOCAL_CS we do not want to support it in BaseGCS.
    if (GetProjectionCode() == BaseGCS::pcvNonEarth)
        {
        // This must be done in case of error since the parser allocates the structure but cannot destroy it
        CSMAP_FREE_AND_CLEAR(m_csParameters);
        status = GeoCoordParse_BadGCS;
        }

    // this will cause the type 66 to be saved with coordSysId set the same as projType.
    m_coordSysId = 0;

    // Even if invalid it is indicated as unmodified.
    SetModified(false);

    // Save the original WKT in case the user wants it back
    if (IsValid() && (GeoCoordParse_Success == status))
        {
        DELETE_AND_CLEAR (m_originalWKT);
        m_originalWKT = new Utf8String(wellKnownText);
        }

    return status;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoCoordParseStatus       BaseGCS::InitFromOSGEOXML
(
    Utf8CP                 osgeoXML
)
{
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return (GeoCoordParseStatus)m_csError;
        }

    AllocateClean();
    SetModified(true);

    GeoCoordParseStatus           status = GeoCoordParse_Success;

    OSGEOXMLParser theXMLParser;
    status = theXMLParser.Process (*this, osgeoXML);

    // this will cause the type 66 to be saved with coordSysId set the same as projType.
    m_coordSysId = 0;

    // Even if invalid it is indicated as unmodified.
    SetModified(false);

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::InitFromEPSGCode
(
StatusInt              *warning,            // Warning. Function returns SUCCESS, but some warning desribed in ERRMSG and warning, passed back.
Utf8StringP             warningOrErrorMsg,  // Error message.
int                     epsgCode
)
    {
    if (epsgCode > 65535)
        return ERROR;

    Utf8String tentativeName; // Used to store match that are deprecated (will allow to continue search for a non-deprecated value)

    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return m_csError;
        }

    Clear();
    InitHorizontal();
    SetModified(true);

    if (NULL != warning)
        *warning = SUCCESS;

    // first try to find a coordinate system called EPSG:nnnnn
    Utf8Char        csName[256];
    BeStringUtilities::Snprintf (csName, "EPSG:%d", epsgCode);

    if (NULL == (m_csParameters = CSMap::CS_csloc (csName)))
        {
        m_csError = cs_Error;
        }
    else
        {
        if (IsDeprecated())
            tentativeName = csName;
        else
            {
            // since we looked it up, we put COORDSYS_KEYNM as the coordsys in the type 66 element.
            m_coordSysId = COORDSYS_KEYNM;
            SetModified(false);
            return SUCCESS;
            }
        }

    // if we get here, we didn't find an EPSG GCS from the synthesized name. We'll look in CS-Map's look-up table.

    char            coordSysName[128];
    enum EcsMapSt   csMapSt;
    coordSysName[0] = '\0';

    csMapSt = csMapIdToNameC (csMapProjGeoCSys,
                              coordSysName,
                              sizeof (coordSysName),
                              csMapFlvrCsMap,
                              csMapFlvrEpsg,
                              static_cast<uint32_t>(epsgCode));

    if (csMapSt == csMapOk)
        {
        CSParameters* otherCsParameters;
        if (NULL != (otherCsParameters = CSMap::CS_csloc(coordSysName)))
            {
            CSMAP_FREE_AND_CLEAR (m_csParameters);

            m_csParameters = otherCsParameters;
            // Even if there is already a tentative Name we prefer this one over the 'EPSG:XYZW' once as all of those of not recommended.
            if (IsDeprecated())
                tentativeName = Utf8String(coordSysName);
            else
                {
                // Not legacy ... we use that one.
                m_coordSysId = COORDSYS_KEYNM;
                SetModified(false);
                m_csError = 0; // Clear potential previous error
                return SUCCESS;
                }
            }
        }

    // Final attempt ... search all entries for stored epsg property
    Utf8String gcsName;
    if (SUCCESS == FindGCSNameFromEPSGCode(gcsName, static_cast<uint16_t>(epsgCode)))
        {
        SetFromCSName(gcsName.c_str());
        return SUCCESS;
        }

    SetModified(false);
    return m_csError;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::GetWellKnownText
(
Utf8StringR         wellKnownText,      // The WKT.
WktFlavor           wktFlavor,          // The WKT Flavor.
bool                originalIfPresent,   // true indicates that if the BaseGCS originates from a WKT fragment then this WKT should be returned
bool                doNotInsertTOWGS84,
bool                posVectorRotationSignConvention
) const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return m_csError;
        }

    if (originalIfPresent && m_originalWKT != nullptr && !m_originalWKT->empty())
        {
        // NOTE: Even if the original WKT was a COMPD_CS we return it as it is
        // regardless the method usually returns non-COMPD_CS
        wellKnownText = *m_originalWKT;
        return SUCCESS;

        }
    char        stringBuf[10240];
    StatusInt   status;
    wellKnownText.clear();

    short wktFlags = wktFlavorUnknown == wktFlavor ? 0 : cs_WKTFLG_MAPNAMES;
    if (doNotInsertTOWGS84)
        wktFlags |= cs_WKTFLG_NOTOWGS84;
    if (posVectorRotationSignConvention)
        wktFlags |= cs_WKTFLG_PVROTSIGNS;

    if (0 > (status = CScs2WktEx (stringBuf, sizeof(stringBuf), (ErcWktFlavor) wktFlavor, &m_csParameters->csdef, NULL, NULL, wktFlags)))
        return status;
    wellKnownText = Utf8String(stringBuf);
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::GetCompoundCSWellKnownText
(
Utf8StringR         wellKnownText,      // The WKT.
WktFlavor           wktFlavor,           // The WKT Flavor.
bool                originalIfPresent,   // true indicates that if the BaseGCS originates from a WKT fragment then this WKT should be returned
bool                doNotInsertTOWGS84,
bool                posVectorRotationSignConvention
) const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return m_csError;
        }

    // Obtain the GCS well known text
    Utf8String temp;
    StatusInt status = SUCCESS;

    // If original WKT is requested and present we copy it otherwise we generate the WKT
    if (originalIfPresent && m_originalWKT != nullptr && !m_originalWKT->empty())
        temp = *m_originalWKT;
    else
        status = GetWellKnownText(temp, wktFlavor, false, doNotInsertTOWGS84, posVectorRotationSignConvention);

    if (SUCCESS == status)
        {
        // If the WKT comes from the original WKT it may already contain a COMPD clause
        // in this case we do not add one.
        if (temp.substr(0, 8) == "COMPD_CS")
            wellKnownText = temp;
        else
            {
            // No COMPD_CS clause ... we add one and add VERT_CS clause at end
            wellKnownText = Utf8String("COMPD_CS[\"") + GetName() + "\",";
            wellKnownText += temp;            // Add plain WKT PROJCS or GEOCS section

            // We complete with Vertical Datum section
            // First determine the texts to be added for various items.
            // WKT texts are not usually meant to be translatable so we use English names when applicable
            VertDatumCode verticalCode = NetVerticalDatumFromGCS(*this);
            Utf8String verticalCSName;
            Utf8String verticalDatumWKTCode;
            Utf8String verticalCSAuthorityName = "EPSG"; // We only support EPSG authority name at the moment
            Utf8String verticalCSAuthorityCode;
            Utf8String verticalDatumName;
            Utf8String verticalDatumAuthorityName = "EPSG"; // We only support EPSG authority name at the moment
            Utf8String verticalDatumAuthorityCode;

            if ((vdcFromDatum == verticalCode) || (vdcEllipsoid == verticalCode))
                {
                verticalCSName = "Ellipsoid Height";
                verticalDatumWKTCode = "2002";
                verticalDatumName = "Ellipsoid";
                // EPSG database defines no code for ellipsoidal height since it is not really a vertical datum
                }
            else if (vdcNGVD29 == verticalCode)
                {
                verticalCSName = "NGVD29";

                verticalDatumWKTCode = "2005";  // Although we use it differently NGVD29 is a geoid vertical CS
                verticalDatumName = "NGVD29";
                verticalCSAuthorityCode = "5702";
                verticalDatumAuthorityCode = "5102";
                }
            else if (vdcNAVD88 == verticalCode)
                {
                verticalCSName = "NAVD88";
                verticalDatumWKTCode = "2005";  // Although we use it differently NAVD88 is a geoid vertical CS
                verticalDatumName = "NAVD88";
                verticalCSAuthorityCode = "5703";
                verticalDatumAuthorityCode = "5103";
                }
            else if (vdcGeoid == verticalCode)
                {
                verticalCSName = "Generic Geoid";
                verticalDatumWKTCode = "2005";
                verticalDatumName = "Generic Vertical Datum";
                // Since we are dealing with a generic Geoid there is no authority code defined
                }
            else
                {
                // This section is only useful in case future version data that uses new datum code unknown to present
                // still results in a valid compound WKT though vertical cs identifiers can then only be guesses.
                verticalCSName = "Unknown Vertical CS";
                verticalDatumName = "Unknown Vertical Datum";
                verticalDatumWKTCode = "2000";  // We use the code for 'other' vertical cs
                }

            wellKnownText += ",VERT_CS[\"" + verticalCSName + "\",VERT_DATUM[\"" + verticalDatumName + "\"," + verticalDatumWKTCode;

            // We only add authority names and code for the OGC flavor
            if ((wktFlavorOGC == wktFlavor) && (verticalDatumAuthorityCode != ""))
                {
                wellKnownText += ",AUTHORITY[\"" + verticalDatumAuthorityName + "\",\"" + verticalDatumAuthorityCode + "\"]";
                }

            // Close VERT_DATUM section
            wellKnownText += "]";

            // UNIT Section
            wellKnownText += ",UNIT[\"";
            Utf8Char conversionFactor[20];
            snprintf(conversionFactor, 20, "%lf", UnitsFromMeters());
            Utf8String unitName;
            GetUnits(unitName);
            // NOTE: When we have a lat/long coordinate system then vertical units are 'meters' assumed.
            if (GetProjectionCode() ==  BaseGCS::pcvUnity)
                unitName = "Meters";

            wellKnownText +=  unitName + "\"," + conversionFactor;

            // We only add authority names and code for the OGC flavor
            if ((wktFlavorOGC == wktFlavor) && GetEPSGUnitCode() != 0)
                {
                wchar_t unitCode[10];
                BeStringUtilities::Itow(unitCode, GetEPSGUnitCode(), 10, 10);
                wellKnownText += ",AUTHORITY[\"EPSG\",\"" + Utf8String(unitCode) + "\"]";
                }

            wellKnownText += "]";

            // We only add AXIS section for the OGC flavor
            if (wktFlavorOGC == wktFlavor)
                wellKnownText += ",AXIS[\"Up\", UP]"; // We only support the UP axis direction

            // We only add authority names and code for the OGC flavor
            if ((wktFlavorOGC == wktFlavor) && (verticalCSAuthorityCode != ""))
                {
                wellKnownText += ",AUTHORITY[\"" + verticalCSAuthorityName + "\",\"" + verticalCSAuthorityCode + "\"]";
                }

            // Close both VERT_CS section and COMPD_CS section
            wellKnownText += "]]";
            }
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::InitFromGeoTiffKeys
(
StatusInt*              warning,            // Warning. Function returns SUCCESS, but some warning desribed in ERRMSG and warning, passed back.
Utf8StringP             warningOrErrorMsg,  // Error message.
IGeoTiffKeysList const* geoTiffKeys,         // The GeoTiff key list
bool                    allowUnitsOverride   // Indicates if the presence of a unit can override GCS units.
)
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return m_csError;
        }

    SetModified(true);

    StatusInt status;
    // The GeoTiffKeyInterpreter maintains state while parsing the geoTiffKeys, and we can have private methods without having to put then on BaseGCS.
    if (NULL == geoTiffKeys)
        return GEOCOORDERR_BadArg;

    GeoTiffKeyInterpreter   interpreter;
    status = interpreter.Process (*this, warning, warningOrErrorMsg, *geoTiffKeys, allowUnitsOverride);
    if (SUCCESS == status)
        {
        if (NULL != m_originalGeoKeys)
            DELETE_AND_CLEAR(m_originalGeoKeys);

        m_originalGeoKeys = new BaseGeoTiffKeysList();

        // We keep a copy of the geotiff keys to be able to give it back if the BaseGCS owner wants it.
        bool                                gotKey;
        IGeoTiffKeysList::GeoKeyItem        geoKey;

        for (gotKey = geoTiffKeys->GetFirstKey (&geoKey); gotKey ; gotKey = geoTiffKeys->GetNextKey (&geoKey))
            {
            if (geoKey.KeyDataType == IGeoTiffKeysList::ASCII)
                m_originalGeoKeys->AddKey(geoKey.KeyID, std::string(geoKey.KeyValue.StringVal));
            else if (geoKey.KeyDataType == IGeoTiffKeysList::LONG)
                m_originalGeoKeys->AddKey(geoKey.KeyID, geoKey.KeyValue.LongVal);
            else if (geoKey.KeyDataType == IGeoTiffKeysList::DOUBLE)
                m_originalGeoKeys->AddKey(geoKey.KeyID, geoKey.KeyValue.DoubleVal);
            }
        }

    SetModified(false);

    return status;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::SetGeoTiffKeys
(
IGeoTiffKeysList*       geoTiffKeys         // The GeoTiff key list to add geokeys to
) const
    {
    return GetGeoTiffKeys(geoTiffKeys, false);
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::GetGeoTiffKeys
(
IGeoTiffKeysList*       geoTiffKeys,         // The GeoTiff key list to add geokeys to
bool                    originalsIfPresent   // true indicates the original geokeys should be returned
) const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return m_csError;
        }

    // The GeoTiffKeyInterpreter maintains state while parsing the geoTiffKeys, and we can have private methods without having to put then on BaseGCS.
    if (NULL == geoTiffKeys)
        return GEOCOORDERR_BadArg;

    if (originalsIfPresent && NULL != m_originalGeoKeys)
        {
        IGeoTiffKeysList::GeoKeyItem        geoKey;
        bool                                gotKey;

        for (gotKey = m_originalGeoKeys->GetFirstKey (&geoKey); gotKey ; gotKey = m_originalGeoKeys->GetNextKey (&geoKey))
            {
            if (geoKey.KeyDataType == IGeoTiffKeysList::ASCII)
                geoTiffKeys->AddKey(geoKey.KeyID, std::string(geoKey.KeyValue.StringVal));
            else if (geoKey.KeyDataType == IGeoTiffKeysList::LONG)
                geoTiffKeys->AddKey(geoKey.KeyID, geoKey.KeyValue.LongVal);
            else if (geoKey.KeyDataType == IGeoTiffKeysList::DOUBLE)
                geoTiffKeys->AddKey(geoKey.KeyID, geoKey.KeyValue.DoubleVal);
            }

        return SUCCESS;
        }

    // Original geo keys not present or not requested ... we build a new set
    GeoTiffKeyCreator   creator (*this, *geoTiffKeys);
    return creator.SaveGCS ();
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::CanSaveDatumToGeoTiffKeys () const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return false;
        }

    if (0 != m_csParameters->datum.key_nm[0])
        return (0 != GetEPSGDatumCode());
    else if (0 != m_csParameters->datum.ell_knm[0])
        return (0 != GetEPSGEllipsoidCode());
    else // user defined prime meridian, etc.
        return true;
    }

/*---------------------------------------------------------------------------------**//**
*   @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::CanSaveToGeoTiffKeys () const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return false;
        }

    bool isGeographic = (cs_PRJCOD_UNITY == m_csParameters->prj_code);
    int  epsgCode;

    // first see if it's an EPSG without doing the search through the other CS's for a match. That's quick.
    epsgCode = GetEPSGCode (true);

    // Check if an EPSG code was found. If it is not geographic then we go with it. If it is geographic
    // we impose that the EPSG code be a valid EPSG entry in the 4000ths (we tolerate Datum codes instead 6000ths of GCS codes as it happens frequently)
    if ( (0 != epsgCode) && (!isGeographic || ((epsgCode >= 6000) && (epsgCode < 7000)) || ((epsgCode >= 4000) && (epsgCode < 5000)) ))
        return true;

    // then do the relatively quick check to see if it's one we could save as user define if we have to.
    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMER:
        case cs_PRJCOD_HOM1XY:
        case cs_PRJCOD_MRCAT:
        case cs_PRJCOD_MRCATK:
        case cs_PRJCOD_LM2SP:
        case cs_PRJCOD_LM1SP:
        case cs_PRJCOD_AZMEA:
        case cs_PRJCOD_ALBER:
        case cs_PRJCOD_AZMED:
        case cs_PRJCOD_EDCNC:
        case cs_PRJCOD_SSTRO:
        case cs_PRJCOD_PSTRO:
        case cs_PRJCOD_OSTRO:
        case cs_PRJCOD_EDCYL:
        case cs_PRJCOD_CSINI:
        case cs_PRJCOD_GNOMC:
        case cs_PRJCOD_MILLR:
        case cs_PRJCOD_ORTHO:
        case cs_PRJCOD_PLYCN:
        case cs_PRJCOD_ROBIN:
        case cs_PRJCOD_SINUS:
        case cs_PRJCOD_VDGRN:
        case cs_PRJCOD_NZLND:
        case cs_PRJCOD_SOTRM:
        case cs_PRJCOD_UNITY:
            if (CanSaveDatumToGeoTiffKeys())
                return true;
        }

#if defined (NOTNOW)
    // not obvious that it's EPSG, can't save as user defined. look for matching EPSG (time consuming).
    epsgCode = GetEPSGCode (false);
    if ( (0 != epsgCode) && (!isGeographic || ((epsgCode >= 6000) && (epsgCode < 7000) )))
        return true;
#endif

    // couldn't find a way to save as GeoTiff
    return false;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::~BaseGCS
(
)
    {
    Clear();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
CSParameters*   BaseGCS::GetCSParameters () const
    {
    return m_csParameters;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
size_t          BaseGCS::GetCSParametersSize () const
    {
    return sizeof(*m_csParameters);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int             BaseGCS::Matches
(
char const * const * matchStrings,
int                  numMixedCase,
int                  numUpperCase,
bool                 anyWord
) const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return 0;
        }

    if ( (NULL == m_csParameters) || (numMixedCase <= 0) )
        return 0;

    // the number of mixed case should always equal or exceed the number of uppercase. Exceed happens when you enter something such that strupr(string).Equals(string).
    BeAssert (numMixedCase >= numUpperCase);

    // Use a string object to avoid static security analysis error about potentiall unterminated strings.
    Utf8String concatString(m_csParameters->csdef.key_nm);
    concatString.append(m_csParameters->csdef.dat_knm);
    concatString.append(m_csParameters->csdef.elp_knm);
    concatString.append(m_csParameters->csdef.desc_nm);
    concatString.append(m_csParameters->csdef.group);
    concatString.append(m_csParameters->csdef.locatn);
    concatString.append(m_csParameters->csdef.source);
    int epsgCode;
    if (0 != (epsgCode = GetEPSGCode (true)))
        {
        char epsgString[40];
        snprintf (epsgString, sizeof(epsgString), "%d", epsgCode);
        concatString.append(epsgString);
        }

    int score=0;

    if (anyWord)
        {
        // can match any word, so use a score based on the word position, and whether it matches the original or upper case.
        // first half of the input strings are the users typed-in case versions. Those are more valuable matches.
        int iScoreMultiple = numMixedCase;
        for (int iString=0; iString < numMixedCase; iString++, iScoreMultiple--)
            {
            char const* searchString        = matchStrings[iString];
            if (NULL != strstr (concatString.c_str(), searchString))
                score += iScoreMultiple * 10;
            }

        // second half of the input strings are the upper case versions.
        std::transform(concatString.begin(), concatString.end(), concatString.begin(), [](char const& c){return (char)toupper(c);});
        iScoreMultiple = numMixedCase + 1;
        for (int iString=numMixedCase; iString < numMixedCase + numUpperCase; iString++, iScoreMultiple--)
            {
            char const* searchString        = matchStrings[iString];
            if (NULL != strstr (concatString.c_str(), searchString))
                score += iScoreMultiple * 7;
            }
        }
    else
        {
        Utf8String upperCaseConcatString(concatString);
        std::transform(upperCaseConcatString.begin(), upperCaseConcatString.end(), upperCaseConcatString.begin(), [](char const& c){return (char)toupper(c);});

        // can match any word, so use a score based on the word position, and whether it matches the original or upper case.
        // first half of the input strings are the users typed-in case versions. Those are more valuable matches.
        int iScoreMultiple = numMixedCase + numUpperCase + 1;
        for (int iString=0; iString < numMixedCase; iString++, iScoreMultiple--)
            {
            char const* searchString            = matchStrings[iString];
            char const* upperCaseSearchString   = matchStrings[numMixedCase + iString];

            if (NULL != strstr (concatString.c_str(), searchString))
                score += iScoreMultiple * 10;
            else if ( (iString < numUpperCase) && (NULL != strstr (upperCaseConcatString.c_str(), upperCaseSearchString)) )
                score += iScoreMultiple * 7;
            else
                return 0;
            }
        return score;
        }

    BeAssert (score >= 0);
    return score;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::Validate
(
T_Utf8StringVector&    errorList
) const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return false;
        }

    int csMapErrors[128];
    int errorCount;

    // check the datum or ellipsoid separately, because those might be coming from user libraries.
    errorCount = CS_cschk (&m_csParameters->csdef, 0, csMapErrors, DIM (csMapErrors));

    if (0 != m_csParameters->csdef.dat_knm[0])
        {
        CSDatumDef* datumDef;
        if (NULL == (datumDef = CSMap::CS_dtdef (this->GetDatumName())))
            csMapErrors[errorCount++] = cs_CSQ_INVDTM;
        else
            CSMap::CS_free (datumDef);
        }
    else if (0 != m_csParameters->csdef.elp_knm[0])
        {
        CSEllipsoidDef* ellipsoidDef;
        if (NULL == (ellipsoidDef = CSMap::CS_eldef(this->GetEllipsoidName())))
            csMapErrors[errorCount++] = cs_CSQ_INVELP;
        else
            CSMap::CS_free (ellipsoidDef);
        }

    for (int iError=0; iError < errorCount; iError++)
        {
        Utf8String thisError;
        errorList.push_back (GetErrorMessage (thisError, csMapErrors[iError]));
        }

    return (0 == errorCount);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::IsValid () const
    {
    return  ((NULL != m_csParameters) && (0 == m_csError));
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::IsStandard () const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return false;
        }

    return  COORDSYS_KEYNM == m_coordSysId;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int             BaseGCS::GetError () const
    {
    return m_csError;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP         BaseGCS::GetErrorMessage (Utf8StringR errorMsg) const
    {
    char    csErrorMsg[512];
    CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
    errorMsg = csErrorMsg;
    return errorMsg.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            GetLocalizedErrorMessage
(
Utf8StringR    message,
int         messageOffset,
bool        geoCoordError       // true for our error codes, false for CSMap error codes.
)
    {
    message.Sprintf ("GeoCoord error %d\n", messageOffset + GeoCoordErrorBase);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP         BaseGCS::GetErrorMessage (Utf8StringR errorMsg, StatusInt  errorCode)
    {
    // this needs work for internationalization, and for handling non CSMap errors.
    errorMsg.clear();

    // the GeoCoordErrors are negative, starting at GeoCoordErrorBase and working to larger negative numbers.
    if ( (errorCode < GeoCoordErrorBase) && (errorCode > GeoCoordErrorEnd) )
        GetLocalizedErrorMessage (errorMsg, GeoCoordErrorBase - errorCode, true);
    else if (cs_CNVRT_RNG == errorCode)
        GetLocalizedErrorMessage (errorMsg, GeoCoordErrorBase - GEOCOORDERR_CoordinateRange, true);
    else
        {
        char msg[1024];
        CSMap::CSerpt(msg, DIM(msg), errorCode);
        errorMsg = msg;
        }

    return errorMsg.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP        BaseGCS::GetName () const
    {
    if (NULL == m_csParameters)
        return "";

    if (NULL == m_nameString)
        m_nameString = new Utf8String (m_csParameters->csdef.key_nm);

    return m_nameString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetName (Utf8CP name)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    CS_stncp (m_csParameters->csdef.key_nm, name, sizeof (m_csParameters->csdef.key_nm));

    if (NULL != m_nameString)
        m_nameString->assign (name);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP     BaseGCS::GetDescription () const
    {
    if (NULL == m_csParameters)
        return "";

    if (NULL == m_descriptionString)
        m_descriptionString = new Utf8String (m_csParameters->csdef.desc_nm);

    return  m_descriptionString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetDescription (Utf8CP description)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    CS_stncp (m_csParameters->csdef.desc_nm, description, sizeof (m_csParameters->csdef.desc_nm));

    if (NULL != m_descriptionString)
        m_descriptionString->assign (description);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP    BaseGCS::GetProjection () const
    {
    if (NULL == m_csParameters)
        return "";

    if (NULL == m_projectionString)
        m_projectionString = new Utf8String (m_csParameters->csdef.prj_knm);

    return  m_projectionString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::ProjectionCodeValue  BaseGCS::GetProjectionCode () const
    {
    if (NULL != m_csParameters)
        return (BaseGCS::ProjectionCodeValue) m_csParameters->prj_code;
    else
        return pcvInvalid;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int         BaseGCS::SetProjectionCode
(
BaseGCS::ProjectionCodeValue  value
)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    int     oldCode = m_csParameters->prj_code;

    // We want to set both the prj_code and the prj_knm
    // make sure we can find the projection code in the table.
    const struct cs_Prjtab_   *projection;
    for (projection = cs_Prjtab; 0 != projection->key_nm[0]; projection++)
        {
        if (projection->code == value)
            {
            m_csParameters->prj_code = value;
            CS_stncp (m_csParameters->csdef.prj_knm, projection->key_nm, sizeof (m_csParameters->csdef.prj_knm));
            break;
            }
        }
    // if we go to the end without finding the code, error.
    if (0 == projection->key_nm[0])
        return GEOCOORDERR_InvalidCoordinateCode;

    // Now determine what to do with the parameters in the 'new' projection.


    // look at the flags to determine what "standard" parameters aren't used, and zero those out.
    // no false origin if cs_PRJFLG_ORGFLS is set.
    if (0 != (projection->flags & cs_PRJFLG_ORGFLS))
        {
        m_csParameters->csdef.x_off = 0.0;
        m_csParameters->csdef.y_off = 0.0;
        }

    // scale reduction supported only if cs_PRJFLG_SCLRED set.
    if ( (0 == (projection->flags & cs_PRJFLG_SCLRED)) || (0.0 == m_csParameters->csdef.scl_red) )
        m_csParameters->csdef.scl_red = 1.0;

    // no origin latitude if cs_PRJFLG_ORGLAT is set.
    if (0 != (projection->flags & cs_PRJFLG_ORGLAT))
        m_csParameters->csdef.org_lat = 0.0;

    // no origin longitude if cs_PRJFLG_ORGLNF is set.
    if (0 != (projection->flags & cs_PRJFLG_ORGLNG))
        m_csParameters->csdef.org_lng = 0.0;


    // find the old an new cs_PrjprmMap_ structure
    struct cs_PrjprmMap_ *oldParamMap = NULL;
    struct cs_PrjprmMap_ *newParamMap = NULL;
    struct cs_PrjprmMap_ *mp;
    for (mp = cs_PrjprmMap; mp->prj_code != cs_PRJCOD_END; mp++)
        {
        if (mp->prj_code == m_csParameters->prj_code)
            newParamMap = mp;
        if (mp->prj_code == oldCode)
            oldParamMap = mp;
        if ( (newParamMap != NULL) && (oldParamMap != NULL) )
            break;
        }

    // shouldn't happen.
    if ( (newParamMap == NULL) || (oldParamMap == NULL) )
        return SUCCESS;

    // step through the paramMaps
    double *paramP;
    int     iParam;
    for (iParam=0, paramP = &m_csParameters->csdef.prj_prm1; iParam <24; iParam++, paramP++)
        {
        int oldParamIndex = oldParamMap->prm_types[iParam];
        int newParamIndex = newParamMap->prm_types[iParam];
        // zero out any that are unused, or completely different between the old an new projection.
        if ( (0 == oldParamIndex) || (0 == newParamIndex))
            *paramP = 0.0;
        else
            {
            // both used. Keep if there's a chance it's usable.
            // That only happens if the log_type is useful.
            cs_Prjprm_  *oldParamDef = &csPrjprm[oldParamIndex];
            cs_Prjprm_  *newParamDef = &csPrjprm[newParamIndex];
            if (oldParamDef->log_type != newParamDef->log_type)
                *paramP = 0.0;
            }
        }

    // Verify that units are consistent with new projection.
    if (pcvUnity == value && (CS_stricmp(m_csParameters->csdef.unit, "DEGREE") != 0))
        {
        CSMap::CS_stncp(m_csParameters->csdef.unit, "DEGREE", DIM(m_csParameters->csdef.unit));
        }
    else if (pcvUnity != value &&  (CS_stricmp(m_csParameters->csdef.unit, "DEGREE") == 0))
        {
        CSMap::CS_stncp(m_csParameters->csdef.unit, "METER", DIM(m_csParameters->csdef.unit));
        }

    // string now wrong.
    DELETE_AND_CLEAR (m_projectionString);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP    BaseGCS::GetGroup (Utf8StringR groupName) const
    {
    groupName.clear();

    if (NULL != m_csParameters)
        groupName = m_csParameters->csdef.group;

    return groupName.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt  BaseGCS::SetGroup (Utf8CP group)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    // We cannot set an arbitrary name ... it must be an existing group
    char        groupName[1024];
    char        groupDescription[2048];
    bool found = false;
    for (int currentIndex = 0; !found && (0 < CSMap::CS_csGrpEnum (currentIndex, groupName, sizeof(groupName), groupDescription, sizeof(groupDescription))) ; currentIndex++)
        found = (0 == BeStringUtilities::Stricmp (group, groupName));

    if (!found)
        return GEOCOORDERR_BadArg;

    CSMap::CS_stncp (m_csParameters->csdef.group, group, DIM(m_csParameters->csdef.group));

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP         BaseGCS::GetLocation (Utf8StringR location) const
    {
    if (NULL != m_csParameters)
        location = m_csParameters->csdef.locatn;
    else
        location.clear();

    return location.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP         BaseGCS::GetSource (Utf8StringR source) const
    {
    if (NULL != m_csParameters)
        source = m_csParameters->csdef.source;
    else
        source.clear();

    return source.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetSource (Utf8CP source)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    CSMap::CS_stncp (m_csParameters->csdef.source, source, DIM(m_csParameters->csdef.source));

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP         BaseGCS::GetUnits (Utf8StringR units) const
    {
    if (NULL != m_csParameters)
        units = m_csParameters->csdef.unit;
    else
        units.clear();

    return units.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int         BaseGCS::GetUnitCode () const
    {
    if (NULL == m_csParameters)
        return -1;

    const struct cs_Unittab_   *pUnit;
    int                         index;
    for (index = 0, pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if (0 == BeStringUtilities::Stricmp (m_csParameters->csdef.unit, pUnit->name))
            return index;
        index++;
        }
    return -1;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int         BaseGCS::GetEPSGUnitCode () const
    {
    int UnitCode     = GetUnitCode();

    if (UnitCode != -1)
        return cs_Unittab[UnitCode].epsgCode;
    else
        return 0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetUnitByKeyname
(
Utf8CP unitName
)
    {
    Utf8String unitName2(unitName);

    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    const struct cs_Unittab_   *pUnit;
    int                         index;
    for (index = 0, pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if (pUnit->type == cs_UTYP_LEN)
            {
            if (unitName2.CompareToI(pUnit->name) == 0)
                {
                CSMap::CS_stncp (m_csParameters->csdef.unit, pUnit->name, DIM (m_csParameters->csdef.unit));
                SetModified(true);
                return SUCCESS;
                }
            index++;
            }
        /* If the unit type is not length then it must be angular and can only be used to set lat/long geographic coordinate systems */
        else if (cs_PRJCOD_UNITY == m_csParameters->prj_code)
            {
            if (unitName2.CompareToI(pUnit->name) == 0)
                {
                CSMap::CS_stncp (m_csParameters->csdef.unit, pUnit->name, DIM (m_csParameters->csdef.unit));
                SetModified(true);
                return SUCCESS;
                }
            index++;
            }
        }
    return GEOCOORDERR_InvalidUnitCode;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetUnitCode
(
int     code
)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    const struct cs_Unittab_   *pUnit;
    int                         index;
    for (index = 0, pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if (pUnit->type == cs_UTYP_LEN)
            {
            if (code == index)
                {
                CSMap::CS_stncp (m_csParameters->csdef.unit, pUnit->name, DIM (m_csParameters->csdef.unit));
                return SUCCESS;
                }
            index++;
            }
        /* If the unit type is not length then it must be angular and can only be used to set lat/long geographic coordinate systems */
        else if (cs_PRJCOD_UNITY == m_csParameters->prj_code)
            {
            if (code == index)
                {
                CSMap::CS_stncp (m_csParameters->csdef.unit, pUnit->name, DIM (m_csParameters->csdef.unit));
                return SUCCESS;
                }
            index++;
            }
        }
    return GEOCOORDERR_InvalidUnitCode;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetOriginLatitude () const
    {
    if (NULL != m_csParameters)
        return m_csParameters->csdef.org_lat;
    else
        return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetOriginLatitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    m_csParameters->csdef.org_lat = value;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetOriginLongitude () const
    {
    if (NULL != m_csParameters)
        return m_csParameters->csdef.org_lng;
    else
        return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetOriginLongitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    m_csParameters->csdef.org_lng = value;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetStandardParallel1 () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_ALBER:
        case cs_PRJCOD_EDCNC:
        case cs_PRJCOD_EDCYL:
        case cs_PRJCOD_EDCYLE:
        case cs_PRJCOD_NACYL:
        case cs_PRJCOD_LM2SP:
        case cs_PRJCOD_LMBLG:
        case cs_PRJCOD_LMMICH:
        case cs_PRJCOD_LMBRTAF:
        case cs_PRJCOD_WCCSL:
        case cs_PRJCOD_MNDOTL:
        case cs_PRJCOD_PSTROSL:
        case cs_PRJCOD_OBQCYL:      // We use StandardParallel1 to get the latitude where the Gaussian sphere is calculated.
        case cs_PRJCOD_WINKL:       // called reference parallel in release notes for 11.13.
            return m_csParameters->csdef.prj_prm1;

        case cs_PRJCOD_MRCAT:
            return m_csParameters->csdef.prj_prm2;

        case cs_PRJCOD_KROVAK:
        case cs_PRJCOD_KROVAKMOD:
        case cs_PRJCOD_KROVK1:
        case cs_PRJCOD_KRVK95:
        case cs_PRJCOD_KRVK951:
        case cs_PRJCOD_MODPC:
            return m_csParameters->csdef.prj_prm3;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetStandardParallel1 (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_ALBER:
        case cs_PRJCOD_EDCNC:
        case cs_PRJCOD_EDCYL:
        case cs_PRJCOD_EDCYLE:
        case cs_PRJCOD_NACYL:
        case cs_PRJCOD_LM2SP:
        case cs_PRJCOD_LMMICH:
        case cs_PRJCOD_LMBLG:
        case cs_PRJCOD_LMBRTAF:
        case cs_PRJCOD_WCCSL:
        case cs_PRJCOD_MNDOTL:
        case cs_PRJCOD_PSTROSL:
        case cs_PRJCOD_OBQCYL:      // We use StandardParallel1 to get the latitude where the Gaussian sphere is calculated.
        case cs_PRJCOD_WINKL:       // called reference parallel in release notes for 11.13.
            m_csParameters->csdef.prj_prm1 = value;
            return SUCCESS;

        case cs_PRJCOD_MRCAT:
            m_csParameters->csdef.prj_prm2 = value;
            return SUCCESS;

        case cs_PRJCOD_KROVAK:
        case cs_PRJCOD_KROVAKMOD:
        case cs_PRJCOD_KROVK1:
        case cs_PRJCOD_KRVK95:
        case cs_PRJCOD_KRVK951:
        case cs_PRJCOD_MODPC:
            m_csParameters->csdef.prj_prm3 = value;
            return SUCCESS;
        }
    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetStandardParallel2 () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_ALBER:
        case cs_PRJCOD_EDCNC:
        case cs_PRJCOD_LM2SP:
        case cs_PRJCOD_LMBLG:
        case cs_PRJCOD_LMBRTAF:
        case cs_PRJCOD_LMMICH:
        case cs_PRJCOD_WCCSL:
        case cs_PRJCOD_MNDOTL:
            return m_csParameters->csdef.prj_prm2;

        case cs_PRJCOD_MODPC:
            return m_csParameters->csdef.prj_prm4;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetStandardParallel2 (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_ALBER:
        case cs_PRJCOD_EDCNC:
        case cs_PRJCOD_LM2SP:
        case cs_PRJCOD_LMBLG:
        case cs_PRJCOD_LMBRTAF:
        case cs_PRJCOD_LMMICH:
        case cs_PRJCOD_WCCSL:
        case cs_PRJCOD_MNDOTL:
            m_csParameters->csdef.prj_prm2 = value;
            return SUCCESS;

        case cs_PRJCOD_MODPC:
            m_csParameters->csdef.prj_prm4 = value;
            return SUCCESS;
        }
    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetFalseEasting () const
    {
    if (NULL != m_csParameters)
        return m_csParameters->csdef.x_off;
    else
        return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetFalseEasting (double value)
    {

    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    m_csParameters->csdef.x_off = value;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetFalseNorthing () const
    {
    if (NULL != m_csParameters)
        return m_csParameters->csdef.y_off;
    else
        return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetFalseNorthing (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    m_csParameters->csdef.y_off = value;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetScaleReduction () const
    {
    if (NULL != m_csParameters)
        return m_csParameters->csdef.scl_red;
    else
        return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetScaleReduction (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    m_csParameters->csdef.scl_red = value;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetMinimumLongitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    return m_csParameters->csdef.ll_min[0];
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetMinimumLongitude (double value)
    {

    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    m_csParameters->csdef.ll_min[0] = value;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetMaximumLongitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    return m_csParameters->csdef.ll_max[0];
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetMaximumLongitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    m_csParameters->csdef.ll_max[0] = value;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetMinimumLatitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;
    else if ((cs_PRJCOD_UNITY == m_csParameters->prj_code) &&
             (m_csParameters->csdef.ll_max[1] <= m_csParameters->csdef.ll_min[1]))
        return -90.0;
    else
        return m_csParameters->csdef.ll_min[1];
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetMinimumLatitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    m_csParameters->csdef.ll_min[1] = value;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetMaximumLatitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;
    else if ((cs_PRJCOD_UNITY == m_csParameters->prj_code) &&
             (m_csParameters->csdef.ll_max[1] <= m_csParameters->csdef.ll_min[1]))
        return 90.0;
    else
        return m_csParameters->csdef.ll_max[1];
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetMaximumLatitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    m_csParameters->csdef.ll_max[1] = value;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double          BaseGCS::GetMinimumUsefulLongitude() const
    {
    if (NULL == m_csParameters)
        return 0.0;
    else
        {
        // Often, the value -180 (or 180 West) is stored as +180 which makes no sense as minimum ... we convert it to -180
        // The exact float compare operation is here intentional
        if (180.0 == m_csParameters->min_ll[0])
            return m_csParameters->cent_mer - 179.99999999;

        return m_csParameters->cent_mer + m_csParameters->min_ll[0];
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double          BaseGCS::GetMaximumUsefulLongitude() const
    {
    if (NULL == m_csParameters)
        return 0.0;
    else
        return m_csParameters->cent_mer + m_csParameters->max_ll[0];
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double          BaseGCS::GetMinimumUsefulLatitude() const
    {
    if (NULL == m_csParameters)
        return 0.0;
    else
        return m_csParameters->min_ll[1];
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double          BaseGCS::GetMaximumUsefulLatitude() const
    {
    if (NULL == m_csParameters)
        return 0.0;
    else
        return m_csParameters->max_ll[1];
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetCentralMeridian () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMER:
        case cs_PRJCOD_TRMRKRG:
        case cs_PRJCOD_GAUSSK:
        case cs_PRJCOD_SOTRM:
        case cs_PRJCOD_WCCST:
        case cs_PRJCOD_MNDOTT:
        case cs_PRJCOD_TRMERAF:
        case cs_PRJCOD_TRMRS:
        case cs_PRJCOD_PLYCN:
        case cs_PRJCOD_CSINI:
        case cs_PRJCOD_MRCAT:
        case cs_PRJCOD_MRCATK:
        case cs_PRJCOD_MRCATPV:
        case cs_PRJCOD_MILLR:
        case cs_PRJCOD_MODPC:
        /* TOTAL Transverse Mercator projection, using the Bernard Flaceliere calculation. (Added by BJB 3/2007). */
        case cs_PRJCOD_TRMERBF:
            return m_csParameters->csdef.prj_prm1;

        case cs_PRJCOD_SINUS:
        case cs_PRJCOD_ROBIN:
        case cs_PRJCOD_NACYL:
            return m_csParameters->csdef.org_lng;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetCentralMeridian (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMER:
        case cs_PRJCOD_TRMRKRG:
        case cs_PRJCOD_GAUSSK:
        case cs_PRJCOD_SOTRM:
        case cs_PRJCOD_WCCST:
        case cs_PRJCOD_MNDOTT:
        case cs_PRJCOD_TRMERAF:
        case cs_PRJCOD_TRMRS:
        case cs_PRJCOD_PLYCN:
        case cs_PRJCOD_CSINI:
        case cs_PRJCOD_MRCAT:
        case cs_PRJCOD_MRCATK:
        case cs_PRJCOD_MRCATPV:
        case cs_PRJCOD_MILLR:
        case cs_PRJCOD_MODPC:
        /* TOTAL Transverse Mercator projection, using the Bernard Flaceliere calculation. (Added by BJB 3/2007). */
        case cs_PRJCOD_TRMERBF:
            m_csParameters->csdef.prj_prm1 = value;
            return SUCCESS;

        case cs_PRJCOD_SINUS:
        case cs_PRJCOD_ROBIN:
        case cs_PRJCOD_NACYL:
            m_csParameters->csdef.org_lng = value;
            return SUCCESS;
        }
    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetEasternMeridian () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    int prjCode = m_csParameters->prj_code;
    if (cs_PRJCOD_MODPC == prjCode)
        return m_csParameters->csdef.prj_prm2;
    else
        return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetEasternMeridian (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    int prjCode = m_csParameters->prj_code;
    if (cs_PRJCOD_MODPC == prjCode)
        {
        m_csParameters->csdef.prj_prm2 = value;
        return SUCCESS;
        }
    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetCentralPointLongitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM1UV:
        case cs_PRJCOD_HOM1XY:
        case cs_PRJCOD_MNDOTOBL:
        case cs_PRJCOD_RSKEW:
        case cs_PRJCOD_RSKEWO:
        case cs_PRJCOD_RSKEWC:
            return m_csParameters->csdef.prj_prm1;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetCentralPointLongitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM1UV:
        case cs_PRJCOD_HOM1XY:
        case cs_PRJCOD_MNDOTOBL:
        case cs_PRJCOD_RSKEW:
        case cs_PRJCOD_RSKEWO:
        case cs_PRJCOD_RSKEWC:
            m_csParameters->csdef.prj_prm1 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetCentralPointLatitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM1UV:
        case cs_PRJCOD_HOM1XY:
        case cs_PRJCOD_MNDOTOBL:
        case cs_PRJCOD_RSKEW:
        case cs_PRJCOD_RSKEWO:
        case cs_PRJCOD_RSKEWC:
            return m_csParameters->csdef.prj_prm2;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetCentralPointLatitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM1UV:
        case cs_PRJCOD_HOM1XY:
        case cs_PRJCOD_MNDOTOBL:
        case cs_PRJCOD_RSKEW:
        case cs_PRJCOD_RSKEWO:
        case cs_PRJCOD_RSKEWC:
            m_csParameters->csdef.prj_prm2 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetPoint1Longitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM2UV:
        case cs_PRJCOD_HOM2XY:
        case cs_PRJCOD_KROVAK:
        case cs_PRJCOD_KROVAKMOD:
        case cs_PRJCOD_KROVK1:
        case cs_PRJCOD_KRVK95:
        case cs_PRJCOD_KRVK951:
            return m_csParameters->csdef.prj_prm1;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetPoint1Longitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM2UV:
        case cs_PRJCOD_HOM2XY:
        case cs_PRJCOD_KROVAK:
        case cs_PRJCOD_KROVAKMOD:
        case cs_PRJCOD_KROVK1:
        case cs_PRJCOD_KRVK95:
        case cs_PRJCOD_KRVK951:
            m_csParameters->csdef.prj_prm1 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetPoint1Latitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM2UV:
        case cs_PRJCOD_HOM2XY:
        case cs_PRJCOD_KROVAK:
        case cs_PRJCOD_KROVAKMOD:
        case cs_PRJCOD_KROVK1:
        case cs_PRJCOD_KRVK95:
        case cs_PRJCOD_KRVK951:
            return m_csParameters->csdef.prj_prm2;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetPoint1Latitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM2UV:
        case cs_PRJCOD_HOM2XY:
        case cs_PRJCOD_KROVAK:
        case cs_PRJCOD_KROVAKMOD:
        case cs_PRJCOD_KROVK1:
        case cs_PRJCOD_KRVK95:
        case cs_PRJCOD_KRVK951:
            m_csParameters->csdef.prj_prm2 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetPoint2Longitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM2UV:
        case cs_PRJCOD_HOM2XY:
            return m_csParameters->csdef.prj_prm3;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetPoint2Longitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM2UV:
        case cs_PRJCOD_HOM2XY:
            m_csParameters->csdef.prj_prm3 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetPoint2Latitude () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM2UV:
        case cs_PRJCOD_HOM2XY:
            return m_csParameters->csdef.prj_prm4;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetPoint2Latitude (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_HOM2UV:
        case cs_PRJCOD_HOM2XY:
            m_csParameters->csdef.prj_prm4 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetAzimuth () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_AZMEA:
        case cs_PRJCOD_AZMED:
        case cs_PRJCOD_AZEDE:
        case cs_PRJCOD_SSTRO:
            return m_csParameters->csdef.prj_prm1;

        case cs_PRJCOD_HOM1UV:
        case cs_PRJCOD_HOM1XY:
        case cs_PRJCOD_MNDOTOBL:
        case cs_PRJCOD_RSKEW:
        case cs_PRJCOD_RSKEWO:
        case cs_PRJCOD_RSKEWC:
            return m_csParameters->csdef.prj_prm3;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetAzimuth (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_AZMEA:
        case cs_PRJCOD_AZMED:
        case cs_PRJCOD_AZEDE:
        case cs_PRJCOD_SSTRO:
            m_csParameters->csdef.prj_prm1 = value;
            return SUCCESS;

        case cs_PRJCOD_HOM1UV:
        case cs_PRJCOD_HOM1XY:
        case cs_PRJCOD_MNDOTOBL:
        case cs_PRJCOD_RSKEW:
        case cs_PRJCOD_RSKEWO:
        case cs_PRJCOD_RSKEWC:
            m_csParameters->csdef.prj_prm3 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetGeoidSeparation () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_WCCST:
            return m_csParameters->csdef.prj_prm2;
        case cs_PRJCOD_WCCSL:
            return m_csParameters->csdef.prj_prm3;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetGeoidSeparation (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_WCCST:
            m_csParameters->csdef.prj_prm2 = value;
            return SUCCESS;
        case cs_PRJCOD_WCCSL:
            m_csParameters->csdef.prj_prm3 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetElevationAboveGeoid () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_MNDOTT:
        case cs_PRJCOD_AZEDE:
            return m_csParameters->csdef.prj_prm2;

        case cs_PRJCOD_WCCST:
        case cs_PRJCOD_MNDOTL:
            return m_csParameters->csdef.prj_prm3;

        case cs_PRJCOD_WCCSL:
        case cs_PRJCOD_MNDOTOBL:
            return m_csParameters->csdef.prj_prm4;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetElevationAboveGeoid (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_MNDOTT:
        case cs_PRJCOD_AZEDE:
            m_csParameters->csdef.prj_prm2 = value;
            return SUCCESS;

        case cs_PRJCOD_WCCST:
        case cs_PRJCOD_MNDOTL:
            m_csParameters->csdef.prj_prm3 = value;
            return SUCCESS;

        case cs_PRJCOD_WCCSL:
        case cs_PRJCOD_MNDOTOBL:
            m_csParameters->csdef.prj_prm4 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetEllipsoidScaleFactor () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_LMMICH:
            return m_csParameters->csdef.prj_prm3;
        }
    return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetEllipsoidScaleFactor (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_LMMICH:
            m_csParameters->csdef.prj_prm3 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int BaseGCS::GetUTMZone () const
    {
    if (NULL == m_csParameters)
        return -1;

    int prjCode = m_csParameters->prj_code;
    if ((cs_PRJCOD_UTM == prjCode) || (cs_PRJCOD_UTMZNBF == prjCode))
        return (int) m_csParameters->csdef.prj_prm1;

    return -1;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetUTMZone (int value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    int prjCode = m_csParameters->prj_code;
    if ((cs_PRJCOD_UTM == prjCode) || (cs_PRJCOD_UTMZNBF == prjCode))
        {
        m_csParameters->csdef.prj_prm1 = value;
        return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int BaseGCS::GetHemisphere () const
    {
    if (NULL == m_csParameters)
        return 0;

    int prjCode = m_csParameters->prj_code;
    if ((cs_PRJCOD_UTM == prjCode) || (cs_PRJCOD_UTMZNBF == prjCode))
        return (int) m_csParameters->csdef.prj_prm2;

    return 0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetHemisphere (int value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    int prjCode = m_csParameters->prj_code;
    if ((cs_PRJCOD_UTM == prjCode) || (cs_PRJCOD_UTMZNBF == prjCode))
        {
        m_csParameters->csdef.prj_prm2 = value;
        return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int BaseGCS::GetQuadrant () const
    {
    if (NULL == m_csParameters)
        return -1;

    // south oriented transverse mercator are already inverted, account for that. See cs_QuadMap and cs_QuadMapSO in csdata.c
    if (cs_PRJCOD_SOTRM == m_csParameters->prj_code)
        {
        switch (m_csParameters->csdef.quad)
            {
            case 0:
            case 1:
                return 3;
            case 2:
                return 4;
            case 3:
                return 1;
            case 4:
                return 2;
            }
        }

    return m_csParameters->csdef.quad;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetQuadrant (short value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    // south oriented transverse mercator needs to be inverted, account for that. See cs_QuadMap and cs_QuadMapSO in csdata.c
    if (cs_PRJCOD_SOTRM == m_csParameters->prj_code)
        {
        switch (value)
            {
            case 0:
            case 1:
                value = 3;
                break;
            case 2:
                value = 4;
                break;
            case 3:
                value = 1;
                break;
            case 4:
                value = 2;
                break;
            }
        }

    m_csParameters->csdef.quad = value;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int BaseGCS::GetDanishSys34Region () const
    {
    if (NULL == m_csParameters)
        return -1;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_SYS34:
        case cs_PRJCOD_SYS34_99:
        case cs_PRJCOD_SYS34_01:
            return (int) m_csParameters->csdef.prj_prm1;
        }

    return -1;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetDanishSys34Region (int value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_SYS34:
        case cs_PRJCOD_SYS34_99:
        case cs_PRJCOD_SYS34_01:
            m_csParameters->csdef.prj_prm1 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetAffineA0 () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            return m_csParameters->csdef.prj_prm2;

        case cs_PRJCOD_LMBRTAF:
            return m_csParameters->csdef.prj_prm3;
        }

    return 0.01;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetAffineA0 (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            m_csParameters->csdef.prj_prm2 = value;
            return SUCCESS;

        case cs_PRJCOD_LMBRTAF:
            m_csParameters->csdef.prj_prm3 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetAffineA1 () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            return m_csParameters->csdef.prj_prm4;

        case cs_PRJCOD_LMBRTAF:
            return m_csParameters->csdef.prj_prm5;
        }

    return 0.01;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetAffineA1 (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            m_csParameters->csdef.prj_prm4 = value;
            return SUCCESS;

        case cs_PRJCOD_LMBRTAF:
            m_csParameters->csdef.prj_prm5 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetAffineA2 () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            return m_csParameters->csdef.prj_prm5;

        case cs_PRJCOD_LMBRTAF:
            return m_csParameters->csdef.prj_prm6;
        }

    return 0.01;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetAffineA2 (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            m_csParameters->csdef.prj_prm5 = value;
            return SUCCESS;

        case cs_PRJCOD_LMBRTAF:
            m_csParameters->csdef.prj_prm6 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetAffineB0 () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            return m_csParameters->csdef.prj_prm3;

        case cs_PRJCOD_LMBRTAF:
            return m_csParameters->csdef.prj_prm4;
        }

    return 0.01;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetAffineB0 (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            m_csParameters->csdef.prj_prm3 = value;
            return SUCCESS;

        case cs_PRJCOD_LMBRTAF:
            m_csParameters->csdef.prj_prm4 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetAffineB1 () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            return m_csParameters->csdef.prj_prm6;

        case cs_PRJCOD_LMBRTAF:
            return m_csParameters->csdef.prj_prm7;
        }

    return 0.01;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetAffineB1 (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            m_csParameters->csdef.prj_prm6 = value;
            return SUCCESS;

        case cs_PRJCOD_LMBRTAF:
            m_csParameters->csdef.prj_prm7 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetAffineB2 () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            return m_csParameters->csdef.prj_prm7;

        case cs_PRJCOD_LMBRTAF:
            return m_csParameters->csdef.prj_prm8;
        }

    return 0.01;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetAffineB2 (double value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            m_csParameters->csdef.prj_prm7 = value;
            return SUCCESS;

        case cs_PRJCOD_LMBRTAF:
            m_csParameters->csdef.prj_prm8 = value;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::GetAffineParameters (double* A0, double* A1, double* A2, double* B0, double* B1, double* B2) const
    {
    if (NULL == m_csParameters)
        return;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            if (NULL != A0)
                *A0 = m_csParameters->csdef.prj_prm2;
            if (NULL != B0)
                *B0 = m_csParameters->csdef.prj_prm3;
            if (NULL != A1)
                *A1 = m_csParameters->csdef.prj_prm4;
            if (NULL != A2)
                *A2 = m_csParameters->csdef.prj_prm5;
            if (NULL != B1)
                *B1 = m_csParameters->csdef.prj_prm6;
            if (NULL != B2)
                *B2 = m_csParameters->csdef.prj_prm7;
            return;


        case cs_PRJCOD_LMBRTAF:
            if (NULL != A0)
                *A0 = m_csParameters->csdef.prj_prm3;
            if (NULL != B0)
                *B0 = m_csParameters->csdef.prj_prm4;
            if (NULL != A1)
                *A1 = m_csParameters->csdef.prj_prm5;
            if (NULL != A2)
                *A2 = m_csParameters->csdef.prj_prm6;
            if (NULL != B1)
                *B1 = m_csParameters->csdef.prj_prm7;
            if (NULL != B2)
                *B2 = m_csParameters->csdef.prj_prm8;
            return;
        }
    return;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::SetAffineParameters (double A0, double A1, double A2, double B0, double B1, double B2)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    double  determinant = (A1 * B2) - (A2 * B1);
    // The exact floating point compare operation is intentional ... the purpose is to check that
    // no two members of same line or column of matrix are exactly equal to 0.0 which would result
    // in an invalid transformation.
    if (determinant == 0.0)
        return GEOCOORDERR_InvalidAffineParameters;

    switch (m_csParameters->prj_code)
        {
        case cs_PRJCOD_TRMERAF:
            m_csParameters->csdef.prj_prm2 = A0;
            m_csParameters->csdef.prj_prm3 = B0;
            m_csParameters->csdef.prj_prm4 = A1;
            m_csParameters->csdef.prj_prm5 = A2;
            m_csParameters->csdef.prj_prm6 = B1;
            m_csParameters->csdef.prj_prm7 = B2;
            return SUCCESS;

        case cs_PRJCOD_LMBRTAF:
            m_csParameters->csdef.prj_prm3 = A0;
            m_csParameters->csdef.prj_prm4 = B0;
            m_csParameters->csdef.prj_prm5 = A1;
            m_csParameters->csdef.prj_prm6 = A2;
            m_csParameters->csdef.prj_prm7 = B1;
            m_csParameters->csdef.prj_prm8 = B2;
            return SUCCESS;
        }

    return GEOCOORDERR_ProjectionDoesntUseParameter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::DefinitionComplete ()
    {
    CSParameters*   newParams;

    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    // Reset previous error
    m_csError = 0;

    if (NULL == (newParams = CSMap::CScsloc1 (&m_csParameters->csdef)))
        {
        // An error was returned likely because the datum used is unknown in the system dictionary.
        // This obviously indicate a custom datum is in use.
        if (nullptr == m_datum || !m_customDatum)
            {
            m_csError = cs_Error;
            return cs_Error;
            }

        CSDatumDef* datumDef = m_datum->GetCSDatumDef(nullptr);
        CSEllipsoidDef* ellipsoidDef = m_datum->GetCSEllipsoidDef();
        if ((nullptr == datumDef) || (nullptr == ellipsoidDef))
            {
            m_csError = cs_Error;
            return cs_Error;
            }

        if (NULL == (newParams = CSMap::CScsloc2 (&m_csParameters->csdef, datumDef, ellipsoidDef)))
            {
            m_csError = cs_Error;
            return cs_Error;
            }
        }

    CSMAP_FREE_AND_CLEAR(m_csParameters);
    m_csParameters = newParams;

    // Clear cached target GCS and datum converter if any
    if (NULL != m_targetGCS)
        {
        m_targetGCS->UnRegisterIsADestinationOf(*this);
        m_targetGCS = NULL;
        }

    if (NULL != m_datumConverter)
        {
        m_datumConverter->Destroy();
        m_datumConverter = NULL;
        }

    SetModified(false);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP    BaseGCS::GetDatumName () const
    {
    if (NULL == m_csParameters)
        return "";

    if (NULL == m_datumNameString)
        m_datumNameString = new Utf8String (m_csParameters->datum.key_nm);

    return  m_datumNameString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int         BaseGCS::GetDatumCode () const
    {
    if (NULL == m_csParameters)
        return -1;

    // if no dat_knm, return -1 to indicate there is no datum and the GCS is ellipsoid based.
    if (0 == m_csParameters->csdef.dat_knm[0])
        return -1;

    Utf8String searchName (m_csParameters->csdef.dat_knm);

    // check system library/
    char    mbDatumName[512];
    for (int index = 0; (0 < CSMap::CS_dtEnum (index, mbDatumName, sizeof(mbDatumName))); index++)
        {
        if (0 == BeStringUtilities::Stricmp (m_csParameters->csdef.dat_knm, mbDatumName))
            return index;
        }

    return Datum::CUSTOM_DATUM_CODE; // It is not in any library this it is a self-contained definition
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
    StatusInt BaseGCS::SetDatumCode(int datumCode) {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    // Datum::CUSTOM_DATUM_CODE (-2) means self-defined datum. This may imply a datum is specifically set or is fully
    // contained in the GCS datum definition and optionally GeodeticTransformDef
    if (Datum::CUSTOM_DATUM_CODE != datumCode && m_customDatum) {
        m_datum->Destroy();
        m_datum = NULL;
        m_customDatum = false;
    }

    // -1 means no datum, ellipse only.
    if (Datum::NO_DATUM_CODE == datumCode)
        {
        // set the ellipse keyname from the datum before clearing the datum.
        CSMap::CS_stncp (m_csParameters->csdef.elp_knm, m_csParameters->datum.ell_knm, sizeof (m_csParameters->csdef.elp_knm));
        memset (m_csParameters->csdef.dat_knm, 0, sizeof (m_csParameters->csdef.dat_knm));
        memset (m_csParameters->datum.key_nm, 0, sizeof (m_csParameters->datum.key_nm));
        memset (m_csParameters->datum.dt_name, 0, sizeof (m_csParameters->datum.dt_name));
        m_csParameters->datum.delta_X = m_csParameters->datum.delta_Y = m_csParameters->datum.delta_Z = 0.0;
        m_csParameters->datum.rot_X   = m_csParameters->datum.rot_Y   = m_csParameters->datum.rot_Z   = 0.0;
        m_csParameters->datum.bwscale = 0.0;
        m_csParameters->datum.to84_via = cs_DTCTYP_NONE;

        // the effect of this line is to look up the ellipse information and install it into csdef.
        SetEllipsoidCode (GetEllipsoidCode());

        return SUCCESS;
        }

    char    dtKeyName[128];
    if (0 > CSMap::CS_dtEnum (datumCode, dtKeyName, sizeof(dtKeyName)))
        return GEOCOORDERR_InvalidDatumCode;

    CSDatum*       datum;
    if (NULL == (datum = CSMap::CS_dtloc (dtKeyName)))
        return GEOCOORDERR_InvalidDatumCode;

    m_csParameters->datum = *datum;
    CSMap::CS_stncp (m_csParameters->csdef.dat_knm, datum->key_nm, sizeof (m_csParameters->csdef.dat_knm));

    if (Utf8String(m_csParameters->csdef.elp_knm) != Utf8String(datum->ell_knm))
        strncpy(m_csParameters->csdef.elp_knm, datum->ell_knm, _countof(datum->ell_knm));

    CSMap::CS_free (datum);

    // doing this causes the Vertical Datum to get set correctly when changing the horizontal datum.
    // (i.e., stays the same when going from NAD83 <-> NAD27, otherwise gets reset to vdcFromDatum.
    SetVerticalDatumCode (GetVerticalDatumCode());

    DELETE_AND_CLEAR (m_datumNameString);
    DELETE_AND_CLEAR (m_datumDescriptionString);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumCP            BaseGCS::GetDatum() const
    {
    if (NULL == m_csParameters)
        return nullptr;

    // If the datum is stored we extract it
    if (m_datum != nullptr)
        return m_datum;

    CSDatumDef* datumDef = CSMap::CS_dtdef (m_csParameters->csdef.dat_knm);

    if (nullptr == datumDef)
        return NULL; // Should only occur for an ellipsoid based non-datum

    m_customDatum = false;
    m_datum = const_cast<DatumP>(Datum::CreateDatum(*datumDef, nullptr));
    CSMAP_FREE_AND_CLEAR(datumDef);

    return m_datum;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt         BaseGCS::SetDatum (DatumP datum)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    if (nullptr != m_datum)
        {
        m_datum->Destroy();
        m_datum = nullptr;
        }

    m_customDatum = false; // Till it is fully set.

    if (nullptr != datum)
        {
        m_datum = datum;

        CSDatumDef* datumDef = m_datum->GetCSDatumDef(nullptr); // We do not need the geodetic transform
        CSEllipsoidDef* ellipsoidDef = m_datum->GetCSEllipsoidDef();
        if ((datumDef == nullptr) || (ellipsoidDef == nullptr))
           return cs_Error;

        CSParameters*   newParams;

        CSMap::CS_stncp(m_csParameters->csdef.dat_knm, datumDef->key_nm, sizeof(m_csParameters->csdef.dat_knm));
        CSMap::CS_stncp(m_csParameters->csdef.elp_knm, datumDef->ell_knm, _countof(datumDef->ell_knm));

        // We now recompute the GCS using new datum and ellipsoid
        if (NULL == (newParams = CSMap::CScsloc2 (&m_csParameters->csdef, datumDef, ellipsoidDef)))
           return cs_Error;

        m_customDatum = true;

        CSMAP_FREE_AND_CLEAR(m_csParameters);
        m_csParameters = newParams;
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool         BaseGCS::HasCustomDatum () const { return m_customDatum; }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP    BaseGCS::GetDatumDescription () const
    {
    if (NULL == m_csParameters)
        return "";

    if (NULL == m_datumDescriptionString)
        m_datumDescriptionString = new Utf8String (m_csParameters->datum.dt_name);

    return  m_datumDescriptionString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP     BaseGCS::GetDatumSource (Utf8StringR datumSource) const
    {
    datumSource.clear();

    if (NULL != m_csParameters)
        {
        if (0 != m_csParameters->datum.key_nm[0])
            {
            CSDatumDef* datumDef;
            CSGeodeticTransformDef* transform = nullptr;
            if (NULL != (datumDef = CSMap::CS_dtdef(this->GetDatumName())))
                {
                datumSource = datumDef->source;
                // free the datum.
                CSMap::CS_free (datumDef);
                }
            if (nullptr != transform)
                CSMap::CS_free(transform);
            }
        }
    return datumSource.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
WGS84ConvertCode  BaseGCS::GetDatumConvertMethod() const
    {
    if (NULL == m_csParameters)
        return ConvertType_NONE;

    if (0 == m_csParameters->datum.key_nm[0])
        return ConvertType_NONE;

    return (WGS84ConvertCode) m_csParameters->datum.to84_via;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void        BaseGCS::GetDatumDelta (DPoint3dR delta) const
    {
    if (NULL == m_csParameters)
        return;

    bool             deltaValid, rotationValid, scaleValid;
    DatumParametersValid (deltaValid, rotationValid, scaleValid);
    if (!deltaValid)
        delta.x = delta.y = delta.z = 0.0;
    else
        {
        delta.x = m_csParameters->datum.delta_X;
        delta.y = m_csParameters->datum.delta_Y;
        delta.z = m_csParameters->datum.delta_Z;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void        BaseGCS::GetDatumRotation (DPoint3dR rotation) const
    {
    if (NULL == m_csParameters)
        return;

    bool             deltaValid, rotationValid, scaleValid;
    DatumParametersValid (deltaValid, rotationValid, scaleValid);
    if (!rotationValid)
        rotation.x = rotation.y = rotation.z = 0.0;
    else
        {
        rotation.x = m_csParameters->datum.rot_X;
        rotation.y = m_csParameters->datum.rot_Y;
        rotation.z = m_csParameters->datum.rot_Z;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double      BaseGCS::GetDatumScale () const
    {
    if (NULL == m_csParameters)
        return 0.0;

    bool             deltaValid, rotationValid, scaleValid;
    DatumParametersValid (deltaValid, rotationValid, scaleValid);
    return (scaleValid) ? m_csParameters->datum.bwscale : 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt              BaseGCS::GetDatumGridFile (GridFileDefinition& gridFileDef) const
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    DatumCP currentDatum = GetDatum();

    if (nullptr != currentDatum && currentDatum->IsValid())
        return currentDatum->GetGridFile(gridFileDef);

    return ERROR;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool        BaseGCS::DatumParametersValid (bool& deltaValid, bool& rotationValid, bool& scaleValid) const
    {
    // initialize to defaults.
    deltaValid = rotationValid = scaleValid = false;

    if (NULL == m_csParameters)
        return false;

    switch (GetDatumConvertMethod())
        {
        case ConvertType_MOLO:
        case ConvertType_3PARM:
        case ConvertType_GEOCTR:
            deltaValid = true;
            break;

        case ConvertType_BURS:
        case ConvertType_7PARM:
            deltaValid = rotationValid = scaleValid = true;
            break;

        case ConvertType_6PARM:
            deltaValid = rotationValid = true;
            break;

        case ConvertType_4PARM:
            deltaValid = scaleValid = true;
            break;
        }

    return (deltaValid || rotationValid || scaleValid);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool        BaseGCS::DatumExtendedParametersValid (bool& deltaValid, bool& rotationValid, bool& scaleValid, bool& gridValid) const
    {
    // initialize to defaults.
    deltaValid = rotationValid = scaleValid = gridValid = false;

    if (NULL == m_csParameters)
        return false;

    switch (GetDatumConvertMethod())
        {
        case ConvertType_MOLO:
        case ConvertType_3PARM:
        case ConvertType_GEOCTR:
            deltaValid = true;
            break;

        case ConvertType_BURS:
        case ConvertType_7PARM:
            deltaValid = rotationValid = scaleValid = true;
            break;

        case ConvertType_6PARM:
            deltaValid = rotationValid = true;
            break;

        case ConvertType_4PARM:
            deltaValid = scaleValid = true;
            break;

        case ConvertType_GENGRID:
            gridValid = true;
            break;
        }

    return (deltaValid || rotationValid || scaleValid || gridValid);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::IsNAD27 () const
    {
    if (NULL == m_csParameters)
        return false;

    return IsNAD27Keyname(m_csParameters->datum.key_nm);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::IsNAD83 () const
    {
    if (NULL == m_csParameters)
        return false;

    return IsNAD83Keyname(m_csParameters->datum.key_nm);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::HasWGS84CoincidentDatum () const
    {
    if (NULL == m_csParameters)
        return false;

    DatumCP theDatum = GetDatum();
    if (theDatum != nullptr && theDatum->IsValid())
      return theDatum->IsWGS84Coincident();

    return true; // No datum implies no datum transformation which is considered coincident.
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP         BaseGCS::GetVerticalDatumName () const
    {
    if (NULL == m_csParameters)
        return "";

    bool    isNAD27 = this->IsNAD27();
    bool    isNAD83 = this->IsNAD83();

    if ( (vdcNGVD29 == m_verticalDatum) || ( (vdcFromDatum == m_verticalDatum) && isNAD27) )
        return "NGVD29";

     if ( (vdcNAVD88 == m_verticalDatum) || ( (vdcFromDatum == m_verticalDatum) && isNAD83) )
        return "NAVD88";

    if (vdcGeoid == m_verticalDatum)
        return "Geoid";

    if (vdcLocalEllipsoid == m_verticalDatum)
        return "Local Ellipsoid";

    // Either vdcFromDatum (with other than NAD83 or NAD27) or vdcEllipsoid result in ellipsoid
    return "Ellipsoid";
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VertDatumCode   BaseGCS::GetVerticalDatumCode () const
    {
    if (NULL == m_csParameters)
        return vdcFromDatum;

    return m_verticalDatum;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VertDatumCode   BaseGCS::GetNetVerticalDatumCode() const
{
    if (NULL == m_csParameters)
        return vdcFromDatum;

    return NetVerticalDatumFromGCS(*this);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::SetVerticalDatumCode
(
VertDatumCode   verticalDatumCode
)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    // There are limitations to using NGVD29 and NAVD88 (Others are worldwide)
    // Normally NGVD29 is only for NAD27 datum but can be used as NAD83 datum
    // Normally NAVD88 is only for NAD83 datum but can be used by NAD27 datum
    if ((vdcNGVD29 == verticalDatumCode || (vdcNAVD88 == verticalDatumCode)) && !(this->IsNAD27() || this->IsNAD83()))
        return GEOCOORDERR_CantSetVerticalDatum;

    if (vdcLocalEllipsoid == verticalDatumCode && HasWGS84CoincidentDatum())
        return GEOCOORDERR_CantSetVerticalDatum;

    // Clear datum converter caches
    if (NULL != m_targetGCS)
    {
        m_targetGCS->UnRegisterIsADestinationOf(*this);
        m_targetGCS = NULL;
    }

    if (NULL != m_datumConverter)
        {
        m_datumConverter->Destroy();
        m_datumConverter = NULL;
        }

    m_verticalDatum = verticalDatumCode;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt  BaseGCS::SetVerticalDatumByKey(Utf8CP verticalDatumKey)
  {
  VertDatumCode vdc = VerticalDatumCodeFromKey(verticalDatumKey);
  if (vdcFromDatum == vdc)
      return ERROR;

  return SetVerticalDatumCode(vdc);
  }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP     BaseGCS::GetEllipsoidName () const
    {
    if (NULL == m_csParameters)
        return "";

    if (NULL == m_ellipsoidNameString)
        m_ellipsoidNameString = new Utf8String (m_csParameters->datum.ell_knm);

    return  m_ellipsoidNameString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int         BaseGCS::GetEllipsoidCode () const
    {
    if (NULL == m_csParameters)
        return Ellipsoid::NO_ELLIPSOID_CODE;

    Utf8String     searchName (m_csParameters->datum.ell_knm);

    // check system library/
    char    mbEllipsoidName[512];
    for (int index = 0; (0 < CS_elEnum (index, mbEllipsoidName, sizeof(mbEllipsoidName))); index++)
        {
        if (0 == BeStringUtilities::Stricmp (m_csParameters->datum.ell_knm, mbEllipsoidName))
            return index;
        }

    // TODO SUPPORT FOR CUSTOM ELLIPSOID BASED GCS

    return Ellipsoid::NO_ELLIPSOID_CODE;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::SetEllipsoidCode
(
int     ellipsoidCode
)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    SetModified(true);

    if (Datum::NO_DATUM_CODE != GetDatumCode())
        return GEOCOORDERR_CantSetEllipsoid;

    // ELLIPSOID_CODE_SEPARATOR (2000000) is the separator, do nothing.
    if (Ellipsoid::ELLIPSOID_CODE_SEPARATOR == ellipsoidCode)
        return GEOCOORDERR_InvalidEllipsoidCode;

    CSEllipsoidDef* ellipsoidDef = NULL;
    char    elKeyName[128];
    if (0 > CS_elEnum (ellipsoidCode, elKeyName, sizeof(elKeyName)))
        return GEOCOORDERR_InvalidEllipsoidCode;

    if (NULL == (ellipsoidDef = CSMap::CS_eldef (elKeyName)))
        return GEOCOORDERR_InvalidEllipsoidCode;

    CSDatum*       datum;
    if (NULL == (datum = CSdtloc2 (NULL, ellipsoidDef)))
        {
        CSMap::CS_free (ellipsoidDef);
        return GEOCOORDERR_InvalidEllipsoidCode;
        }

    m_csParameters->datum = *datum;
    CSMap::CS_stncp (m_csParameters->csdef.elp_knm, ellipsoidDef->key_nm, sizeof (m_csParameters->csdef.elp_knm));
    CSMap::CS_free (datum);
    CSMap::CS_free (ellipsoidDef);

    DELETE_AND_CLEAR (m_ellipsoidNameString);
    DELETE_AND_CLEAR (m_ellipsoidDescriptionString);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP     BaseGCS::GetEllipsoidDescription () const
    {
    if (NULL == m_csParameters)
        return "";

    if (NULL == m_ellipsoidDescriptionString)
        m_ellipsoidDescriptionString = new Utf8String (m_csParameters->datum.el_name);

    return  m_ellipsoidDescriptionString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP         BaseGCS::GetEllipsoidSource (Utf8StringR ellipsoidSource) const
    {
    ellipsoidSource.clear();

    if (NULL != m_csParameters)
        {
        if (0 != m_csParameters->datum.ell_knm[0])
            {
            CSEllipsoidDef* ellipsoidDef;
            if (NULL != (ellipsoidDef = CSMap::CS_eldef (m_csParameters->datum.ell_knm)))
                {
                ellipsoidSource = ellipsoidDef->source;
                // free the ellipsoid.
                CSMap::CS_free (ellipsoidDef);
                }
            }
        }
    return ellipsoidSource.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetEllipsoidEquatorialRadius () const
    {
    if (NULL != m_csParameters)
        return m_csParameters->datum.e_rad;
    else
        return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetEllipsoidPolarRadius () const
    {
    if (NULL != m_csParameters)
        return m_csParameters->datum.p_rad;
    else
        return 0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::GetEllipsoidEccentricity () const
    {
    if (NULL != m_csParameters)
        return m_csParameters->datum.ecent;
    else
        return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool    BaseGCS::GetCanEdit () const
    {
    return m_canEdit;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void    BaseGCS::SetCanEdit
(
bool    value
)
    {
    m_canEdit = value;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double          BaseGCS::GetScaleAlongMeridian
(
GeoPointCR      point
) const
    {
    if (NULL != m_csParameters)
        return CSMap::CS_cssch (m_csParameters, &point);
    else
        return 1.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double          BaseGCS::GetScaleAlongParallel
(
GeoPointCR      point
) const
    {
    if (NULL != m_csParameters)
        return CSMap::CS_cssck (m_csParameters, &point);
    else
        return 1.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double          BaseGCS::GetGridScale
(
GeoPointCR      point
) const
    {
    if (NULL != m_csParameters)
        return CSMap::CS_csscl (m_csParameters, &point);
    else
        return 1.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double          BaseGCS::GetConvergenceAngle
(
GeoPointCR      point
) const
    {
    if (NULL != m_csParameters)
        return CSMap::CS_cscnv (m_csParameters, &point);
    else
        return 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::GetDistance
(
double      *distance,
double      *azimuth,
GeoPointCR  startPoint,
GeoPointCR  endPoint
) const
    {

    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    StatusInt status = GetDistanceInMeters(distance, azimuth, startPoint, endPoint);

    if (NULL != distance)
        *distance *= UnitsFromMeters();

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::GetDistanceInMeters
(
double      *distance,
double      *azimuth,
GeoPointCR  startPoint,
GeoPointCR  endPoint
) const
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    double  tempDistance;
    double  tempAzimuth;
    if (NULL == distance)
        distance = &tempDistance;
    if (NULL == azimuth)
        azimuth = &tempAzimuth;

    double  equatorialRadius = GetEllipsoidEquatorialRadius ();
    double  eccentricity     = GetEllipsoidEccentricity ();

    *azimuth = CSMap::CS_llazdd (equatorialRadius, eccentricity * eccentricity, &startPoint, &endPoint, distance);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       BaseGCS::GetCenterPoint
(
GeoPointR       centerPoint
) const
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    if (0 != m_csError)
        {
        centerPoint.Init (0.0, 0.0, 0.0);
        return m_csError;
        }
    // In examiming it, I discovered that CS_fillIn seems to always set csdef.org_lng and csdef.org_lat.
    // Thus I use it rather than try to figure out how to use the cs_prjprm function. It seemed to me that
    // we needed access to their cs_prjTab structure, but that they did not give access through the API.
    CSDefinition tempCS = m_csParameters->csdef;
    CSMap::CS_fillIn (&tempCS);
    centerPoint.Init (tempCS.org_lng, tempCS.org_lat, 0.0);

    // if we have a LocalTransformer, we want to go to Cartesian, transform, then go back to LL.
    if (m_localTransformer.IsValid())
        {
        DPoint3d    cartesian = {0.0, 0.0, 0.0};

        LatLongFromCartesian (centerPoint, cartesian);

#if defined (VERIFICATION_DEBUGGING)
        // use the CS-map function directly to get the center point in the underlying GCS's Cartesian coordinates.
        CSMap::CS_ll3cs (m_csParameters, &internalCartesian, &centerPoint);

        // get that Cartesian point to be converted from internal and to internal and around
        // This is debug only code and the result is discarded.
        DPoint3d    cartesian1, cartesian2;
        InternalCartesianFromCartesian (cartesian1, internalCartesian);
        CartesianFromInternalCartesian (cartesian2, internalCartesian);

        DPoint3d    check1, check2;
        InternalCartesianFromCartesian (check2, cartesian2);
        CartesianFromInternalCartesian (check1, cartesian1);

        CSMap::CS_cs3ll (m_csParameters, &center1, &cartesian1);
        CSMap::CS_cs3ll (m_csParameters, &center2, &cartesian2);
#endif

        }

    return SUCCESS;
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::IsEquivalent (BaseGCSCR compareTo) const
    {
    bool    datumDifferent, csDifferent, verticalDatumDifferent, localTransformDifferent;
    return Compare (compareTo, datumDifferent, csDifferent, verticalDatumDifferent, localTransformDifferent, true);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::IsEqual (BaseGCSCR compareTo) const
    {
    if (NULL == m_csParameters)
        return false;

    if (NULL == compareTo.m_csParameters)
        return false;

    CSDefinition    thisDef    = m_csParameters->csdef;
    CSDefinition    compareDef = compareTo.m_csParameters->csdef;

    // the projection codes have to match.
    if (m_csParameters->prj_code != compareTo.m_csParameters->prj_code)
        return false;

    // the projection flags have to match.
    if (m_csParameters->prj_flags != compareTo.m_csParameters->prj_flags)
        return false;

    // unless the prj_flgs says no origin longitude is used (note bit set means not used), they must be equal.
    if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGLNG)) && !doubleSame (thisDef.org_lng, compareDef.org_lng) )
        return false;

    // unless the prj_flgs says no origin latitude is used (note bit set means not used), they must be equal.
    if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGLAT)) && !doubleSame (thisDef.org_lat, compareDef.org_lat) )
        return false;

    // if the scale is not the same, they're not same units, can't be the same.
    if (!doubleSame (thisDef.scale, compareDef.scale))
        return false;

    // unless the prj_flgs says no false easting/northing is used (note bit set means not use), they must be equal.
    if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGFLS)) && (!distanceSame (thisDef.x_off, compareDef.x_off) || !distanceSame (thisDef.y_off, compareDef.y_off)) )
        return false;

    // if the prj_flgs says a scale reduction is used (note bit set used), they must be equal.
    if ( (0 != (m_csParameters->prj_flags & cs_PRJFLG_SCLRED)) && !doubleSame (thisDef.scl_red, compareDef.scl_red))
        return false;

    // find the parameter map for this projection
    struct cs_PrjprmMap_ *mp;
    for (mp = cs_PrjprmMap; mp->prj_code != cs_PRJCOD_END; mp++)
        {
        if (mp->prj_code == m_csParameters->prj_code)
            break;
        }

    if (mp->prj_code == cs_PRJCOD_END)
        return true;

    if (cs_PRJCOD_UNITY != m_csParameters->prj_code) // All others (except lat/long for which parameters are irrelevant)
        {
        // find which parameters are needed for the projection by using cs_prjprm, compare those.
        double *thisDouble;
        double *compareDouble;
        int     iParam;
        for (iParam = 0, thisDouble = &thisDef.prj_prm1, compareDouble = &compareDef.prj_prm1; iParam < 24; iParam++, thisDouble++, compareDouble++)
            {
            // if the parameter index is 0, then that parameter's not used. There are never any embedded 0's so we can stop at the first one we encounter.
            // NOTE: we don't need to know what it's used for, just that it is used.
            int parameterIndex = mp->prm_types[iParam];
            if (parameterIndex <= 0)
                break;

            // for the northern/southern hemisphere parameter, 0 and 1 are the same.
            if (cs_PRMCOD_HSNS == parameterIndex)
               {
               if ( (*thisDouble >= 0.0) != (*compareDouble >= 0.0) )
                    return false;
               }
            else
                {
                if (!doubleSame (*thisDouble, *compareDouble))
                    return false;
                }
            }
        }

    // Keynames must be the same (if set)
    if (0 != strcmp (m_csParameters->datum.key_nm, compareTo.m_csParameters->datum.key_nm))
        return false;

    // If datum keyname is null the ellipsoid must be the same
    if ( (0 == m_csParameters->datum.key_nm[0]) && (0 != strcmp (m_csParameters->datum.ell_knm, compareTo.m_csParameters->datum.ell_knm)) )
        return false;

    if (m_verticalDatum != compareTo.m_verticalDatum)
        return false;

    if (!LocalTransformer::IsEquivalent (m_localTransformer, compareTo.m_localTransformer))
        return false;

    // quads must match.
    if (thisDef.quad != compareDef.quad)
        return false;

    if (!Utf8String(GetDescription()).Equals(compareTo.GetDescription()))
        return false;

    Utf8String tempString1;
    Utf8String tempString2;
    if (!Utf8String(GetSource(tempString1)).Equals(compareTo.GetSource(tempString2)))
        return false;

    if (!Utf8String(GetName()).Equals(compareTo.GetName()))
        return false;

    if (!Utf8String(GetGroup(tempString1)).Equals(compareTo.GetGroup(tempString1)))
        return false;

    if (!Utf8String(GetUnits(tempString1)).Equals(compareTo.GetUnits(tempString1)))
        return false;

    if (!doubleSame(GetMinimumLongitude(), compareTo.GetMinimumLongitude()))
        return false;

    if (!doubleSame(GetMaximumLongitude(), compareTo.GetMaximumLongitude()))
        return false;

    if (!doubleSame(GetMinimumLatitude(), compareTo.GetMinimumLatitude()))
        return false;

    if (!doubleSame(GetMaximumLatitude(), compareTo.GetMaximumLatitude()))
        return false;

    return true;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::CorrectVerticalDatumToPreserveLegacyElevation(const DRange3d& extent, BaseGCSCR targetGCS)
    {
    DPoint3d midPoint = DPoint3d::From((extent.high.x + extent.low.x) / 2, (extent.high.y + extent.low.y) / 2, (extent.high.z + extent.low.z) / 2);

    Transform transformNoElevation;
    SetReprojectElevation(false);
    ReprojectStatus res = GetLinearTransform(&transformNoElevation, extent, targetGCS, nullptr, nullptr);
    if (!(REPROJECT_Success == res || REPROJECT_CSMAPERR_OutOfUsefulRange == res || REPROJECT_CSMAPERR_VerticalDatumConversionError == res))
        return ERROR;

    Transform transformWithElevation;
    SetReprojectElevation(true);
    res = GetLinearTransform(&transformWithElevation, extent, targetGCS, nullptr, nullptr);
    if (!(REPROJECT_Success == res || REPROJECT_CSMAPERR_OutOfUsefulRange == res || REPROJECT_CSMAPERR_VerticalDatumConversionError == res))
        return ERROR;

    DPoint3d ptTransformedNoElevation, ptTransformedWithElevation;
    transformNoElevation.Multiply(ptTransformedNoElevation, midPoint);
    transformWithElevation.Multiply(ptTransformedWithElevation, midPoint);
    if (fabs(ptTransformedNoElevation.z - ptTransformedWithElevation.z) > 1E-6)
        {
        std::vector<VertDatumCode> verticalDatums{ vdcFromDatum, vdcGeoid, vdcEllipsoid };
        if (IsNAD27() || IsNAD83())
            {
            verticalDatums.push_back(vdcNGVD29);
            verticalDatums.push_back(vdcNAVD88);
            }

        for (auto verticalDatum : verticalDatums)
            {
            BaseGCSPtr copyGCS = BaseGCS::CreateGCS(*this);
            copyGCS->SetVerticalDatumCode(verticalDatum);
            res = copyGCS->GetLinearTransform(&transformWithElevation, extent, targetGCS, nullptr, nullptr);
            if ((REPROJECT_Success == res || REPROJECT_CSMAPERR_OutOfUsefulRange == res || REPROJECT_CSMAPERR_VerticalDatumConversionError == res))
                {
                transformWithElevation.Multiply(ptTransformedWithElevation, midPoint);
                if (fabs(ptTransformedNoElevation.z - ptTransformedWithElevation.z) <= 1E-6)
                    {
                    // we can use this vertical datum - when the extent is reprojected and this vertical datum
                    // is set the extent elevation will be the same as if it was reprojected with reproject
                    // elevation switched off as was the case with legacy code
                    SetVerticalDatumCode(verticalDatum);
                    break;
                    }
                }
            }
        }

    return SUCCESS; // success may mean nothing changed, a suitable vertical datum was already selected
    }

#define SET_RETURN_OPT(var)   {var=true;if(stopFirstDifference) return false;}
#define SET_RETURN(var)       {var=true;return false;}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
inline double BaseGCSUtilGetUTMZoneCenterMeridian(int zoneNumber)
    {
    return ((zoneNumber - 30) * 6) - 3;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
*
* @param datum1, datum2 - The datums to compare
* @param tolerateEquivalentDifferencesWhenDeprecated - true indicates that the method
*        can consider deprecated datums (LEGACY group) as equivalent if datum are equivalent
*        in everything else
* @param tolerateEquivalentDifferencesInAllCases - true indicates that the method
*        can consider  datums as equivalent if datum transformation method are equivalent
*        in everything else (mathematically). This for example includes a 7 parameter
*        transform with scale of 0 PPM with 6 parameter transform and so on.
* @param shallowCompare - true indicates that the datum definition only is compared and
*                         the actual geodetic transform if external is not obtained nor
*                         compared. This must be used if a datum is not extracted from
*                         system dictionary.
+---------------+---------------+---------------+---------------+---------------+------*/
static bool     DatumEquivalent
(
CSDatum&    datum1,
CSDatum&    datum2,
bool tolerateEquivalentDifferencesWhenDeprecated,
bool tolerateEquivalentDifferencesInAllCases,
bool shallowCompare
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return false;

    bool oneIsDeprecated = false;

    // if keynames are the same we can skip this.
    if ( (0 != datum1.key_nm[0]) && (0 != datum2.key_nm[0]) && (0 == strcmp (datum1.key_nm, datum2.key_nm)) )
        return true;

    if (!distanceSame(datum1.e_rad, datum2.e_rad))
        return false;

    if (!distanceSame(datum1.p_rad, datum2.p_rad))
        return false;

    // Although the geocentric parameters may be set we want to distanciate from the concept of
    // fallback for grid files. Even if those were originally set we want to consider the grid files to be always reachable.
    // and thus different geocentric parameter values are then considered irrelevant.
    bool transform1IsGeocentric = (datum1.to84_via == cs_DTCTYP_MOLO ||
                                   datum1.to84_via == cs_DTCTYP_GEOCTR ||
                                   datum1.to84_via == cs_DTCTYP_3PARM ||
                                   datum1.to84_via == cs_DTCTYP_7PARM ||
                                   datum1.to84_via == cs_DTCTYP_4PARM ||
                                   datum1.to84_via == cs_DTCTYP_6PARM ||
                                   datum1.to84_via == cs_DTCTYP_BURS);


    bool transform2IsGeocentric = (datum2.to84_via == cs_DTCTYP_MOLO ||
                                   datum2.to84_via == cs_DTCTYP_GEOCTR ||
                                   datum2.to84_via == cs_DTCTYP_3PARM ||
                                   datum2.to84_via == cs_DTCTYP_7PARM ||
                                   datum2.to84_via == cs_DTCTYP_4PARM ||
                                   datum2.to84_via == cs_DTCTYP_6PARM ||
                                   datum2.to84_via == cs_DTCTYP_BURS);

    if (transform1IsGeocentric && transform2IsGeocentric)
        {
        if (!distanceSame(datum1.delta_X, datum2.delta_X))
            return false;

        if (!distanceSame(datum1.delta_Y, datum2.delta_Y))
            return false;

        if (!distanceSame(datum1.delta_Z, datum2.delta_Z))
            return false;

        if (!doubleSame (datum1.rot_X, datum2.rot_X))
            return false;

        if (!doubleSame (datum1.rot_Y, datum2.rot_Y))
            return false;

        if (!doubleSame (datum1.rot_Z, datum2.rot_Z))
            return false;

        if (!doubleSame(datum1.bwscale, datum2.bwscale))
            return false;
        }

    bool transform1IsGridFile = (datum1.to84_via == cs_DTCTYP_NAD27 ||
                                 datum1.to84_via == cs_DTCTYP_NAD83 ||
                                 datum1.to84_via == cs_DTCTYP_HPGN ||
                                 datum1.to84_via == cs_DTCTYP_AGD66 ||
                                 datum1.to84_via == cs_DTCTYP_AGD84 ||
                                 datum1.to84_via == cs_DTCTYP_NZGD49 ||
                                 datum1.to84_via == cs_DTCTYP_ATS77 ||
                                 datum1.to84_via == cs_DTCTYP_NZGD2K ||
                                 datum1.to84_via == cs_DTCTYP_CSRS ||
                                 datum1.to84_via == cs_DTCTYP_TOKYO ||
                                 datum1.to84_via == cs_DTCTYP_RGF93 ||
                                 datum1.to84_via == cs_DTCTYP_DHDN ||
                                 datum1.to84_via == cs_DTCTYP_CHENYX ||
                                 datum1.to84_via == cs_DTCTYP_GENGRID ||
                                 datum1.to84_via == cs_DTCTYP_ED50 ||
                                 datum1.to84_via == cs_DTCTYP_GDA94);

    bool transform2IsGridFile = (datum2.to84_via == cs_DTCTYP_NAD27 ||
                                 datum2.to84_via == cs_DTCTYP_NAD83 ||
                                 datum2.to84_via == cs_DTCTYP_HPGN ||
                                 datum2.to84_via == cs_DTCTYP_AGD66 ||
                                 datum2.to84_via == cs_DTCTYP_AGD84 ||
                                 datum2.to84_via == cs_DTCTYP_NZGD49 ||
                                 datum2.to84_via == cs_DTCTYP_ATS77 ||
                                 datum2.to84_via == cs_DTCTYP_NZGD2K ||
                                 datum2.to84_via == cs_DTCTYP_CSRS ||
                                 datum2.to84_via == cs_DTCTYP_TOKYO ||
                                 datum2.to84_via == cs_DTCTYP_RGF93 ||
                                 datum2.to84_via == cs_DTCTYP_DHDN ||
                                 datum2.to84_via == cs_DTCTYP_CHENYX ||
                                 datum2.to84_via == cs_DTCTYP_GENGRID ||
                                 datum2.to84_via == cs_DTCTYP_ED50 ||
                                 datum2.to84_via == cs_DTCTYP_GDA94);

    // If the methods are different (but not both grid files) we need additional checks ...
    // Note that the support of grid files as a datum setting has been deprecated. Grid file support is
    // fully a matter of the geodetic transform thus checked below (if not shallow compare)
    if (datum1.to84_via != datum2.to84_via && !(transform1IsGridFile && transform2IsGridFile))
        {
        // If the methods are fundamentally equal ... we tolerate
        // Note that we include MOLO / GEOCENTRIC or 3PARAMs is their delta values are zero
        bool isNullTransfo1 = ((datum1.to84_via == cs_DTCTYP_NONE) || (datum1.to84_via == cs_DTCTYP_NAD83) ||
                               (datum1.to84_via == cs_DTCTYP_WGS84) || (datum1.to84_via == cs_DTCTYP_ETRF89) ||
                               (((datum1.to84_via == cs_DTCTYP_MOLO) || (datum1.to84_via == cs_DTCTYP_GEOCTR) || (datum1.to84_via == cs_DTCTYP_3PARM)) &&
                                 (distanceSame(datum1.delta_X, 0.0) && distanceSame(datum1.delta_Y, 0.0) && distanceSame(datum1.delta_Z, 0.0))) ||
                                   ((datum1.to84_via == cs_DTCTYP_7PARM) &&
                                    (distanceSame(datum1.delta_X, 0.0) && distanceSame(datum1.delta_Y, 0.0) && distanceSame(datum1.delta_Z, 0.0) &&
                                     doubleSame(datum1.rot_X, 0.0) && doubleSame(datum1.rot_Y, 0.0) && doubleSame(datum1.rot_Z, 0.0) && doubleSame(datum1.bwscale, 0.0))));
        bool isNullTransfo2 = ((datum2.to84_via == cs_DTCTYP_NONE) || (datum2.to84_via == cs_DTCTYP_NAD83) ||
                               (datum2.to84_via == cs_DTCTYP_WGS84) || (datum2.to84_via == cs_DTCTYP_ETRF89) ||
                               (((datum2.to84_via == cs_DTCTYP_MOLO) || (datum2.to84_via == cs_DTCTYP_GEOCTR) || (datum2.to84_via == cs_DTCTYP_3PARM)) &&
                                 (distanceSame(datum2.delta_X, 0.0) && distanceSame(datum2.delta_Y, 0.0) && distanceSame(datum2.delta_Z, 0.0))) ||
                                   ((datum2.to84_via == cs_DTCTYP_7PARM) &&
                                    (distanceSame(datum2.delta_X, 0.0) && distanceSame(datum2.delta_Y, 0.0) && distanceSame(datum2.delta_Z, 0.0) &&
                                     doubleSame(datum2.rot_X, 0.0) && doubleSame(datum2.rot_Y, 0.0) && doubleSame(datum2.rot_Z, 0.0) && doubleSame(datum2.bwscale, 0.0))));

        if (!(isNullTransfo1 && isNullTransfo2))
            {
            if (!tolerateEquivalentDifferencesWhenDeprecated && !tolerateEquivalentDifferencesInAllCases)
                return false;
            else
                {
                // We tolerate some differences in the method when one is deprecated or in all cases depending on flag
                // First check if the methods are possibly compatible
                if (((datum1.to84_via == cs_DTCTYP_MOLO) || (datum1.to84_via == cs_DTCTYP_GEOCTR) || (datum1.to84_via == cs_DTCTYP_3PARM)) &&
                    ((datum2.to84_via == cs_DTCTYP_MOLO) || (datum2.to84_via == cs_DTCTYP_GEOCTR) || (datum2.to84_via == cs_DTCTYP_3PARM)))
                    {
                    // Both datum use one of the transformations based on 3 parameters and we already know their parameters to be equal.

                    if (!tolerateEquivalentDifferencesInAllCases)
                        {
                        // All we need to determine is if either datum is deprecated.
                        // Unfortunately the CSDatum structure does not hold the group name which is used to store
                        // the deprecated indication ("LEGACY")
                        DatumCP datum1raw = Datum::CreateDatum(datum1.key_nm);
                        DatumCP datum2raw = Datum::CreateDatum(datum2.key_nm);

                        bool deprecated1 = datum1raw->IsDeprecated();
                        bool deprecated2 = datum2raw->IsDeprecated();

                        datum1raw->Destroy();
                        datum2raw->Destroy();
                        oneIsDeprecated = deprecated1 || deprecated2; // This flag is used below for testing geodetic path.
                        if (!deprecated1 && !deprecated2)
                            return false;  // None are deprecated ... we consider different.
                        }
                    }
                else if (((datum1.to84_via == cs_DTCTYP_7PARM) || (datum1.to84_via == cs_DTCTYP_BURS) || (datum1.to84_via == cs_DTCTYP_6PARM)) &&
                         ((datum2.to84_via == cs_DTCTYP_7PARM) || (datum2.to84_via == cs_DTCTYP_BURS) || (datum2.to84_via == cs_DTCTYP_6PARM)))
                    {
                    // Both datum use one of the transformations based on 3 parameters and we already know their parameters to be equal.

                    if (!tolerateEquivalentDifferencesInAllCases)
                        {
                        // All we need to determine is if either datum is deprecated.
                        // Unfortunately the CSDatum structure does not hold the group name which is used to store
                        // the deprecated indication ("LEGACY")
                        DatumCP datum1raw = Datum::CreateDatum(datum1.key_nm);
                        DatumCP datum2raw = Datum::CreateDatum(datum2.key_nm);

                        bool deprecated1 = datum1raw->IsDeprecated();
                        bool deprecated2 = datum2raw->IsDeprecated();

                        datum1raw->Destroy();
                        datum2raw->Destroy();
                        oneIsDeprecated = deprecated1 || deprecated2; // This flag is used below for testing geodetic path.
                        if (!deprecated1 && !deprecated2)
                            return false;  // None are deprecated ... we consider different.
                        }
                    }
                }
            }
        }

    // If shallow compare we stop here and consider the datum equal without extracting the
    // geodetic transformations.
    if (shallowCompare)
        return true;

    // Starting with latest version of csmap the geodetic transformation is not part of the
    // datum proper (except for fallback backward compatibility) so it may happen that
    // datum have identical definitions but should be considered different.
    // To verify we must generate the datum converter and verify they are equivalent
    //
    // Note that the following process may result into false-positives but we have decided that better be safe than sorry and
    // go through an unrequired reprojection instead to taking the risk of considering datums equivalent while they are not.
    CSDatumDef* wgs84Def = CSMap::CS_dtdef("WGS84");

    // If we did not get the datum definition then we will consider the datums equivalent
    if (NULL == wgs84Def)
        return true;

    CSDatum* wgs84 = CSdtloc1(wgs84Def);

    CSMap::CS_free(wgs84Def);

    if (NULL == wgs84)
        {
        return true;
        }

    // TODO Switch to using DatumConverter and GeodeticTransform class

    CSDatumConvert* theDatumConverter1 = CSMap::CSdtcsu (&datum1, wgs84);
    CSDatumConvert* theDatumConverter2 = CSMap::CSdtcsu (&datum2, wgs84);

    CSMap::CS_free(wgs84);

    // If no datum converter can be created we cannot judge the equivalence.
    // We will consider the datums equal since in all likelyhood they effectively are.
    if (NULL == theDatumConverter1 && NULL == theDatumConverter2)
        return true;

    // If only one is null then we will assume different datums since they would not result into
    // any equivalent transformation
    if (NULL != theDatumConverter1 && NULL == theDatumConverter2)
        {
        CSMap::CS_dtcls (theDatumConverter1);
        return false;
        }
    if (NULL == theDatumConverter1 && NULL != theDatumConverter2)
        {
        CSMap::CS_dtcls (theDatumConverter2);
        return false;
        }


    // Now we must analyse the datum converter to determine if the transformation is equivalent.
    // Notice that there is no function provided by CSMAP for the purpose yet.
    bool datumsEquivalent = true;

    if (theDatumConverter1->xfrmCount != theDatumConverter2->xfrmCount)
        datumsEquivalent = false;

    // For every individual transformation part of the convertion path ...
    for (int idxXForms=0 ; datumsEquivalent && (idxXForms < theDatumConverter1->xfrmCount); idxXForms++)
        {
#if (0) // TODO Something wrong here ... will be fixed
        // Compare selected fields only
        if ((theDatumConverter1->xforms[idxXForms]->methodCode       != theDatumConverter2->xforms[idxXForms]->methodCode) ||
            (theDatumConverter1->xforms[idxXForms]->isNullXfrm       != theDatumConverter2->xforms[idxXForms]->isNullXfrm) ||
            (!doubleSame(theDatumConverter1->xforms[idxXForms]->accuracy, theDatumConverter2->xforms[idxXForms]->accuracy)))
            {
#if (0)
            if (!tolerateEquivalentDifferencesInAllCases)
                datumsEquivalent = false;
            else
                {
                bool equivalentMethod;
                // Even though method may be different we check in more details for equivalence
                if (((theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_MOLOD) || (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_GEOCT) || (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_3PARM)) &&
                    ((theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_MOLOD) || (theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_GEOCT) || (theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_3PARM)))
                    {
                    // Three parameter transform of some kind ... we consider equivalent
                    equivalentMethod = true;
                    }
                else if (((theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_MOLOD) ||
                          (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_GEOCT) ||
                          (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_3PARM)) &&
                        ((theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_7PARM)))
                    {
                    // Check that rotation s 0.0 for all components
                    if (!doubleSame(theDatumConverter2->xforms[idxXForms]->
                    // Check that scale PPM is zero
                    }


                }
#else
            datumsEquivalent = false;
#endif
            }
#endif

        // So far so good but now we must check the specific parameters. Except for grid shift files we can assume
        // a simple compare will do the job.
        // NOTE: Abridged Molodenski stores for debugging purposes the names of the datums
        // as part of its structure. As the names may be different this would result into those being
        // considered different. Since csmap has not activated Abridged Molodenski yet an we do not intend to use it we will
        // simply live with these eventual false-negatives.
        // For grid shift files since the pointers to file names will be different even if refering to the same file we must be
        // more precise.
        if (datumsEquivalent)
            {
            // If it is one of the grid shift file method
            if ((cs_DTCPRMTYP_GRIDINTP & cs_DTCPRMTYP_MASK) == (theDatumConverter1->xforms[idxXForms]->methodCode & cs_DTCPRMTYP_MASK))
                {
                struct csGridi_* datum1GridXForm = (struct csGridi_*)&(theDatumConverter1->xforms[idxXForms]->xforms.gridi);
                struct csGridi_* datum2GridXForm = (struct csGridi_*)&(theDatumConverter2->xforms[idxXForms]->xforms.gridi);

                // First test the various numeric parameters
                if ((datum1GridXForm->maxIterations != datum2GridXForm->maxIterations) ||
                    (datum1GridXForm->userDirection != datum2GridXForm->userDirection) ||
                    (datum1GridXForm->useBest != datum2GridXForm->useBest) ||
                    (datum1GridXForm->fallbackDir != datum2GridXForm->fallbackDir) ||
                    (datum1GridXForm->fileCount != datum2GridXForm->fileCount))
                    datumsEquivalent = false;

                // Fallback requires some detail checking
                if (datumsEquivalent)
                    {
                    if (datum1GridXForm->fallback != datum2GridXForm->fallback)
                        {
                        // The fallbacks pointed may be different but then they must refer to the same fallback transform name.
                        if ((NULL == datum1GridXForm->fallback) || (NULL == datum2GridXForm->fallback))
                            datumsEquivalent = false;

                        if ((datumsEquivalent) && (0 != strncmp(datum1GridXForm->fallback->xfrmName, datum2GridXForm->fallback->xfrmName, sizeof (datum2GridXForm->fallback->xfrmName))))
                            datumsEquivalent = false;
                        }
                    }

                if (datumsEquivalent)
                    {
                    // All that remains is to compare file names and individual grid shift file method params. Notice that the order of the files is important
                    // for grid shift files so we impose the exact same order also
                    for (short fileIdx = 0 ; datumsEquivalent && (fileIdx < datum1GridXForm->fileCount) ; fileIdx++)
                        {
                        // Only selected fields are tested as the structure contains cache and buffering members.
                        if ((datum1GridXForm->gridFiles[fileIdx]->direction != datum2GridXForm->gridFiles[fileIdx]->direction) ||
                            (datum1GridXForm->gridFiles[fileIdx]->format != datum2GridXForm->gridFiles[fileIdx]->format) ||
                            (datum1GridXForm->gridFiles[fileIdx]->density != datum2GridXForm->gridFiles[fileIdx]->density) ||
                            (datum1GridXForm->gridFiles[fileIdx]->errorValue != datum2GridXForm->gridFiles[fileIdx]->errorValue) ||
                            (datum1GridXForm->gridFiles[fileIdx]->cnvrgValue != datum2GridXForm->gridFiles[fileIdx]->cnvrgValue) ||
                            (datum1GridXForm->gridFiles[fileIdx]->maxIterations != datum2GridXForm->gridFiles[fileIdx]->maxIterations))
                            datumsEquivalent = false;

                        // All that remains to check is the filename
                        if (datumsEquivalent)
                            {
                            datumsEquivalent = (0 == strncmp(datum1GridXForm->gridFiles[fileIdx]->filePath, datum2GridXForm->gridFiles[fileIdx]->filePath, MAXPATH));
                            }
                        }
                    }
                }
            else
                {
                // None of the other methods have pointer outside their structure except for Abridged Molodenski we do not use anyway
                // and currently deactivated by csmap we simply compare byte-wise
//                size_t sizeToCompare = sizeof(theDatumConverter1->xforms[idxXForms]) - (size_t)(((Byte*)(&(theDatumConverter1->xforms[idxXForms])) - (Byte*)(&(theDatumConverter1->xforms[idxXForms]->methodCode))));
                size_t sizeToCompare = (size_t)(((Byte*)(&(theDatumConverter1->xforms[idxXForms]->xfrmName)) - (Byte*)(&(theDatumConverter1->xforms[idxXForms]->methodCode))));
                datumsEquivalent = (0 == memcmp((Byte*) &(theDatumConverter1->xforms[idxXForms]->methodCode), (Byte*) &(theDatumConverter2->xforms[idxXForms]->methodCode), sizeToCompare));

                if (!datumsEquivalent && (oneIsDeprecated && tolerateEquivalentDifferencesWhenDeprecated || tolerateEquivalentDifferencesInAllCases))
                    {

                    // In some case we consider two different transformations as equivalent enough when the flag is set and at least
                    if (((theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_MOLOD) || (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_GEOCT) || (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_3PARM)) &&
                        ((theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_MOLOD) || (theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_GEOCT) || (theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_3PARM)))
                        {
                        if (distanceSame(((((theDatumConverter1->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaX, ((((theDatumConverter2->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaX) &&
                            distanceSame(((((theDatumConverter1->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaY, ((((theDatumConverter2->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaY) &&
                            distanceSame(((((theDatumConverter1->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaZ, ((((theDatumConverter2->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaZ))
                            datumsEquivalent = true; // They are basically similar so we revert the equivalence flag.
                        }
                    }

                if (!datumsEquivalent) // If non equivalent whatever the deprecation state we tolerate many ways of expressing a null transformation
                    {
                    if (( (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_MOLOD) || (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_GEOCT) ||
                          (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_3PARM) || (theDatumConverter1->xforms[idxXForms]->methodCode == cs_DTCMTH_NULLX)) &&
                        ( (theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_MOLOD) || (theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_GEOCT) ||
                          (theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_3PARM) || (theDatumConverter2->xforms[idxXForms]->methodCode == cs_DTCMTH_NULLX)))
                        {
                        // If the transform parameters are equal to zero then even if not deprecated they may be identical
                        if (distanceSame(((((theDatumConverter1->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaX, ((((theDatumConverter2->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaX) &&
                            distanceSame(((((theDatumConverter1->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaY, ((((theDatumConverter2->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaY) &&
                            distanceSame(((((theDatumConverter1->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaZ, ((((theDatumConverter2->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaZ))
                            {
                            if (distanceSame(((((theDatumConverter1->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaX, 0.0) &&
                                distanceSame(((((theDatumConverter1->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaY, 0.0) &&
                                distanceSame(((((theDatumConverter1->xforms[idxXForms])->gxDef).parameters).geocentricParameters).deltaZ, 0.0))
                                datumsEquivalent = true;
                            }
                        }
                    }
                }
            }
        }

    // Release the datum converters.
    CSMap::CS_dtcls (theDatumConverter1);
    CSMap::CS_dtcls (theDatumConverter2);

    // The following additional step is required for cases where the datum transformations to WGS84 are identical but there exists a
    // specific geodetic path between the two specified datums. This will occur for example for some NAD83 variants.
    // NAD83 is considered coincident to WGS84 and so is NSRS11 (NAD83/2011) but there exists a complex geodetic transformation
    // path between NAD83 to NSRS11 that must be applied anyway for these source and target.
    if (datumsEquivalent)
        {
        CSDatumConvert* theDatumConverterDirect = CSMap::CSdtcsu(&datum1, &datum2);
        // If datum converter can be created we cannot judge the equivalence.
        // We will consider the datums equal since in all likelyhood they effectively are.
        if (NULL == theDatumConverterDirect)
            return true;

        // The datum transformation must contain null transformations only (or no transformation)
        if (theDatumConverterDirect->xfrmCount != 0)
            {
            bool tentativeDatumEquivalent = true;
            for (int indexXForm = 0 ; indexXForm < theDatumConverterDirect->xfrmCount ; ++indexXForm)
                {
                if (false == theDatumConverterDirect->xforms[indexXForm]->isNullXfrm)
                    {
                    // Some transformations are not null. The only possible equality is if there are two
                    // transformations that are identical but reversed. We will check at the exit of loop
                    tentativeDatumEquivalent = false;
                    }
                }

            if (!tentativeDatumEquivalent)
                {
                // One or more transformation is not null ... check if two oposite identical xforms
                if (2 == theDatumConverterDirect->xfrmCount)
                    {
                    size_t sizeToCompare = (size_t)(((Byte*)(&(theDatumConverterDirect->xforms[0]->xfrmName)) - (Byte*)(&(theDatumConverterDirect->xforms[0]->epsgNbr))));
                    tentativeDatumEquivalent = (0 == memcmp((Byte*) &(theDatumConverterDirect->xforms[0]->epsgNbr), (Byte*) &(theDatumConverterDirect->xforms[1]->epsgNbr), sizeToCompare));
                    tentativeDatumEquivalent = tentativeDatumEquivalent && (theDatumConverterDirect->xforms[0]->methodCode == theDatumConverterDirect->xforms[1]->methodCode);
                    }
                }

            datumsEquivalent = tentativeDatumEquivalent;
            }
        CSMap::CS_dtcls(theDatumConverterDirect);
        }

    return datumsEquivalent;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::Compare (BaseGCSCR compareTo, bool& datumDifferent, bool& csDifferent, bool& verticalDatumDifferent, bool& localTransformDifferent, bool stopFirstDifference) const
    {
    datumDifferent          = false;
    csDifferent             = false;
    verticalDatumDifferent  = false;
    localTransformDifferent = false;

    if (NULL == m_csParameters)
        return false;

    if (NULL == compareTo.m_csParameters)
        return false;

    CSDefinition    thisDef    = m_csParameters->csdef;
    CSDefinition    compareDef = compareTo.m_csParameters->csdef;

    bool isTransverseMercator = (m_csParameters->prj_code == cs_PRJCOD_TRMER || m_csParameters->prj_code == cs_PRJCOD_GAUSSK ||
                                 m_csParameters->prj_code == cs_PRJCOD_TRMERBF || m_csParameters->prj_code == cs_PRJCOD_TRMRKRG);
    bool isCompareTransverseMercator = (compareTo.m_csParameters->prj_code == cs_PRJCOD_TRMER || compareTo.m_csParameters->prj_code == cs_PRJCOD_GAUSSK ||
                                        compareTo.m_csParameters->prj_code == cs_PRJCOD_TRMERBF || compareTo.m_csParameters->prj_code == cs_PRJCOD_TRMRKRG);

    bool isUTM = (m_csParameters->prj_code == cs_PRJCOD_UTM || m_csParameters->prj_code == cs_PRJCOD_UTMZNBF);
    bool isCompareUTM = (compareTo.m_csParameters->prj_code == cs_PRJCOD_UTM || compareTo.m_csParameters->prj_code == cs_PRJCOD_UTMZNBF);


    // Identify different projection codes that are similar and may lead to equivalent coordinate systems
    if ((isUTM && isCompareTransverseMercator) ||
        (isTransverseMercator && isCompareUTM))
        {
        // UTM and Transverse mercator can be equivalent depending on the values of the parameters
        // Obtain the zone and hemisphere of the UTM projection
        int hemisphere;
        int zone;
        double falseEasting;
        double falseNorthing;
        double centralMeridian;
        double scale;

        if (isUTM)
            {
            hemisphere = GetHemisphere ();
            zone = GetUTMZone();
            falseEasting = compareTo.GetFalseEasting();
            falseNorthing = compareTo.GetFalseNorthing();
            centralMeridian = compareTo.GetCentralMeridian();
            scale = compareTo.GetScaleReduction();
            }
        else
            {
            hemisphere = compareTo.GetHemisphere();
            zone = compareTo.GetUTMZone();
            falseEasting = GetFalseEasting();
            falseNorthing = GetFalseNorthing();
            centralMeridian = GetCentralMeridian();
            scale = GetScaleReduction();
            }
        if (!distanceSame(falseEasting, 500000))
            SET_RETURN (csDifferent)

        if (hemisphere == 1)
            {
            if (!distanceSame(0.0, falseNorthing))
                SET_RETURN (csDifferent)
            }
        else
            {
            if (!distanceSame(10000000.0, falseNorthing))
                SET_RETURN (csDifferent)
            }

        if (!doubleSame(centralMeridian, BaseGCSUtilGetUTMZoneCenterMeridian(zone) ))
            SET_RETURN (csDifferent)

        if (!doubleSame(scale, 0.9996))
            SET_RETURN(csDifferent)
        }
    else if (isTransverseMercator && isCompareTransverseMercator)        {
        if (!distanceSame(GetFalseEasting(), compareTo.GetFalseEasting()))
            SET_RETURN(csDifferent)

        if (!distanceSame(GetFalseNorthing(), compareTo.GetFalseNorthing()))
            SET_RETURN(csDifferent)

        if (!doubleSame(GetCentralMeridian(), compareTo.GetCentralMeridian()))
            SET_RETURN(csDifferent)

        if (!doubleSame(GetScaleReduction(), compareTo.GetScaleReduction()))
            SET_RETURN(csDifferent)
        }
    else if ((m_csParameters->prj_code == cs_PRJCOD_MRCAT && compareTo.m_csParameters->prj_code == cs_PRJCOD_MRCATK) ||
             (m_csParameters->prj_code == cs_PRJCOD_MRCATK && compareTo.m_csParameters->prj_code == cs_PRJCOD_MRCAT))
        {
        // Mercator with scale reduction can be equivalent to mercator given the standard parallel expresses
        // the equivalent scale reduction.
        if (m_csParameters->prj_code == cs_PRJCOD_MRCATK)
            {
            double e_sq = m_csParameters->datum.ecent * m_csParameters->datum.ecent;
            double stdParallel = CSmrcatPhiFromK (e_sq, m_csParameters->csdef.scl_red);
            if (!doubleSame(stdParallel, compareTo.m_csParameters->csdef.prj_prm2))
                SET_RETURN (csDifferent)
            }
        else
            {
            double e_sq = compareTo.m_csParameters->datum.ecent * compareTo.m_csParameters->datum.ecent;
            double stdParallel = CSmrcatPhiFromK (e_sq, compareTo.m_csParameters->csdef.scl_red);
            if (!doubleSame(stdParallel, m_csParameters->csdef.prj_prm2))
                SET_RETURN (csDifferent)
            }

        if (!doubleSame (thisDef.prj_prm1, compareDef.prj_prm1))
            SET_RETURN (csDifferent)

        // unless the prj_flgs says no origin longitude is used (note bit set means not used), they must be equal.
        if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGLNG)) && !doubleSame (thisDef.org_lng, compareDef.org_lng) )
            SET_RETURN (csDifferent)

        // unless the prj_flgs says no origin latitude is used (note bit set means not used), they must be equal.
        if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGLAT)) && !doubleSame (thisDef.org_lat, compareDef.org_lat) )
            SET_RETURN (csDifferent)

        // if the scale is not the same, they're not same units, can't be the same.
        if (!doubleSame (thisDef.scale, compareDef.scale))
            SET_RETURN (csDifferent)

        // unless the prj_flgs says no false easting/northing is used (note bit set means not use), they must be equal.
        if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGFLS)) && (!distanceSame (thisDef.x_off, compareDef.x_off) || !distanceSame (thisDef.y_off, compareDef.y_off)) )
            SET_RETURN (csDifferent)

        // if the prj_flgs says a scale reduction is used (note bit set used), they must be equal.
        if ( (0 != (m_csParameters->prj_flags & cs_PRJFLG_SCLRED)) && !doubleSame (thisDef.scl_red, compareDef.scl_red))
            SET_RETURN (csDifferent)

        }
    else if ((m_csParameters->prj_code == cs_PRJCOD_LMTAN && compareTo.m_csParameters->prj_code == cs_PRJCOD_LM1SP) ||
             (m_csParameters->prj_code == cs_PRJCOD_LM1SP && compareTo.m_csParameters->prj_code == cs_PRJCOD_LMTAN))
        {
        // Note that Lambert tangential and Lambert 1 sp are technically identical (same parameters and all)

        // unless the prj_flgs says no origin longitude is used (note bit set means not used), they must be equal.
        if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGLNG)) && !doubleSame (thisDef.org_lng, compareDef.org_lng) )
            SET_RETURN (csDifferent)

        // unless the prj_flgs says no origin latitude is used (note bit set means not used), they must be equal.
        if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGLAT)) && !doubleSame (thisDef.org_lat, compareDef.org_lat) )
            SET_RETURN (csDifferent)

        // if the scale is not the same, they're not same units, can't be the same.
        if (!doubleSame (thisDef.scale, compareDef.scale))
            SET_RETURN (csDifferent)

        // unless the prj_flgs says no false easting/northing is used (note bit set means not use), they must be equal.
        if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGFLS)) && (!distanceSame (thisDef.x_off, compareDef.x_off) || !distanceSame (thisDef.y_off, compareDef.y_off)) )
            SET_RETURN (csDifferent)

        // if the prj_flgs says a scale reduction is used (note bit set used), they must be equal.
        if ( (0 != (m_csParameters->prj_flags & cs_PRJFLG_SCLRED)) && !doubleSame (thisDef.scl_red, compareDef.scl_red))
            SET_RETURN (csDifferent)

        // No additional parameters for Lambert tangential and 1SP
        }
    else
        {
        // General case ...

        // the projection codes have to match unless they are equivalent.
        if (m_csParameters->prj_code != compareTo.m_csParameters->prj_code)
            {
            if (isUTM && isCompareUTM)
                {
                // the projection flags have to match.
                if (m_csParameters->prj_flags != compareTo.m_csParameters->prj_flags)
                    SET_RETURN_OPT(csDifferent)
                }
            else
                SET_RETURN_OPT(csDifferent)
            }
        else
            {

            // the projection flags have to match.
            if (m_csParameters->prj_flags != compareTo.m_csParameters->prj_flags)
                SET_RETURN_OPT (csDifferent)
            }
        // unless the prj_flgs says no origin longitude is used (note bit set means not used), they must be equal.
        if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGLNG)) && !doubleSame (thisDef.org_lng, compareDef.org_lng) )
            SET_RETURN (csDifferent)

        // unless the prj_flgs says no origin latitude is used (note bit set means not used), they must be equal.
        if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGLAT)) && !doubleSame (thisDef.org_lat, compareDef.org_lat) )
            SET_RETURN (csDifferent)

        // if the scale is not the same, they're not same units, can't be the same.
        if (!doubleSame (thisDef.scale, compareDef.scale))
            SET_RETURN (csDifferent)

        // unless the prj_flgs says no false easting/northing is used (note bit set means not use), they must be equal.
        if ( (0 == (m_csParameters->prj_flags & cs_PRJFLG_ORGFLS)) && (!distanceSame (thisDef.x_off, compareDef.x_off) || !distanceSame (thisDef.y_off, compareDef.y_off)) )
            SET_RETURN (csDifferent)

        // if the prj_flgs says a scale reduction is used (note bit set used), they must be equal.
        if ( (0 != (m_csParameters->prj_flags & cs_PRJFLG_SCLRED)) && !doubleSame (thisDef.scl_red, compareDef.scl_red))
            SET_RETURN (csDifferent)

        // find the parameter map for this projection
        struct cs_PrjprmMap_ *mp;
        for (mp = cs_PrjprmMap; mp->prj_code != cs_PRJCOD_END; mp++)
            {
            if (mp->prj_code == m_csParameters->prj_code)
                break;
            }

        if (mp->prj_code == cs_PRJCOD_END)
            return true;

        if ((cs_PRJCOD_LMMICH == m_csParameters->prj_code) ||(cs_PRJCOD_LM2SP == m_csParameters->prj_code) || (cs_PRJCOD_LMBLG == m_csParameters->prj_code) || (cs_PRJCOD_ALBER == m_csParameters->prj_code) || (cs_PRJCOD_EDCNC == m_csParameters->prj_code))
            {
            // We process Lambert 2SP differently since the order of parallels is irrelevant
            if ((!doubleSame(thisDef.prj_prm1,compareDef.prj_prm1) && !doubleSame(thisDef.prj_prm1,compareDef.prj_prm2)) ||
                (!doubleSame(thisDef.prj_prm2,compareDef.prj_prm2) && !doubleSame(thisDef.prj_prm2,compareDef.prj_prm1)))
                SET_RETURN (csDifferent)
            }
        else if (cs_PRJCOD_UNITY != m_csParameters->prj_code) // All others (except lat/long for which parameters are irrelevant)
            {
            // find which parameters are needed for the projection by using cs_prjprm, compare those.
            double *thisDouble;
            double *compareDouble;
            int     iParam;
            for (iParam = 0, thisDouble = &thisDef.prj_prm1, compareDouble = &compareDef.prj_prm1; iParam < 24; iParam++, thisDouble++, compareDouble++)
                {
                // if the parameter index is 0, then that parameter's not used. There are never any embedded 0's so we can stop at the first one we encounter.
                // NOTE: we don't need to know what it's used for, just that it is used.
                int parameterIndex = mp->prm_types[iParam];
                if (parameterIndex <= 0)
                    break;

                // for the northern/southern hemisphere parameter, 0 and 1 are the same.
                if (cs_PRMCOD_HSNS == parameterIndex)
                   {
                   if ( (*thisDouble >= 0.0) != (*compareDouble >= 0.0) )
                        SET_RETURN (csDifferent)
                   }
                else
                    {
                    if (!doubleSame (*thisDouble, *compareDouble))
                        SET_RETURN (csDifferent)
                    }
                }
            }
        }

    DatumCP datum1 = GetDatum();
    DatumCP datum2 = compareTo.GetDatum();

    // If one is null but the other not then they are different. If both are null we do not care.
    if ((nullptr == datum1 && nullptr != datum2) || (nullptr != datum1 && nullptr == datum2))
        SET_RETURN_OPT(datumDifferent)

    if (nullptr != datum1 && nullptr != datum2)
        {
        if (!datum1->IsEquivalent(*datum2))
            SET_RETURN_OPT(datumDifferent)
        }

    // Although this should be unnecessary it is because the compare is actually stricter here ...
    if (!DatumEquivalent(m_csParameters->datum, compareTo.m_csParameters->datum, true, false, false))
        SET_RETURN_OPT(datumDifferent)

    if (NetVerticalDatumFromGCS(*this) != NetVerticalDatumFromGCS(compareTo))
        SET_RETURN_OPT (verticalDatumDifferent)

    if (!LocalTransformer::IsEquivalent (m_localTransformer, compareTo.m_localTransformer))
        SET_RETURN_OPT (localTransformDifferent)

    // quads must match.
    if (thisDef.quad != compareDef.quad)
        SET_RETURN (csDifferent)

    return true;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCSUtilGetRangeSpecified (bvector<GeoPoint>&     shape,
                             double              minLongitude,
                             double              maxLongitude,
                             double              minLatitude,
                             double              maxLatitude)
    {
    GeoPoint point;
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCSUtilGetRangeAboutPrimeMeridianAndEquator (bvector<GeoPoint>&  shape,
                                                double              allowedDeltaAboutPrimeMeridian,
                                                double              allowedDeltaAboutEquator)
    {
    GeoPoint point;
    point.Init(-allowedDeltaAboutPrimeMeridian, -allowedDeltaAboutEquator, 0.0);
    shape.push_back(point);
    point.Init(-allowedDeltaAboutPrimeMeridian, allowedDeltaAboutEquator, 0.0);
    shape.push_back(point);
    point.Init(allowedDeltaAboutPrimeMeridian, allowedDeltaAboutEquator, 0.);
    shape.push_back(point);
    point.Init(allowedDeltaAboutPrimeMeridian, -allowedDeltaAboutEquator, 0.0);
    shape.push_back(point);
    point.Init(-allowedDeltaAboutPrimeMeridian, -allowedDeltaAboutEquator, 0.0);
    shape.push_back(point);
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCSUtilGetRangeAboutMeridianAndEquator  (bvector<GeoPoint>&  shape,
                                            double              specifiedMeridian,
                                            double              allowedDeltaAboutMeridian,
                                            double              allowedDeltaAboutEquator)
    {
    const double minLongitude = specifiedMeridian - allowedDeltaAboutMeridian;
    const double maxLongitude = specifiedMeridian + allowedDeltaAboutMeridian;
    const double minLatitude = -allowedDeltaAboutEquator;
    const double maxLatitude = allowedDeltaAboutEquator;

    GeoPoint point;
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCSUtilGetRangeAboutMeridianAndParallel (bvector<GeoPoint>&     shape,
                                            double              specifiedMeridian,
                                            double              allowedDeltaAboutMeridian,
                                            double              specifiedParallel,
                                            double              allowedDeltaAboutParallel)
    {
    const double minLongitude = specifiedMeridian - allowedDeltaAboutMeridian;
    const double maxLongitude = specifiedMeridian + allowedDeltaAboutMeridian;
    const double minLatitude = specifiedParallel - allowedDeltaAboutParallel;
    const double maxLatitude = specifiedParallel + allowedDeltaAboutParallel;

    GeoPoint point;
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCSUtilGetRangeAboutMeridianAndBoundParallel    (bvector<GeoPoint>&  shape,
                                                    double              specifiedMeridian,
                                                    double              allowedDeltaAboutMeridian,
                                                    double              specifiedParallel,
                                                    double              allowedDeltaAboutParallel,
                                                    double              southMostAllowedParallel,
                                                    double              northMostAllowedParallel)
    {
    const double minLongitude = specifiedMeridian - allowedDeltaAboutMeridian;
    const double maxLongitude = specifiedMeridian + allowedDeltaAboutMeridian;

    double minLatitude = specifiedParallel - allowedDeltaAboutParallel;
    if (minLatitude < southMostAllowedParallel)
        minLatitude = southMostAllowedParallel;

    double maxLatitude = specifiedParallel + allowedDeltaAboutParallel;
    if (maxLatitude > northMostAllowedParallel)
        maxLatitude = northMostAllowedParallel;

    GeoPoint point;
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCSUtilGetRangeAboutMeridianAndTwoStandardBoundParallel (bvector<GeoPoint>&  shape,
                                                            double              specifiedMeridian,
                                                            double              allowedDeltaAboutMeridian,
                                                            double              standardParallel1,
                                                            double              standardParallel2,
                                                            double              allowedDeltaAboutParallels,
                                                            double              southMostAllowedParallel,
                                                            double              northMostAllowedParallel)
    {
    const double minLongitude = specifiedMeridian - allowedDeltaAboutMeridian;
    const double maxLongitude = specifiedMeridian + allowedDeltaAboutMeridian;

    double minLatitude;
    double maxLatitude;
    if (standardParallel1 < standardParallel2)
        {
        minLatitude = standardParallel1 - allowedDeltaAboutParallels;
        if (minLatitude < southMostAllowedParallel)
            minLatitude = southMostAllowedParallel;
        maxLatitude = standardParallel2 + allowedDeltaAboutParallels;
        if (maxLatitude > northMostAllowedParallel)
            maxLatitude = northMostAllowedParallel;
        }
    else
        {
        minLatitude = standardParallel2 - allowedDeltaAboutParallels;
        if (minLatitude < southMostAllowedParallel)
            minLatitude = southMostAllowedParallel;
        maxLatitude = standardParallel1 + allowedDeltaAboutParallels;
        if (maxLatitude > northMostAllowedParallel)
            maxLatitude = northMostAllowedParallel;
        }

    GeoPoint point;
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCSUtilGetRangeAboutBoundMeridianAndBoundParallel   (bvector<GeoPoint>&     shape,
                                                        double              specifiedMeridian,
                                                        double              allowedDeltaAboutMeridian,
                                                        double              westMostAllowedMeridian,
                                                        double              eastMostAllowedMeridian,
                                                        double              specifiedParallel,
                                                        double              allowedDeltaAboutParallel,
                                                        double              southMostAllowedParallel,
                                                        double              northMostAllowedParallel)
    {
    double minLongitude = specifiedMeridian - allowedDeltaAboutMeridian;
    if (minLongitude < westMostAllowedMeridian)
        minLongitude = westMostAllowedMeridian;
    double maxLongitude = specifiedMeridian + allowedDeltaAboutMeridian;
    if (maxLongitude > eastMostAllowedMeridian)
        maxLongitude = eastMostAllowedMeridian;
    double minLatitude = specifiedParallel - allowedDeltaAboutParallel;
    if (minLatitude < southMostAllowedParallel)
        minLatitude = southMostAllowedParallel;
    double maxLatitude = specifiedParallel + allowedDeltaAboutParallel;
    if (maxLatitude > northMostAllowedParallel)
        maxLatitude = northMostAllowedParallel;

    GeoPoint point;
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, maxLatitude, 0.0);
    shape.push_back(point);
    point.Init(maxLongitude, minLatitude, 0.0);
    shape.push_back(point);
    point.Init(minLongitude, minLatitude, 0.0);
    shape.push_back(point);
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* Returns the domain of application for GCS. This domain is the math domain intersected
* with the logical domain if one is set.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::GetMathematicalDomain
(
bvector<GeoPoint>&    shape
) const
    {
    // Given the library is NOT initialized ...
    if (!IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return (StatusInt)m_csError;
        }

	if (NULL == m_csParameters)
		return (StatusInt)GEOCOORDERR_InvalidCoordSys;

    // Some explanation about the values specified below and their intent.
    // First it must be inderstood that the current implementation is in progress.
    // The present implementation fixes some reported issues related to the
    // display and management of rasters when reprojection is involved.
    // The principle attempts to define the geo domain of a specific projection using
    // extent defined as min and max longitude and latitude. Such definition is adequate
    // for many projections but not all. For example Lamber Comformal Conic domain is
    // correctly defined using such definition. For transverse mercator and derivatives
    // the domain can likewise be defined using this method. Others like Oblique Mercator
    // or stereographic projections cannot as their area definition is not alligned
    // to latitude and longitudes. We assume that a smaller area can be defined using
    // plain geo extent but we are not sure. When the North and South pole are included we
    // have not yet defined a way to indicate this representation other than by specifying
    // exact min or max to either North or Sout pole latitude but the actual
    // case never occured so the implementation has currently been postponed
    // till more adequate research can be done.
    //
    // Concerning the definition of Transverse Mercators and derivative the mathematical domain
    // is usually defined from North to South pole on a longitude with of some
    // specific value ... We provide a very large area in this case. In practice we have had
    // cases where the datum shift during the reprojection process shifted the North and South pole
    // sufficiently that a longitude located on one side of the Earth became in the other datum
    // on the other size of the pole (17E Longitude became 163W Longitude)
    // For this reason we have decided to limit the upper and lower latitudes for all
    // projections to 89.9 degrees (any greater values resulted in the problem in our case)
    // This means that the zone will remain about 12 kilometers from the poles. For cartography
    // made in the pole areas, other projection methods will have to be used.

    const ProjectionCodeValue projectionCode = GetProjectionCode();

    // If datum transformation method is limitative by nature we will use the user-defined domain except for the danish systems.
    WGS84ConvertCode datumConvert = GetDatumConvertMethod();

    if ((projectionCode != pcvTransverseMercatorDenmarkSys34 && projectionCode != pcvTransverseMercatorDenmarkSys3499 && projectionCode != pcvTransverseMercatorDenmarkSys3401) &&
        ((ConvertType_MREG  == datumConvert) ||
         (ConvertType_NAD27 == datumConvert) ||
         (ConvertType_HPGN  == datumConvert) ||
         (ConvertType_AGD66 == datumConvert) ||
         (ConvertType_AGD84 == datumConvert) ||
         (ConvertType_NZGD4 == datumConvert) ||
         (ConvertType_ATS77 == datumConvert) ||
         (ConvertType_CSRS  == datumConvert) ||
         (ConvertType_TOKYO == datumConvert) ||
         (ConvertType_RGF93 == datumConvert) ||
         (ConvertType_ED50  == datumConvert) ||
         (ConvertType_DHDN  == datumConvert) ||
         (ConvertType_GENGRID == datumConvert) ||
         (ConvertType_CHENYX == datumConvert)))
        {
        double minLongitude = GetMinimumUsefulLongitude();
        double maxLongitude = GetMaximumUsefulLongitude();
        double minLatitude = GetMinimumUsefulLatitude();
        double maxLatitude = GetMaximumUsefulLatitude();
        if ((minLongitude != maxLongitude) && (minLatitude != minLongitude))
            {
            // The user-defined are as defined in the dictionary but CSMAP requires a tiny difference from absolute
            // position specified (for example Transverse Mercator is technically valid up to 90 latitude but CSMAP requires a few centimeters appart
            // just in case. For this reason we minimise slightly the extent
            minLongitude += 0.0000028;
            maxLongitude -= 0.0000028;
            minLatitude += 0.0000028;
            maxLatitude -= 0.0000028;
            return BaseGCSUtilGetRangeSpecified(shape, minLongitude, maxLongitude, minLatitude, maxLatitude);
            }
        }

    switch (projectionCode)
        {
        case pcvCassini :
            {
            return BaseGCSUtilGetRangeAboutMeridianAndEquator(shape,
                                                   GetCentralMeridian(), 80.0,
                                                   89.9);
            }
        case pcvEckertIV :
        case pcvEckertVI :
        case pcvMillerCylindrical :
        case pcvUnity :
        case pcvGoodeHomolosine :
        case pcvModifiedStereographic :
        case pcvEqualAreaAuthalicNormal :
        case pcvEqualAreaAuthalicTransverse :
        case pcvSinusoidal :
        case pcvVanderGrinten :
        case pcvRobinsonCylindrical :
        case pcvWinkelTripel :
        case pcvEquidistantCylindrical :
        case pcvEquidistantCylindricalEllipsoid :
        case pcvPlateCarree :
            // good around the globe
            return BaseGCSUtilGetRangeAboutPrimeMeridianAndEquator (shape, 180.0, 89.9);

        case pcvMercatorScaleReduction :
        case pcvMercator :
        case pcvPopularVisualizationPseudoMercator :
            {
            // The Mercator projection implementation limits somewhat the valid extent to the
            // user domain specified.
            double minLongitude = GetMinimumUsefulLongitude();
            double maxLongitude = GetMaximumUsefulLongitude();
            double minLatitude = GetMinimumUsefulLatitude();
            double maxLatitude = GetMaximumUsefulLatitude();
            if ((minLongitude != maxLongitude) && (minLatitude != minLongitude))
                {
                // The user-defined are as defined in the dictionary but CSMAP requires a tiny difference from absolute
                // position specified (for example Transverse Mercator is technically valid up to 90 latitude but CSMAP requires a few centimeters apart
                // just in case. For this reason we minimize slightly the extent
                minLongitude += 0.0000028;
                maxLongitude -= 0.0000028;
                minLatitude += 0.0000028;
                maxLatitude -= 0.0000028;
                return BaseGCSUtilGetRangeSpecified(shape, minLongitude, maxLongitude, minLatitude, maxLatitude);
                }

            // good pretty close 90 degrees east and west of central meridian
            return BaseGCSUtilGetRangeAboutMeridianAndEquator(shape,
                                                   GetCentralMeridian (),
                                                   179.999999,
                                                   80.0);
            }
        case pcvLambertEquidistantAzimuthal :
        case pcvAzimuthalEquidistantElevatedEllipsoid :
        case pcvLambertEqualAreaAzimuthal :
        case pcvOrthographic :
        case pcvObliqueStereographic :
        case pcvSnyderObliqueStereographic :
        case pcvPolarStereographic :
        case pcvPolarStereographicStandardLatitude :
        case pcvGnomonic :
        case pcvBipolarObliqueConformalConic :
	        {
	        // Eventually we will study more attentively how to
	        // Compute the mathematical extent but for the moment we will limit to the
            // user extent
            double minLongitude = GetMinimumUsefulLongitude();
            double maxLongitude = GetMaximumUsefulLongitude();
            double minLatitude = GetMinimumUsefulLatitude();
            double maxLatitude = GetMaximumUsefulLatitude();
            if ((minLongitude != maxLongitude) && (minLatitude != minLongitude))
            {
            return BaseGCSUtilGetRangeSpecified(shape, minLongitude, maxLongitude, minLatitude, maxLatitude);
            }

            // Even though it cannot be computed, the domain must be set as the caller may not check the return status.
            BaseGCSUtilGetRangeAboutPrimeMeridianAndEquator (shape, 180.0, 89.9);
            return BSIERROR; // return not implemented;
	    }

        case pcvTransverseMercator :
        case pcvGaussKrugerTranverseMercator :
        case pcvSouthOrientedTransverseMercator :
        case pcvTransverseMercatorAffinePostProcess :
        case pcvTransverseMercatorMinnesota :
        case pcvTransverseMercatorWisconsin:
        case pcvTransverseMercatorKruger :
            // Transverse Mercator will work relatively well from North to South pole and XX degrees either way of longitude of origin
            return BaseGCSUtilGetRangeAboutMeridianAndEquator(shape,
                                                   GetCentralMeridian(), 15.0,
                                                   89.9);

	// This version of Transverse Mercator allows going further out of the zone center than the other
        // version.
        case pcvTotalTransverseMercatorBF :
            return BaseGCSUtilGetRangeAboutMeridianAndEquator(shape,
                                                   GetCentralMeridian(), 30.0,
                                                   89.9);

        // The following are close enough to TM but require latitude origin
        case pcvObliqueCylindricalHungary :
            // Transverse Mercator will work relatively well from North to South pole and XX degrees either way of longitude of origin
            return BaseGCSUtilGetRangeAboutMeridianAndEquator(shape, GetOriginLongitude(), 30.0, 89.9);

        case BaseGCS::pcvTransverseMercatorOstn97:
        case BaseGCS::pcvTransverseMercatorOstn02:
        case BaseGCS::pcvTransverseMercatorOstn15:
            {
            GeoPoint point;
            point.Init(-7.4, 60.8, 0.0);
            shape.push_back(point);
            point.Init(2.15, 60.8, 0.0);
            shape.push_back(point);
            point.Init(2.15, 49.9, 0.0);
            shape.push_back(point);
            point.Init(-7.4, 49.9, 0.0);
            shape.push_back(point);
            point.Init(-7.4, 60.8, 0.0);
            shape.push_back(point);
            return SUCCESS;
            }

        case pcvCzechKrovak :
        case pcvCzechKrovakObsolete :
        case pcvCzechKrovak95 :
        case pcvCzechKrovak95Obsolete :
        case pcvCzechKrovakModified :
            // Hard-coded domain as origin longitude give 17.39W which couldn't be used as a central meridian for this
            // area. According to AR, these projections are oblique/conical and this strange origin longitude
            // could have been used as a mean of correction for non-standard prime meridian (not greenwich) used.
            return BaseGCSUtilGetRangeAboutMeridianAndParallel(shape, 17.5, 7.5, 49.5, 2.5);

        case pcvTransverseMercatorDenmarkSys34 :
        case pcvTransverseMercatorDenmarkSys3499 :
        case pcvTransverseMercatorDenmarkSys3401 :
            {
	    // The regions have specific and complex shapes. These shapes have
            // established by trial and error. They could not be made square because the
            // grid definition barely include the island it represents.
            int region = GetDanishSys34Region();

            // 1  ==> jylland
            // 2  ==> sjaelland
            // 3  ==> bornholm
	    GeoPoint point;

            if (1 == region)
                {
		        point.Init(8.2930, 54.7757, 0.0);
		        shape.push_back(point);
		        point.Init(7.9743, 55.0112, 0.0);
		        shape.push_back(point);
		        point.Init(7.5544, 56.4801, 0.0);
		        shape.push_back(point);
		        point.Init(8.0280, 57.1564, 0.0);
		        shape.push_back(point);
		        point.Init(10.4167, 58.0417, 0.0);
		        shape.push_back(point);
		        point.Init(10.9897, 57.7786, 0.0);
		        shape.push_back(point);
		        point.Init(11.5395, 57.1551, 0.0);
		        shape.push_back(point);
		        point.Init(12.0059, 56.5088, 0.0);
		        shape.push_back(point);
		        point.Init(11.7200, 54.9853, 0.0);
		        shape.push_back(point);
		        point.Init(10.5938, 54.5951, 0.0);
		        shape.push_back(point);
		        point.Init(8.2930, 54.7757, 0.0);
		        shape.push_back(point);
                }
            else if (2 == region)
                {
#if (1)
                // For some obscure reason the domain of this zone used to be the one deactivated below
                // but now it is the one included here. I suspect this is because a reversibility test was either
                // added or the tolerance to the application of the reversibility test modified.
                // &&AR To be checked.
		        point.Init(13.6160, 56.3874, 0.0);
		        shape.push_back(point);
		        point.Init(13.6803, 55.9697, 0.0);
		        shape.push_back(point);
		        point.Init(13.3465, 55.1436, 0.0);
		        shape.push_back(point);
		        point.Init(12.6916, 54.6633, 0.0);
		        shape.push_back(point);
		        point.Init(11.8615, 54.3089, 0.0);
		        shape.push_back(point);
		        point.Init(10.5746, 54.5406, 0.0);
		        shape.push_back(point);
		        point.Init(10.1280, 54.8928, 0.0);
		        shape.push_back(point);
		        point.Init(10.1619, 55.2380, 0.0);
		        shape.push_back(point);
		        point.Init(10.3488, 56.0007, 0.0);
		        shape.push_back(point);
		        point.Init(11.0446, 56.6799, 0.0);
		        shape.push_back(point);
		        point.Init(11.6792, 56.8603, 0.0);
		        shape.push_back(point);
		        point.Init(13.6160, 56.3874, 0.0);
		        shape.push_back(point);

#else
		        point.Init(11.5108, 54.4367, 0.0);
		        shape.push_back(point);
		        point.Init(10.2526, 54.6795, 0.0);
		        shape.push_back(point);
		        point.Init(9.6333, 55.0286, 0.0);
		        shape.push_back(point);
		        point.Init(9.6157, 55.3831, 0.0);
		        shape.push_back(point);
		        point.Init(10.0748, 56.0823, 0.0);
		        shape.push_back(point);
		        point.Init(11.5664, 56.9520, 0.0);
		        shape.push_back(point);
		        point.Init(13.2099, 56.5104, 0.0);
		        shape.push_back(point);
		        point.Init(13.2097, 54.8276, 0.0);
		        shape.push_back(point);
		        point.Init(12.8531, 54.6593, 0.0);
		        shape.push_back(point);
		        point.Init(12.1009, 54.5007, 0.0);
		        shape.push_back(point);
		        point.Init(11.5108, 54.4367, 0.0);
		        shape.push_back(point);
#endif
                }
            else
                {
                BeAssert (3 == region);
		        point.Init(14.510, 54.942, 0.0);
		        shape.push_back(point);
		        point.Init(14.510, 55.431, 0.0);
		        shape.push_back(point);
		        point.Init(15.300, 55.431, 0.0);
		        shape.push_back(point);
		        point.Init(15.300, 54.942, 0.0);
		        shape.push_back(point);
		        point.Init(14.510, 54.942, 0.0);
		        shape.push_back(point);
                }
            }
            return BSISUCCESS;

        // The conic
        case pcvAmericanPolyconic :
        case pcvModifiedPolyconic :
            // For conics we can extent 90 degrees east and west amd from xx degrees up or down from lowest/upper standard parallels
            return BaseGCSUtilGetRangeAboutMeridianAndBoundParallel(shape,
                                                         GetCentralMeridian(),
							                             89.999999,
                                                         GetOriginLatitude(),
							                             30.0,
                                                         -89.9,
							                             89.9);

        case pcvLambertTangential :
        case pcvLambertConformalConicOneParallel :
        case pcvSnyderTransverseMercator :
            // For conics we can extent 90 degrees east and west amd from xx degrees up or down from lowest/upper standard parallels
            return BaseGCSUtilGetRangeAboutMeridianAndBoundParallel(shape,
                                                         GetOriginLongitude(),
							                             89.999999,
                                                         GetOriginLatitude(),
							                             30.0,
                                                         -89.9,
							                             89.9);

        case pcvBonne :
            return BaseGCSUtilGetRangeAboutMeridianAndBoundParallel(shape,
                                                         GetOriginLongitude(),
							                             170.999999,
                                                         GetOriginLatitude(),
							                             60.0,
                                                         -89.9,
							                             89.9);

        case pcvEquidistantConic :
        case pcvAlbersEqualArea :
        case pcvLambertConformalConicTwoParallel :
        case pcvLambertConformalConicWisconsin :
        case pcvLambertConformalConicBelgian :
        case pcvLambertConformalConicMinnesota:
        case pcvLambertConformalConicAffinePostProcess :
            // For conics we can extent 90 degrees east and west amd from xx degrees up or down from lowest/upper standard parallels
            return BaseGCSUtilGetRangeAboutMeridianAndTwoStandardBoundParallel(shape,
                                                                    GetOriginLongitude(),
								                                    89.9999,
                                                                    GetStandardParallel1(),
								                                    GetStandardParallel2(),
								                                    30.0,
                                                                    -80.0,
								                                    80.0);

        case pcvObliqueCylindricalSwiss :
            // This projection is usually only used in Switzerland but can also be used in Hungary
            // we cannot hard code the extent based on the Switzerland extent but must instead compute the
            // extent based on the latitude and longitude of origin.
            return BaseGCSUtilGetRangeAboutMeridianAndParallel(shape, GetOriginLongitude(), 6.0, GetOriginLatitude(), 6.0);


        // Other local projections
        case pcvHotineObliqueMercator :
        case pcvMollweide :
        case pcvRectifiedSkewOrthomorphic :
        case pcvRectifiedSkewOrthomorphicCentered :
        case pcvRectifiedSkewOrthomorphicOrigin :
        case pcvHotineObliqueMercator1UV :
        case pcvHotineObliqueMercator1XY :
        case pcvHotineObliqueMercator2UV :
        case pcvHotineObliqueMercator2XY :
	        {
	        // We have not yet determined the mathematical extent of these.
	        // This should cause little problems as all are rarely used
	        double minLongitude = GetMinimumUsefulLongitude();
	        double maxLongitude = GetMaximumUsefulLongitude();
	        double minLatitude = GetMinimumUsefulLatitude();
	        double maxLatitude = GetMaximumUsefulLatitude();

	        if ((minLongitude != maxLongitude) && (minLatitude != minLongitude))
    	    	return BaseGCSUtilGetRangeSpecified(shape, minLongitude, maxLongitude, minLatitude, maxLatitude);

            // Even though it cannot be computed, the domain must be set as the caller may not check the return status.
            BaseGCSUtilGetRangeAboutPrimeMeridianAndEquator (shape, 180.0, 89.9);
            return BSIERROR; // return not implemented;
 	        }

        case pcvObliqueMercatorMinnesota :
        case pcvNewZealandNationalGrid :
    	    {
	        // These are local grids. Eventually we will study more attentively how to
	        // Compute the mathematical extent but for the moment we will limit to the
            // user extent
	        double minLongitude = GetMinimumUsefulLongitude();
	        double maxLongitude = GetMaximumUsefulLongitude();
	        double minLatitude = GetMinimumUsefulLatitude();
	        double maxLatitude = GetMaximumUsefulLatitude();
	        if ((minLongitude != maxLongitude) && (minLatitude != minLongitude))
        		return BaseGCSUtilGetRangeSpecified(shape, minLongitude, maxLongitude, minLatitude, maxLatitude);

	        // User domain not set ... we will use the default
            // Even though it cannot be computed, the domain must be set as the caller may not check the return status.
            BaseGCSUtilGetRangeAboutPrimeMeridianAndEquator (shape, 180.0, 89.9);
            return BSIERROR; // return not implemented;
	        }
        // Other
        case pcvNonEarth :
        case pcvNonEarthScaleRotation :
        case pcvObliqueConformalConic :
            BaseGCSUtilGetRangeAboutPrimeMeridianAndEquator (shape, 180.0, 89.9);
            return BSIERROR; // return not implemented;

        case pcvUniversalTransverseMercator :
            return BaseGCSUtilGetRangeAboutMeridianAndEquator(shape, BaseGCSUtilGetUTMZoneCenterMeridian(GetUTMZone()), 15.0, 89.9);

	    // This version of transverse mercator allow going further out of the zone center
        case pcvTotalUniversalTransverseMercator :
	        return BaseGCSUtilGetRangeAboutMeridianAndEquator(shape, BaseGCSUtilGetUTMZoneCenterMeridian(GetUTMZone()), 30.0, 89.9);

        default:
            break;
        }

    return BSIERROR;
    }

/*---------------------------------------------------------------------------------**//**
* Returns the extent of the domain of application for GCS.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::GetMathematicalDomainExtent
(
double& minLongitude,
double& maxLongitude,
double& minLatitude,
double& maxLatitude
) const
    {
    StatusInt       status = SUCCESS;
    bvector<GeoPoint> mathShape;

    minLongitude = 0.0;
    maxLongitude = 0.0;
    minLatitude = 0.0;
    maxLatitude = 0.0;

    if (SUCCESS == (status = GetMathematicalDomain(mathShape)))
        {
        if (mathShape.size() > 0)
            {
            minLongitude = mathShape[0].longitude;
            maxLongitude = mathShape[0].longitude;
            minLatitude = mathShape[0].latitude;
            maxLatitude = mathShape[0].latitude;
            for (size_t indexPoint = 1 ; indexPoint < mathShape.size() ; indexPoint++)
                {
                minLongitude = (mathShape[indexPoint].longitude < minLongitude ? mathShape[indexPoint].longitude : minLongitude);
                maxLongitude = (mathShape[indexPoint].longitude > maxLongitude ? mathShape[indexPoint].longitude : maxLongitude);
                minLatitude = (mathShape[indexPoint].latitude < minLatitude ? mathShape[indexPoint].latitude : minLatitude);
                maxLatitude = (mathShape[indexPoint].latitude > maxLatitude ? mathShape[indexPoint].latitude : maxLatitude);
                }
            }
        }
    return status;
    }

#ifdef DICTIONARY_MANAGEMENT_ONLY
/*---------------------------------------------------------------------------------**//**
* @description: This method appears to have been originally written by Norm Olsen
* the person behind CSMAP. It appears to have been provided to Doug Bilinski outside
* CSMAP delivery. The result was addapted to Doug's "architecture" and was finally
* adpated to BaseGCS for dictionary management purposes only.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt BaseGCS::OutputAsASC
(
Utf8StringR GCSAsASC
) const
    {
    StatusInt       status = SUCCESS;

    std::ostringstream GCSAsASCStream(GCSAsASC);

    if (!IsValid())
        return GEOCOORDERR_InvalidCoordSys;


    int order;
    int logTen;
    int prec;

    int32_t lngFrmt;
    int32_t latFrmt;
    int32_t xyFrmt;
    int32_t zzFrmt;
    int32_t anglFrmt;
    int32_t redFrmt;
    int32_t sclFrmt;
    int32_t coefFrmt;

    double tmpDbl;
    double zeroVal;
    struct cs_Prjtab_ *prjPtr;
    char ctemp [64];

    /* Locate the projection in the projection table. */
    for (prjPtr = cs_Prjtab; prjPtr->code != cs_PRJCOD_END; prjPtr += 1)
        {
        if (!strcmp (m_csParameters->csdef.prj_knm, prjPtr->key_nm))
            break;
        }
    if (prjPtr->code == cs_PRJCOD_END)
        {
        return 1;
        }

    /* Adjust the output value formatting as appropriate. */
    lngFrmt  = csLngFrmt;
    latFrmt  = csLatFrmt;
    xyFrmt   = csXyFrmt;
    zzFrmt   = csZzFrmt;
    anglFrmt = csAnglFrmt;
    redFrmt  = csRedFrmt;
    sclFrmt  = csSclFrmt;
    coefFrmt = csCoefFrmt;

    if ((prjPtr->flags & cs_PRJFLG_GEOGR) != 0)
        {
        /* Special changes for Unity projection here. */
        }

    UnitCP theUnit = Unit::FindUnit (m_csParameters->csdef.unit);

    /* Compute an apprropriate precision value based on the unit. */
    if ((prjPtr->flags & cs_PRJFLG_GEOGR) == 0)
        {
        tmpDbl = theUnit->GetConversionFactor();
        tmpDbl = log10 (tmpDbl);
        if (tmpDbl < 0.0)
            tmpDbl -= 0.4;
        else
            tmpDbl += 0.4;

        logTen = (int)tmpDbl;
        prec = 3 + logTen;
        zeroVal = pow (10.0, (double)(-prec));
        }
    else
        {
        tmpDbl = theUnit->GetConversionFactor();
        tmpDbl = log10 (tmpDbl);
        if (tmpDbl < 0.0)
            tmpDbl -= 0.4;
        else
            tmpDbl += 0.4;

        logTen = (int)tmpDbl;
        prec = 9 - logTen;
        zeroVal = pow (10.0, (double)(-prec));
        }
    xyFrmt = (xyFrmt & ~cs_ATOF_PRCMSK) | (prec + 1);

    /* We we do not have any Minimum non-zero values, create them now. */
    if (m_csParameters->csdef.zero [XX] == 0.0 && m_csParameters->csdef.zero [YY] == 0.0)
        {
        m_csParameters->csdef.zero [XX] = zeroVal;
        m_csParameters->csdef.zero [YY] = zeroVal;
        }

    /* Extract, and fprintf some stuff that's standard for all
       projections. Note, we try to stick to the basic order
       that was established, and somewhat maintained, since the
       first ASCII file was written. */
    GCSAsASCStream << "CS_NAME: " << m_csParameters->csdef.key_nm << std::endl
             << "          GROUP: " << m_csParameters->csdef.group << std::endl
             << "        DESC_NM: " << m_csParameters->csdef.desc_nm << std::endl
             << "         SOURCE: " << m_csParameters->csdef.source << std::endl;

    if (m_csParameters->csdef.dat_knm [0] != '\0')
        {
        GCSAsASCStream << "        DT_NAME: " << m_csParameters->csdef.dat_knm << std::endl;
        }
    else
        {
        GCSAsASCStream << "        EL_NAME: " << m_csParameters->csdef.elp_knm << std::endl;
        }
    GCSAsASCStream << "           PROJ: " << m_csParameters->csdef.prj_knm << std::endl
             << "           UNIT: " << m_csParameters->csdef.unit << std::endl;

    switch (m_csParameters->prj_code)
        {
        case  cs_PRJCOD_UNITY:
            if (m_csParameters->csdef.prj_prm1 != 0.0 || m_csParameters->csdef.prj_prm2 != 0.0)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
                GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, lngFrmt);
                GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
                }
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_TRMRKRG:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_TRMER:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

/*        case  cs_PRJCOD_TRMERBF:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            fprintf (fstr_out, "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            fprintf (fstr_out, "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            fprintf (fstr_out, "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            fprintf (fstr_out, "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            fprintf (fstr_out, "          Y_OFF: " << ctemp << std::endl;
            break;
*/

        case  cs_PRJCOD_ALBER:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case cs_PRJCOD_MRCAT:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case cs_PRJCOD_MRCATPV:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;


        case  cs_PRJCOD_AZMED:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, anglFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_LMTAN:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_PLYCN:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_MODPC:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, lngFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, latFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm4, latFrmt);
            GCSAsASCStream << "          PARM4: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_AZMEA:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, anglFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_EDCNC:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_MILLR:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_MSTRO:
            if (m_csParameters->csdef.order != 0)
                {
                GCSAsASCStream << "          ORDER: " << m_csParameters->csdef.order << std::endl;
                }
            if      (m_csParameters->csdef.prj_prm23 != 0.0 || m_csParameters->csdef.prj_prm24 != 0.0)
                order = 12;
            else if (m_csParameters->csdef.prj_prm21 != 0.0 || m_csParameters->csdef.prj_prm22 != 0.0)
                order = 11;
            else if (m_csParameters->csdef.prj_prm19 != 0.0 || m_csParameters->csdef.prj_prm20 != 0.0)
                order = 10;
            else if (m_csParameters->csdef.prj_prm17 != 0.0 || m_csParameters->csdef.prj_prm18 != 0.0)
                order =  9;
            else if (m_csParameters->csdef.prj_prm15 != 0.0 || m_csParameters->csdef.prj_prm16 != 0.0)
                order =  8;
            else if (m_csParameters->csdef.prj_prm13 != 0.0 || m_csParameters->csdef.prj_prm14 != 0.0)
                order =  7;
            else if (m_csParameters->csdef.prj_prm11 != 0.0 || m_csParameters->csdef.prj_prm12 != 0.0)
                order =  6;
            else if (m_csParameters->csdef.prj_prm9  != 0.0 || m_csParameters->csdef.prj_prm10 != 0.0)
                order =  5;
            else if (m_csParameters->csdef.prj_prm7  != 0.0 || m_csParameters->csdef.prj_prm8  != 0.0)
                order =  4;
            else if (m_csParameters->csdef.prj_prm5  != 0.0 || m_csParameters->csdef.prj_prm6  != 0.0)
                order =  3;
            else if (m_csParameters->csdef.prj_prm3  != 0.0 || m_csParameters->csdef.prj_prm4  != 0.0)
                order =  2;
            else if (m_csParameters->csdef.prj_prm1  != 0.0 || m_csParameters->csdef.prj_prm2  != 0.0)
                order =  1;
            else
                order = 0;

            if (order >= 1)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, coefFrmt);
                GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, coefFrmt);
                GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
                }
            if (order >= 2)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, coefFrmt);
                GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm4, coefFrmt);
                GCSAsASCStream << "          PARM4: " << ctemp << std::endl;
                }
            if (order >= 3)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm5, coefFrmt);
                GCSAsASCStream << "          PARM5: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm6, coefFrmt);
                GCSAsASCStream << "          PARM6: " << ctemp << std::endl;
                }
            if (order >= 4)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm7, coefFrmt);
                GCSAsASCStream << "          PARM7: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm8, coefFrmt);
                GCSAsASCStream << "          PARM8: " << ctemp << std::endl;
                }
            if (order >= 5)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm9, coefFrmt);
                GCSAsASCStream << "          PARM9: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm10, coefFrmt);
                GCSAsASCStream << "          PARM10: " << ctemp << std::endl;
                }
            if (order >= 6)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm11, coefFrmt);
                GCSAsASCStream << "          PARM11: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm12, coefFrmt);
                GCSAsASCStream << "          PARM12: " << ctemp << std::endl;
                }
            if (order >= 7)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm13, coefFrmt);
                GCSAsASCStream << "          PARM13: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm14, coefFrmt);
                GCSAsASCStream << "          PARM14: " << ctemp << std::endl;
                }
            if (order >= 8)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm15, coefFrmt);
                GCSAsASCStream << "          PARM15: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm16, coefFrmt);
                GCSAsASCStream << "          PARM16: " << ctemp << std::endl;
                }
            if (order >= 9)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm17, coefFrmt);
                GCSAsASCStream << "          PARM17: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm18, coefFrmt);
                GCSAsASCStream << "          PARM18: " << ctemp << std::endl;
                }
            if (order >= 10)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm19, coefFrmt);
                GCSAsASCStream << "          PARM19: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm20, coefFrmt);
                GCSAsASCStream << "          PARM20: " << ctemp << std::endl;
                }
            if (order >= 11)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm21, coefFrmt);
                GCSAsASCStream << "          PARM21: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm22, coefFrmt);
                GCSAsASCStream << "          PARM22: " << ctemp << std::endl;
                }
            if (order >= 12)
                {
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm23, coefFrmt);
                GCSAsASCStream << "          PARM23: " << ctemp << std::endl;
                CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm24, coefFrmt);
                GCSAsASCStream << "          PARM24: " << ctemp << std::endl;
                }
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_NZLND:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_SINUS:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_ORTHO:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_GNOMC:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_EDCYL:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_EDCYLE:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_PCARREE:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_VDGRN:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_WINKL:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_CSINI:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_ROBIN:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_BONNE:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_EKRT4:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_EKRT6:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_MOLWD:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_HMLSN:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_NACYL:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_TACYL:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_BPCNC:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, lngFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm4, latFrmt);
            GCSAsASCStream << "          PARM4: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm5, anglFrmt);
            GCSAsASCStream << "          PARM5: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm6, latFrmt);
            GCSAsASCStream << "          PARM6: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm7, latFrmt);
            GCSAsASCStream << "          PARM7: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_SWISS:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_PSTRO:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_OSTRO:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_SSTRO:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_LM1SP:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_LM2SP:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_LMBLG:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_WCCSL:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, zzFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm4, zzFrmt);
            GCSAsASCStream << "          PARM4: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_WCCST:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, zzFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, zzFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_MNDOTL:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, zzFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_MNDOTT:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, zzFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_SOTRM:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_UTM:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, 1L);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, 1L);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            break;

//case  cs_PRJCOD_UTMZNBF:
//            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, 1L);
//            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
//            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, 1L);
//            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
//            break;

        case  cs_PRJCOD_TRMRS:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        //case  cs_PRJCOD_TRMERBF:
        //    CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
        //    GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
        //    CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
        //    GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
        //    CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
        //    GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
        //    CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
        //    GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
        //    CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
        //    GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
        //    break;

        case  cs_PRJCOD_HOM1UV:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, anglFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_HOM1XY:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, anglFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_MNDOTOBL:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, anglFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm4, zzFrmt);
            GCSAsASCStream << "          PARM4: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;


        case  cs_PRJCOD_HOM2UV:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, lngFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm4, latFrmt);
            GCSAsASCStream << "          PARM4: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case  cs_PRJCOD_HOM2XY:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, lngFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm4, latFrmt);
            GCSAsASCStream << "          PARM4: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;
        // COORDSYS_RSKEW
        case  cs_PRJCOD_RSKEW:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, anglFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;
        // COORDSYS_RSKWC
        case  cs_PRJCOD_RSKEWC:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, anglFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;
        // COORDSYS_GAUSK
        case  cs_PRJCOD_GAUSSK:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;
        // COORDSYS_KRVKP
        // COORDSYS_KRVKR
        // COORDSYS_KRVKG
        case cs_PRJCOD_KROVAK:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, latFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;
        case cs_PRJCOD_KROVAKMOD:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, latFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;
        case cs_PRJCOD_KROVK1:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, latFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG" << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;
        case cs_PRJCOD_KRVK95:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, latFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG" << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;
        case cs_PRJCOD_KRVK951:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, latFrmt);
            GCSAsASCStream << "          PARM2: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm3, latFrmt);
            GCSAsASCStream << "          PARM3: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG" << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case cs_PRJCOD_MRCATK:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.scl_red, redFrmt);
            GCSAsASCStream << "        SCL_RED: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

        case cs_PRJCOD_PSTROSL:
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, latFrmt);
            GCSAsASCStream << "          PARM1: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lng, lngFrmt);
            GCSAsASCStream << "        ORG_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.org_lat, latFrmt);
            GCSAsASCStream << "        ORG_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.x_off, xyFrmt);
            GCSAsASCStream << "          X_OFF: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.y_off, xyFrmt);
            GCSAsASCStream << "          Y_OFF: " << ctemp << std::endl;
            break;

                case cs_PRJCOD_SYS34:
                case cs_PRJCOD_SYS34_99:
                case cs_PRJCOD_SYS34_01:
                        /* These projection have every parameters hard coded ... nothing to add */

        case  cs_PRJCOD_OBLQM:
            /* Should never get here.  This code is never used as there
               are several variations of this projection, and the codes
               for each of the variations are the codes you will see. */

        case cs_PRJCOD_OCCNC:
            /* Should never get here.  This code was never used and was
               essentially established as a placeholder for a projection
               which never got implemented. */
    /*  case cs_PRJCOD_STERO: */
            /* This code is obsolete since about release 8.  The original
               stereographic has been replaced by the Polar Stereographic,
               the Oblique Stereographic, and the Snyder Stereographic. */
        default:
            /* Should never get here.  Probably should issue a message
               of some sort. */
        break;
        }

    /* Finish off with some standard stuff; i.e. applies to all projections. */
    if (m_csParameters->csdef.quad != 0)
        {
        GCSAsASCStream << "           QUAD: " << m_csParameters->csdef.quad << std::endl;
        }
    if (m_csParameters->csdef.hgt_lng != 0.0 || m_csParameters->csdef.hgt_lat != 0.0 || m_csParameters->csdef.hgt_zz != 0.0)
        {
        CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.hgt_lng, lngFrmt);
        GCSAsASCStream << "        HGT_LNG: " << ctemp << std::endl;
        CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.hgt_lat, latFrmt);
        GCSAsASCStream << "        HGT_LAT: " << ctemp << std::endl;
        CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.hgt_zz, zzFrmt);
        GCSAsASCStream << "         HGT_ZZ: " << ctemp << std::endl;
        }
    if (m_csParameters->csdef.ll_min [LNG] != 0.0 || m_csParameters->csdef.ll_min [LAT] != 0.0 ||
        m_csParameters->csdef.ll_max [LNG] != 0.0 || m_csParameters->csdef.ll_max [LAT] != 0.0)
        {
        if (m_csParameters->prj_code == cs_PRJCOD_UNITY)
            {
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm1, lngFrmt);
            GCSAsASCStream << "        MIN_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.ll_min [LAT], latFrmt);
            GCSAsASCStream << "        MIN_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.prj_prm2, lngFrmt);
            GCSAsASCStream << "        MAX_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.ll_max [LAT], latFrmt);
            GCSAsASCStream << "        MAX_LAT: " << ctemp << std::endl;
            }
        else
            {
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.ll_min [LNG], lngFrmt);
            GCSAsASCStream << "        MIN_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.ll_min [LAT], latFrmt);
            GCSAsASCStream << "        MIN_LAT: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.ll_max [LNG], lngFrmt);
            GCSAsASCStream << "        MAX_LNG: " << ctemp << std::endl;
            CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.ll_max [LAT], latFrmt);
            GCSAsASCStream << "        MAX_LAT: " << ctemp << std::endl;
            }
        }
    if (m_csParameters->csdef.xy_min [LNG] != 0.0 || m_csParameters->csdef.xy_min [LAT] != 0.0 ||
        m_csParameters->csdef.xy_max [LNG] != 0.0 || m_csParameters->csdef.xy_max [LAT] != 0.0)
        {
        CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.xy_min [LNG], xyFrmt);
        GCSAsASCStream << "         MIN_XX: " << ctemp << std::endl;
        CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.xy_min [LAT], xyFrmt);
        GCSAsASCStream << "         MIN_YY: " << ctemp << std::endl;
        CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.xy_max [LNG], xyFrmt);
        GCSAsASCStream << "         MAX_XX: " << ctemp << std::endl;
        CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.xy_max [LAT], xyFrmt);
        GCSAsASCStream << "         MAX_YY: " << ctemp << std::endl;
        }
    CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.zero [XX], xyFrmt);
    GCSAsASCStream << "         ZERO_X: " << ctemp << std::endl;
    CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.zero [YY], xyFrmt);
    GCSAsASCStream << "         ZERO_Y: " << ctemp << std::endl;
    CS_ftoa (ctemp, sizeof (ctemp), m_csParameters->csdef.map_scl, sclFrmt);
    GCSAsASCStream << "        MAP_SCL: " << ctemp << std::endl;

    /* Write an extra new line to indicate the end
       of the coordinate system.  Not necessary, but
       makes the string a lot easier to read. */

    GCSAsASCStream << std::endl;

    GCSAsASC = GCSAsASCStream.str();

    /* Return the status code. */
    return SUCCESS;
    }
#endif // DICTIONARY_MANAGEMENT_ONLY



#ifdef UNUSED_CODE
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
static bool     EllipsoidEquivalent
(
CSDatum&            datum,
CSEllipsoidDef&     ellipsoid
)
    {
    return true;
    }
#endif

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::HasEquivalentDatum
(
BaseGCSCR        compareTo
) const
    {
    return DatumEquivalent (m_csParameters->datum, compareTo.m_csParameters->datum, false, false, false);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
static int      EPSGCodeFromName
(
CharCP    epsgName
)
    {
    // if the name is of the form EPSG:xxxx, use the xxxx
    if (0 == strncmp (epsgName, "EPSG:", 5))
        {
        // Note that some keynames have the form EPSG:XXXX-X or EPSG:XXXXA such as EPSG:3399-1 or EPSG:3399A
        // Those must be refused as they are variant that must not be taken as pure EPSG values.
        int position = 5;
        // Advance after digits
        while (isdigit(epsgName[position]) && epsgName[position] != '\0')
            position++;
        // If first position after digit is not end of keyname there is some postfix ... not EPSG
        if (epsgName[position] != '\0')
            return 0;

        int     epsgNum;
        if (1 == sscanf (&epsgName[5], "%d", &epsgNum))
            return epsgNum;
        }
    return 0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int             BaseGCS::GetEPSGCode (bool noSearch) const
    {
    if (NULL == m_csParameters)
        return 0;

    // if the epsgNbr is in the CS, use that.
    if (0 != m_csParameters->csdef.epsgNbr)
        return m_csParameters->csdef.epsgNbr;

    // If code was previously searched and found return it.
    if (m_foundEPSGCode > 0)
        return m_foundEPSGCode;

    int     epsgNum;
    if (0 != (epsgNum = EPSGCodeFromName (m_csParameters->csdef.key_nm)))
        return epsgNum;

    // try CS_Map's internal lookup table.
    if (KcsNmInvNumber != (epsgNum = csMapNameToIdC (csMapProjGeoCSys,
                                                     csMapFlvrEpsg,
                                                     csMapFlvrCsMap,
                                                     m_csParameters->csdef.key_nm)))
        return epsgNum;

    if (noSearch)
        return 0;

    // we didn't find an EPSG Number the easy way, have to search.
    int         index;
    char        csKeyName[128];
    BaseGCSP    gcs = NULL;
    for (index = 0; (0 < CSMap::CS_csEnum (index, csKeyName, sizeof(csKeyName))); index++)
        {
        if (NULL == gcs)
            gcs = new BaseGCS (csKeyName);
         else
            gcs->SetFromCSName (csKeyName);

        if (gcs->IsValid())
            {
            if ( (0 != (epsgNum = gcs->m_csParameters->csdef.epsgNbr)) || (0 != (epsgNum = EPSGCodeFromName (gcs->m_csParameters->csdef.key_nm))) )
                {
                if (this->IsEquivalent (*gcs))
                    {
                    delete gcs;
                    if (epsgNum < 65535)
                        m_foundEPSGCode = static_cast<short>(epsgNum);
                    return epsgNum;
                    }
                }
            }
        }

    if (NULL != gcs)
        delete gcs;

    return 0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int             BaseGCS::GetEPSGDatumCode
(
bool    noSearch
) const
    {
    if (NULL == m_csParameters)
        return 0;

    int     epsgNum;
    if (0 != (epsgNum = EPSGCodeFromName (m_csParameters->datum.key_nm)))
        return epsgNum;

    // CS_Map does not copy the epsgNbr from the _CS_dtdef structure to the _CS_datum structure, so we have to look up the cs_dtdef
    CSDatumDef *dtDef;
    if (NULL != (dtDef = CSMap::CS_dtdef (m_csParameters->datum.key_nm)))
        {
        epsgNum = dtDef->epsgNbr;
        CSMap::CS_free (dtDef);
        if (0 != epsgNum)
            return epsgNum;
        }

    // try CS_Map's internal lookup table.
    if (KcsNmInvNumber != (epsgNum = csMapNameToIdC (csMapDatumKeyName,
                                                     csMapFlvrEpsg,
                                                     csMapFlvrCsMap,
                                                     m_csParameters->datum.key_nm)))
        return epsgNum;

    // Also try the autodesk flavor as we did introduce quite a few of these
    if (KcsNmInvNumber != (epsgNum = csMapNameToIdC (csMapDatumKeyName,
                                                     csMapFlvrEpsg,
                                                     csMapFlvrAutodesk,
                                                     m_csParameters->datum.key_nm)))
        return epsgNum;

    if (noSearch)
        return 0;

    // we didn't find an EPSG Number the easy way, have to search.
    int     index;
    char    dtKeyName[128];
    for (index = 0; (0 < CSMap::CS_dtEnum (index, dtKeyName, sizeof(dtKeyName))); index++)
        {
        if (NULL != (dtDef = CSMap::CS_dtdef (dtKeyName)))
            {
            if (0 == (epsgNum = dtDef->epsgNbr))
                epsgNum = EPSGCodeFromName (dtDef->key_nm);

            CSMap::CS_free (dtDef);

            // if it might be an EPSG datum, compare it to our datum.
            if (0 != epsgNum)
                {
                CSDatum*       datum;
                if (NULL != (datum = CSMap::CS_dtloc (dtKeyName)))
                    {
                    if (DatumEquivalent (m_csParameters->datum, *datum, false, false, false))
                        {
                        CSMap::CS_free (datum);
                        return epsgNum;
                        }
                    CSMap::CS_free (datum);
                    }
                }
            }
        }

    return 0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int             BaseGCS::GetEPSGEllipsoidCode
(
bool    noSearch
) const
    {
    if (NULL == m_csParameters)
        return 0;

    int     epsgNum;
    if (0 != (epsgNum = EPSGCodeFromName (m_csParameters->datum.ell_knm)))
        return epsgNum;

    // CS_Map does not copy the epsgNbr from the _CS_eldef structure to the _CS_datum structure, so we have to look up the cs_eldef
    CSEllipsoidDef *elDef;
    if (NULL != (elDef = CSMap::CS_eldef (m_csParameters->datum.ell_knm)))
        {
        epsgNum = elDef->epsgNbr;
        CSMap::CS_free (elDef);
        if (0 != epsgNum)
            return epsgNum;
        }

    // try CS_Map's internal lookup table.
    if (KcsNmInvNumber != (epsgNum = csMapNameToIdC (csMapEllipsoidKeyName,
                                                     csMapFlvrEpsg,
                                                     csMapFlvrCsMap,
                                                     m_csParameters->datum.ell_knm)))
        return epsgNum;

    if (KcsNmInvNumber != (epsgNum = csMapNameToIdC (csMapEllipsoidKeyName,
                                                     csMapFlvrEpsg,
                                                     csMapFlvrAutodesk,
                                                     m_csParameters->datum.ell_knm)))
        return epsgNum;

    if (noSearch)
        return 0;

    // we didn't find an EPSG Number the easy way, have to search.
    int     index;
    char    elKeyName[128];
    for (index = 0; (0 < CS_elEnum (index, elKeyName, sizeof(elKeyName))); index++)
        {
        if (NULL != (elDef = CSMap::CS_eldef (elKeyName)))
            {
            if (0 == (epsgNum = elDef->epsgNbr))
                epsgNum = EPSGCodeFromName (elDef->key_nm);

            // if it might be an EPSG ellipsoid , compare it to the info in our datum.
            if (0 != epsgNum)
                {
                if (distanceSame(m_csParameters->datum.e_rad, elDef->e_rad) && distanceSame(m_csParameters->datum.p_rad, elDef->p_rad))
                    {
                    CSMap::CS_free (elDef);
                    return epsgNum;
                    }
                }
            CSMap::CS_free (elDef);
            }
        }

    return 0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int             BaseGCS::GetStoredEPSGCode () const
    {
    if (NULL == m_csParameters)
        return 0;

    return m_csParameters->csdef.epsgNbr;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   BaseGCS::SetStoredEPSGCode (short value)
    {
    if (NULL == m_csParameters)
        return GEOCOORDERR_InvalidCoordSys;

    if (value < 0)
        return GEOCOORDERR_BadArg;

    m_csParameters->csdef.epsgNbr = value;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool  BaseGCS::IsDeprecated() const
    {
    static Utf8String deprecated("LEGACY");

    Utf8String groupName;

    return (0 == deprecated.CompareTo(GetGroup(groupName)));
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool BaseGCS::IsProjected() const
    {
    return (BaseGCS::pcvUnity != GetProjectionCode());
    }

// ----------------------------------------------------------------------------------
// These Methods are related to the ability to have a local coordinate system that is
// related to the Cartesian coordinate system by the LocalTransformerP

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            BaseGCS::SetLocalTransformer
(
LocalTransformerP   transformer
)
    {
    m_localTransformer = transformer;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
LocalTransformerP   BaseGCS::GetLocalTransformer () const
    {
    return m_localTransformer.get();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            BaseGCS::InternalCartesianFromCartesian
(
DPoint3dR       outInternalCartesian,
DPoint3dCR      inCartesian
) const
    {
    if (m_localTransformer.IsNull())
        outInternalCartesian = inCartesian;
    else
        m_localTransformer->InternalCartesianFromCartesian (outInternalCartesian, inCartesian);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            BaseGCS::CartesianFromInternalCartesian
(
DPoint3dR       outCartesian,
DPoint3dCR      inInternalCartesian
) const
    {
    if (m_localTransformer.IsNull())
        outCartesian = inInternalCartesian;
    else
        m_localTransformer->CartesianFromInternalCartesian (outCartesian, inInternalCartesian);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            BaseGCS::InternalCartesianFromCartesian2D
(
DPoint2dR       outInternalCartesian,
DPoint2dCR      inCartesian
) const
    {
    if (m_localTransformer.IsNull())
        outInternalCartesian = inCartesian;
    else
        m_localTransformer->InternalCartesianFromCartesian2D (outInternalCartesian, inCartesian);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            BaseGCS::CartesianFromInternalCartesian2D
(
DPoint2dR       outCartesian,
DPoint2dCR      inInternalCartesian
) const
    {
    if (m_localTransformer.IsNull())
        outCartesian = inInternalCartesian;
    else
        m_localTransformer->CartesianFromInternalCartesian2D (outCartesian, inInternalCartesian);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
LocalTransformerP       LocalTransformer::CreateLocalTransformer (LocalTransformType transformType, double parameters[12])
    {
    if (TRANSFORM_Helmert == transformType)
        return HelmertLocalTransformer::Create (parameters[0], parameters[1], parameters[2], parameters[3], parameters[4]);

    return NULL;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
LocalTransformerP LocalTransformer::CreateLocalTransformerFromJson(BeJsConst jsonValue, Utf8String& errorMessage) {
    // Helmert is the only transformer currently supported.
    if (jsonValue["helmert2DWithZOffset"].isNull()) {
        errorMessage = "Unknown transform type or no transform defined";
        return nullptr;
    }

    return HelmertLocalTransformer::CreateFromJson(jsonValue["helmert2DWithZOffset"], errorMessage);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool                    LocalTransformer::IsEquivalent (LocalTransformerPtr const& transformer1, LocalTransformerPtr const& transformer2)
    {
    if ( transformer1.IsNull() != transformer2.IsNull() )
        return false;

    if (transformer1.IsNull())
        return true;

    return transformer1->IsEquivalent (transformer2.get());
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
LocalTransformer::LocalTransformer () {}
LocalTransformer::~LocalTransformer () {}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
HelmertLocalTransformer::HelmertLocalTransformer (double a, double b, double c, double d, double e)
    {
    m_a = a;
    m_b = b;
    m_c = c;
    m_d = d;
    m_e = e;

    ComputeInverse ();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
HelmertLocalTransformer*         HelmertLocalTransformer::Create (double a, double b, double c, double d, double e)
    {
    return new HelmertLocalTransformer (a, b, c, d, e);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
HelmertLocalTransformer* HelmertLocalTransformer::CreateFromJson(BeJsConst jsonValue, Utf8String& errorMessage) {

    // All properties must be provided (none are optional)
    if (jsonValue["translationX"].isNull() || jsonValue["translationY"].isNull() || jsonValue["translationZ"].isNull() ||
        jsonValue["scale"].isNull() || jsonValue["rotDeg"].isNull()) {
        errorMessage = "At least one property missing for Helmert Transformer";
        return nullptr;
    }

    double c = jsonValue["translationX"].asDouble();
    double d = jsonValue["translationY"].asDouble();
    double e = jsonValue["translationZ"].asDouble();

    double scale = jsonValue["scale"].asDouble();

    if (0.0 == scale) {
        errorMessage = "Scale cannot be zero in an Helmert transformation";
        return nullptr;
    }

    double rotationRad = jsonValue["rotDeg"].asDouble() * PI / 180.0;

    double a = scale * cos(rotationRad);
    double b = scale * sin(rotationRad);

    return new HelmertLocalTransformer(a, b, c, d, e);
}

    /*---------------------------------------------------------------------------------**/ /**
     * @bsimethod
     +---------------+---------------+---------------+---------------+---------------+------*/
    StatusInt HelmertLocalTransformer::ToJson(BeJsValue jsonValue, bool includeRoot) {
        BeJsValue theValue = (includeRoot ? jsonValue["helmert2DWithZOffset"] : jsonValue);
        theValue.toObject();
        double aSqPlusbSq = m_a * m_a + m_b * m_b;

        theValue["rotDeg"] = atan2(m_b, m_a) * 180 / PI;
        theValue["scale"] = sqrt(aSqPlusbSq);

        theValue["translationX"] = m_c;
        theValue["translationY"] = m_d;
        theValue["translationZ"] = m_e;

        return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::ComputeInverse ()
    {
    double  aSqPlusbSq = m_a * m_a + m_b * m_b;
    if (0 != aSqPlusbSq)
        {
        m_inverseA =  m_a         / aSqPlusbSq;
        m_inverseB = -1.0 * m_b   / aSqPlusbSq;
        m_inverseC = -1.0 * (m_a * m_c + m_b * m_d) / aSqPlusbSq;
        m_inverseD = (m_b * m_c - m_a * m_d) / aSqPlusbSq;
        m_inverseE = -1.0 * m_e;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::InternalCartesianFromCartesian (DPoint3dR outInternalCartesian, DPoint3dCR inCartesian) const
    {
    // this must work when outInternalCartesian and inCartesian are the same reference.
    double x = inCartesian.x;
    double y = inCartesian.y;
    outInternalCartesian.x = m_a * x - m_b * y + m_c;
    outInternalCartesian.y = m_b * x + m_a * y + m_d;
    outInternalCartesian.z = inCartesian.z + m_e;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::CartesianFromInternalCartesian (DPoint3dR outCartesian, DPoint3dCR inInternalCartesian) const
    {
    // this must work when outCartesian and inInternalCartesian are the same reference.
    double x = inInternalCartesian.x;
    double y = inInternalCartesian.y;
    outCartesian.x = m_inverseA * x - m_inverseB * y + m_inverseC;
    outCartesian.y = m_inverseB * x + m_inverseA * y + m_inverseD;
    outCartesian.z = inInternalCartesian.z + m_inverseE;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::InternalCartesianFromCartesian2D (DPoint2dR outInternalCartesian, DPoint2dCR inCartesian) const
    {
    // this must work when outInternalCartesian and inCartesian are the same reference.
    double x = inCartesian.x;
    double y = inCartesian.y;
    outInternalCartesian.x = m_a * x - m_b * y + m_c;
    outInternalCartesian.y = m_b * x + m_a * y + m_d;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::CartesianFromInternalCartesian2D (DPoint2dR outCartesian, DPoint2dCR inInternalCartesian) const
    {
    // this must work when outCartesian and inInternalCartesian are the same reference.
    double x = inInternalCartesian.x;
    double y = inInternalCartesian.y;
    outCartesian.x = m_inverseA * x - m_inverseB * y + m_inverseC;
    outCartesian.y = m_inverseB * x + m_inverseA * y + m_inverseD;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::GetInternalCartesianFromCartesianTransform (TransformR transform)
    {
    transform.form3d[0][0] = m_a;
    transform.form3d[0][1] = -1.0 * m_b;
    transform.form3d[0][2] = 0.0;
    transform.form3d[0][3] = m_c;

    transform.form3d[1][0] = m_b;
    transform.form3d[1][1] = m_a;
    transform.form3d[1][2] = 0.0;
    transform.form3d[1][3] = m_d;

    transform.form3d[2][0] = 0.0;
    transform.form3d[2][1] = 0.0;
    transform.form3d[2][2] = 1.0;
    transform.form3d[2][3] = m_e;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::GetCartesianFromInternalCartesianTransform (TransformR transform)
    {
    transform.form3d[0][0] = m_inverseA;
    transform.form3d[0][1] = -1.0 * m_inverseB;
    transform.form3d[0][2] = 0.0;
    transform.form3d[0][3] = m_inverseC;

    transform.form3d[1][0] = m_inverseB;
    transform.form3d[1][1] = m_inverseA;
    transform.form3d[1][2] = 0.0;
    transform.form3d[1][3] = m_inverseD;

    transform.form3d[2][0] = 0.0;
    transform.form3d[2][1] = 0.0;
    transform.form3d[2][2] = 1.0;
    transform.form3d[2][3] = m_inverseE;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::GetDescription (Utf8String& description) const
    {
    description.assign ("Helmert Transformation");
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            HelmertLocalTransformer::IsEquivalent (LocalTransformerCP other) const
    {
    HelmertLocalTransformer const*  otherHelmert;
    if (NULL == (otherHelmert = dynamic_cast <HelmertLocalTransformer const*> (other)))
        return false;
    return ( doubleSame(m_a, otherHelmert->m_a) && doubleSame(m_b, otherHelmert->m_b) && doubleSame(m_c, otherHelmert->m_c) && doubleSame(m_d, otherHelmert->m_d) && doubleSame(m_e, otherHelmert->m_e));
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::SaveParameters (uint16_t& transformType, double parameters[12]) const
    {
    transformType = TRANSFORM_Helmert;
    parameters[0] = m_a;
    parameters[1] = m_b;
    parameters[2] = m_c;
    parameters[3] = m_d;
    parameters[4] = m_e;
    }

/*---------------------------------------------------------------------------------**//**
* Read local transform parameters from memory.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            HelmertLocalTransformer::ReadParameters (double parameters[12])
    {
    m_a = parameters[0];
    m_b = parameters[1];
    m_c = parameters[2];
    m_d = parameters[3];
    m_e = parameters[4];

    ComputeInverse();
    }

double          HelmertLocalTransformer::GetA () const {return m_a;}
double          HelmertLocalTransformer::GetB () const {return m_b;}
double          HelmertLocalTransformer::GetC () const {return m_c;}
double          HelmertLocalTransformer::GetD () const {return m_d;}
double          HelmertLocalTransformer::GetE () const {return m_e;}

void            HelmertLocalTransformer::SetA (double val) { m_a = val; ComputeInverse(); }
void            HelmertLocalTransformer::SetB (double val) { m_b = val; ComputeInverse(); }
void            HelmertLocalTransformer::SetC (double val) { m_c = val; ComputeInverse(); }
void            HelmertLocalTransformer::SetD (double val) { m_d = val; ComputeInverse(); }
void            HelmertLocalTransformer::SetE (double val) { m_e = val; ComputeInverse(); }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
LocalTransformerP   HelmertLocalTransformer::Copy () const
    {
    return new HelmertLocalTransformer (m_a, m_b, m_c, m_d, m_e);
    }

// End of Local Coordinate methods.
// ----------------------------------------------------------------------------------

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus BaseGCS::LatLongFromCartesian
(
GeoPointR       outLatLong,         // <= latitude longitude
DPoint3dCR      inCartesian         // => Cartesian, in GCS's units.
) const
    {
    DPoint3d    internalCartesian;

	if (NULL == m_csParameters)
		return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    InternalCartesianFromCartesian (internalCartesian, inCartesian);
    return (ReprojectStatus) CSMap::CS_cs3ll (m_csParameters, &outLatLong, &internalCartesian);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus BaseGCS::LatLongFromCartesian2D
(
GeoPoint2dR     outLatLong,         // <= latitude longitude
DPoint2dCR      inCartesian         // => Cartesian, in GCS's units.
) const
    {
    DPoint2d    internalCartesian;

	if (NULL == m_csParameters)
		return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    InternalCartesianFromCartesian2D (internalCartesian, inCartesian);

    // unfortunately, CS_cs2ll takes 3d points.
    DPoint3d    cartesian3d = {internalCartesian.x, internalCartesian.y, 0.0};
    GeoPoint    outLatLong3d;
    StatusInt status = CSMap::CS_cs2ll (m_csParameters, &outLatLong3d, &cartesian3d);
    outLatLong.Init (outLatLong3d.longitude, outLatLong3d.latitude);

    return (ReprojectStatus) status;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus BaseGCS::CartesianFromLatLong
(
DPoint3dR       outCartesian,       // <= Cartesian, in GCS's units.
GeoPointCR      inLatLong           // => latitude longitude
) const
    {
    ReprojectStatus     status;
    DPoint3d    internalCartesian;

	if (NULL == m_csParameters)
		return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    status = (ReprojectStatus) CSMap::CS_ll3cs (m_csParameters, &internalCartesian, &inLatLong);

    // In case a hard error occured ... we zero out all values
    if ((REPROJECT_Success != status) && (REPROJECT_CSMAPERR_OutOfUsefulRange != status) && (REPROJECT_CSMAPERR_VerticalDatumConversionError != status) )
        outCartesian.x = outCartesian.y = outCartesian.z = 0.0;
    else
        CartesianFromInternalCartesian (outCartesian, internalCartesian);

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus BaseGCS::CartesianFromLatLong2D
(
DPoint2dR       outCartesian,       // <= Cartesian, in GCS's units.
GeoPoint2dCR    inLatLong           // => latitude longitude
) const
    {
    StatusInt   status;

	if (NULL == m_csParameters)
		return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    GeoPoint    inLatLong3d;
    inLatLong3d.Init (inLatLong.longitude, inLatLong.latitude, 0.0);

    DPoint3d    internalCartesian3d;
    status = CSMap::CS_ll2cs (m_csParameters, &internalCartesian3d, &inLatLong3d);

    // In case a hard error occured ... we zero out all values
    if ((SUCCESS != status) && (cs_CNVRT_USFL != status))
        outCartesian.x = outCartesian.y = 0.0;
    else
        {
        outCartesian.x = internalCartesian3d.x;
        outCartesian.y = internalCartesian3d.y;
        CartesianFromInternalCartesian2D (outCartesian, outCartesian);
        }

    return (ReprojectStatus) status;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double          BaseGCS::UnitsFromMeters
(
) const
    {
    if (NULL == m_csParameters)
        return 1.0; // We return 1 in case someone tries to invert without checking against zero

    return m_csParameters->csdef.scale;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::RangeTestResult BaseGCS::CheckGeoPointRange
(
GeoPointCR      points,
int             numPoints
) const
    {
    if (NULL == m_csParameters)
        return RangeTestOutsideMathDomain;

    return (BaseGCS::RangeTestResult) CSMap::CS_llchk (m_csParameters, numPoints, &points);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
BaseGCS::RangeTestResult BaseGCS::CheckCartesianRange
(
DPoint3dCR      points,
int             numPoints
) const
    {
    if (NULL == m_csParameters)
        return RangeTestOutsideMathDomain;

    return (BaseGCS::RangeTestResult) CSMap::CS_xychk (m_csParameters, numPoints, &points);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DgnProjectionTypes     BaseGCS::DgnProjectionTypeFromCSDefName
(
CharCP        projectionKeyName
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return COORDSYS_NONE;

    int             iCoordSys;
    CoordSysData*   coordSys;

    for (iCoordSys=0, coordSys = csDataMap; iCoordSys < DIM (csDataMap); iCoordSys++, coordSys++)
        {
        if ( (NULL != coordSys->csMapKeyName) && (0 == strcmp (projectionKeyName, coordSys->csMapKeyName)) )
            return coordSys->dgnProjectionType;
        }
    return COORDSYS_NONE;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DgnProjectionTypes     BaseGCS::DgnProjectionTypeFromCSMapProjectionCode
(
BaseGCS::ProjectionCodeValue projectionCode
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return COORDSYS_NONE;

    int             iCoordSys;
    CoordSysData*   coordSys;

    for (iCoordSys=0, coordSys = csDataMap; iCoordSys < DIM (csDataMap); iCoordSys++, coordSys++)
        {
        if ( (pcvInvalid != coordSys->csMapProjCodeValue) && (projectionCode == coordSys->csMapProjCodeValue) )
            return coordSys->dgnProjectionType;
        }
    return COORDSYS_NONE;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumConverterP BaseGCS::SetDatumConverter
(
BaseGCSCR        targetGCS         // => target coordinate system
)
    {
    return SetupDatumConverterFor(targetGCS);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumConverterP BaseGCS::SetupDatumConverterFor
(
BaseGCSCR        targetGCS         // => target coordinate system
) const
    {
    if (NULL != m_datumConverter)
        {
        m_datumConverter->Destroy();
        m_datumConverter = NULL;
        }
    m_datumConverter = DatumConverter::Create (*this, targetGCS);

    if (NULL != m_targetGCS)
        m_targetGCS->UnRegisterIsADestinationOf(*this);

    m_targetGCS = &targetGCS;
    m_targetGCS->RegisterIsADestinationOf(*this);

    if (m_datumConverter!=NULL)
        m_datumConverter->SetReprojectElevation (m_reprojectElevation);

    return m_datumConverter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::ClearCache() const
    {
    // Clean up cache data so we release our hold upon other BaseGCS
    if (NULL != m_datumConverter)
        {
        m_datumConverter->Destroy();
        m_datumConverter = NULL;
        }

    // Normally the caller is the pointed GCS of which the address is m_targetGCS
    // We do not need to unregister the present GCS from the list of pointed GCS of the caller.
    m_targetGCS = NULL;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::ClearConverterCache() const
    {
    // Clean up cache data so we release our hold upon other BaseGCS
    if (NULL != m_datumConverter)
        {
        m_datumConverter->Destroy();
        m_datumConverter = NULL;
        }

    if (nullptr != m_targetGCS)
        {
        m_targetGCS->UnRegisterIsADestinationOf(*this);
        m_targetGCS = NULL;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::RegisterIsADestinationOf(BaseGCSCR baseGCSThatUsesCurrentAsADestination) const
    {
    m_listOfPointingGCS.push_back(&baseGCSThatUsesCurrentAsADestination);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::UnRegisterIsADestinationOf(BaseGCSCR baseGCSThatUsesCurrentAsADestination) const
    {
    for (bvector<BaseGCSCP>::iterator itr = m_listOfPointingGCS.begin() ; itr != m_listOfPointingGCS.end() ; itr++)
        {
        if ((*itr) == &baseGCSThatUsesCurrentAsADestination)
			{
            m_listOfPointingGCS.erase(itr);
			break;
			}
        }
    }

/*---------------------------------------------------------------------------------**//**

* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void BaseGCS::SetModified(bool modified)
    {
    if (modified)
        {
        // We clear all cache parameters
        if (NULL != m_targetGCS)
            {
            m_targetGCS->UnRegisterIsADestinationOf(*this);
            m_targetGCS = NULL;
            }

        if (NULL != m_datumConverter)
            {
            m_datumConverter->Destroy();
            m_datumConverter = NULL;
            }

        if (nullptr != m_datum && !m_customDatum)
            {
            m_datum->Destroy();
            m_datum = nullptr;
            }

        DELETE_AND_CLEAR(m_nameString);
        DELETE_AND_CLEAR(m_descriptionString);
        DELETE_AND_CLEAR(m_projectionString);
        DELETE_AND_CLEAR(m_datumNameString);
        DELETE_AND_CLEAR(m_datumDescriptionString);
        DELETE_AND_CLEAR(m_ellipsoidNameString);
        DELETE_AND_CLEAR(m_ellipsoidDescriptionString);

        // Clear original settings
        DELETE_AND_CLEAR(m_originalGeoKeys);
        if (nullptr != m_originalWKT)
            m_originalWKT->clear();

        // Clear the link between other BaseGCS to this one used as a cached target
        for (size_t i = 0; i < m_listOfPointingGCS.size(); i++)
            m_listOfPointingGCS[i]->ClearCache();

        m_listOfPointingGCS.clear();
        }

    m_modified = modified;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::SetReprojectElevation (bool value)
    {
    bool    returnValue = m_reprojectElevation;
    m_reprojectElevation = value;

    if (NULL != m_datumConverter)
        m_datumConverter->SetReprojectElevation (value);

    return returnValue;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            BaseGCS::GetReprojectElevation () const
    {
    return m_reprojectElevation;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus BaseGCS::LatLongFromLatLong
(
GeoPointR       outLatLong,         // <= latitude longitude in targetGCS
GeoPointCR      inLatLong,          // => latitude longitude in this GCS
BaseGCSCR       targetGCS           // => target coordinate system
) const
    {
    // make sure datum converter is set up for the destination.
    if (&targetGCS != m_targetGCS)
        SetupDatumConverterFor(targetGCS);

    if (NULL == m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    if (NULL == targetGCS.m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    ReprojectStatus status = REPROJECT_Success;
    if (NULL != m_datumConverter)
        status = m_datumConverter->ConvertLatLong3D (outLatLong, inLatLong);
    else
        {
        outLatLong = inLatLong;
        status = REPROJECT_CSMAPERR_DatumConverterNotSet; // May be interpreted as a warning.
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus BaseGCS::LatLongFromLatLong2D
(
GeoPoint2dR     outLatLong,         // <= latitude longitude in targetGCS
GeoPoint2dCR    inLatLong,          // => latitude longitude in this GCS
BaseGCSCR       targetGCS           // => target coordinate system
) const
    {

	if (NULL == m_csParameters)
		return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

	if (NULL == targetGCS.m_csParameters)
		return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    // make sure datum converter is set up for the destination.
    if (&targetGCS != m_targetGCS)
        SetupDatumConverterFor (targetGCS);

    ReprojectStatus status = REPROJECT_Success;
    if (NULL != m_datumConverter)
        status = m_datumConverter->ConvertLatLong2D (outLatLong, inLatLong);
    else
        {
        outLatLong = inLatLong;
        status = REPROJECT_CSMAPERR_DatumConverterNotSet; // May be interpreted as a warning.
        }

    return status;
    }

static bool     s_radiansPerDegreeInitialized = false;
static double   s_radiansPerDegree;
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::RadiansFromDegrees(double inDegrees) {
    if (!s_radiansPerDegreeInitialized) {
        s_radiansPerDegree = atan(1.0) / 45.0;
        s_radiansPerDegreeInitialized = true;
    }
    return inDegrees * s_radiansPerDegree;
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
double BaseGCS::DegreesFromRadians(double inRadians) {
    if (!s_radiansPerDegreeInitialized) {
        s_radiansPerDegree = atan(1.0) / 45.0;
        s_radiansPerDegreeInitialized = true;
    }
    return inRadians / s_radiansPerDegree;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus   BaseGCS::LatLongFromXYZ
(
GeoPointR       outLatLong,
DPoint3dCR      inXYZ
) const
    {
    if (NULL == m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    static EllipsoidCP WGS84Ellipsoid = nullptr;
    if (nullptr == WGS84Ellipsoid)
        WGS84Ellipsoid = Ellipsoid::CreateEllipsoid("WGS84");

    if (nullptr == WGS84Ellipsoid)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys; // Can only occur if dictionary absent

    bool WGS84Datum = HasWGS84CoincidentDatum();

    DatumCP theDatum = GetDatum();
    if (theDatum == nullptr || !theDatum->IsValid())
      return REPROJECT_BadArgument; // We do not want to deal with datumless GCS since we will not deal with vertical datums then ... we return an ERROR;

    bool differentEllipsoid = !theDatum->GetEllipsoid()->IsEquivalent(*WGS84Ellipsoid);

    // A WGS84 coincident datum must have the same ellipsoid shape for this to work.
    if (WGS84Datum && differentEllipsoid)
        return REPROJECT_CSMAPERR_VerticalDatumConversionError;

    VertDatumCode elevationDatumCode = NetVerticalDatumFromGCS(*this);

    // We will not process local ellipsoid to WGS84 ellipsoid here as this require a full blown datum converter.
    if (!WGS84Datum && elevationDatumCode != vdcLocalEllipsoid)
        return REPROJECT_CSMAPERR_VerticalDatumConversionError;

    CSMap::CS_xyzToLlh (&outLatLong, &inXYZ, m_csParameters->datum.e_rad, m_csParameters->datum.ecent * m_csParameters->datum.ecent);

    if (WGS84Datum && (vdcEllipsoid != elevationDatumCode))
        {
        // Elevation is not ellipsoid based which is the result of the previous function
        // We must convert

        // If elevation datum is NGVD29 based then we need to initialize the vertical datum conversion.
        if (vdcNGVD29 == elevationDatumCode)
            if (0 != CSvrtconInit())
                return REPROJECT_CSMAPERR_VerticalDatumConversionError;

        VerticalDatumConverter* vertConverter =  new VerticalDatumConverter (IsNAD27(), vdcEllipsoid, elevationDatumCode);

        GeoPoint inLatLong = {outLatLong.longitude, outLatLong.latitude, outLatLong.elevation};

        vertConverter->ConvertElevation (outLatLong, inLatLong);

        // I know that not caching the vertical datum converter may prove inefficient for multiple calls
        // but I elected not to clutter the BaseGCS class with yet another cached member since GeoCentric conversion
        // is rare and if used will be few. If usage proves me wrong feel free to add required member.
        delete vertConverter;
        }

    return REPROJECT_Success;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus   BaseGCS::XYZFromLatLong
(
DPoint3dR       outXYZ,
GeoPointCR      inLatLong
) const
    {
    if (NULL == m_csParameters)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys;

    GeoPoint effectInLatLong = inLatLong;

    static EllipsoidCP WGS84Ellipsoid = nullptr;
    if (nullptr == WGS84Ellipsoid)
        WGS84Ellipsoid = Ellipsoid::CreateEllipsoid("WGS84");

    if (nullptr == WGS84Ellipsoid)
        return (ReprojectStatus)GEOCOORDERR_InvalidCoordSys; // Can only occur if dictionary absent

    bool WGS84Datum = HasWGS84CoincidentDatum();
    DatumCP theDatum = GetDatum();
    if (theDatum == nullptr || !theDatum->IsValid())
      return REPROJECT_BadArgument; // We do not want to deal with datumless GCS since we will not deal with vertical datums then ... we return an ERROR;

    bool differentEllipsoid = !theDatum->GetEllipsoid()->IsEquivalent(*WGS84Ellipsoid);

    // A WGS84 coincident datum must have the same ellipsoid shape for this to work.
    if (WGS84Datum && differentEllipsoid)
        return REPROJECT_CSMAPERR_VerticalDatumConversionError;

    VertDatumCode elevationDatumCode = NetVerticalDatumFromGCS(*this);

    // We will not process local ellipsoid to WGS84 ellipsoid here as this require a full blown datum converter.
    if (!WGS84Datum && elevationDatumCode != vdcLocalEllipsoid)
        return REPROJECT_CSMAPERR_VerticalDatumConversionError;

    if (WGS84Datum && (vdcEllipsoid != elevationDatumCode))
        {
        // Elevation is not local ellipsoid based which is the required input of the geocentric function
        // We must convert

        // If elevation datum is NGVD29 based then we need to initialize the vertical datum conversion.
        if (vdcNGVD29 == elevationDatumCode)
            if (0 != CSvrtconInit())
                return REPROJECT_CSMAPERR_VerticalDatumConversionError;

        VerticalDatumConverter* vertConverter =  new VerticalDatumConverter (IsNAD27(), elevationDatumCode, vdcEllipsoid);

        vertConverter->ConvertElevation (effectInLatLong, inLatLong);

        // I know that not caching the vertical datum converter may prove inefficient for multiple calls
        // but I elected not to clutter the BaseGCS class with yet another cached member since GeoCentric conversion
        // is rare and if used will be few. If usage proves me wrong feel free to add required member.
        delete vertConverter;
        }

	CSMap::CS_llhToXyz (&outXYZ, &effectInLatLong, m_csParameters->datum.e_rad, m_csParameters->datum.ecent * m_csParameters->datum.ecent);

    return REPROJECT_Success;
    }


#if defined (TRAVERSE_UNITS)
typdef void (*UnitCallback)(void* callbackArg, CharCP unitName, CharCP pluralName, int system, double factor, int32_t epsgCode, int index);
/*---------------------------------------------------------------------------------**//**
* Traverses all linear units in the CSMap unit table.
* @return   Angular value in degrees
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void     TraverseLinearUnits
(
UnitCallback    callback,
void*           callbackArg
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return;
        }

    const struct cs_Unittab_   *pUnit;
    int                         index;
    for (index = 0, pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if (pUnit->type == cs_UTYP_LEN)
            callback (callbackArg, pUnit->name, pUnit->pluralName, pUnit->system, pUnit->factor, pUnit->epsgCode, index);
        }
    }

/*---------------------------------------------------------------------------------**//**
* Traverses all angular units in the CSMap unit table.
* @return   Angular value in degrees
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void     TraverseAngularUnits
(
UnitCallback    callback,
void*           callbackArg
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return;
        }

    const struct cs_Unittab_   *pUnit;
    int                         index;
    for (index = 0, pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if (pUnit->type == cs_UTYP_ANG)
            callback (callbackArg, pUnit->name, pUnit->pluralName, pUnit->system, pUnit->factor, pUnit->epsgCode, index);
        }
    }
#endif

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
T_Utf8StringVector*   BaseGCS::GetLinearUnitNames
(
)
    {
    T_Utf8StringVector*    unitNames = new T_Utf8StringVector();

    if (!BaseGCS::IsLibraryInitialized())
        return unitNames;

    const struct cs_Unittab_   *pUnit;
    for (pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        if (pUnit->type == cs_UTYP_LEN)
            {
            unitNames->push_back (Utf8String(pUnit->name));
            }
        }

    return unitNames;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
T_Utf8StringVector*   BaseGCS::GetUnitNames
(
)
    {
    T_Utf8StringVector*    unitNames = new T_Utf8StringVector();

    if (!BaseGCS::IsLibraryInitialized())
        return unitNames;

    const struct cs_Unittab_   *pUnit;
    for (pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++)
        {
        unitNames->push_back (Utf8String(pUnit->name));
        }

    return unitNames;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
T_Utf8StringVector*   BaseGCS::GetDatumNames
(
)
    {
    T_Utf8StringVector*    datumNames = new T_Utf8StringVector();

    if (!BaseGCS::IsLibraryInitialized())
        return datumNames;

    int     index;
    char    dtKeyName[128];
    for (index = 0; (0 < CSMap::CS_dtEnum (index, dtKeyName, sizeof(dtKeyName))); index++)
        {
        datumNames->push_back (Utf8String(dtKeyName));
        }

    return datumNames;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
T_Utf8StringVector*   BaseGCS::GetEllipsoidNames
(
)
    {
    T_Utf8StringVector*    ellipsoidNames = new T_Utf8StringVector();

    if (!BaseGCS::IsLibraryInitialized())
        return ellipsoidNames;

    int     index;
    char    elKeyName[128];
    for (index = 0; (0 < CS_elEnum (index, elKeyName, sizeof(elKeyName))); index++)
        {
        ellipsoidNames->push_back (Utf8String(elKeyName));
        }

    return ellipsoidNames;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumConverter::DatumConverter
(
CSDatumConvert*         datumConvert,
VerticalDatumConverter* verticalDatumConverter
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return;

    m_datumConvert              = datumConvert;
    m_verticalDatumConverter    = verticalDatumConverter;

    // Allow soft errors to go through and let caller decide of the way to process ... (Soft errors will have return status greater than 0)
    if (NULL != m_datumConvert)
        m_datumConvert->block_err   = cs_DTCFLG_BLK_W;

    // by default, we convert elevations when we're converting 3D.
    // to make it not so, call SetReprojectElevation (false);
    // TODO determine how we deal with ellipsoids changes.
    m_reprojectElevation        = true;
    if ((NULL != m_verticalDatumConverter) && m_verticalDatumConverter->NeedsDatumElevationChange())
        m_3dDatumConvertFunc = CSMap::CS_dtcvt3D;
    else
        m_3dDatumConvertFunc = CSMap::CS_dtcvt;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VerticalDatumConverter*         GetVerticalDatumConverterFromCode
(
    bool                fromIsNAD27,
    VertDatumCode       fromVDC,
    VertDatumCode       toVDC
)
{
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    // Net vertical datum cannot be vdcFromDatum
    BeAssert(fromVDC != vdcFromDatum);
    BeAssert(toVDC != vdcFromDatum);

    // If either vertical datum codes are NGVD29 or NAVD88 then we init
    // the VERTCON american vertical datum system
    if (fromVDC == vdcNGVD29 || fromVDC == vdcNAVD88 || toVDC == vdcNGVD29 || toVDC == vdcNAVD88)
        if (0 != CSvrtconInit())
            return NULL;

    // This value is irrelevant when we are not performing NGVD29/NAVD88 vertical datum shift.
    return new VerticalDatumConverter(fromIsNAD27, fromVDC, toVDC);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
VerticalDatumConverter*         GetVerticalDatumConverter
(
BaseGCSCR       from,
BaseGCSCR       to
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    if (!from.IsValid() || !to.IsValid())
        return NULL;

    VertDatumCode   fromVDC = NetVerticalDatumFromGCS (from);
    VertDatumCode   toVDC   = NetVerticalDatumFromGCS (to);

    // Net vertical datum cannot be vdcFromDatum
    BeAssert(fromVDC != vdcFromDatum);
    BeAssert(toVDC != vdcFromDatum);

    bool fromIsNAD27 = from.IsNAD27();
    return GetVerticalDatumConverterFromCode(fromIsNAD27, fromVDC, toVDC);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumConverterP         DatumConverter::Create
(
BaseGCSCR       from,
BaseGCSCR       to
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    if (!from.IsValid() || !to.IsValid())
        return NULL;

    VerticalDatumConverter* verticalDatumConverter = GetVerticalDatumConverter (from, to);
    // TODO Remove everything and go directly to the datum portion?
    CSDatumConvert  *datumConvert = CSMap::CS_dtcsu (from.GetCSParameters(), to.GetCSParameters());

    if (NULL != datumConvert)
        return new DatumConverter (datumConvert, verticalDatumConverter);
    else
        {
        if (NULL != verticalDatumConverter)
            delete verticalDatumConverter;

        // Obtain the datum and check if there are some stored geodetic transforms...
        DatumCP fromDatum = from.GetDatum();
        DatumCP toDatum = to.GetDatum();

        if ((nullptr == fromDatum) || (nullptr == toDatum))
            return nullptr;

        return DatumConverter::Create(*fromDatum, *toDatum, from.GetVerticalDatumCode(), to.GetVerticalDatumCode());
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumConverterP         DatumConverter::Create
(
DatumCR     fromDatum,
DatumCR     toDatum
)
    {
    DatumConverterP newConverter = DatumConverter::Create(fromDatum, toDatum, vdcGeoid, vdcGeoid);

    // Since no real vertical datum provided elevation reprojection is irrelevant.
    if (nullptr != newConverter)
        newConverter->SetReprojectElevation(false);

    return newConverter;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumConverterP         DatumConverter::Create
(
    DatumCR       fromDatum,
    DatumCR       toDatum,
    VertDatumCode fromVerticalDatum,
    VertDatumCode toVerticalDatum
)
{
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    if (!fromDatum.IsValid() || !toDatum.IsValid())
        return NULL;

    CSDatum* srcCSDatum = fromDatum.GetCSDatum();
    CSDatum* dstCSDatum = toDatum.GetCSDatum();

    if ((NULL == srcCSDatum) || (NULL == dstCSDatum))
        return NULL;

    bool fromIsNAD27 = fromDatum.IsNAD27();

    VertDatumCode   fromVDC = NetVerticalDatumFromDatum (fromDatum, fromVerticalDatum);
    VertDatumCode   toVDC   = NetVerticalDatumFromDatum (toDatum, toVerticalDatum);

    // Net vertical datum cannot be vdcFromDatum
    BeAssert(fromVDC != vdcFromDatum);
    BeAssert(toVDC != vdcFromDatum);

    VerticalDatumConverter* verticalDatumConverter = GetVerticalDatumConverterFromCode(fromIsNAD27, fromVDC, toVDC);

    // TODO Instead of calling this should we not simply check that the datum does not a self-defined datum or a set transform ...
    // On the other hand calling this insures shortcuts in geodetic path are taken into account.
    CSDatumConvert  *datumConvert = nullptr;

    datumConvert = CSMap::CSdtcsu(srcCSDatum, dstCSDatum);

    if (NULL != datumConvert)
        return new DatumConverter(datumConvert, verticalDatumConverter);
    else
        {
        // Make use of the geodetic transform path capacity to build from stored transforms
        GeodeticTransformPath* fullPath = GeodeticTransformPath::Create(fromDatum, toDatum);

        if (nullptr == fullPath)
            {
            // TODO Do we really allow vertical converter if no horizontal converter?
            if (verticalDatumConverter != nullptr)
                return new DatumConverter(datumConvert, verticalDatumConverter);
            else
                return nullptr;
            }

        datumConvert = nullptr; //struct cs_Dtcprm_ *dtcPtr;
        datumConvert = (CSDatumConvert*)CS_malc(sizeof(CSDatumConvert)); // CS_malc (sizeof (struct cs_Dtcprm_));
        if (NULL == datumConvert)
            {
            fullPath->Destroy();
            if (verticalDatumConverter != nullptr)
                delete verticalDatumConverter;
            return nullptr;
            }

        CS_stncp(datumConvert->srcKeyName, fullPath->GetSourceDatumName(), sizeof(datumConvert->srcKeyName));
        CS_stncp(datumConvert->trgKeyName, fullPath->GetTargetDatumName(), sizeof(datumConvert->trgKeyName));
        datumConvert->pathName[0] = '\0';
        datumConvert->description[0] = '\0';
        datumConvert->source[0] = '\0';
        datumConvert->group[0] = '\0';
        datumConvert->block_err = cs_DTCFLG_BLK_W;
        datumConvert->xfrmCount = 0;
        datumConvert->listCount = 0;
        datumConvert->rptCount = 0;
        int idx;

        for (idx = 0; idx < 10; idx += 1)
            {
            datumConvert->errLngLat[idx][0] = datumConvert->errLngLat[idx][1] = 0;
            }
        for (idx = 0; idx < csPATH_MAXXFRM; idx += 1)
            {
            datumConvert->xforms[idx] = NULL;
            }

        // Run through path, obtain def and compound them
        for (size_t index = 0; index < fullPath->GetGeodeticTransformCount(); index++)
            {
            GeodeticTransformP currentTransform = fullPath->GetGeodeticTransform(index);

            // CSMAP does not tolerate no names for source and target datum even if we provide.
            if (Utf8String(currentTransform->GetSourceDatumName()) == "")
                currentTransform->SetSourceDatumName("Unnamed");

            if (Utf8String(currentTransform->GetTargetDatumName()) == "")
                currentTransform->SetTargetDatumName("Unnamed");

            CSGeodeticTransformDef const* xtrfDef = currentTransform->GetCSGeodeticTransformDef();
            CSGeodeticTransformDef const* fallbackXtrfDef = currentTransform->GetFallbackCSGeodeticTransformDef();

            if (nullptr == xtrfDef)
                {
                CSMap::CS_dtcls(datumConvert);
                fullPath->Destroy();
                if (verticalDatumConverter != nullptr)
                    delete verticalDatumConverter;
                return nullptr;
                }

            struct cs_GxXform_* newTransform = nullptr;

            if (nullptr == fallbackXtrfDef)
                newTransform = CS_gxloc1(xtrfDef, cs_DTCDIR_FWD);

            if (nullptr == newTransform)
                {
                // Most probably one of the source or target datums is unknown (custom defined)
                if (0 == index)
                    {
                    if (fullPath->GetGeodeticTransformCount() - 1 == index)
                        {
                        // This transform is the only one in the path ...
                        newTransform = CS_gxloc1DtmProvided(xtrfDef, cs_DTCDIR_FWD, srcCSDatum, dstCSDatum, fallbackXtrfDef);
                        }
                    else
                        {
                        // First transform in path but not last ... we try extracting the target datum
                        CSDatum* trgDtPtr = CS_dtloc(xtrfDef->trgDatum);
                        if (NULL != trgDtPtr)
                            {
                            newTransform = CS_gxloc1DtmProvided(xtrfDef, cs_DTCDIR_FWD, srcCSDatum, trgDtPtr, fallbackXtrfDef);
                            CS_free(trgDtPtr);
                            }
                        else
                            {
                            // No target datum name or target datum unknown ... we try with the ellipsoid definition
                            EllipsoidCP transformTargetEllipsoid = currentTransform->GetTargetEllipsoid();
                            if (nullptr != transformTargetEllipsoid)
                                {
                                // We also need the source ellipsoid
                                EllipsoidCP sourceEllipsoid = fromDatum.GetEllipsoid();
                                if (nullptr == sourceEllipsoid) // If source datum ellipsoid invalid ... we use the transform source ellipsoid
                                    sourceEllipsoid = currentTransform->GetSourceEllipsoid();

                                if (nullptr != sourceEllipsoid)
                                    newTransform = CS_gxloc1ElDefProvided(xtrfDef, cs_DTCDIR_FWD, sourceEllipsoid->GetCSEllipsoidDef(), transformTargetEllipsoid->GetCSEllipsoidDef(), fallbackXtrfDef);
                                }
                            }
                        }
                    }
                else if (fullPath->GetGeodeticTransformCount() - 1 == index)
                    {
                    // Last transform in path but not first ... we try extracting the source datum
                    CSDatum* srcDtPtr = CS_dtloc(xtrfDef->srcDatum);
                    if (NULL != srcDtPtr)
                        {
                        newTransform = CS_gxloc1DtmProvided(xtrfDef, cs_DTCDIR_FWD, srcDtPtr, dstCSDatum, fallbackXtrfDef);
                        CS_free(srcDtPtr);
                        }
                    else
                        {
                        // No source datum name or source datum unknown ... we try with the ellipsoid definition
                        EllipsoidCP transformSourceEllipsoid = currentTransform->GetSourceEllipsoid();
                        if (nullptr != transformSourceEllipsoid)
                            {
                            // We also need the source ellipsoid
                            EllipsoidCP targetEllipsoid = toDatum.GetEllipsoid();
                            if (nullptr == targetEllipsoid) // If target datum ellipsoid invalid ... we use the transform target ellipsoid
                                targetEllipsoid = currentTransform->GetTargetEllipsoid();

                            if (nullptr != targetEllipsoid)
                                newTransform = CS_gxloc1ElDefProvided(xtrfDef, cs_DTCDIR_FWD, transformSourceEllipsoid->GetCSEllipsoidDef(), targetEllipsoid->GetCSEllipsoidDef(), fallbackXtrfDef);
                            }
                        }
                    }
                else
                    {
                    // We totally need to rely on the transform ellipsoids definitions;
                    EllipsoidCP transformSourceEllipsoid = currentTransform->GetSourceEllipsoid();
                    EllipsoidCP transformTargetEllipsoid = currentTransform->GetTargetEllipsoid();
                    if (nullptr != transformSourceEllipsoid && nullptr != transformTargetEllipsoid)
                        newTransform = CS_gxloc1ElDefProvided(xtrfDef, cs_DTCDIR_FWD, transformSourceEllipsoid->GetCSEllipsoidDef(), transformTargetEllipsoid->GetCSEllipsoidDef(), fallbackXtrfDef);
                    }
                // No else ... transform is in middle and we do not have the datum definition known.
                // TODO allow ellipsoid in GeodeticTransform to complete
                }
            if (nullptr == newTransform)
                {
                // Obviously some file is missing and it should be reported.
                CSMap::CS_dtcls(datumConvert);
                fullPath->Destroy();
                datumConvert = NULL;
                if (verticalDatumConverter != nullptr)
                    delete verticalDatumConverter;
                return nullptr;
                }

            datumConvert->xforms[datumConvert->xfrmCount++] = newTransform;
            }

        fullPath->Destroy();
        // TODO Do we really allow vertical converter if no horizontal converter?
        if (nullptr != datumConvert || nullptr != verticalDatumConverter)
            return new DatumConverter(datumConvert, verticalDatumConverter);
        }

    return NULL;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumConverter::~DatumConverter
(
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return ;

    if (NULL != m_datumConvert)
        {
        CSMap::CS_dtcls (m_datumConvert);
        m_datumConvert = NULL;
        }
    if (NULL != m_verticalDatumConverter)
        {
        delete m_verticalDatumConverter;
        m_verticalDatumConverter = NULL;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            DatumConverter::Destroy () const { delete this; }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus DatumConverter::ConvertLatLong3D
(
GeoPointR   outLatLong,
GeoPointCR  inLatLong
) const
    {
    ReprojectStatus status = REPROJECT_Success;
    if (NULL != m_datumConvert)
        status = (ReprojectStatus) (*m_3dDatumConvertFunc) (m_datumConvert, &inLatLong, &outLatLong);
    else
        outLatLong = inLatLong;

    if (m_reprojectElevation && (NULL != m_verticalDatumConverter))
        {
        StatusInt verticalStatus;
        verticalStatus = m_verticalDatumConverter->ConvertElevation (outLatLong, inLatLong);

        // horizontal status has precedence
        if ((REPROJECT_Success == status) && (SUCCESS != verticalStatus))
            status = REPROJECT_CSMAPERR_VerticalDatumConversionError;
        }

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
ReprojectStatus DatumConverter::ConvertLatLong2D
(
GeoPoint2dR   outLatLong,
GeoPoint2dCR  inLatLong
) const
    {
    if (NULL == m_datumConvert)
        {
        // this is the case where we had to Create a non-null DatumConverter because of a vertical datum shift.
        outLatLong = inLatLong;
        return REPROJECT_Success;
        }

    GeoPoint inLatLong3d;
    inLatLong3d.Init (inLatLong.longitude, inLatLong.latitude, 0.0);

    GeoPoint outLatLong3d;
    ReprojectStatus status = (ReprojectStatus) CSMap::CS_dtcvt (m_datumConvert, &inLatLong3d, &outLatLong3d);
    outLatLong.Init (outLatLong3d.longitude, outLatLong3d.latitude);

    return status;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            DatumConverter::SetReprojectElevation   // <= returns old value.
(
bool            reprojectElevation
)
    {
    bool    wasReprojecting = m_reprojectElevation;

    m_reprojectElevation = reprojectElevation;

    if (m_reprojectElevation)
        {
        // TODO This prevents ellipsoid elevation changes from being applied.
        // Note that there is no vertical datum when ellipsoid to ellipsoid
        if ((NULL != m_verticalDatumConverter) && m_verticalDatumConverter->NeedsDatumElevationChange())
            m_3dDatumConvertFunc = CSMap::CS_dtcvt3D;
        else
            m_3dDatumConvertFunc = CSMap::CS_dtcvt;
        }
    else
        {
        m_3dDatumConvertFunc    = CSMap::CS_dtcvt;
        }

    return wasReprojecting;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            DatumConverter::GetReprojectElevation
(
) const
    {
    return m_reprojectElevation;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
size_t      DatumConverter::GetGeodeticTransformCount () const
    {
    if (NULL == m_datumConvert)
        return (size_t)0;

    return (size_t)m_datumConvert->xfrmCount;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformP   DatumConverter::GetGeodeticTransform (size_t index, bool* directApply) const
    {
    if (NULL == m_datumConvert)
        return NULL;

    if (index < 0 || index > (size_t)(m_datumConvert->xfrmCount - 1))
        return NULL;

    if (directApply != NULL)
        *directApply = (m_datumConvert->xforms[index]->userDirection == 1);

    GeodeticTransformDataAvailability dataAvailability = GeodeticTransformDataAvailability::DataAvailable;

    if (m_datumConvert->xforms[index]->methodCode == cs_DTCMTH_NONE)
        dataAvailability = GeodeticTransformDataAvailability::DataUnavailable;
    else if (m_datumConvert->xforms[index]->methodCode == cs_DTCMTH_SKIP)
        dataAvailability = GeodeticTransformDataAvailability::AvailabilityUnknown;

    return GeodeticTransform::CreateGeodeticTransform(
              m_datumConvert->xforms[index]->gxDef,
              dataAvailability);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   DatumConverter::IsNullTransform() const
    {
    if (NULL == m_datumConvert)
        return false;

    // Get rid of the vertical datum constraint
    if (m_reprojectElevation && (NULL != m_verticalDatumConverter) && !m_verticalDatumConverter->IsNullTransform())
        return false;

    bool nullTransform = false;

    bvector<GeodeticTransformP> listOfTransforms;

    if (SUCCESS == FillListOfTransformsFromCSDatumConvert(listOfTransforms, *(this->m_datumConvert)))
        nullTransform = RepresentsNullTransform(listOfTransforms);

    // Clean up
    for (auto transform : listOfTransforms)
        transform->Destroy();

    listOfTransforms.clear();

    return nullTransform;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   DatumConverter::IsEquivalent(DatumConverterCR compareTo, bool looselyCompare) const
    {
    if (NULL == m_datumConvert)
        return false;

    if (NULL == compareTo.m_datumConvert)
        return false;

    // If both are null transforms ... then that is it
    if (IsNullTransform() && compareTo.IsNullTransform())
        return true;

    // Get rid of the vertical datum constraint
    if (m_reprojectElevation != compareTo.m_reprojectElevation)
        return false;

    if (m_reprojectElevation && (NULL != m_verticalDatumConverter) &&
       (NULL != compareTo.m_verticalDatumConverter) && !m_verticalDatumConverter->IsEquivalent(*(compareTo.m_verticalDatumConverter)))
        return false;

    bool identical = false;

    bvector<GeodeticTransformP> listOfTransforms1;
    bvector<GeodeticTransformP> listOfTransforms2;

    if ((SUCCESS == FillListOfTransformsFromCSDatumConvert(listOfTransforms1, *(this->m_datumConvert))) && (SUCCESS == FillListOfTransformsFromCSDatumConvert(listOfTransforms2, *(compareTo.m_datumConvert))))
        identical = GeodeticTransformPathAreEquivalent(listOfTransforms1, listOfTransforms2, looselyCompare);

    // Clean up
    for (auto transform1 : listOfTransforms1)
        transform1->Destroy();
    for (auto transform2 : listOfTransforms2)
        transform2->Destroy();

    listOfTransforms1.clear();
    listOfTransforms2.clear();

    return identical;
    }

/*=================================================================================**//**
* Unit Class - exposes CSMap unit information
+===============+===============+===============+===============+===============+======*/
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
UnitCP          Unit::FindUnit (Utf8CP unitName)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    const struct cs_Unittab_   *pUnit;
    int                         index;
    for (index=0, pUnit = cs_Unittab; cs_UTYP_END != pUnit->type; pUnit++, index++)
        {
        if (0 == BeStringUtilities::Stricmp (unitName, pUnit->name))
            return new Unit (index);
        }

    return NULL;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Unit::Unit (int index)
    {
    if (!BaseGCS::IsLibraryInitialized())
        m_csUnit = NULL;
    else
        m_csUnit = &cs_Unittab[index];

    m_nameString            = NULL;
    m_pluralNameString      = NULL;
    m_abbreviationString    = NULL;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Unit::GetName() const
    {
    if (NULL == m_csUnit)
        return "";

    if (NULL == m_nameString)
        m_nameString = new Utf8String (m_csUnit->name);
    return m_nameString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Unit::GetPluralName() const
    {
    if (NULL == m_csUnit)
        return "";

    if (NULL == m_pluralNameString)
        m_pluralNameString = new Utf8String (m_csUnit->pluralName);
    return m_pluralNameString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Unit::GetAbbreviation() const
    {
    if (NULL == m_csUnit)
        return "";

    if (NULL == m_abbreviationString)
        m_abbreviationString = new Utf8String (m_csUnit->abrv);
    return m_abbreviationString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoUnitSystem       Unit::GetSystem() const
    {
    if (NULL == m_csUnit)
        return GeoUnitSystem::None;

    // make this line up with PP's definitions.
    if (cs_USYS_Metric == m_csUnit->system)
        return GeoUnitSystem::Metric;
    else if (cs_USYS_English == m_csUnit->system)
        return GeoUnitSystem::English;
    return GeoUnitSystem::None;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeoUnitBase     Unit::GetBase() const
    {
    if (NULL == m_csUnit)
        return GeoUnitBase::None;

    if (cs_UTYP_LEN == m_csUnit->type)
        return GeoUnitBase::Meter;
    else if (cs_UTYP_ANG == m_csUnit->type)
        return GeoUnitBase::Degree;
    return GeoUnitBase::None;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int   Unit::GetEPSGCode() const
    {
    if (NULL == m_csUnit)
        return 0;

    return m_csUnit->epsgCode;
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              Unit::GetConversionFactor() const
    {
    if (NULL == m_csUnit)
        return 1.0; // Return 1 instead of 0 in case invert is performed without checking

    return m_csUnit->factor;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Unit::~Unit ()
    {
    DELETE_AND_CLEAR (m_nameString);
    DELETE_AND_CLEAR (m_pluralNameString);
    DELETE_AND_CLEAR (m_abbreviationString);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            Unit::Destroy () const { delete this; }

/*=================================================================================**//**
* UnitEnumerator Class
+===============+===============+===============+===============+===============+======*/
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
UnitEnumerator::UnitEnumerator () {m_currentIndex = -1;}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool                UnitEnumerator::MoveNext ()
    {
    if (!BaseGCS::IsLibraryInitialized())
        return false;

    if (m_currentIndex < -1)
        return false;

    m_currentIndex++;
    if ( (cs_UTYP_END != cs_Unittab[m_currentIndex].type) && (cs_UTYP_OFF != cs_Unittab[m_currentIndex].type) )
        return true;

    // set up for repeated failures.
    m_currentIndex = -2;
    return false;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
UnitCP              UnitEnumerator::GetCurrent()
    {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    if (m_currentIndex < 0)
        return NULL;

    return new Unit(m_currentIndex);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
UnitEnumerator::~UnitEnumerator() {}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            UnitEnumerator::Destroy () const { delete this; }

/*=================================================================================**//**
* EllipsoidEnumerator Class
+===============+===============+===============+===============+===============+======*/
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidEnumerator::EllipsoidEnumerator ()
{
m_currentIndex              = -1;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool                EllipsoidEnumerator::MoveNext ()
    {
    if (!BaseGCS::IsLibraryInitialized())
        return false;

    if (m_currentIndex < -1)
        return false;

    m_currentIndex++;

    char    ellipsoidName[512];
    if (1 == CS_elEnum (m_currentIndex, ellipsoidName, _countof (ellipsoidName)))
        {
        m_currentEllipsoidName = ellipsoidName;
        return true;
        }

    // set up for repeated failures.
    m_currentEllipsoidName.clear();
    m_currentIndex = -2;
    return false;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidCP         EllipsoidEnumerator::GetCurrent()
    {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    if (m_currentIndex < 0)
        return NULL;

    return Ellipsoid::CreateEllipsoid (m_currentEllipsoidName.c_str());
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidEnumerator::~EllipsoidEnumerator() {}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            EllipsoidEnumerator::Destroy () const { delete this; }

/*=================================================================================**//**
* Ellipsoid Class
+===============+===============+===============+===============+===============+======*/
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidEnumeratorP  Ellipsoid::CreateEnumerator ()
    {
    return new EllipsoidEnumerator();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidP             Ellipsoid::CreateEllipsoid ()
    {
    return new Ellipsoid ();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidCP           Ellipsoid::CreateEllipsoid (Utf8CP keyName)
    {
    return new Ellipsoid (keyName);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidCP           Ellipsoid::CreateEllipsoid (EllipsoidCR source)
    {
    return new Ellipsoid (source);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidCP           Ellipsoid::CreateEllipsoid (const CSEllipsoidDef& ellipsoidDef)
    {
    return new Ellipsoid (ellipsoidDef);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Ellipsoid::Ellipsoid ()
    {
    m_csError = 0;
    if (!BaseGCS::IsLibraryInitialized())
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;

    m_ellipsoidDef = (CSEllipsoidDef*)CS_malc(sizeof(CSEllipsoidDef));
    memset(m_ellipsoidDef, 0, sizeof(CSEllipsoidDef));

    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Ellipsoid::Ellipsoid (Utf8CP keyName)
    {
    m_ellipsoidDef      = NULL;
    m_nameString        = NULL;
    m_descriptionString = NULL;

    if (!BaseGCS::IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return;
        }

    m_ellipsoidDef = CSMap::CS_eldef (keyName);

    m_csError = (NULL != m_ellipsoidDef) ? 0 : cs_Error;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Ellipsoid::Ellipsoid (EllipsoidCR source)
    {
    m_ellipsoidDef      = NULL;
    m_nameString        = NULL;
    m_descriptionString = NULL;

    if (!BaseGCS::IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        return;
        }

    if (NULL == source.m_ellipsoidDef)
        {
        m_ellipsoidDef = NULL;
        m_csError = source.m_csError;
        }
    else
        {
        m_ellipsoidDef  = (CSEllipsoidDef*) CS_malc (sizeof(CSEllipsoidDef));
        memcpy (m_ellipsoidDef, source.m_ellipsoidDef, sizeof (CSEllipsoidDef));
        m_csError = source.m_csError;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Ellipsoid::Ellipsoid (const CSEllipsoidDef &ellipsoidDef)
    {
    m_ellipsoidDef  = (CSEllipsoidDef*) CS_malc (sizeof (CSEllipsoidDef));
    memcpy (m_ellipsoidDef, &ellipsoidDef, sizeof(CSEllipsoidDef));
    m_csError       = 0;

    m_nameString        = NULL;
    m_descriptionString = NULL;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidP          Ellipsoid::Clone () const
    {
    if (NULL == m_ellipsoidDef)
        return NULL;

    return const_cast <EllipsoidP> (CreateEllipsoid (*m_ellipsoidDef));
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool                Ellipsoid::IsValid () const
    {
    return  NULL != m_ellipsoidDef;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int                 Ellipsoid::GetError () const
    {
    return m_csError;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Ellipsoid::GetErrorMessage (Utf8StringR errorMsg) const
    {
    if (!BaseGCS::IsLibraryInitialized())
        return errorMsg.c_str();

    char    csErrorMsg[512];
    CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
    errorMsg = csErrorMsg;
    return errorMsg.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Ellipsoid::GetName() const
    {
    if (NULL == m_ellipsoidDef)
        return "";

    if (NULL == m_nameString)
        m_nameString = new Utf8String (m_ellipsoidDef->key_nm);

    return m_nameString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Ellipsoid::SetName (Utf8CP value)
    {
    if (NULL == m_ellipsoidDef)
        return GEOCOORDERR_InvalidEllipsoid;

    Utf8String mbName (value);
    if (mbName.length() >= _countof (m_ellipsoidDef->key_nm))
        return GEOCOORDERR_StringTooLong;

    char    copy[1024];
    CS_stncp (copy, mbName.c_str(), _countof (copy));
    if (0 != CS_nampp (copy))
        return GEOCOORDERR_CoordSysIllegalName;

    CS_stncp (m_ellipsoidDef->key_nm, mbName.c_str(), _countof (m_ellipsoidDef->key_nm));
    m_ellipsoidDef->epsgNbr = 0;

    DELETE_AND_CLEAR (m_nameString);

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Ellipsoid::GetDescription() const
    {
    if (NULL == m_ellipsoidDef)
        return "";

    if (NULL == m_descriptionString)
        m_descriptionString = new Utf8String (m_ellipsoidDef->name);

    return m_descriptionString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Ellipsoid::SetDescription (Utf8CP value)
    {
    if (NULL == m_ellipsoidDef)
        return GEOCOORDERR_InvalidEllipsoid;

    Utf8String mbDescription (value);

    if (mbDescription.length() >= _countof (m_ellipsoidDef->name))
        return GEOCOORDERR_StringTooLong;

    CS_stncp (m_ellipsoidDef->name, mbDescription.c_str(), _countof(m_ellipsoidDef->name));

    DELETE_AND_CLEAR (m_descriptionString);

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Ellipsoid::GetSource (Utf8StringR source) const
    {
    source.clear();
    if (NULL != m_ellipsoidDef)
        source = m_ellipsoidDef->source;

    return source.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Ellipsoid::SetSource (Utf8CP value)
    {
    if (NULL == m_ellipsoidDef)
        return GEOCOORDERR_InvalidEllipsoid;

    Utf8String mbSource (value);
    if (mbSource.length() >= _countof (m_ellipsoidDef->source))
        return GEOCOORDERR_StringTooLong;

    CS_stncp (m_ellipsoidDef->source, mbSource.c_str(), _countof(m_ellipsoidDef->source));

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt Ellipsoid::FromJson(BeJsConst jsonValue, Utf8StringR errorMessage) {
    StatusInt result = SUCCESS;

    Clear();

    // Error processing lambda definitions
    auto BadProperty = [&errorMessage](Utf8CP name, StatusInt status = GEOCOORDERR_BadArg) {
        errorMessage.Sprintf("'%s' is invalid", name);
        return status;
    };

    auto MissingProperty = [&errorMessage](Utf8CP name) {
        errorMessage.Sprintf("'%s' is missing", name);
        return GEOCOORDERR_MissingPropertyOrParameter;
    };

    // TODO name property would contain the name for user-defined GCS, Datum, Ellipsoid
    // if (!jsonValue["name"].isNull())
    //    m_label = jsonValue["name"].asString();

    // We first try using the keyname
    // If we were sucessful then we do not validate the definition is similar.
    if (!jsonValue["id"].isNull()) {
        // The identifier is present ... we will try to locate it in the system dictionary
        CSEllipsoidDef* newEllipsoidDef;
        if (NULL != (newEllipsoidDef = CSMap::CS_eldef(jsonValue["id"].asString().c_str()))) {
            if (NULL != m_ellipsoidDef)
                CSMAP_FREE_AND_CLEAR(m_ellipsoidDef);

            m_ellipsoidDef = newEllipsoidDef;

            return SUCCESS;
        }
    }

    if (NULL == m_ellipsoidDef) // Allocate structure if required
        m_ellipsoidDef = (CSEllipsoidDef*)CS_malc(sizeof(CSEllipsoidDef));

    // Clear parameters
    memset(m_ellipsoidDef, 0, sizeof(CSEllipsoidDef));

    Utf8String name;
    if (!jsonValue["id"].isNull())
        name = jsonValue["id"].asString();

    SetName(name.c_str());

    if (!jsonValue["description"].isNull())
        SetDescription(jsonValue["description"].asString().c_str());

    if (!jsonValue["source"].isNull())
        SetSource(jsonValue["source"].asString().c_str());

    if (!jsonValue["epsg"].isNull()) {
        int epsgCode = jsonValue["epsg"].asInt();
        if (0 > epsgCode || 32768 < epsgCode)
            return BadProperty("epsg");
        SetEPSGCode((short)epsgCode);
    }

    if (!jsonValue["deprecated"].isNull() && (jsonValue["deprecated"].asBool() == true))
        SetGroup("LEGACY");
    else
        SetGroup("NONE");

    if (jsonValue["equatorialRadius"].isNull())
        return MissingProperty("equatorialRadius");

    if (SUCCESS != (result = SetEquatorialRadius(jsonValue["equatorialRadius"].asDouble())))
        return BadProperty("equatorialRadius", result);

    if (jsonValue["polarRadius"].isNull())
        return MissingProperty("polarRadius");

    if (SUCCESS != (result = SetPolarRadius(jsonValue["polarRadius"].asDouble())))
        return BadProperty("polarRadius", result);

    return result;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt         Ellipsoid::ToJson(BeJsValue jsonValue, bool shortForm) const
    {
    if (NULL == m_ellipsoidDef)
        return GEOCOORDERR_InvalidEllipsoid;

    Utf8String sourceString;

    // TODO name property would contain the name for user-defined GCS, Datum, Ellipsoid
    // if (m_label.size() > 0)
    //    jsonValue["name"] = Utf8String(m_label.c_str());

    jsonValue["id"] = Utf8String(GetName());

    if (!shortForm)
        {
        jsonValue["description"] = Utf8String(GetDescription());
        jsonValue["source"] = Utf8String(GetSource(sourceString));
        int theEPSGCode = GetEPSGCode();
        if (theEPSGCode > 0)
            jsonValue["epsg"] = theEPSGCode;

        if (IsDeprecated())   // Default is false
            jsonValue["deprecated"] = true;
        }

    jsonValue["equatorialRadius"] = GetEquatorialRadius();
    jsonValue["polarRadius"] = GetPolarRadius();

    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP    Ellipsoid::GetGroup (Utf8StringR groupName) const
    {
    groupName.clear();

    if (NULL != m_ellipsoidDef)
        groupName = m_ellipsoidDef->group;

    return groupName.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt    Ellipsoid::SetGroup (Utf8StringCR groupName)
    {
    if (NULL == m_ellipsoidDef)
        return GEOCOORDERR_InvalidEllipsoid;

    // Check size (5 chars max for ellipsoid groups)
    if (groupName.size() >= DIM(m_ellipsoidDef->group))
        return GEOCOORDERR_BadArg;

    CSMap::CS_stncp (m_ellipsoidDef->group, groupName.c_str(), DIM(m_ellipsoidDef->group));

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool  Ellipsoid::IsDeprecated() const
    {
    // Ellipsoid groups are only 5 character long so we use shorted flag
    static Utf8String deprecated("LEGAC");

    if (NULL == m_ellipsoidDef)
        return false;

    Utf8String groupName;

    return (0 == deprecated.CompareTo(GetGroup(groupName)));
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              Ellipsoid::GetPolarRadius() const
    {
    return (NULL == m_ellipsoidDef) ? 0.0 : m_ellipsoidDef->p_rad;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Ellipsoid::SetPolarRadius (double value)
    {
    if (NULL == m_ellipsoidDef)
        return GEOCOORDERR_InvalidEllipsoid;

    // Validate allowed values (100 meters to 70 million meters)
    if (100 > value || 70000000 < value)
        return GEOCOORDERR_BadArg;

    m_ellipsoidDef->p_rad = value;
    CalculateParameters (m_ellipsoidDef->flat, m_ellipsoidDef->ecent, m_ellipsoidDef->e_rad, m_ellipsoidDef->p_rad);
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              Ellipsoid::GetEquatorialRadius() const
    {
    return (NULL == m_ellipsoidDef) ? 0.0 : m_ellipsoidDef->e_rad;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt                Ellipsoid::SetEquatorialRadius (double value)
    {
    if (NULL == m_ellipsoidDef)
        return GEOCOORDERR_InvalidEllipsoid;

    // Validate allowed values (100 meters to 70 million meters)
    if (100 > value || 70000000 < value)
        return GEOCOORDERR_BadArg;

    m_ellipsoidDef->e_rad = value;
    CalculateParameters (m_ellipsoidDef->flat, m_ellipsoidDef->ecent, m_ellipsoidDef->e_rad, m_ellipsoidDef->p_rad);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              Ellipsoid::GetEccentricity() const
    {
    return (NULL == m_ellipsoidDef) ? 0.0 : m_ellipsoidDef->ecent;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int                 Ellipsoid::GetEPSGCode() const
    {
    return (NULL == m_ellipsoidDef) ? 0 : m_ellipsoidDef->epsgNbr;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Ellipsoid::SetEPSGCode (short value)
    {
    if (NULL == m_ellipsoidDef)
        return GEOCOORDERR_InvalidEllipsoid;

    // Make sure value is not negative
    if (value < 0)
        return GEOCOORDERR_BadArg;

    m_ellipsoidDef->epsgNbr = value;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            Ellipsoid::IsEquivalent (EllipsoidCR compareTo) const
    {
    if (NULL == m_ellipsoidDef)
        return false;

    if (NULL == compareTo.m_ellipsoidDef)
        return false;

    if (!distanceSame(m_ellipsoidDef->e_rad, compareTo.m_ellipsoidDef->e_rad))
        return false;

    if (!distanceSame(m_ellipsoidDef->p_rad, compareTo.m_ellipsoidDef->p_rad))
        return false;

    return true;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
CSEllipsoidDef*                Ellipsoid::GetCSEllipsoidDef () const
    {
    return m_ellipsoidDef;
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            Ellipsoid::CalculateParameters (double& flattening, double& eccentricity, double equatorialRadius, double polarRadius)
    {
    if (0.0 == equatorialRadius)
        return false;

    flattening = (equatorialRadius - polarRadius) / equatorialRadius;
    eccentricity = sqrt (2.0 * flattening - (flattening * flattening));

    return true;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Ellipsoid::~Ellipsoid()
    {
    Clear();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            Ellipsoid::Destroy () const { delete this; }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void Ellipsoid::Clear()
    {
    if (nullptr != m_nameString)
        delete m_nameString;
    m_nameString = nullptr;

    if (nullptr != m_descriptionString)
        delete m_descriptionString;
    m_descriptionString = nullptr;

    CSMAP_FREE_AND_CLEAR (m_ellipsoidDef);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void Ellipsoid::AllocateClean()
    {
    Clear();

    if (NULL == m_ellipsoidDef)
        m_ellipsoidDef = (CSEllipsoidDef*)CS_malc(sizeof(CSEllipsoidDef));

    // Clear parameters
    memset(m_ellipsoidDef, 0, sizeof(CSEllipsoidDef));
    }

#ifdef DICTIONARY_MANAGEMENT_ONLY // Used for internal dictionary management only
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt Ellipsoid::OutputAsASC
(
Utf8StringR            EllipsoidAsASC      // The ASC Text
) const
    {
    if (NULL == m_ellipsoidDef)
        return GEOCOORDERR_InvalidEllipsoid;

    StatusInt       status = SUCCESS;

    std::ostringstream EllipsoidAsASCStream(EllipsoidAsASC);

    if (!IsValid())
        return ERROR;

    EllipsoidAsASCStream << "EL_NAME: " <<  m_ellipsoidDef->key_nm << std::endl
             << "        DESC_NM: " <<  m_ellipsoidDef->name << std::endl
             <<"         SOURCE: " << m_ellipsoidDef->source << std::endl
             <<"          E_RAD: " << m_ellipsoidDef->e_rad << std::endl
             <<"          P_RAD: " << m_ellipsoidDef->p_rad << std::endl
             << std::endl;

    EllipsoidAsASC = EllipsoidAsASCStream.str();

    return status;
    }
#endif

/*=================================================================================**//**
* DatumEnumerator Class
+===============+===============+===============+===============+===============+======*/
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumEnumerator::DatumEnumerator ()
{
m_currentIndex  = -1;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool                DatumEnumerator::MoveNext ()
    {
    if (!BaseGCS::IsLibraryInitialized())
        return false;

    if (m_currentIndex < -1)
        return false;

    m_currentIndex++;

    char    datumName[512];
    if (1 == CSMap::CS_dtEnum (m_currentIndex, datumName, _countof (datumName)))
        {
        m_currentDatumName = datumName;
        return true;
        }

    // set up for repeated failures.
    m_currentIndex = -2;
    m_currentDatumName.clear();
    return false;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumCP             DatumEnumerator::GetCurrent()
    {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    for (;;)
        {
        if (m_currentIndex < 0)
            return NULL;

        // don't return invalid datum.
        DatumCP datum = Datum::CreateDatum (m_currentDatumName.c_str());
        if (datum->IsValid())
            return datum;

        datum->Destroy();

        if (!MoveNext())
            return NULL;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumEnumerator::~DatumEnumerator() {}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            DatumEnumerator::Destroy () const { delete this; }

/*=================================================================================**//**
* Datum Class
+===============+===============+===============+===============+===============+======*/
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumEnumeratorP  Datum::CreateEnumerator ()
    {
    return new DatumEnumerator();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumP  Datum::CreateDatum ()
    {
    return new Datum ();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumCP             Datum::CreateDatum (Utf8CP keyName)
    {
    return new Datum (keyName);
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumCP             Datum::CreateDatumFromEPSGCode (int epsgCode)
    {
    return new Datum (epsgCode);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Datum::Datum (int epsgCode)
    {
    m_datumDef = NULL;
    if (!BaseGCS::IsLibraryInitialized())
        {
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        }
    else
        {
        CSDatumDef* datumDef;
        int         index;
        char        dtKeyName[128];
        for (index = 0; (0 < CSMap::CS_dtEnum (index, dtKeyName, sizeof(dtKeyName))); index++)
            {
            if (NULL != (datumDef = CSMap::CS_dtdef (dtKeyName)))
                {
                if (epsgCode == datumDef->epsgNbr)
                    {
                    m_datumDef = datumDef;
                    break;
                    }

                CSMAP_FREE_AND_CLEAR (datumDef);
                }
            }

          m_csError          = (NULL != m_datumDef) ? 0 : cs_Error;
          }

    m_csDatum                    = NULL;
    m_ellipsoid                  = NULL;
    m_customEllipsoid            = false;
    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    m_ellipsoidNameString        = NULL;
    m_ellipsoidDescriptionString = NULL;
    m_listOfTransformsToWgs84    = NULL;
    m_listOfSetTransforms        = NULL;
    m_listOfAdditionalPathsBuilt = false;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Datum::Datum ()
    {
    m_csError = 0;
    if (!BaseGCS::IsLibraryInitialized())
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;

    m_datumDef = (CSDatumDef*)CS_malc(sizeof(CSDatumDef));

    if (nullptr == m_datumDef)
    {
        m_csError = -1;
        return;
    }

    memset(m_datumDef, 0, sizeof(CSDatumDef));

    m_csDatum                    = NULL;
    m_ellipsoid                  = NULL;
    m_customEllipsoid            = false;
    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    m_ellipsoidNameString        = NULL;
    m_ellipsoidDescriptionString = NULL;
    m_listOfTransformsToWgs84    = NULL;
    m_listOfSetTransforms        = NULL;
    m_listOfAdditionalPathsBuilt = false;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Datum::Datum (Utf8CP keyName)
    {
    if (!BaseGCS::IsLibraryInitialized())
        {
        m_datumDef = NULL;
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        }
    else
        {
        m_datumDef         = CSMap::CS_dtdef (keyName);
        m_csError          = (NULL != m_datumDef) ? 0 : cs_Error;
        }

    m_csDatum                    = NULL;
    m_ellipsoid                  = NULL;
    m_customEllipsoid            = false;
    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    m_ellipsoidNameString        = NULL;
    m_ellipsoidDescriptionString = NULL;
    m_listOfTransformsToWgs84    = NULL;
    m_listOfSetTransforms        = NULL;
    m_listOfAdditionalPathsBuilt = false;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumCP Datum::CreateDatum(CSDatumDef const& datumDef, CSGeodeticTransformDef const* geodeticTransform) {
    return new Datum (datumDef, geodeticTransform);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Datum::Datum(CSDatumDef const& datumDef, CSGeodeticTransformDef const* geodeticTransform) {
    if (!BaseGCS::IsLibraryInitialized())
        {
        m_datumDef = NULL;
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        }
    else
        {
        m_datumDef                   = (CSDatumDef*) CS_malc (sizeof (CSDatumDef));
        memcpy (m_datumDef, &datumDef, sizeof(CSDatumDef));
        m_csError                    = 0;
        }


    m_csDatum                    = NULL;
    m_ellipsoid                  = NULL;
    m_customEllipsoid            = false;
    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    m_ellipsoidNameString        = NULL;
    m_ellipsoidDescriptionString = NULL;
    m_listOfTransformsToWgs84    = NULL;
    m_listOfSetTransforms        = NULL;
    m_listOfAdditionalPathsBuilt = false;

    if (nullptr != geodeticTransform)
        {
        GeodeticTransform* baseTransform = GeodeticTransform::CreateGeodeticTransform(*geodeticTransform, GeodeticTransformDataAvailability::AvailabilityUnknown);
        if (nullptr != baseTransform)
            {
            GeodeticTransformPathP transformPath = GeodeticTransformPath::Create();
            transformPath->AddGeodeticTransform(baseTransform);
            SetStoredGeodeticTransformPath(transformPath);
            }
        }
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumCP Datum::CreateDatum(CSDatum const& datum, CSGeodeticTransformDef const* geodeticTransform) {
        return new Datum(datum, geodeticTransform);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Datum::Datum (CSDatum const& datum, CSGeodeticTransformDef const* geodeticTransform)
    {
    m_csDatum                    = NULL;
    m_ellipsoid                  = NULL;
    m_customEllipsoid            = false;
    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    m_ellipsoidNameString        = NULL;
    m_ellipsoidDescriptionString = NULL;
    m_listOfTransformsToWgs84    = NULL;
    m_listOfSetTransforms        = NULL;
    m_listOfAdditionalPathsBuilt = false;

    if (!BaseGCS::IsLibraryInitialized())
        {
        m_datumDef = NULL;
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        }
    else
        {
        m_datumDef                   = (CSDatumDef*) CS_malc (sizeof (CSDatumDef));
        memset(m_datumDef, 0, sizeof(CSDatumDef));
        CSMap::CS_stncp(m_datumDef->key_nm, datum.key_nm, DIM(m_datumDef->key_nm));
        CSMap::CS_stncp(m_datumDef->ell_knm, datum.ell_knm, DIM(m_datumDef->ell_knm));
        m_datumDef->delta_X = datum.delta_X;
        m_datumDef->delta_Y = datum.delta_Y;
        m_datumDef->delta_Z = datum.delta_Z;
        m_datumDef->rot_X = datum.rot_X;
        m_datumDef->rot_Y = datum.rot_Y;
        m_datumDef->rot_Z = datum.rot_Z;
        m_datumDef->bwscale = datum.bwscale;
        CSMap::CS_stncp(m_datumDef->name, datum.dt_name, DIM(m_datumDef->name));
        m_datumDef->to84_via = datum.to84_via;

        // Check if ellipsoid is accessible?
        CSEllipsoidDef* ellipsoidDef = nullptr;
        if (NULL == (ellipsoidDef = CSMap::CS_eldef (datum.ell_knm)))
            {
            // The ellipsoid is not in system library ... we must create a custom one
            Ellipsoid* tempEllipsoid = const_cast<Ellipsoid*>(Ellipsoid::CreateEllipsoid());
            tempEllipsoid->SetName(datum.ell_knm);
            tempEllipsoid->SetDescription(datum.el_name);

            tempEllipsoid->SetPolarRadius(datum.p_rad);
            tempEllipsoid->SetEquatorialRadius(datum.e_rad);
            tempEllipsoid->SetGroup("");
            tempEllipsoid->SetSource("");
            tempEllipsoid->SetEPSGCode(0);
            m_ellipsoid = tempEllipsoid;
            m_customEllipsoid = true;
            }
        else
            {
            CSMAP_FREE_AND_CLEAR (ellipsoidDef);
            }
        m_csError                    = 0;
        }

    if (nullptr != geodeticTransform)
        {
        GeodeticTransform* baseTransform = GeodeticTransform::CreateGeodeticTransform(*geodeticTransform, GeodeticTransformDataAvailability::AvailabilityUnknown);
        if (nullptr != baseTransform)
            {
            GeodeticTransformPathP transformPath = GeodeticTransformPath::Create();
            transformPath->AddGeodeticTransform(baseTransform);
            SetStoredGeodeticTransformPath(transformPath);
            }
        }
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
DatumP Datum::Clone() const {
    if (NULL == m_datumDef)
        return NULL;

    DatumP cloned = const_cast<DatumP>(CreateDatum(*m_datumDef, nullptr));

    if (m_customEllipsoid)
        cloned->SetEllipsoid(m_ellipsoid->Clone());

    if (nullptr != m_listOfSetTransforms)
        cloned->SetStoredGeodeticTransformPath(m_listOfSetTransforms->Clone());

    return cloned;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt Datum::FromJson(BeJsConst jsonValue, Utf8StringR errorMessage) {
    StatusInt status;

    // Error processing lambda definitions
    auto BadProperty = [&errorMessage](Utf8CP name, StatusInt status = GEOCOORDERR_BadArg) {
        errorMessage.Sprintf("'%s' is invalid", name);
        return status;
    };

    auto BadArg = [&errorMessage](Utf8CP message) {
        errorMessage = message;
        return GEOCOORDERR_BadArg;
    };

    Clear();

    // TODO name property would contain the name for user-defined GCS, Datum, Ellipsoid
    // if (!jsonValue["name"].isNull())
    //     m_label = jsonValue["name"].asString();

    // We first try using the keyname
    // If we were successful then we do not we validate the definition is similar.
    if (!jsonValue["id"].isNull())
        {
        // The identifier is present ... we will try to locate it in the system dictionary
        CSDatumDef*                 newDatumDef;
        if (NULL != (newDatumDef = CSMap::CS_dtdef(jsonValue["id"].asString().c_str())))
            {
            if (NULL != m_datumDef)
                CSMAP_FREE_AND_CLEAR(m_datumDef);
            m_datumDef = newDatumDef;
            return SUCCESS;
            }

        }

    if (NULL == m_datumDef) // Allocate structure if required
        m_datumDef = (CSDatumDef*) CS_malc (sizeof (CSDatumDef));

    memset(m_datumDef, 0, sizeof(CSDatumDef));

    Utf8String name;
    if (!jsonValue["id"].isNull())
        name = jsonValue["id"].asString();

    SetName(name.c_str());

    if (!jsonValue["description"].isNull())
        SetDescription(jsonValue["description"].asString().c_str());

    if (!jsonValue["source"].isNull())
        SetSource(jsonValue["source"].asString().c_str());

    if (!jsonValue["epsg"].isNull())
        {
        int epsgCode = jsonValue["epsg"].asInt();
        if (0 > epsgCode || 32767 < epsgCode)
            return BadProperty("epsg");

        SetEPSGCode((short)epsgCode);
        }

    if (!jsonValue["deprecated"].isNull() && (jsonValue["deprecated"].asBool() == true))
        SetGroup("LEGACY");
    else
        SetGroup("NONE");

    int ellipsoidCode = -1;

    // Try ellipsoid id first
    if (!jsonValue["ellipsoidId"].isNull())
        {
        ellipsoidCode = FindEllipsoidIndex(jsonValue["ellipsoidId"].asString().c_str());

        Utf8String searchName = jsonValue["ellipsoidId"].asString();
        }

    // If there is no ellipsoid try full ellipsoid definition
    if ((ellipsoidCode < 0) && !jsonValue["ellipsoid"].isNull())
        {
        auto theEllipsoid = jsonValue["ellipsoid"];

        if (!theEllipsoid["id"].isNull())
            ellipsoidCode = FindEllipsoidIndex(theEllipsoid["id"].asString().c_str());

        if (ellipsoidCode < 0)
            {
            // Last chance is for the ellipsoid to be fully custom
            EllipsoidP customEllipsoid = Ellipsoid::CreateEllipsoid();
            if (SUCCESS != (status = customEllipsoid->FromJson(theEllipsoid, errorMessage)))
                {
                // Could not obtain a custom made ellipsoid ...
                customEllipsoid->Destroy();
                return BadProperty("ellipsoid");
                }

            // Set the self-defined fully custom ellipsoid
            SetEllipsoid(customEllipsoid);
            }
        else
            SetEllipsoidCode(ellipsoidCode);
        }
    else
        SetEllipsoidCode(ellipsoidCode);

    // Default transform is Geocentric with all zero values
    SetConvertToWGS84MethodCode(ConvertType_GEOCTR);
    DPoint3d delta;
    delta.Init(0.0, 0.0, 0.0);
    SetDelta(delta);
    DPoint3d rotation;
    rotation.Init(0.0, 0.0, 0.0);
    SetRotation(rotation);
    SetScale(0.0); // Not really a scale ... divergence from 1.0 only

    // If there is a single transform and it is storable in the datum then we extract it.
    if (!jsonValue["transforms"].isNull())
        {
        auto transformsValue = jsonValue["transforms"];

        // Add all transforms to datum
        GeodeticTransformPathP transformPath = GeodeticTransformPath::Create();

        for (unsigned int index = 0; index < transformsValue.size() && !transformsValue[index].isNull() ; index++)
            {
            GeodeticTransform* theTransform2 = GeodeticTransform::CreateGeodeticTransform();
            if (nullptr == theTransform2)
                return BadArg("Bad Transform");

            if (SUCCESS != (status = theTransform2->FromJson(transformsValue[index], errorMessage)))
                return status;

            transformPath->AddGeodeticTransform(theTransform2);
            }

        if (transformPath->GetGeodeticTransformCount() > 0)
            {
            // We set the final target name to WGS84 if not set (if set we assume WGS84 or an equivalent datum)
            if (Utf8String(transformPath->GetTargetDatumName()) == "")
                transformPath->GetGeodeticTransform(transformPath->GetGeodeticTransformCount() - 1)->SetTargetDatumName("WGS84");
            else if (Utf8String(transformPath->GetTargetDatumName()) != "WGS84")
                {
                // When the last is not WGS84 then it must be a known equivalent.
                DatumCP targetDatum = Datum::CreateDatum(transformPath->GetTargetDatumName());
                if (nullptr != targetDatum && targetDatum->IsValid())
                    {
                    // Target datum is known ...we just get rid of it.
                    if (nullptr != targetDatum)
                        targetDatum->Destroy();
                    }
                else
                    {
                    if (nullptr != targetDatum)
                        targetDatum->Destroy();

                    // Target datum is unknown (assumed equivalent to WGS84) ... we add a neutral step
                    GeodeticTransformP neutralTransform = GeodeticTransform::CreateGeodeticTransform();
                    neutralTransform->SetSourceDatumName(transformPath->GetTargetDatumName());
                    neutralTransform->SetTargetDatumName("WGS84");
                    neutralTransform->SetConvertMethodCode(GenConvertCode::GenConvertType_NONE);
                    transformPath->AddGeodeticTransform(neutralTransform);
                    }
                }
            // Then set the final path in Datum.
            SetStoredGeodeticTransformPath(transformPath);
            }
        else
            transformPath->Destroy();
        }

    if (!jsonValue["additionalTransformPaths"].isNull())
        {
        auto transformPathsValue = jsonValue["additionalTransformPaths"];

        // Add all additional transform paths to datum
        for (unsigned int index = 0; index < transformPathsValue.size() && !transformPathsValue[index].isNull() ; index++)
            {
            GeodeticTransformPathP transformPath = GeodeticTransformPath::Create();

            if (nullptr == transformPath)
                return BadArg("Bad Path");

            if (SUCCESS != (status = transformPath->FromJson(transformPathsValue[index], errorMessage)))
                return status;

            AddAdditionalGeodeticTransformPath(transformPath);
            }
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt         Datum::ToJson(BeJsValue jsonValue, bool expandEllipsoid, bool includeDeprecatedAdditionals) const
    {
    Utf8String errorMessage = "";

    // Error processing lambda definitions
    auto BadProperty = [&errorMessage](Utf8CP name, StatusInt status = GEOCOORDERR_BadArg)
        {
        errorMessage.Sprintf("'%s' is invalid", name);
        return status;
        };

    StatusInt result = SUCCESS;

    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    Utf8String sourceString;

    // TODO name property would contain the name for user-defined GCS, Datum, Ellipsoid
    // if (m_label.size() > 0)
    //     jsonValue["name"] = Utf8String(m_id.c_str());

    jsonValue["id"] = Utf8String(GetName());
    jsonValue["description"] = Utf8String(GetDescription());
    jsonValue["source"] = Utf8String(GetSource(sourceString));

    int theEPSGCode = GetEPSGCode();
    if (theEPSGCode > 0) // Zero value indicates no EPSG code ... we simply not set.
        jsonValue["epsg"] = theEPSGCode;

    if (IsDeprecated())   // Default is false;
        jsonValue["deprecated"] = true;

    jsonValue["ellipsoidId"] = Utf8String(GetEllipsoidName());

    EllipsoidCP theEllipsoid = Ellipsoid::CreateEllipsoid(GetEllipsoidName());

    if (theEllipsoid != nullptr)
        {
        if (expandEllipsoid)
            result = theEllipsoid->ToJson(jsonValue["ellipsoid"]);
        theEllipsoid->Destroy();
        if (SUCCESS != result)
            return BadProperty("Ellipsoid", result);
        }
    else
        return ERROR;

    // Now we need to obtain the geodetic transformation to WGS84
    static DatumCP wgs84Datum = Datum::CreateDatum("WGS84");

    if (wgs84Datum == nullptr)
        return ERROR;

    // Create a datum converter to LL84 and extract non-null transformations
    GeodeticTransformPath* transformPath = GeodeticTransformPath::Create(*this, *wgs84Datum);
    if (transformPath == nullptr)
        return ERROR;

    int indexTransforms = 0;
    BeJsValue geodeticTransformsArrayVal(jsonValue["transforms"]);
    geodeticTransformsArrayVal.toArray();

    for (size_t index = 0; index < transformPath->GetGeodeticTransformCount(); index++)
        {
        GeodeticTransformCP geodeticTransform = transformPath->GetGeodeticTransform(index);

        if (geodeticTransform != nullptr)
            {
            if (!geodeticTransform->IsNullTransform())
                {
                BeJsValue geodeticTransformVal(geodeticTransformsArrayVal[indexTransforms]);

                if (SUCCESS != (result = geodeticTransform->ToJson(geodeticTransformVal)))
                    {
                    transformPath->Destroy();
                    return BadProperty("GeodeticTransform", result);
                    }

                indexTransforms++;
                }
            }
        }
    transformPath->Destroy();


    // If there were no transform we add a NONE to indicate conversion is null (same as WGS84)
    // An empty list of transform is interpreted as transform undefined (which is different than no transform)
    if (indexTransforms == 0)
        {
        BeJsValue nullTrfVal(geodeticTransformsArrayVal[0]);
        nullTrfVal["method"] = "None";
        }

    // Process additional paths ... for those we only dump paths to non-deprecated datum except if self
    // is deprecated.
    int indexPaths = 0;
    if (GetAdditionalGeodeticTransformPaths().size() > 0)
        {
        BeJsValue geodeticAdditionalTransformPathsArrayVal(jsonValue["additionalTransformPaths"]);
        geodeticAdditionalTransformPathsArrayVal.toArray();

        bvector<GeodeticTransformPathCP> const & additionalPaths = GetAdditionalGeodeticTransformPaths();

        for (auto currentPath : additionalPaths)
            {
            if (currentPath != nullptr)
                {
                if (!IsDeprecated() && !includeDeprecatedAdditionals)
                    {
                    // If all intermediate target datums are deprecated then we bypass
                    bool deprecated = true;
                    for (size_t index = 0 ; deprecated && (index < currentPath->GetGeodeticTransformCount()); index++)
                        {
                        GeodeticTransformCP currentTransform = currentPath->GetGeodeticTransform(index);

                        if (Utf8String("") != currentTransform->GetTargetDatumName())
                            {
                            DatumCP targetDatum = Datum::CreateDatum(currentTransform->GetTargetDatumName());
                            if (nullptr != targetDatum)
                                {
                                if (!targetDatum->IsDeprecated())
                                    deprecated = false;
                                targetDatum->Destroy();
                                }
                            }
                        }
                    if (deprecated)
                        continue; // If target is deprecated we bypass dumping json
                    }
                BeJsValue currentPathVal(geodeticAdditionalTransformPathsArrayVal[indexPaths]);

                if (SUCCESS != (result = currentPath->ToJson(currentPathVal)))
                    {
                    currentPath->Destroy();
                    return BadProperty("GeodeticTransformPath", result);
                    }

                indexPaths++;
                }
            }
        }

    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPathCP Datum::GetGeodeticTransformPathToWGS84() const
    {
    // If the datum is system then geodetic transforms come from the dictionary
    if (nullptr == m_listOfTransformsToWgs84)
        {
        if (NULL == m_datumDef)
            return m_listOfTransformsToWgs84;

        // Create a datum converter to WGS84
        m_listOfTransformsToWgs84 = GeodeticTransformPath::CreateToWgs84(*this);
        if ((nullptr != m_listOfTransformsToWgs84) && (m_listOfTransformsToWgs84->GetGeodeticTransformCount() >= 1))
            m_listOfTransformsToWgs84->GetGeodeticTransform(m_listOfTransformsToWgs84->GetGeodeticTransformCount() - 1)->SetTargetDatumName("WGS84");
        else
            {
            // It is technically possible for m_listOfTransformsToWgs84 to be non-null if the list is empty. We then destroy.
            if (nullptr != m_listOfTransformsToWgs84)
                {
                m_listOfTransformsToWgs84->Destroy();
                m_listOfTransformsToWgs84 = nullptr;
                }

            // This is a user library or a self sufficient datum
            // If there is a stored geodetic transform then we obtain the target datum.
            if ((m_listOfSetTransforms != nullptr) && (m_listOfSetTransforms->GetGeodeticTransformCount() > 0))
                {
                // Check target datum
                if ((Utf8String(m_listOfSetTransforms->GetTargetDatumName()) == "") ||
                    (Utf8String(m_listOfSetTransforms->GetTargetDatumName()) == "WGS84") ||
                    (Utf8String(m_listOfSetTransforms->GetTargetDatumName()) == "EPSG:4326"))
                    {
                    // Target datum is already WGS84 or unspecified at which we assume WGS84
                    m_listOfTransformsToWgs84 = m_listOfSetTransforms->Clone();
                    if ((nullptr != m_listOfTransformsToWgs84) && (m_listOfTransformsToWgs84->GetGeodeticTransformCount() >= 1))
                        m_listOfTransformsToWgs84->GetGeodeticTransform(m_listOfTransformsToWgs84->GetGeodeticTransformCount() - 1)->SetTargetDatumName("WGS84");
                    }
                else
                    {
                    // Create a datum converter to WGS84 from set target
                    DatumCP destDatum = Datum::CreateDatum(m_listOfSetTransforms->GetTargetDatumName());
                    if (destDatum == nullptr || !destDatum->IsValid())
                        {
                        if (nullptr != destDatum)
                            destDatum->Destroy();

                        return nullptr;
                        }

                    GeodeticTransformPathP intermediatePath = GeodeticTransformPath::CreateToWgs84(*destDatum);
                    if (nullptr != intermediatePath)
                        {
                        m_listOfTransformsToWgs84 = GeodeticTransformPath::CreateMerged(*m_listOfSetTransforms, *intermediatePath);

                        intermediatePath->Destroy();
                        }

                    if ((nullptr != m_listOfTransformsToWgs84) && (m_listOfTransformsToWgs84->GetGeodeticTransformCount() >= 1))
                            m_listOfTransformsToWgs84->GetGeodeticTransform(m_listOfTransformsToWgs84->GetGeodeticTransformCount() - 1)->SetTargetDatumName("WGS84");

                    destDatum->Destroy();
                    }
                }
            else
                {
                // Create a datum converter to WGS84 (since no transform set fall back will be used)
                m_listOfTransformsToWgs84 = GeodeticTransformPath::CreateToWgs84(*this);
                if ((m_listOfTransformsToWgs84 != nullptr) && (m_listOfTransformsToWgs84->GetGeodeticTransformCount() >= 1))
                    m_listOfTransformsToWgs84->GetGeodeticTransform(m_listOfTransformsToWgs84->GetGeodeticTransformCount() - 1)->SetTargetDatumName("WGS84");
                }
            }
        }

    return m_listOfTransformsToWgs84;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bvector<GeodeticTransformPathCP> const & Datum::GetAdditionalGeodeticTransformPaths() const
    {
    if (!m_listOfAdditionalPathsBuilt)
        {
        // Clear just in case
        for (auto path : m_listOfAdditionalPaths)
            path->Destroy();
        m_listOfAdditionalPaths.clear();

        if (NULL == m_datumDef)
            return m_listOfAdditionalPaths;

        // WGS84 or strictly coincident (ETRF89) cannot have additional paths
        if ((BeStringUtilities::Stricmp(m_datumDef->key_nm, "WGS84") == 0) ||
            (BeStringUtilities::Stricmp(m_datumDef->key_nm, "EPSG:6326") == 0) ||
            (BeStringUtilities::Stricmp(m_datumDef->key_nm, "ETRS89") == 0) ||
            (BeStringUtilities::Stricmp(m_datumDef->key_nm, "ETRF89") == 0))
            {
            m_listOfAdditionalPathsBuilt = true;
            return m_listOfAdditionalPaths;
            }

        // Get List of paths
        int number = CS_gpdefFrom(nullptr, 0, m_datumDef->key_nm);

        bvector<Utf8String> listOfTargets;
        if (number > 0)
            {
            struct cs_GeodeticPath_ ** arrayGp2 = reinterpret_cast<struct cs_GeodeticPath_ **>(CS_malc(number * sizeof(struct cs_GeodeticPath_ *)));
            if (nullptr != arrayGp2)
                {
                CS_gpdefFrom(arrayGp2, number, m_datumDef->key_nm);

                for (int i = 0 ; i < number ; i++)
                    {
                    if (nullptr != arrayGp2[i])
                        {
                        if (BeStringUtilities::Stricmp(m_datumDef->key_nm, arrayGp2[i]->srcDatum) == 0)
                            listOfTargets.push_back(Utf8String(arrayGp2[i]->trgDatum));
                        else
                            listOfTargets.push_back(Utf8String(arrayGp2[i]->srcDatum));

                        CSMAP_FREE_AND_CLEAR(arrayGp2[i]);
                        }
                    }
                CSMAP_FREE_AND_CLEAR (arrayGp2);
                }
            }

        // Get List of transforms
        number = CS_gxdefFrom(nullptr, 0, m_datumDef->key_nm);

        if (number > 0)
            {
            struct cs_GeodeticTransform_ ** arrayGx2 = reinterpret_cast<struct cs_GeodeticTransform_ **>(CS_malc(number * sizeof(struct cs_GeodeticPath_ *)));
            if (nullptr != arrayGx2)
                {
                CS_gxdefFrom(arrayGx2, number, m_datumDef->key_nm);

                for (int i = 0 ; i < number ; i++)
                    {
                    if (nullptr != arrayGx2[i])
                        {
                        if (BeStringUtilities::Stricmp(m_datumDef->key_nm, arrayGx2[i]->srcDatum) == 0)
                            listOfTargets.push_back(Utf8String(arrayGx2[i]->trgDatum));
                        else
                            listOfTargets.push_back(Utf8String(arrayGx2[i]->srcDatum));
                        }
                    CSMAP_FREE_AND_CLEAR(arrayGx2[i]);
                    }
                CSMAP_FREE_AND_CLEAR (arrayGx2);
                }
            }

        // Build a list of fully created paths. We remove all paths leading the WGS84 or strickly equivalent (ETRF89)
        bvector<GeodeticTransformPath const *> listOfPossibleAdditionalPaths;
        for (auto currentDatumName : listOfTargets)
            {
            if ((currentDatumName != "WGS84") && (currentDatumName != "EPSG:6326") &&
                (currentDatumName != "ETRF89") && (currentDatumName != "ETRS89"))

                {
                DatumCP currentDatum = Datum::CreateDatum(currentDatumName.c_str());
                if (nullptr != currentDatum)
                    {
                    GeodeticTransformPathCP newPath = GeodeticTransformPath::Create(*this, *currentDatum);
                    if (nullptr != newPath)
                        {
                        if (newPath->GetGeodeticTransformCount() > 0)
                            listOfPossibleAdditionalPaths.push_back(newPath);
                        else
                            newPath->Destroy();
                        }
                    currentDatum->Destroy();
                    }
                }
            }

        if (listOfPossibleAdditionalPaths.size() > 0)
            {
            // Now that we have the list of all paths we want to eliminate the paths that contain other paths.
            // We will also eliminate the paths that are fully contained in the path to WGS84
            // To do this we fetch the longest path (with the most steps) add it (if not included in WGS84)
            // Then move to the next longest, verify it in not in any previously retained path and so on till all paths
            // have been eliminated or added.

            // We first locate the longest path.
            size_t longestIndex = 0;
            size_t countLongest = 0;
            do {
                countLongest = 0;
                for (size_t i = 0 ; i < listOfPossibleAdditionalPaths.size() ; i++)
                    {
                    if (nullptr != listOfPossibleAdditionalPaths[i]) // We may nullify pointers as they are discarded
                        {
                        // If this path is already part of the path to WGS84 we discard
                        GeodeticTransformPathCP pathToWgs84 = GetGeodeticTransformPathToWGS84();
                        if (nullptr != pathToWgs84 && pathToWgs84->ContainsTransformPathTo(listOfPossibleAdditionalPaths[i]->GetTargetDatumName()))
                            {
                            listOfPossibleAdditionalPaths[i]->Destroy();
                            listOfPossibleAdditionalPaths[i] = nullptr;
                            }
                        else if (countLongest < listOfPossibleAdditionalPaths[i]->GetGeodeticTransformCount())
                            {
                            countLongest = listOfPossibleAdditionalPaths[i]->GetGeodeticTransformCount();
                            longestIndex = i;
                            }
                        }
                    }

                // Now we process this longest path ...
                if (countLongest > 0)
                    {
                    for (auto path : m_listOfAdditionalPaths)
                        {
                        // If the path is already a portion of a retained additional path we discard it.
                        if (path->ContainsTransformPathTo(listOfPossibleAdditionalPaths[longestIndex]->GetTargetDatumName()))
                            {
                            listOfPossibleAdditionalPaths[longestIndex]->Destroy();
                            listOfPossibleAdditionalPaths[longestIndex] = nullptr;
                            break;
                            }
                        }

                    if (nullptr != listOfPossibleAdditionalPaths[longestIndex]) // If the longest is still non-null it is unique and moved to final list
                        {
                        m_listOfAdditionalPaths.push_back(listOfPossibleAdditionalPaths[longestIndex]);
                        listOfPossibleAdditionalPaths[longestIndex] = nullptr;
                        }
                    }
                }
            while (countLongest > 0); // Till all have been processed.
            }

        m_listOfAdditionalPathsBuilt = true;
        }

    return m_listOfAdditionalPaths;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt Datum::AddAdditionalGeodeticTransformPath(GeodeticTransformPathCP newPath)
    {
    if (nullptr == newPath)
        return ERROR;

    m_listOfAdditionalPaths.push_back(newPath);
    m_listOfAdditionalPathsBuilt = true;
    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPathCP Datum::GetStoredGeodeticTransformPath() const
    {
    return m_listOfSetTransforms;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt Datum::SetStoredGeodeticTransformPath(GeodeticTransformPathP newPath)
    {
    if (NULL == m_datumDef)
        return ERROR;

    if (m_listOfSetTransforms != nullptr)
        m_listOfSetTransforms->Destroy();

    if (m_listOfTransformsToWgs84 != nullptr)
        {
        m_listOfTransformsToWgs84->Destroy();
        m_listOfTransformsToWgs84 = nullptr;
        }

    for (auto path : m_listOfAdditionalPaths)
        path->Destroy();
    m_listOfAdditionalPaths.clear();
    m_listOfAdditionalPathsBuilt  = false;

    if (nullptr != newPath)
        {
        // If the path contains a single transform and this transform is one of the various geocentric types
        // then we copy parameters in the basic parameters of the datum.
        // If the path is long or contains a complex (grid file) transform then we mark the datum as GRID FILE based
        // and nullify the transform parameters. This will insure the datum converter engine will not accidentally locate an
        // invalid transformation path.
        // Default transform is 7 parameter with all zero values
        SetConvertToWGS84MethodCode(ConvertType_7PARM);
        DPoint3d delta;
        delta.Init(0.0, 0.0, 0.0);
        SetDelta(delta);
        DPoint3d rotation;
        rotation.Init(0.0, 0.0, 0.0);
        SetRotation(rotation);
        SetScale(0.0); // Not really a scale ... divergence from 1.0 only

        // Now that parameters are nullified ... we set to gengrid as default
        SetConvertToWGS84MethodCode(ConvertType_GENGRID);

        GeodeticTransformP simplified = newPath->CreateSimplifiedGeocentricTransform();
        if (nullptr != simplified)
            {
            if (simplified->GetConvertMethodCode() == GenConvertCode::GenConvertType_GEOCTR)
                {
                SetConvertToWGS84MethodCode(ConvertType_GEOCTR);
                simplified->GetDelta(delta);
                SetDelta(delta);
                }
            else if (simplified->GetConvertMethodCode() == GenConvertCode::GenConvertType_7PARM)
                {
                SetConvertToWGS84MethodCode(ConvertType_7PARM);
                simplified->GetRotation(rotation);
                simplified->GetDelta(delta);
                SetDelta(delta);
                SetRotation(rotation);
                SetScale(simplified->GetScale());
                }
            else if (simplified->GetConvertMethodCode() == GenConvertCode::GenConvertType_NONE)
                {
                SetConvertToWGS84MethodCode(ConvertType_NONE);
                }
            simplified->Destroy();
            }
        }

    // Now we take the path provided (even if null)
    m_listOfSetTransforms = newPath;

    if (nullptr != m_listOfSetTransforms && m_listOfSetTransforms->GetGeodeticTransformCount() > 0 && Utf8String(m_listOfSetTransforms->GetSourceDatumName()) != GetName())
        {
        m_listOfSetTransforms->GetGeodeticTransform(0)->SetSourceDatumName(GetName());
        }

    // No else ... default was already GENGRID which cannot be solved by default datum converter creator.

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   Datum::HasNullTransformToWGS84() const
{
    if (NULL == m_datumDef)
        return false;

    // If there are geodetic transforms...
    // Calling the method triggers extraction of geodetic transforms from system library (if relevant)
    if (nullptr != GetGeodeticTransformPathToWGS84() && GetGeodeticTransformPathToWGS84()->GetGeodeticTransformCount() > 0)
        return GetGeodeticTransformPathToWGS84()->IsNullTransform();

    // No geodetic transform stored or defined ... check the fallback
    return ((m_datumDef->to84_via == cs_DTCTYP_NONE) ||
            (m_datumDef->to84_via == cs_DTCTYP_NAD83) ||
            (m_datumDef->to84_via == cs_DTCTYP_WGS84) ||
            (m_datumDef->to84_via == cs_DTCTYP_ETRF89) ||
            (((m_datumDef->to84_via == cs_DTCTYP_MOLO) || (m_datumDef->to84_via == cs_DTCTYP_GEOCTR) || (m_datumDef->to84_via == cs_DTCTYP_3PARM)) &&
              (distanceSame(m_datumDef->delta_X, 0.0) && distanceSame(m_datumDef->delta_Y, 0.0) && distanceSame(m_datumDef->delta_Z, 0.0))) ||
            (((m_datumDef->to84_via == cs_DTCTYP_7PARM) || (m_datumDef->to84_via == cs_DTCTYP_BURS) || (m_datumDef->to84_via == cs_DTCTYP_6PARM) || (m_datumDef->to84_via == cs_DTCTYP_4PARM)) &&
              (distanceSame(m_datumDef->delta_X, 0.0) && distanceSame(m_datumDef->delta_Y, 0.0) && distanceSame(m_datumDef->delta_Z, 0.0) &&
              doubleSame(m_datumDef->rot_X, 0.0) && doubleSame(m_datumDef->rot_Y, 0.0) && doubleSame(m_datumDef->rot_Z, 0.0) && doubleSame(m_datumDef->bwscale, 0.0))));
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool                Datum::IsValid () const
    {
    return  NULL != m_datumDef;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool              Datum::HasMissingGridFiles(bvector<Utf8String>& listOfFiles, bool includeFilesInAdditionalPaths, bool includeFilesToDeprecatedDatums) const
    {
    bool hasMissingFiles = false;

    if (nullptr != m_listOfSetTransforms)
        {
        hasMissingFiles = m_listOfSetTransforms->HasMissingGridFiles(listOfFiles);
        }
    else
        {
        GeodeticTransformPathCP thePath = GetGeodeticTransformPathToWGS84();
        if (nullptr != thePath)
            {
            hasMissingFiles = thePath->HasMissingGridFiles(listOfFiles);
            }
        }

    if (includeFilesInAdditionalPaths && GetAdditionalGeodeticTransformPaths().size() > 0)
        {
        for (auto path : GetAdditionalGeodeticTransformPaths())
            {
            if (path->HasMissingGridFiles(listOfFiles, includeFilesToDeprecatedDatums))
                hasMissingFiles = true;
            }

        // Remove duplicate file names.
        std::sort(listOfFiles.begin(), listOfFiles.end(), [](const Utf8String& a, const Utf8String& b) -> bool {return (0 > BeStringUtilities::Stricmp(a.c_str(), b.c_str()));});
        auto newEnd = std::unique(listOfFiles.begin(), listOfFiles.end());
        listOfFiles.resize(std::distance(listOfFiles.begin(), newEnd));
        }

    return hasMissingFiles;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool  Datum::IsDeprecated() const
    {
    static Utf8String deprecated("LEGACY");

    if (NULL == m_datumDef)
        return false;

    Utf8String groupName;

    return (0 == deprecated.CompareTo(GetGroup(groupName)));
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            Datum::IsNAD27 () const
    {
    if (NULL == m_datumDef)
        return false;

    return IsNAD27Keyname(m_datumDef->key_nm);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            Datum::IsNAD83 () const
    {
    if (NULL == m_datumDef)
        return false;

    return IsNAD83Keyname(m_datumDef->key_nm);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            Datum::IsWGS84Coincident () const
    {
    if (NULL == m_datumDef)
        return false;

    if  (IsWGS84CoincidentKeyname(m_datumDef->key_nm))
        return true;

    // Now we need to obtain the geodetic transformation to WGS84
    static DatumCP wgs84Datum;
    if (nullptr == wgs84Datum)
        wgs84Datum = Datum::CreateDatum("WGS84");

    if (nullptr == wgs84Datum)
        return false; // Can only occur if dictionary files absent

    // We do a datum compare
    if (DatumEquivalent(*(GetCSDatum()), *(wgs84Datum->GetCSDatum()), true, true, false))
        return true;

    // This call forces extraction of geodetic transforms from system dictionary
    if (nullptr != GetGeodeticTransformPathToWGS84())
        {
        if (!GetGeodeticTransformPathToWGS84()->IsVerticallyNeutral())
            return false;
        }

    // If we get here then everything is equal
    return true;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int                 Datum::GetError () const
    {
    return m_csError;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Datum::GetErrorMessage (Utf8StringR errorMsg) const
    {
    if (!BaseGCS::IsLibraryInitialized())
        return errorMsg.c_str();

    char    csErrorMsg[512];
    CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
    errorMsg = csErrorMsg;
    return errorMsg.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Datum::GetName() const
    {
    if (NULL == m_datumDef)
        return "";

    if (NULL == m_nameString)
        m_nameString = new Utf8String (m_datumDef->key_nm);

    return m_nameString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Datum::SetName (Utf8CP value)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    Utf8String mbName (value);
    if (mbName.length() >= _countof (m_datumDef->key_nm))
        return GEOCOORDERR_StringTooLong;

    char    copy[1024];
    CS_stncp (copy, mbName.c_str(), _countof (copy));
    if (0 != CS_nampp (copy))
        return GEOCOORDERR_CoordSysIllegalName;

    CS_stncp (m_datumDef->key_nm, mbName.c_str(), _countof (m_datumDef->key_nm));
    m_datumDef->epsgNbr = 0;
    CSMAP_FREE_AND_CLEAR (m_csDatum);

    DELETE_AND_CLEAR (m_nameString);

    // If the datum has stored transforms the source name must be updated
    if (nullptr != m_listOfSetTransforms && m_listOfSetTransforms->GetGeodeticTransformCount() > 0)
        {
        m_listOfSetTransforms->GetGeodeticTransform(0)->SetSourceDatumName(value);
        }

    if (nullptr != m_listOfTransformsToWgs84)
        {
        m_listOfTransformsToWgs84->Destroy();
        m_listOfTransformsToWgs84 = nullptr;
        }

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Datum::GetDescription() const
    {
    if (NULL == m_datumDef)
        return "";

    if (NULL == m_descriptionString)
        m_descriptionString = new Utf8String (m_datumDef->name);

    return m_descriptionString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Datum::SetDescription (Utf8CP value)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    Utf8String mbDescription (value);
    if (mbDescription.length() >= _countof (m_datumDef->name))
        return GEOCOORDERR_StringTooLong;

    CS_stncp (m_datumDef->name, mbDescription.c_str(), _countof (m_datumDef->name));
    CSMAP_FREE_AND_CLEAR (m_csDatum);
    DELETE_AND_CLEAR (m_descriptionString);
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Datum::GetSource (Utf8StringR source) const
    {
    source.clear();

    if (NULL == m_datumDef)
        return "";

    source = m_datumDef->source;

    return source.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Datum::SetSource (Utf8CP value)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    Utf8String mbSource (value);
    if (mbSource.length() >= _countof (m_datumDef->source))
        return GEOCOORDERR_StringTooLong;

    CS_stncp (m_datumDef->source, mbSource.c_str(), _countof (m_datumDef->source));
    CSMAP_FREE_AND_CLEAR (m_csDatum);

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int                 Datum::GetEPSGCode() const
    {
    return (NULL == m_datumDef) ? 0 : m_datumDef->epsgNbr;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt                 Datum::SetEPSGCode(short value)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    if (value < 0)
        return GEOCOORDERR_BadArg; // Should we validate upper value? Either yes or change documentation.

    m_datumDef->epsgNbr = value;

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
WGS84ConvertCode    Datum::GetConvertToWGS84MethodCode() const
    {
    return (WGS84ConvertCode) ((NULL == m_datumDef) ? 0 : m_datumDef->to84_via);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Datum::SetConvertToWGS84MethodCode (WGS84ConvertCode value)
    {
    int     intValue = (int) value;
    if ( (intValue < 0) || (intValue > ConvertType_MAXVALUE) )
        return GEOCOORDERR_BadArg;

    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    m_datumDef->to84_via = static_cast<short>(intValue); // NEEDSWORK - is cast correct?  Can intValue be a short?
    CSMAP_FREE_AND_CLEAR (m_csDatum);

    return BSISUCCESS;;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool    Datum::UsesAGeocentricMethod() const
    {
    if (nullptr == m_datumDef)
        return false;

    return (m_datumDef->to84_via == cs_DTCTYP_MOLO ||
             m_datumDef->to84_via == cs_DTCTYP_GEOCTR ||
             m_datumDef->to84_via == cs_DTCTYP_3PARM ||
             m_datumDef->to84_via == cs_DTCTYP_7PARM ||
             m_datumDef->to84_via == cs_DTCTYP_4PARM ||
             m_datumDef->to84_via == cs_DTCTYP_6PARM ||
             m_datumDef->to84_via == cs_DTCTYP_BURS);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void                Datum::GetDelta (DPoint3dR delta) const
    {
    delta.x = delta.y = delta.z = 0.0;

    if (NULL == m_datumDef)
        return;

    bool             deltaValid, rotationValid, scaleValid;
    ParametersValid (deltaValid, rotationValid, scaleValid);
    if (deltaValid)
        {
        delta.x = m_datumDef->delta_X;
        delta.y = m_datumDef->delta_Y;
        delta.z = m_datumDef->delta_Z;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Datum::SetDelta (DPoint3dCR delta)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    bool             deltaValid, rotationValid, scaleValid;
    ParametersValid (deltaValid, rotationValid, scaleValid);
    if (deltaValid)
        {
        m_datumDef->delta_X = delta.x;
        m_datumDef->delta_Y = delta.y;
        m_datumDef->delta_Z = delta.z;
        CSMAP_FREE_AND_CLEAR (m_csDatum);
        return BSISUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void                Datum::GetRotation (DPoint3dR rotation) const
    {
    rotation.x = rotation.y = rotation.z = 0.0;

    if (NULL == m_datumDef)
        return;

    bool             deltaValid, rotationValid, scaleValid;
    ParametersValid (deltaValid, rotationValid, scaleValid);
    if (rotationValid)
        {
        rotation.x = m_datumDef->rot_X;
        rotation.y = m_datumDef->rot_Y;
        rotation.z = m_datumDef->rot_Z;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Datum::SetRotation (DPoint3dCR rotation)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    bool             deltaValid, rotationValid, scaleValid;
    ParametersValid (deltaValid, rotationValid, scaleValid);
    if (rotationValid)
        {
        m_datumDef->rot_X = rotation.x;
        m_datumDef->rot_Y = rotation.y;
        m_datumDef->rot_Z = rotation.z;
        CSMAP_FREE_AND_CLEAR (m_csDatum);
        return BSISUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              Datum::GetScale () const
    {
    if (NULL == m_datumDef)
        return 0.0;

    bool             deltaValid, rotationValid, scaleValid;
    ParametersValid (deltaValid, rotationValid, scaleValid);
    return (scaleValid) ? m_datumDef->bwscale : 0.0;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Datum::SetScale (double value)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    bool             deltaValid, rotationValid, scaleValid;
    ParametersValid (deltaValid, rotationValid, scaleValid);
    if (scaleValid)
        {
        m_datumDef->bwscale = value;
        CSMAP_FREE_AND_CLEAR (m_csDatum);
        return BSISUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt              Datum::GetGridFile (GridFileDefinition& gridFileDef, bool strict) const
    {
    if (NULL == m_datumDef)
        return ERROR;

    if (GetConvertToWGS84MethodCode() != ConvertType_GENGRID)
        return ERROR;

    // Check for a stored path (user defined or custom)
    GeodeticTransformPathCP thePathToSearch = GetStoredGeodeticTransformPath();

    // If no stored path then locate from library
    if (nullptr == thePathToSearch)
        thePathToSearch = GetGeodeticTransformPathToWGS84();

    if (nullptr != thePathToSearch)
        {
        // Locate the grid file transform in the list if any
        size_t gridFileTransformIndex = 0;
        for (;gridFileTransformIndex < thePathToSearch->GetGeodeticTransformCount(); ++gridFileTransformIndex)
            {
            if (thePathToSearch->GetGeodeticTransform(gridFileTransformIndex)->GetConvertMethodCode() == GenConvertCode::GenConvertType_GFILE)
                break;
            // If strict then if the transform is not grid file base then it must be null ...
            if (strict && !thePathToSearch->GetGeodeticTransform(gridFileTransformIndex)->IsNullTransform())
                return ERROR;
            }

        // If strict then all other transforms after grid file must be null
        if (strict)
            {
            for (size_t index2 = gridFileTransformIndex + 1; index2 < thePathToSearch->GetGeodeticTransformCount(); ++index2)
                {
                if (!thePathToSearch->GetGeodeticTransform(index2)->IsNullTransform())
                    return ERROR;
                }
            }

        if (gridFileTransformIndex < thePathToSearch->GetGeodeticTransformCount() &&
            thePathToSearch->GetGeodeticTransform(gridFileTransformIndex)->GetGridFileDefinitionCount() > 0)
            {
            gridFileDef = thePathToSearch->GetGeodeticTransform(gridFileTransformIndex)->GetGridFileDefinition(0);
            return SUCCESS;
            }
        }

    return ERROR;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           Datum::SetGridFile (const GridFileDefinition& gridFileDef)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    if (m_listOfTransformsToWgs84 != nullptr)
        {
        m_listOfTransformsToWgs84->Destroy();
        m_listOfTransformsToWgs84 = nullptr;
        }

    if (m_listOfSetTransforms != nullptr)
        {
        m_listOfSetTransforms->Destroy();
        m_listOfSetTransforms = nullptr;
        }

    for (auto path : m_listOfAdditionalPaths)
        path->Destroy();
    m_listOfAdditionalPaths.clear();
    m_listOfAdditionalPathsBuilt  = false;

    SetConvertToWGS84MethodCode(ConvertType_GENGRID);

    m_listOfSetTransforms = GeodeticTransformPath::Create();
    if (nullptr == m_listOfSetTransforms)
        return ERROR;

    GeodeticTransformP newTransform = GeodeticTransform::CreateGeodeticTransform();
    if (nullptr == newTransform)
        {
        m_listOfSetTransforms->Destroy();
        m_listOfSetTransforms = nullptr;
        return ERROR;
        }

    newTransform->SetSourceDatumName(GetName());
    newTransform->SetTargetDatumName("WGS84");
    newTransform->SetConvertMethodCode(GenConvertCode::GenConvertType_GFILE);
    newTransform->AddGridFileDefinition(gridFileDef);
    m_listOfSetTransforms->AddGeodeticTransform(newTransform);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Datum::GetEllipsoidName() const
    {
    if (NULL == m_datumDef)
        return "";

    if (NULL == m_ellipsoidNameString)
        m_ellipsoidNameString = new Utf8String (m_datumDef->ell_knm);

    return m_ellipsoidNameString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int                 Datum::GetEllipsoidCode () const
    {
    if (NULL == m_datumDef)
        return Ellipsoid::NO_ELLIPSOID_CODE;

    Utf8String searchName (m_datumDef->ell_knm);

    // check system library
    char mbEllipsoidName[512];
    for (int index = 0; (0 < CS_elEnum (index, mbEllipsoidName, _countof(mbEllipsoidName))); index++)
        {
        if (0 == BeStringUtilities::Stricmp (m_datumDef->ell_knm, mbEllipsoidName))
            return index;
        }

    if (m_customEllipsoid && nullptr != m_ellipsoid)
        return Ellipsoid::CUSTOM_ELLIPSOID_CODE;

    return Ellipsoid::NO_ELLIPSOID_CODE;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt       Datum::SetEllipsoidCode (int ellipsoidCode)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    // ELLIPSOID_CODE_SEPARATOR (2000000) is the separator, do nothing.
    if (Ellipsoid::ELLIPSOID_CODE_SEPARATOR == ellipsoidCode)
        return GEOCOORDERR_InvalidEllipsoidCode;

    if (Ellipsoid::CUSTOM_ELLIPSOID_CODE == ellipsoidCode && nullptr != m_ellipsoid)
        return SUCCESS;

    m_customEllipsoid = false;

    CSEllipsoidDef* ellipsoidDef    = NULL;

    char    elKeyName[128];
    if (CS_elEnum (ellipsoidCode, elKeyName, sizeof(elKeyName)) <= 0)
        return GEOCOORDERR_InvalidEllipsoidCode;

    if (NULL == (ellipsoidDef = CSMap::CS_eldef (elKeyName)))
        return GEOCOORDERR_InvalidEllipsoidCode;

    CSDatum*       datum;
    if (NULL == (datum = CSdtloc2 (NULL, ellipsoidDef)))
        {
        CSMap::CS_free (ellipsoidDef);
        return GEOCOORDERR_InvalidEllipsoidCode;
        }

    CSMap::CS_stncp (m_datumDef->ell_knm, ellipsoidDef->key_nm, sizeof (m_datumDef->ell_knm));

    // keep the new datum, discard the old.
    CSMAP_FREE_AND_CLEAR (m_csDatum);
    m_csDatum = datum;

    // create a new ellipsoid from the CSEllipsoidDef, discard the old.
    if (NULL != m_ellipsoid)
        m_ellipsoid->Destroy();
    m_ellipsoid = Ellipsoid::CreateEllipsoid (*ellipsoidDef);

    if (nullptr != ellipsoidDef)
        CSMap::CS_free (ellipsoidDef);

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             Datum::GetEllipsoidDescription() const
    {
    if (NULL == m_datumDef)
        return "";

    if (NULL == m_ellipsoid)
        m_ellipsoid = Ellipsoid::CreateEllipsoid (m_datumDef->ell_knm);

    return (NULL == m_ellipsoid) ? NULL : m_ellipsoid->GetDescription();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP              Datum::GetEllipsoidSource (Utf8StringR source) const
    {
    source.clear();

    if (NULL == m_datumDef)
        return "";

    if (NULL == m_ellipsoid)
        m_ellipsoid = Ellipsoid::CreateEllipsoid (m_datumDef->ell_knm);
    return (NULL == m_ellipsoid) ? NULL : m_ellipsoid->GetSource (source);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              Datum::GetEllipsoidPolarRadius () const
    {
    if (NULL == m_datumDef)
        return 0.0;

    if (NULL == m_ellipsoid)
        m_ellipsoid = Ellipsoid::CreateEllipsoid (m_datumDef->ell_knm);

    return (NULL == m_ellipsoid) ? 0.0 : m_ellipsoid->GetPolarRadius();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              Datum::GetEllipsoidEquatorialRadius () const
    {
    if (NULL == m_datumDef)
        return 0.0;

    if (NULL == m_ellipsoid)
        m_ellipsoid = Ellipsoid::CreateEllipsoid (m_datumDef->ell_knm);

    return (NULL == m_ellipsoid) ? 0.0 : m_ellipsoid->GetEquatorialRadius();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              Datum::GetEllipsoidEccentricity () const
    {
    if (NULL == m_datumDef)
        return 0.0;

    if (NULL == m_ellipsoid)
        m_ellipsoid = Ellipsoid::CreateEllipsoid (m_datumDef->ell_knm);

    return (NULL == m_ellipsoid) ? 0.0 : m_ellipsoid->GetEccentricity();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidCP         Datum::GetEllipsoid() const
    {
    if (NULL == m_datumDef)
        return NULL;

    if (nullptr == m_ellipsoid)
        {
        BeAssert(!m_customEllipsoid);
        m_ellipsoid = Ellipsoid::CreateEllipsoid (m_datumDef->ell_knm);
        }

    return m_ellipsoid; // Can be manually set or generated.
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt        Datum::SetEllipsoid(EllipsoidP newEllipsoid)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    if (nullptr != m_ellipsoid)
        {
        m_ellipsoid->Destroy();
        m_ellipsoid = nullptr;
        }

    if (nullptr != newEllipsoid)
        {
        m_customEllipsoid = true;
        m_ellipsoid = newEllipsoid;

        // Clear cached pre-computed datum
        if (NULL == m_csDatum)
            CSMAP_FREE_AND_CLEAR (m_csDatum);

        CSMap::CS_stncp(m_datumDef->ell_knm, m_ellipsoid->GetName(), sizeof(m_datumDef->ell_knm));
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void                Datum::ParametersValid (bool& deltaValid, bool& rotationValid, bool& scaleValid) const
    {
    // initialize to defaults.
    deltaValid = rotationValid = scaleValid = false;
    switch (GetConvertToWGS84MethodCode())
        {
        case ConvertType_MOLO:
        case ConvertType_3PARM:
        case ConvertType_GEOCTR:
            deltaValid = true;
            break;

        case ConvertType_BURS:
        case ConvertType_7PARM:
            deltaValid = rotationValid = scaleValid = true;
            break;

        case ConvertType_6PARM:
            deltaValid = rotationValid = true;
            break;

        case ConvertType_4PARM:
            deltaValid = scaleValid = true;
            break;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void                Datum::ExtendedParametersValid (bool& deltaValid, bool& rotationValid, bool& scaleValid, bool& gridValid) const
    {
    // initialize to defaults.
    deltaValid = rotationValid = scaleValid = gridValid = false;
    switch (GetConvertToWGS84MethodCode())
        {
        case ConvertType_MOLO:
        case ConvertType_3PARM:
        case ConvertType_GEOCTR:
            deltaValid = true;
            break;

        case ConvertType_BURS:
        case ConvertType_7PARM:
            deltaValid = rotationValid = scaleValid = true;
            break;

        case ConvertType_6PARM:
            deltaValid = rotationValid = true;
            break;

        case ConvertType_4PARM:
            deltaValid = scaleValid = true;
            break;

        case ConvertType_GENGRID:
            gridValid = true;
            break;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            Datum::IsEquivalent (DatumCR compareTo, bool looselyCompare) const
    {
    if (NULL == m_datumDef)
        return false;

    if (NULL == compareTo.m_datumDef)
        return false;

    // We do a superficial datum compare
    CSDatum* selfCSDatum = GetCSDatum();
    CSDatum* compareCSDatum = compareTo.GetCSDatum();
    BeAssert(nullptr != selfCSDatum && nullptr != compareCSDatum);

    if (nullptr == selfCSDatum || nullptr == compareCSDatum)
        return false;

    if (!DatumEquivalent(*(GetCSDatum()), *(compareTo.GetCSDatum()), true, true, true))
        return false;

    // Now we obtain the DatumTransform to WGS84 for both

    // Now we need to obtain the geodetic transformation to WGS84
    static DatumCP wgs84Datum;
    if (nullptr == wgs84Datum)
        wgs84Datum = Datum::CreateDatum("WGS84");

    if (wgs84Datum == nullptr)
        return false;

    // This call forces extraction of geodetic transforms from system dictionary
    if (nullptr != GetGeodeticTransformPathToWGS84() && nullptr != compareTo.GetGeodeticTransformPathToWGS84() &&
        GetGeodeticTransformPathToWGS84()->GetGeodeticTransformCount() != 0 && compareTo.GetGeodeticTransformPathToWGS84()->GetGeodeticTransformCount() != 0)
        {
        if (!GetGeodeticTransformPathToWGS84()->IsEquivalent(*(compareTo.GetGeodeticTransformPathToWGS84()), looselyCompare))
            return false;
        }

    if (nullptr != GetStoredGeodeticTransformPath() && nullptr != compareTo.GetStoredGeodeticTransformPath() &&
        GetStoredGeodeticTransformPath()->GetGeodeticTransformCount() != 0 && compareTo.GetStoredGeodeticTransformPath()->GetGeodeticTransformCount() != 0)
        {
        if (!GetStoredGeodeticTransformPath()->IsEquivalent(*(compareTo.GetStoredGeodeticTransformPath()), looselyCompare))
            return false;
        }

    bool foundEquivalent = true; // Initialize to true in case there are no additional paths
    for (auto path : GetAdditionalGeodeticTransformPaths())
        {
        foundEquivalent = false;

        // We only compare paths to non-deprecated datums
        DatumCP targetDatum = Datum::CreateDatum(path->GetTargetDatumName());
        if (nullptr != targetDatum)
            {
            bool deprecated = targetDatum->IsDeprecated();
            targetDatum->Destroy();
            if (deprecated)
                {
                foundEquivalent = true;
                continue; // If target is deprecated we bypass dumping json
                }
            }

        for (auto comparePath : compareTo.GetAdditionalGeodeticTransformPaths())
            {
            if (nullptr != comparePath && path->IsEquivalent(*comparePath, looselyCompare))
                {
                foundEquivalent = true;
                break;
                }
            }
        if (!foundEquivalent)
            break;
        }

    if (!foundEquivalent)
        return false;

    // The following additional step is required for cases where the datum transformations to WGS84 are identical but there exists a
    // specific geodetic path between the two specified datums. This will occur for example for some NAD83 variants.
    // NAD83 is considered coincident to WGS84 and so is NSRS11 (NAD83/2011) but there exists a complex geodetic transformation
    // path between NAD83 to NSRS11 that must be applied anyway for these source and target.
    DatumConverter* datumConverterDirect = DatumConverter::Create(*this, compareTo);
    if (datumConverterDirect == nullptr)
        {
        // If not direct transformation could be derived it means that at least one
        // datum has not any entry in the dictionary in which case the definition tested above is the only path possible
        // and has been tested as equivalent thus the datums are equivalent
        return true;
        }

    if (!datumConverterDirect->IsNullTransform())
        {
        datumConverterDirect->Destroy();
        return false;
        }

    datumConverterDirect->Destroy();

    // If we get here then everything is equal
    return true;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
CSDatum*            Datum::GetCSDatum() const
    {
    if (NULL != m_csDatum)
        return m_csDatum;

    if (NULL == m_datumDef)
        return NULL;

    CSEllipsoidDef* ellipsoidDef = NULL;

    if (NULL != (ellipsoidDef = CSMap::CS_eldef (m_datumDef->ell_knm)))
        {
        m_csDatum = CSdtloc2(m_datumDef, ellipsoidDef);
        CSMap::CS_free(ellipsoidDef);
        }
    else if (m_customEllipsoid && nullptr != m_ellipsoid)
        {
        ellipsoidDef = m_ellipsoid->GetCSEllipsoidDef();
        if (NULL == ellipsoidDef)
            return NULL;

        m_csDatum = CSdtloc2(m_datumDef, ellipsoidDef);
        // We do not free the ellipsoid def!
        }

    return m_csDatum;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
CSDatumDef*            Datum::GetCSDatumDef(CSGeodeticTransformDef const** geodeticTransformDef) const
    {
    if (nullptr != geodeticTransformDef)
        {
        *geodeticTransformDef = nullptr;

        if (nullptr != m_listOfSetTransforms && m_listOfSetTransforms->GetGeodeticTransformCount() > 0)
            {
            *geodeticTransformDef = m_listOfSetTransforms->GetGeodeticTransform(0)->GetCSGeodeticTransformDef();
            }
        }

    return m_datumDef;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
CSEllipsoidDef*            Datum::GetCSEllipsoidDef() const
    {
    if (nullptr == m_datumDef)
        return nullptr; // Datum is invalid

    if (nullptr == m_ellipsoid)
        {
        BeAssert(!m_customEllipsoid);
        m_ellipsoid = Ellipsoid::CreateEllipsoid (m_datumDef->ell_knm);
        }

    return m_ellipsoid->GetCSEllipsoidDef();
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Datum::~Datum()
    {
    Clear();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void Datum::Clear()
    {
    if (NULL != m_datumDef)
        CSMap::CS_free (m_datumDef);
    m_datumDef = nullptr;

    if (NULL != m_csDatum)
        CSMap::CS_free (m_csDatum);
    m_csDatum = nullptr;

    if (NULL != m_ellipsoid)
        m_ellipsoid->Destroy();
    m_ellipsoid = nullptr;
    m_customEllipsoid = false;

    DELETE_AND_CLEAR (m_nameString);
    DELETE_AND_CLEAR (m_descriptionString);
    DELETE_AND_CLEAR (m_ellipsoidNameString);
    DELETE_AND_CLEAR (m_ellipsoidDescriptionString);

    for (auto path : m_listOfAdditionalPaths)
        path->Destroy();

    m_listOfAdditionalPaths.clear();
    m_listOfAdditionalPathsBuilt  = false;

    if (m_listOfTransformsToWgs84 != nullptr) {
        m_listOfTransformsToWgs84->Destroy();
        m_listOfTransformsToWgs84 = nullptr;
    }

    if (m_listOfSetTransforms != nullptr) {
        m_listOfSetTransforms->Destroy();
        m_listOfSetTransforms = nullptr;
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void Datum::AllocateClean()
    {
    Clear();

    m_datumDef = CSMap::CS_dtdef("WGS84");
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            Datum::Destroy () const { delete this; }

#ifdef DICTIONARY_MANAGEMENT_ONLY
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt Datum::OutputAsASC
(
Utf8StringR       DatumAsASC
) const
{
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    StatusInt       status = SUCCESS;

    std::ostringstream DatumAsAscStream(DatumAsASC);

    if (!IsValid())
        return ERROR;

    uint32_t     gcTo84via = 0;
    char   szCsTo84Keyname[64];

    szCsTo84Keyname[0] = 0;

    DatumAsAscStream << "DT_NAME: " << m_datumDef->key_nm << std::endl
               << "        DESC_NM: " << m_datumDef->name << std::endl
               << "         SOURCE: " << m_datumDef->source << std::endl
               << "      ELLIPSOID: " << m_datumDef->ell_knm << std::endl;

    switch (m_datumDef->to84_via)
        {
        case cs_DTCTYP_MOLO:
            DatumAsAscStream << "            USE: MOLODENSKY" << std::endl;
            DatumAsAscStream << "        DELTA_X: " << m_datumDef->delta_X << std::endl
                       << "        DELTA_Y: " << m_datumDef->delta_Y << std::endl
                       << "        DELTA_Z: " << m_datumDef->delta_Z << std::endl;
            break;

        case cs_DTCTYP_MREG:
            DatumAsAscStream << "            USE: MULREG" << std::endl;
            //Values are carried but not used.  Meant to provide a quick way of using alternate almost equivalent definition.
            if (!distanceSame(0.0, m_datumDef->delta_X))
                DatumAsAscStream << "        DELTA_X: " << m_datumDef->delta_X << std::endl;
            if (!distanceSame(0.0, m_datumDef->delta_Y))
                DatumAsAscStream << "        DELTA_Y: " << m_datumDef->delta_Y << std::endl;
            if (!distanceSame(0.0, m_datumDef->delta_Z))
                DatumAsAscStream << "        DELTA_Z: " << m_datumDef->delta_Z << std::endl;
            break;

        case cs_DTCTYP_BURS:
            DatumAsAscStream << "            USE: BURSA" << std::endl;
            DatumAsAscStream << "        DELTA_X: " << m_datumDef->delta_X << std::endl
                       << "        DELTA_Y: " << m_datumDef->delta_Y << std::endl
                       << "        DELTA_Z: " << m_datumDef->delta_Z << std::endl
                       << "          ROT_X: " << m_datumDef->rot_X << std::endl
                       << "          ROT_Y: " << m_datumDef->rot_Y << std::endl
                       << "          ROT_Z: " << m_datumDef->rot_Z << std::endl
                       << "        BWSCALE: " << m_datumDef->bwscale << std::endl;
            break;

        case cs_DTCTYP_NAD27:
            DatumAsAscStream << "            USE: NAD27" << std::endl;
            break;

        case cs_DTCTYP_NAD83:
            DatumAsAscStream << "            USE: NAD83" << std::endl;
            break;

        case cs_DTCTYP_WGS84:
            DatumAsAscStream << "            USE: WGS84" << std::endl;
            break;

        case cs_DTCTYP_WGS72:
            DatumAsAscStream << "            USE: WGS72" << std::endl;
            break;

        case cs_DTCTYP_HPGN:
            DatumAsAscStream << "            USE: HPGN" << std::endl;
            break;

        case cs_DTCTYP_7PARM:
            DatumAsAscStream << "            USE: 7PARAMETER" << std::endl;
            DatumAsAscStream << "        DELTA_X: " << m_datumDef->delta_X << std::endl
                       << "        DELTA_Y: " << m_datumDef->delta_Y << std::endl
                       << "        DELTA_Z: " << m_datumDef->delta_Z << std::endl
                       << "          ROT_X: " << m_datumDef->rot_X << std::endl
                       << "          ROT_Y: " << m_datumDef->rot_Y << std::endl
                       << "          ROT_Z: " << m_datumDef->rot_Z << std::endl
                       << "        BWSCALE: " << m_datumDef->bwscale << std::endl;
            break;

        case cs_DTCTYP_AGD66:
            DatumAsAscStream << "            USE: AGD66" << std::endl;
            break;

        case cs_DTCTYP_3PARM:
            DatumAsAscStream << "            USE: 3PARAMETER" << std::endl;
            DatumAsAscStream << "        DELTA_X: " << m_datumDef->delta_X << std::endl
                       << "        DELTA_Y: " << m_datumDef->delta_Y << std::endl
                       << "        DELTA_Z: " << m_datumDef->delta_Z << std::endl;
            break;

        case cs_DTCTYP_6PARM:
            DatumAsAscStream << "            USE: 6PARAMETER" << std::endl;
            DatumAsAscStream << "        DELTA_X: " << m_datumDef->delta_X << std::endl
                       << "        DELTA_Y: " << m_datumDef->delta_Y << std::endl
                       << "        DELTA_Z: " << m_datumDef->delta_Z << std::endl
                       << "          ROT_X: " << m_datumDef->rot_X << std::endl
                       << "          ROT_Y: " << m_datumDef->rot_Y << std::endl
                       << "          ROT_Z: " << m_datumDef->rot_Z << std::endl;
            break;

        case cs_DTCTYP_4PARM:
            DatumAsAscStream << "            USE: 4PARAMETER" << std::endl;
            DatumAsAscStream << "        DELTA_X: " << m_datumDef->delta_X << std::endl
                       << "        DELTA_Y: " << m_datumDef->delta_Y << std::endl
                       << "        DELTA_Z: " << m_datumDef->delta_Z << std::endl
                       << "        BWSCALE: " << m_datumDef->bwscale << std::endl;
            break;

        case cs_DTCTYP_AGD84:
            DatumAsAscStream << "            USE: AGD84" << std::endl;
            break;

        case cs_DTCTYP_NZGD49:
            DatumAsAscStream << "            USE: NZGD49" << std::endl;
            break;

        case cs_DTCTYP_ATS77:
            DatumAsAscStream << "            USE: ATS77" << std::endl;
            break;

        case cs_DTCTYP_GDA94:
            DatumAsAscStream << "            USE: GDA94" << std::endl;
            break;

        case cs_DTCTYP_NZGD2K:
            DatumAsAscStream << "            USE: NZGD2K" << std::endl;
            break;

        case cs_DTCTYP_CSRS:
            DatumAsAscStream << "            USE: CSRS" << std::endl;
            break;

        case cs_DTCTYP_TOKYO:
            DatumAsAscStream << "            USE: JGD2K" << std::endl;
            break;

        case cs_DTCTYP_RGF93:
            DatumAsAscStream << "            USE: RGF93" << std::endl;
            break;

        case cs_DTCTYP_ED50:
            DatumAsAscStream << "            USE: ED50" << std::endl;
            break;

        case cs_DTCTYP_ETRF89:
            DatumAsAscStream << "            USE: ETRF89" << std::endl;
            break;

#ifdef GEOCOORD_ENHANCEMENT
        case cs_DTCTYP_GENGRID:
            DatumAsAscStream << "            USE: GENGRID" << std::endl;
            break;
#endif

        case cs_DTCTYP_PLYNM:
            DatumAsAscStream << "            USE: POLYNM" << std::endl;
            break;

        default:
            return ERROR;
        }

    DatumAsAscStream << std::endl;

    DatumAsASC = DatumAsAscStream.str();

    return status;
    }
#endif

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP    Datum::GetGroup (Utf8StringR groupName) const
    {
    groupName.clear();

    if (NULL != m_datumDef)
        groupName = m_datumDef->group;

    return groupName.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt    Datum::SetGroup (Utf8StringCR groupName)
    {
    if (NULL == m_datumDef)
        return GEOCOORDERR_InvalidDatum;

    // Check size (23 chars max for ellipsoid groups)
    if (groupName.size() >= DIM(m_datumDef->group))
        return GEOCOORDERR_BadArg;

    CSMap::CS_stncp (m_datumDef->group, groupName.c_str(), DIM(m_datumDef->group));

    return SUCCESS;
    }

/*=================================================================================**//**
* GridFileDefinition Class
+===============+===============+===============+===============+===============+======*/

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GridFileDefinition::GridFileDefinition(const char* fileName, GridFileFormat format, GridFileDirection direction)
    {
    BeAssert(direction == GridFileDirection::DIRECTION_DIRECT ||
             direction == GridFileDirection::DIRECTION_INVERSE ||
             direction == GridFileDirection::DIRECTION_NONE);

    m_format = format;
    m_direction = direction;
    m_fileName = GeoCoordWorkspaces::ToUnixName(fileName);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GridFileDefinition::GridFileDefinition(const GridFileDefinition& obj)
    {
    m_format = obj.m_format;
    m_direction = obj.m_direction;
    m_fileName = obj.m_fileName;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GridFileDefinition::~GridFileDefinition() {}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GridFileDefinition& GridFileDefinition::operator=(const GridFileDefinition& obj)
    {
    if (this != &obj)
        {
        m_format = obj.m_format;
        m_direction = obj.m_direction;
        m_fileName = obj.m_fileName;
        }
    return *this;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
const Utf8String& GridFileDefinition::GetFileName() const
    {
    return m_fileName;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void GridFileDefinition::SetFileName(const Utf8CP newFileName)
    {
    m_fileName = newFileName;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GridFileFormat GridFileDefinition::GetFormat() const
    {
    return m_format;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void GridFileDefinition::SetFormat(GridFileFormat newFormat)
    {
    m_format = newFormat;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GridFileDirection GridFileDefinition::GetDirection() const
    {
    return m_direction;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void GridFileDefinition::SetDirection(GridFileDirection newDirection)
    {
    m_direction = newDirection;
    }

/*---------------------------------------------------------------------------------**//**
* STATIC FUNCTION (Documentation in declaration above)
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt FillListOfTransformsFromCSDatumConvert(bvector<GeodeticTransformP>& listOfTransforms, CSDatumConvert const & datumConverter)
    {
    for (size_t index = 0; index < static_cast<size_t>(datumConverter.xfrmCount); index++)
        {
        GeodeticTransformP newGeodeticTransform = GeodeticTransform::CreateGeodeticTransform(*(datumConverter.xforms[index]));

        if (nullptr != newGeodeticTransform)
            listOfTransforms.push_back(newGeodeticTransform);
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* STATIC FUNCTION (Documentation in declaration above)
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
static bool     RepresentsNullTransform(bvector<GeodeticTransformP> const& listOfTransforms)
    {
    bvector<GeodeticTransformP> workingCopyOfList;

    for (auto transform : listOfTransforms)
        {
        if ((nullptr != transform) && (!transform->IsNullTransform()))
            workingCopyOfList.push_back(transform->Clone());
        }

    // If the number of transforms is odd then they cannot be equivalent
    if (workingCopyOfList.size() % 2 != 0)
        {
        for (auto trf : workingCopyOfList)
            trf->Destroy();

        workingCopyOfList.clear();

        return false;
        }

    size_t midSize = workingCopyOfList.size() / 2;

    bool identical = true;
    for (size_t index = 0 ; (identical) && (index < midSize); index++)
        {
        GeodeticTransformP reversedTransform = workingCopyOfList[index]->Clone();
        if (nullptr == reversedTransform)
            identical = false;
        else
            {
            if (SUCCESS != reversedTransform->Reverse())
                identical = false;
            else
                identical = workingCopyOfList[workingCopyOfList.size() - index - 1]->IsEquivalent(*reversedTransform);

            reversedTransform->Destroy();
            }
        }

    for (auto trf2 : workingCopyOfList)
        trf2->Destroy();

    workingCopyOfList.clear();

    return identical;
    }

/*---------------------------------------------------------------------------------**//**
* STATIC FUNCTION (Documentation in declaration above)
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
static bool     GeodeticTransformPathAreEquivalent(bvector<GeodeticTransformP> const& listOfTransforms1, bvector<GeodeticTransformP> const& listOfTransforms2, bool looselyCompare)
    {
    // If both are null transforms ... then that is it
    if (RepresentsNullTransform(listOfTransforms1) && RepresentsNullTransform(listOfTransforms2))
        return true;

    size_t index2 = 0; // This points to the next geodetic transform in the compared converter
    for (size_t index1 = 0; index1 < listOfTransforms1.size(); ++index1)
    {
        GeodeticTransformCP currentTransform = listOfTransforms1[index1];

        if (nullptr == currentTransform)
            return false;

        if (!currentTransform->IsNullTransform())
        {
            GeodeticTransformCP compareTransform;
            do {
                // Find the next non-null transform in compare converter
                if (index2 >= listOfTransforms2.size())
                    return false;

                compareTransform = listOfTransforms2[index2];
                if (nullptr == compareTransform)
                    return false;

                index2++;
            } while (compareTransform->IsNullTransform());

            if (!currentTransform->IsEquivalent(*compareTransform, looselyCompare))
                return false;
        }
    }

    // If we get here then we have found an equivalent transform for every non-null transforms of self
    // All we need to verify now is that there are no additional transforms in the compared converter.
    for (; index2 < listOfTransforms2.size(); index2++) // index2 already points to the next transform
    {
        GeodeticTransformCP compareTransform2 = listOfTransforms2[index2];
        if (nullptr == compareTransform2)
            return false;

        if (!compareTransform2->IsNullTransform())
            return false;
    }

    return true;
    }

/*=================================================================================**//**
* GeodeticTransform Class
+===============+===============+===============+===============+===============+======*/
/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformP             GeodeticTransform::CreateGeodeticTransform ()
    {
    return new GeodeticTransform ();
    }

/*---------------------------------------------------------------------------------**//**
// TODO Not sure needed
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformP             GeodeticTransform::CreateGeodeticTransform (Utf8CP keyName)
    {
    return new GeodeticTransform (keyName);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransform::GeodeticTransform ()
    {
    m_csError = 0;
    if (!BaseGCS::IsLibraryInitialized())
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;

    m_geodeticTransformDef                   = (CSGeodeticTransformDef*) CS_malc (sizeof (CSGeodeticTransformDef));
    memset(m_geodeticTransformDef, 0, sizeof(CSGeodeticTransformDef));
    CS_stncp(m_geodeticTransformDef->xfrmName, "Unnamed", _countof(m_geodeticTransformDef->xfrmName));
    m_geodeticTransformDef->cnvrgValue = 1e-09;
    m_geodeticTransformDef->errorValue = 1e-06;
    m_geodeticTransformDef->accuracy = 1.0;
    m_geodeticTransformDef->maxIterations = 20;

    m_sourceEllipsoid            = NULL;
    m_targetEllipsoid            = NULL;
    m_dataAvailability = GeodeticTransformDataAvailability::AvailabilityUnknown;
    m_fallback                   = NULL;
    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    m_sourceString               = NULL;
    m_sourceDatumString          = NULL;
    m_destDatumString            = NULL;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransform::GeodeticTransform (const GridFileDefinition& gridFileDefinition)
    {
    m_csError = 0;
    if (!BaseGCS::IsLibraryInitialized())
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;

    m_geodeticTransformDef                   = (CSGeodeticTransformDef*) CS_malc (sizeof (CSGeodeticTransformDef));
    memset(m_geodeticTransformDef, 0, sizeof(CSGeodeticTransformDef));
    CS_stncp(m_geodeticTransformDef->xfrmName, "Unnamed", _countof(m_geodeticTransformDef->xfrmName));
    m_geodeticTransformDef->cnvrgValue = 1e-09;
    m_geodeticTransformDef->errorValue = 1e-06;
    m_geodeticTransformDef->accuracy = 1.0;
    m_geodeticTransformDef->maxIterations = 20;

    m_sourceEllipsoid            = NULL;
    m_targetEllipsoid            = NULL;
    m_dataAvailability = GeodeticTransformDataAvailability::AvailabilityUnknown;
    m_fallback                   = NULL;

    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    m_sourceString               = NULL;
    m_sourceDatumString          = NULL;
    m_destDatumString            = NULL;

    SetConvertMethodCode(GenConvertCode::GenConvertType_GFILE);
    AddGridFileDefinition(gridFileDefinition);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransform::GeodeticTransform (Utf8CP keyName)
    {
    if (!BaseGCS::IsLibraryInitialized())
        {
        m_geodeticTransformDef = NULL;
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        }
    else
        {
        m_geodeticTransformDef         = CSMap::CS_gxdef (keyName);
        m_csError          = (NULL != m_geodeticTransformDef) ? 0 : cs_Error;
        }

    m_dataAvailability = GeodeticTransformDataAvailability::AvailabilityUnknown;

    m_fallback                   = NULL; // TODO extract fallback if there is one.
    if (nullptr != m_geodeticTransformDef && m_geodeticTransformDef->methodCode == (short)GenConvertCode::GenConvertType_GFILE)
        {
        // Check for presence of a fallback
        if (Utf8String(m_geodeticTransformDef->parameters.fileParameters.fallback).size() > 0)
            {
            m_fallback = GeodeticTransform::CreateGeodeticTransform(m_geodeticTransformDef->parameters.fileParameters.fallback);

            // Validate fallback
            if (nullptr != m_fallback)
                {
                GenConvertCode convertCode = m_fallback->GetConvertMethodCode();
                if (convertCode != GenConvertCode::GenConvertType_3PARM && convertCode != GenConvertCode::GenConvertType_MOLO &&
                    convertCode != GenConvertCode::GenConvertType_GEOCTR && convertCode != GenConvertCode::GenConvertType_4PARM &&
                    convertCode != GenConvertCode::GenConvertType_6PARM && convertCode != GenConvertCode::GenConvertType_BURS &&
                    convertCode != GenConvertCode::GenConvertType_7PARM)
                    {
                    // invalid convertion method
                    m_fallback->Destroy();
                    m_fallback = nullptr;
                    }
                else if (convertCode == GenConvertCode::GenConvertType_3PARM || convertCode == GenConvertCode::GenConvertType_MOLO ||
                         convertCode == GenConvertCode::GenConvertType_GEOCTR || convertCode == GenConvertCode::GenConvertType_4PARM ||
                         convertCode == GenConvertCode::GenConvertType_6PARM || convertCode == GenConvertCode::GenConvertType_BURS)
                    {
                    // One geocentric method but we normalize to 7 parameters
                    m_fallback->SetConvertMethodCode(GenConvertCode::GenConvertType_7PARM);
                    }
                }
            }
        }

    m_sourceEllipsoid            = NULL;
    m_targetEllipsoid            = NULL;

    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    m_sourceString               = NULL;
    m_sourceDatumString          = NULL;
    m_destDatumString            = NULL;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformP             GeodeticTransform::CreateGeodeticTransform
(const GridFileDefinition& gridFileDefinition)
    {
    return new GeodeticTransform (gridFileDefinition);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformP             GeodeticTransform::CreateGeodeticTransform(CSGeodeticTransform const& geodeticTransform)
    {
    return new GeodeticTransform(geodeticTransform);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformP             GeodeticTransform::CreateGeodeticTransform
(CSGeodeticTransformDef const& geodeticTransformDef,
 GeodeticTransformDataAvailability dataAvailability,
 EllipsoidP sourceEllipsoid,
 EllipsoidP targetEllipsoid,
 CSGeodeticTransformDef const * fallback)
    {
    return new GeodeticTransform (geodeticTransformDef, dataAvailability, sourceEllipsoid, targetEllipsoid, fallback);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransform::GeodeticTransform(CSGeodeticTransform const& geodeticTransform)
    {

    bool direct = (geodeticTransform.userDirection == 1);

    // Capture fallback is appropriate
    CSGeodeticTransformDef const* fallbackXtrfDef = nullptr;
    if (geodeticTransform.methodCode == cs_DTCMTH_GFILE && (nullptr != geodeticTransform.xforms.gridi.fallback))
        fallbackXtrfDef = &(geodeticTransform.xforms.gridi.fallback->gxDef);

    // If custom ellispoids convert from xform
    Ellipsoid* srcEllipsoid = nullptr;
    DatumCP tempDatum = nullptr;
    tempDatum = Datum::CreateDatum(geodeticTransform.srcDatum.key_nm);
    if (nullptr != tempDatum)
        {
        // Datum known ... no need for custom ellipsoid
        tempDatum->Destroy();
        tempDatum = nullptr;
        }
    else
        {
        // Unknown datum ... we will create a custom ellipsoid
        srcEllipsoid = Ellipsoid::CreateEllipsoid();
        srcEllipsoid->SetName(geodeticTransform.srcDatum.ell_knm);
        srcEllipsoid->SetPolarRadius(geodeticTransform.srcDatum.p_rad);
        srcEllipsoid->SetEquatorialRadius(geodeticTransform.srcDatum.e_rad);
        }

    Ellipsoid* trgEllipsoid = nullptr;
    tempDatum = Datum::CreateDatum(geodeticTransform.trgDatum.key_nm);
    if (nullptr != tempDatum)
        {
        // Datum known ... no need for custom ellipsoid
        tempDatum->Destroy();
        tempDatum = nullptr;
        }
    else
        {
        // Unknown datum ... we will create a custom ellipsoid
        trgEllipsoid = Ellipsoid::CreateEllipsoid();
        trgEllipsoid->SetName(geodeticTransform.trgDatum.ell_knm);
        trgEllipsoid->SetPolarRadius(geodeticTransform.trgDatum.p_rad);
        trgEllipsoid->SetEquatorialRadius(geodeticTransform.trgDatum.e_rad);
        }

    m_dataAvailability = GeodeticTransformDataAvailability::DataAvailable;

    if (geodeticTransform.methodCode == cs_DTCMTH_NONE)
        m_dataAvailability = GeodeticTransformDataAvailability::DataUnavailable;
    else if (geodeticTransform.methodCode == cs_DTCMTH_SKIP)
        m_dataAvailability = GeodeticTransformDataAvailability::AvailabilityUnknown;

    if (!BaseGCS::IsLibraryInitialized())
        {
        m_geodeticTransformDef = NULL;
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        }
    else
        {
        m_geodeticTransformDef = (CSGeodeticTransformDef*)CS_malc(sizeof(CSGeodeticTransformDef));
        memcpy(m_geodeticTransformDef, &(geodeticTransform.gxDef), sizeof(CSGeodeticTransformDef));
        m_csError = 0;
        }

    m_fallback = nullptr;
    if (nullptr != fallbackXtrfDef)
        m_fallback = GeodeticTransform::CreateGeodeticTransform(*fallbackXtrfDef);

    // Validate fallback
    if (nullptr != m_fallback)
        {
        GenConvertCode convertCode = m_fallback->GetConvertMethodCode();
        if (convertCode != GenConvertCode::GenConvertType_3PARM && convertCode != GenConvertCode::GenConvertType_MOLO &&
            convertCode != GenConvertCode::GenConvertType_GEOCTR && convertCode != GenConvertCode::GenConvertType_4PARM &&
            convertCode != GenConvertCode::GenConvertType_6PARM && convertCode != GenConvertCode::GenConvertType_BURS &&
            convertCode != GenConvertCode::GenConvertType_7PARM)
            {
            // invalid convertion method
            m_fallback->Destroy();
            m_fallback = nullptr;
            }
        else if (convertCode == GenConvertCode::GenConvertType_3PARM || convertCode == GenConvertCode::GenConvertType_MOLO ||
            convertCode == GenConvertCode::GenConvertType_GEOCTR || convertCode == GenConvertCode::GenConvertType_4PARM ||
            convertCode == GenConvertCode::GenConvertType_6PARM || convertCode == GenConvertCode::GenConvertType_BURS)
            {
            // One geocentric method but we normalize to 7 parameters
            m_fallback->SetConvertMethodCode(GenConvertCode::GenConvertType_7PARM);
            }
        }

    // Even if no fallback provided the main definition can have one
    if (nullptr == m_fallback && nullptr != m_geodeticTransformDef && m_geodeticTransformDef->methodCode == (short)GenConvertCode::GenConvertType_GFILE)
        {
        // Check for presence of a fallback
        if (Utf8String(m_geodeticTransformDef->parameters.fileParameters.fallback).size() > 0)
            {
            m_fallback = GeodeticTransform::CreateGeodeticTransform(m_geodeticTransformDef->parameters.fileParameters.fallback);

            // Validate fallback
            if (nullptr != m_fallback)
                {
                GenConvertCode convertCode = m_fallback->GetConvertMethodCode();
                if (convertCode != GenConvertCode::GenConvertType_3PARM && convertCode != GenConvertCode::GenConvertType_MOLO &&
                    convertCode != GenConvertCode::GenConvertType_GEOCTR && convertCode != GenConvertCode::GenConvertType_4PARM &&
                    convertCode != GenConvertCode::GenConvertType_6PARM && convertCode != GenConvertCode::GenConvertType_BURS &&
                    convertCode != GenConvertCode::GenConvertType_7PARM)
                    {
                    // invalid convertion method
                    m_fallback->Destroy();
                    m_fallback = nullptr;
                    }
                else if (convertCode == GenConvertCode::GenConvertType_3PARM || convertCode == GenConvertCode::GenConvertType_MOLO ||
                    convertCode == GenConvertCode::GenConvertType_GEOCTR || convertCode == GenConvertCode::GenConvertType_4PARM ||
                    convertCode == GenConvertCode::GenConvertType_6PARM || convertCode == GenConvertCode::GenConvertType_BURS)
                    {
                    // One geocentric method but we normalize to 7 parameters
                    m_fallback->SetConvertMethodCode(GenConvertCode::GenConvertType_7PARM);
                    }
                }
            }
        }

    m_sourceEllipsoid = srcEllipsoid;
    m_targetEllipsoid = trgEllipsoid;

    m_nameString = NULL;
    m_descriptionString = NULL;
    m_sourceString = NULL;
    m_sourceDatumString = NULL;
    m_destDatumString = NULL;

    // Make sure they use the same datum name and ellipsoid();
    if (nullptr != m_fallback)
        {
        m_fallback->SetSourceDatumName(GetSourceDatumName());
        m_fallback->SetTargetDatumName(GetTargetDatumName());
        if (nullptr != m_sourceEllipsoid)
            m_fallback->SetSourceEllipsoid(m_sourceEllipsoid->Clone());
        if (nullptr != m_targetEllipsoid)
            m_fallback->SetTargetEllipsoid(m_targetEllipsoid->Clone());
        }

    // Then finally if the direction is reversed ... we reverse self
    if (!direct)
        this->Reverse();
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransform::GeodeticTransform (
 CSGeodeticTransformDef const& geodeticTransformDef,
 GeodeticTransformDataAvailability dataAvailability,
 EllipsoidP sourceEllipsoid,
 EllipsoidP targetEllipsoid,
 CSGeodeticTransformDef const * fallback)
    {
    m_dataAvailability = dataAvailability;

    if (!BaseGCS::IsLibraryInitialized())
        {
        m_geodeticTransformDef = NULL;
        m_csError = GEOCOORDERR_GeoCoordNotInitialized;
        }
    else
        {
        m_geodeticTransformDef                   = (CSGeodeticTransformDef*) CS_malc (sizeof (CSGeodeticTransformDef));
        memcpy (m_geodeticTransformDef, &geodeticTransformDef, sizeof(CSGeodeticTransformDef));
        m_csError                    = 0;
        }

    m_fallback = nullptr;
    if (nullptr != fallback)
        m_fallback = GeodeticTransform::CreateGeodeticTransform(*fallback);

    // Validate fallback
    if (nullptr != m_fallback)
        {
        GenConvertCode convertCode = m_fallback->GetConvertMethodCode();
        if (convertCode != GenConvertCode::GenConvertType_3PARM && convertCode != GenConvertCode::GenConvertType_MOLO &&
            convertCode != GenConvertCode::GenConvertType_GEOCTR && convertCode != GenConvertCode::GenConvertType_4PARM &&
            convertCode != GenConvertCode::GenConvertType_6PARM && convertCode != GenConvertCode::GenConvertType_BURS &&
            convertCode != GenConvertCode::GenConvertType_7PARM)
            {
            // invalid convertion method
            m_fallback->Destroy();
            m_fallback = nullptr;
            }
        else if (convertCode == GenConvertCode::GenConvertType_3PARM || convertCode == GenConvertCode::GenConvertType_MOLO ||
                 convertCode == GenConvertCode::GenConvertType_GEOCTR || convertCode == GenConvertCode::GenConvertType_4PARM ||
                 convertCode == GenConvertCode::GenConvertType_6PARM || convertCode == GenConvertCode::GenConvertType_BURS)
            {
            // One geocentric method but we normalize to 7 parameters
            m_fallback->SetConvertMethodCode(GenConvertCode::GenConvertType_7PARM);
            }
        }

    // Even if no fallback provided the main definition can have one
    if (nullptr == m_fallback && nullptr != m_geodeticTransformDef && m_geodeticTransformDef->methodCode == (short)GenConvertCode::GenConvertType_GFILE)
        {
        // Check for presence of a fallback
        if (Utf8String(m_geodeticTransformDef->parameters.fileParameters.fallback).size() > 0)
            {
            m_fallback = GeodeticTransform::CreateGeodeticTransform(m_geodeticTransformDef->parameters.fileParameters.fallback);

            // Validate fallback
            if (nullptr != m_fallback)
                {
                GenConvertCode convertCode = m_fallback->GetConvertMethodCode();
                if (convertCode != GenConvertCode::GenConvertType_3PARM && convertCode != GenConvertCode::GenConvertType_MOLO &&
                    convertCode != GenConvertCode::GenConvertType_GEOCTR && convertCode != GenConvertCode::GenConvertType_4PARM &&
                    convertCode != GenConvertCode::GenConvertType_6PARM && convertCode != GenConvertCode::GenConvertType_BURS &&
                    convertCode != GenConvertCode::GenConvertType_7PARM)
                    {
                    // invalid convertion method
                    m_fallback->Destroy();
                    m_fallback = nullptr;
                    }
                else if (convertCode == GenConvertCode::GenConvertType_3PARM || convertCode == GenConvertCode::GenConvertType_MOLO ||
                         convertCode == GenConvertCode::GenConvertType_GEOCTR || convertCode == GenConvertCode::GenConvertType_4PARM ||
                         convertCode == GenConvertCode::GenConvertType_6PARM || convertCode == GenConvertCode::GenConvertType_BURS)
                    {
                    // One geocentric method but we normalize to 7 parameters
                    m_fallback->SetConvertMethodCode(GenConvertCode::GenConvertType_7PARM);
                    }
                }
            }
        }

    m_sourceEllipsoid            = sourceEllipsoid;
    m_targetEllipsoid            = targetEllipsoid;

    m_nameString                 = NULL;
    m_descriptionString          = NULL;
    m_sourceString               = NULL;
    m_sourceDatumString          = NULL;
    m_destDatumString            = NULL;

    // Make sure they use the same datum name and ellipsoid();
    if (nullptr != m_fallback)
        {
        m_fallback->SetSourceDatumName(GetSourceDatumName());
        m_fallback->SetTargetDatumName(GetTargetDatumName());
        if (nullptr != m_sourceEllipsoid)
            m_fallback->SetSourceEllipsoid(m_sourceEllipsoid->Clone());
        if (nullptr != m_targetEllipsoid)
            m_fallback->SetTargetEllipsoid(m_targetEllipsoid->Clone());
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool  GeodeticTransform::IsDeprecated() const
    {
    static Utf8String deprecated("LEGACY");

    Utf8String groupName;

    return (0 == deprecated.CompareTo(GetGroup(groupName)));
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP    GeodeticTransform::GetGroup (Utf8StringR groupName) const
    {
    groupName.clear();

    if (NULL != m_geodeticTransformDef)
        groupName = m_geodeticTransformDef->group;

    return groupName.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt    GeodeticTransform::SetGroup (Utf8StringCR groupName)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    // Check size (23 chars max for ellipsoid groups)
    if (groupName.size() >= DIM(m_geodeticTransformDef->group))
        return GEOCOORDERR_BadArg;

    CSMap::CS_stncp (m_geodeticTransformDef->group, groupName.c_str(), DIM(m_geodeticTransformDef->group));

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            GeodeticTransform::IsVerticallyNeutral () const
    {
    if (NULL == m_geodeticTransformDef)
        return false;

    // Now verify the transformation process proper
    bool transformIsGeocentric = (m_geodeticTransformDef->methodCode == cs_DTCMTH_MOLOD ||
                                  m_geodeticTransformDef->methodCode == cs_DTCMTH_3PARM ||
                                  m_geodeticTransformDef->methodCode == cs_DTCMTH_GEOCT ||
                                  m_geodeticTransformDef->methodCode == cs_DTCMTH_7PARM ||
                                  m_geodeticTransformDef->methodCode == cs_DTCMTH_4PARM ||
                                  m_geodeticTransformDef->methodCode == cs_DTCMTH_6PARM ||
                                  m_geodeticTransformDef->methodCode == cs_DTCMTH_BURSA ||
                                  m_geodeticTransformDef->methodCode == cs_DTCMTH_FRAME ||
                                  m_geodeticTransformDef->methodCode == cs_DTCMTH_BDKAS);

    if (!transformIsGeocentric && m_geodeticTransformDef->methodCode != cs_DTCMTH_MULRG && m_geodeticTransformDef->methodCode != cs_DTCMTH_PLYNM)
        return true; // Non-geocentric transforms (grid file, multiple regression...) do not affect elevation except mulreg and polynomial.

    // Some method not inherently vertical neutral ... it may define a null transform
    return IsNullTransform();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            GeodeticTransform::IsEquivalent (GeodeticTransformCR compareTo, bool looselyCompare) const
    {
    if (NULL == m_geodeticTransformDef)
        return false;

    if (NULL == compareTo.m_geodeticTransformDef)
        return false;

    // Verify ellipsoids are compatible
    EllipsoidCP sourceEllipsoid1 = GetSourceEllipsoid();
    EllipsoidCP sourceEllipsoid2 = compareTo.GetSourceEllipsoid();
    if (nullptr != sourceEllipsoid1 && nullptr != sourceEllipsoid2 && !sourceEllipsoid1->IsEquivalent(*sourceEllipsoid2))
        return false;

    EllipsoidCP targetEllipsoid1 = GetTargetEllipsoid();
    EllipsoidCP targetEllipsoid2 = compareTo.GetTargetEllipsoid();
    if (nullptr != targetEllipsoid1 && nullptr != targetEllipsoid2 && !targetEllipsoid1->IsEquivalent(*targetEllipsoid2))
        return false;

    // Compare fallback ... if one has a fallback then the other must
    if ((nullptr != m_fallback && nullptr == compareTo.m_fallback) || (nullptr == m_fallback && nullptr != compareTo.m_fallback))
        return false;

    // And fallback must be equivalent
    if (nullptr != m_fallback && nullptr != compareTo.m_fallback && !m_fallback->IsEquivalent(*(compareTo.m_fallback)))
        return false;

    // Now verify the transformation process proper
    bool transform1IsGeocentric = (m_geodeticTransformDef->methodCode == cs_DTCMTH_MOLOD ||
                                   m_geodeticTransformDef->methodCode == cs_DTCMTH_3PARM ||
                                   m_geodeticTransformDef->methodCode == cs_DTCMTH_GEOCT ||
                                   m_geodeticTransformDef->methodCode == cs_DTCMTH_7PARM ||
                                   m_geodeticTransformDef->methodCode == cs_DTCMTH_4PARM ||
                                   m_geodeticTransformDef->methodCode == cs_DTCMTH_6PARM ||
                                   m_geodeticTransformDef->methodCode == cs_DTCMTH_BURSA ||
                                   m_geodeticTransformDef->methodCode == cs_DTCMTH_FRAME ||
                                   m_geodeticTransformDef->methodCode == cs_DTCMTH_BDKAS);

    bool transform2IsGeocentric = (compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_MOLOD ||
                                   compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_3PARM ||
                                   compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_GEOCT ||
                                   compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_7PARM ||
                                   compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_4PARM ||
                                   compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_6PARM ||
                                   compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_BURSA ||
                                   compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_FRAME ||
                                   compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_BDKAS);

    if (transform1IsGeocentric && transform2IsGeocentric)
        {
        if (!looselyCompare)
            {
            if ((m_geodeticTransformDef->methodCode       != compareTo.m_geodeticTransformDef->methodCode) ||
                (!doubleSame(m_geodeticTransformDef->accuracy, compareTo.m_geodeticTransformDef->accuracy)))
                return false;
            }

        if (!doubleSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.deltaX,     m_geodeticTransformDef->parameters.geocentricParameters.deltaX) ||
            !doubleSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.deltaY,     m_geodeticTransformDef->parameters.geocentricParameters.deltaY) ||
            !doubleSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.deltaZ,     m_geodeticTransformDef->parameters.geocentricParameters.deltaZ) ||
            !arcSecondsSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.rotateX,    m_geodeticTransformDef->parameters.geocentricParameters.rotateX) ||
            !arcSecondsSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.rotateY,    m_geodeticTransformDef->parameters.geocentricParameters.rotateY) ||
            !arcSecondsSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.rotateZ,    m_geodeticTransformDef->parameters.geocentricParameters.rotateZ) ||
            !scalePPMSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.scale,      m_geodeticTransformDef->parameters.geocentricParameters.scale) ||
            !doubleSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.translateX, m_geodeticTransformDef->parameters.geocentricParameters.translateX) ||
            !doubleSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.translateY, m_geodeticTransformDef->parameters.geocentricParameters.translateY) ||
            !doubleSame(compareTo.m_geodeticTransformDef->parameters.geocentricParameters.translateZ, m_geodeticTransformDef->parameters.geocentricParameters.translateZ))
             return false;

        return true;
        }
    else if (IsNullTransform() && compareTo.IsNullTransform())
        {
        // Both are null or equivalent so they are equivalent
        return true;
        }
    else if (((cs_DTCPRMTYP_GRIDINTP & cs_DTCPRMTYP_MASK) == (m_geodeticTransformDef->methodCode & cs_DTCPRMTYP_MASK)) &&
             ((cs_DTCPRMTYP_GRIDINTP & cs_DTCPRMTYP_MASK) == (compareTo.m_geodeticTransformDef->methodCode & cs_DTCPRMTYP_MASK)))
        {
        // Both are grid file based
        struct cs_GeodeticTransform_::csGeodeticXformParameters::csGeodeticXformParmsGridFiles_* datum1GridXForm = (struct cs_GeodeticTransform_::csGeodeticXformParameters::csGeodeticXformParmsGridFiles_*)&(m_geodeticTransformDef->parameters.fileParameters);
        struct cs_GeodeticTransform_::csGeodeticXformParameters::csGeodeticXformParmsGridFiles_* datum2GridXForm = (struct cs_GeodeticTransform_::csGeodeticXformParameters::csGeodeticXformParmsGridFiles_*)&(compareTo.m_geodeticTransformDef->parameters.fileParameters);

        if (nullptr == datum1GridXForm || nullptr == datum2GridXForm)
            return false;

        // First test the various numeric parameters
        if (datum1GridXForm->fileReferenceCount != datum2GridXForm->fileReferenceCount)
            return false;

        // Fallback requires some detail checking
        if (!looselyCompare && (0 != strncmp(datum1GridXForm->fallback, datum2GridXForm->fallback, sizeof (datum2GridXForm->fallback))))
            return false;

        // All that remains is to compare file names and individual grid shift file method params. Notice that the order of the files is important
        // for grid shift files so we impose the exact same order also
        for (short fileIdx = 0 ; (fileIdx < datum1GridXForm->fileReferenceCount) ; fileIdx++)
            {
            // Only selected fields are tested as the structure contains cache and buffering members.
            if ((datum1GridXForm->fileNames[fileIdx].direction != datum2GridXForm->fileNames[fileIdx].direction) ||
                (datum1GridXForm->fileNames[fileIdx].fileFormat != datum2GridXForm->fileNames[fileIdx].fileFormat))
                return false;

            // All that remains to check is the filename. We normalize the slashes to UNIX style.
            Utf8String filePath1(datum1GridXForm->fileNames[fileIdx].fileName);
            Utf8String filePath2(datum2GridXForm->fileNames[fileIdx].fileName);

            // Change windows slash into unix slashes.
            size_t location;
            while ((location = filePath1.find("\\")) != std::string::npos)
                {
                filePath1.replace(location, 1, "/");
                }

            while ((location = filePath2.find("\\")) != std::string::npos)
                {
                filePath2.replace(location, 1, "/");
                }

            if (filePath1 != filePath2)
                return false;
            }

        return true;
        }
    else if ((compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_MULRG) && (m_geodeticTransformDef->methodCode == cs_DTCMTH_MULRG))
        {
        // Both are multiple regression ... parameters are associated to name and direction we do not have ...
        // we will assume correct since user-defined transforms cannot be Multiple Regression
        return true;
        }
    else if ((compareTo.m_geodeticTransformDef->methodCode == cs_DTCMTH_WGS72) && (m_geodeticTransformDef->methodCode == cs_DTCMTH_WGS72))
        {
        // Standalone method that is not NULLX
        return true;
        }


    // Out of options ... we do not know what this is
    return false;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt GeodeticTransform::Reverse() {
    if (NULL == m_geodeticTransformDef)
        return ERROR;

    // Source and target names must be reversed
    Utf8String xfrmName = Utf8String(m_geodeticTransformDef->srcDatum) + "_to_" + m_geodeticTransformDef->trgDatum;

    char buffer[512];
    CS_stncp(buffer, m_geodeticTransformDef->trgDatum, _countof(m_geodeticTransformDef->trgDatum));
    DELETE_AND_CLEAR(m_destDatumString);
    CS_stncp(m_geodeticTransformDef->trgDatum, m_geodeticTransformDef->srcDatum, _countof(m_geodeticTransformDef->trgDatum));
    DELETE_AND_CLEAR(m_sourceDatumString);
    CS_stncp(m_geodeticTransformDef->srcDatum, buffer, _countof(m_geodeticTransformDef->trgDatum));

    // Fix transform name if required.
    if (xfrmName == m_geodeticTransformDef->xfrmName || xfrmName == "" || xfrmName == "Unnamed") {
        xfrmName = Utf8String(m_geodeticTransformDef->srcDatum) + "_to_" + m_geodeticTransformDef->trgDatum;
        if (xfrmName != "")
            CS_stncp(m_geodeticTransformDef->xfrmName, xfrmName.c_str(), _countof(m_geodeticTransformDef->xfrmName));
    }

    // Inverse the ellipsoids
    EllipsoidCP swapEllipsoid = m_sourceEllipsoid;
    m_sourceEllipsoid = m_targetEllipsoid;
    m_targetEllipsoid = swapEllipsoid;

    if (IsNullTransform())
        return SUCCESS; // Null transform need no reversal

    switch (GetConvertMethodCode())
        {
        case GenConvertCode::GenConvertType_NONE:
            return SUCCESS;

        case GenConvertCode::GenConvertType_MOLO:
        case GenConvertCode::GenConvertType_3PARM:
        case GenConvertCode::GenConvertType_GEOCTR:
            {
            // Simply negate the values
            DPoint3d delta;
            GetDelta(delta);
            delta.x = -delta.x;
            delta.y = -delta.y;
            delta.z = -delta.z;
            SetDelta(delta);
            return SUCCESS;
            }

        case GenConvertCode::GenConvertType_4PARM:
            {
            // Simply negate the values and inverse the scale
            DPoint3d delta;
            GetDelta(delta);
            delta.x = -delta.x;
            delta.y = -delta.y;
            delta.z = -delta.z;
            SetDelta(delta);
            double scale = GetScale(); // The scale is difference from 1.0, not a true scale factor
            SetScale(-scale);
            return SUCCESS;
            }
        case GenConvertCode::GenConvertType_BURS:
        case GenConvertCode::GenConvertType_7PARM:
        case GenConvertCode::GenConvertType_6PARM:
        case GenConvertCode::GenConvertType_BDKAS: // NOTE Molodenski Badekas has an additional final step
            {
            // Rotation components inject some complexity.
            DPoint3d delta;
            GetDelta(delta);
            DPoint3d rotation;
            GetRotation(rotation);
            double scalePPM = GetScale();
            double scale = 1 + (scalePPM * 0.000001);

            DPoint3d rotationRadian;
            // Rotations are expressed in arc seconds --> convert to radians
            rotationRadian.x = Angle::DegreesToRadians(rotation.x / 3600.0);
            rotationRadian.y = Angle::DegreesToRadians(rotation.y / 3600.0);
            rotationRadian.z = Angle::DegreesToRadians(rotation.z / 3600.0);

            // There is probably an easier way to set the rotation matrix with all three angles but this one works
            double          x00 = cos(rotationRadian.y) * cos(rotationRadian.z);
            double          x01 = cos(rotationRadian.x) * sin(rotationRadian.z) + sin(rotationRadian.x) * sin(rotationRadian.y) * cos(rotationRadian.z);
            double          x02 = sin(rotationRadian.x) * sin(rotationRadian.z) - cos(rotationRadian.x) * sin(rotationRadian.y) * cos(rotationRadian.z);
            double          x10 = -cos(rotationRadian.y) * sin(rotationRadian.z);
            double          x11 = cos(rotationRadian.x) * cos(rotationRadian.z) - sin(rotationRadian.x) * sin(rotationRadian.y) * sin(rotationRadian.z);
            double          x12 = sin(rotationRadian.x) * cos(rotationRadian.z) + cos(rotationRadian.x) * sin(rotationRadian.y) * sin(rotationRadian.z);
            double          x20 = sin(rotationRadian.y);
            double          x21 = -sin(rotationRadian.x) * cos(rotationRadian.y);
            double          x22 = cos(rotationRadian.x) * cos(rotationRadian.y);

            RotMatrix rotationMatrix = RotMatrix::FromRowValues(x00, x01, x02, x10, x11, x12, x20, x21, x22);

            // Invert
            if (!rotationMatrix.Invert())
                return ERROR;

            // The temporary delta is the rotated original delta
            DPoint3d temporaryDelta;
            rotationMatrix.Multiply(temporaryDelta, delta);

            // Which we simply scale to obtain the final delta
            DPoint3d finalDelta;
            finalDelta.x = -temporaryDelta.x / scale;
            finalDelta.y = -temporaryDelta.y / scale;
            finalDelta.z = -temporaryDelta.z / scale;

            rotationMatrix.GetRowValues(x00, x01, x02, x10, x11, x12, x20, x21, x22);

            // Extract the three angles ... Maybe RotMatrix has an easier way to do it but I did not find it
            DPoint3d finalRotationRadian;
            finalRotationRadian.x = atan2(-x21, x22);
            finalRotationRadian.y = atan2(cos(finalRotationRadian.x) * x20, x22);
            finalRotationRadian.z = atan2(-x10, x00);

            DPoint3d finalRotation;
            // Convert to arc seconds
            finalRotation.x = Angle::RadiansToDegrees(finalRotationRadian.x) * 3600.0;
            finalRotation.y = Angle::RadiansToDegrees(finalRotationRadian.y) * 3600.0;
            finalRotation.z = Angle::RadiansToDegrees(finalRotationRadian.z) * 3600.0;

            // final scale is simply inverse of original scale
            double finalScale = 1 / scale;
            double finalScalePPM = (finalScale - 1.0) / 0.000001;

            SetDelta(finalDelta);
            SetRotation(finalRotation);
            if (GetConvertMethodCode() != GenConvertCode::GenConvertType_6PARM)
                SetScale(finalScalePPM);

            if (GetConvertMethodCode() == GenConvertCode::GenConvertType_BDKAS)
                {
                DPoint3d translation;
                GetTranslation(translation);
                DPoint3d temporaryTranslation;
                rotationMatrix.Multiply(temporaryTranslation, translation);

                // Which we simply scale to obtain the final delta
                // NOTE! We do not negate the translation
                DPoint3d finalTranslation;
                finalTranslation.x = temporaryTranslation.x / scale;
                finalTranslation.y = temporaryTranslation.y / scale;
                finalTranslation.z = temporaryTranslation.z / scale;

                SetTranslation(finalTranslation);
                }

            return SUCCESS;
            }

        case GenConvertCode::GenConvertType_GFILE:
            {
            // Need only to change the direction.
            struct cs_GeodeticTransform_::csGeodeticXformParameters::csGeodeticXformParmsGridFiles_* datum1GridXForm = (struct cs_GeodeticTransform_::csGeodeticXformParameters::csGeodeticXformParmsGridFiles_*)&(m_geodeticTransformDef->parameters.fileParameters);

            if (nullptr == datum1GridXForm)
                return ERROR;

            // Reversal process invalidates the fallback solution name since there is not reverse flag
            // By nullifying the fallback name we insure the fallback in the m_fallback member will be used.
            datum1GridXForm->fallback[0] = '\0';

            for (short fileIdx = 0 ; (fileIdx < datum1GridXForm->fileReferenceCount) ; fileIdx++)
                {
                if (datum1GridXForm->fileNames[fileIdx].direction == (char)GridFileDirection::DIRECTION_INVERSE)
                    datum1GridXForm->fileNames[fileIdx].direction = (char)GridFileDirection::DIRECTION_DIRECT;
                else
                    datum1GridXForm->fileNames[fileIdx].direction = (char)GridFileDirection::DIRECTION_INVERSE;
                }

            // Reverse fallback if there is one
            if (nullptr != m_fallback)
                m_fallback->Reverse();

            return SUCCESS;
            }
        }

    // Other methods such as Multiple regression are not reversible.
    return ERROR;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformP             GeodeticTransform::Clone() const
    {
    return CreateGeodeticTransform(*m_geodeticTransformDef,
                                   m_dataAvailability,
                                  (nullptr != m_sourceEllipsoid ? m_sourceEllipsoid->Clone() : nullptr),
                                  (nullptr != m_targetEllipsoid ? m_targetEllipsoid->Clone() : nullptr),
                                  (nullptr != m_fallback ? m_fallback->GetCSGeodeticTransformDef() : nullptr));
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int                 GeodeticTransform::GetError () const
    {
    return m_csError;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             GeodeticTransform::GetErrorMessage (Utf8StringR errorMsg) const
    {
    if (!BaseGCS::IsLibraryInitialized())
        return errorMsg.c_str();

    char    csErrorMsg[512];
    CSMap::CS_errmsg (csErrorMsg, DIM(csErrorMsg));
    errorMsg = csErrorMsg;
    return errorMsg.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool                GeodeticTransform::IsValid () const
    {
    return  NULL != m_geodeticTransformDef;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool            GeodeticTransform::IsNullTransform () const
    {
    bool isNullTransform = false;

    // initialize to defaults.
    switch (GetConvertMethodCode())
        {
        case GenConvertCode::GenConvertType_NONE:
            isNullTransform = true;
            break;

        case GenConvertCode::GenConvertType_MOLO:
        case GenConvertCode::GenConvertType_3PARM:
        case GenConvertCode::GenConvertType_GEOCTR:
            {
            DPoint3d delta;
            GetDelta(delta);

            isNullTransform = (doubleSame(delta.x, 0.0) && doubleSame(delta.y, 0.0) && doubleSame(delta.z, 0.0));
            }
            break;

        case GenConvertCode::GenConvertType_BURS:
        case GenConvertCode::GenConvertType_7PARM:
            {
            DPoint3d delta;
            DPoint3d rotation;
            double scale = GetScale();
            GetDelta(delta);
            GetRotation(rotation);

            isNullTransform = (doubleSame(delta.x, 0.0) && doubleSame(delta.y, 0.0) && doubleSame(delta.z, 0.0) &&
                               doubleSame(rotation.x, 0.0) && doubleSame(rotation.y, 0.0) && doubleSame(rotation.z, 0.0) &&
                               doubleSame(scale, 0.0));
            }
            break;

        case GenConvertCode::GenConvertType_6PARM:
            {
            DPoint3d delta;
            DPoint3d rotation;
            GetDelta(delta);
            GetRotation(rotation);

            isNullTransform = (doubleSame(delta.x, 0.0) && doubleSame(delta.y, 0.0) && doubleSame(delta.z, 0.0) &&
                               doubleSame(rotation.x, 0.0) && doubleSame(rotation.y, 0.0) && doubleSame(rotation.z, 0.0));
            }
            break;

        case GenConvertCode::GenConvertType_4PARM:
            {
            DPoint3d delta;
            double scale = GetScale();

            GetDelta(delta);

            isNullTransform = (doubleSame(delta.x, 0.0) && doubleSame(delta.y, 0.0) && doubleSame(delta.z, 0.0) &&
                               doubleSame(scale, 0.0));
            }
            break;

        case GenConvertCode::GenConvertType_BDKAS:
            {
            DPoint3d delta;
            DPoint3d rotation;
            DPoint3d translation;
            double scale = GetScale();

            GetDelta(delta);
            GetRotation(rotation);
            GetTranslation(translation);

            isNullTransform = (doubleSame(delta.x, 0.0) && doubleSame(delta.y, 0.0) && doubleSame(delta.z, 0.0) &&
                               doubleSame(rotation.x, 0.0) && doubleSame(rotation.y, 0.0) && doubleSame(rotation.z, 0.0) &&
                               doubleSame(translation.x, 0.0) && doubleSame(translation.y, 0.0) && doubleSame(translation.z, 0.0) &&
                               doubleSame(scale, 0.0));
            }
            break;

        // Grid file and Multiple regression are never null
        }

    return isNullTransform;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             GeodeticTransform::GetName() const
    {
    if (NULL == m_geodeticTransformDef)
        return "";

    if (NULL == m_nameString)
        m_nameString = new Utf8String (m_geodeticTransformDef->xfrmName);

    return m_nameString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetName (Utf8CP value)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    Utf8String mbName (value);
    if (mbName.length() >= _countof (m_geodeticTransformDef->xfrmName))
        return GEOCOORDERR_StringTooLong;

    char    copy[1024];
    CS_stncp (copy, mbName.c_str(), _countof (copy));
    if (0 != CS_nampp (copy))
        return GEOCOORDERR_CoordSysIllegalName;

    CS_stncp (m_geodeticTransformDef->xfrmName, mbName.c_str(), _countof (m_geodeticTransformDef->xfrmName));
    m_geodeticTransformDef->epsgCode = 0;

    DELETE_AND_CLEAR (m_nameString);

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             GeodeticTransform::GetDescription() const
    {
    if (NULL == m_geodeticTransformDef)
        return "";

    if (NULL == m_descriptionString)
        m_descriptionString = new Utf8String (m_geodeticTransformDef->description);

    return m_descriptionString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetDescription (Utf8CP value)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    Utf8String mbDescription (value);
    if (mbDescription.length() >= _countof (m_geodeticTransformDef->description))
        return GEOCOORDERR_StringTooLong;

    CS_stncp (m_geodeticTransformDef->description, mbDescription.c_str(), _countof (m_geodeticTransformDef->description));
    DELETE_AND_CLEAR (m_descriptionString);
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             GeodeticTransform::GetSource() const
    {
    if (NULL == m_geodeticTransformDef)
        return "";

    if (NULL == m_sourceString)
        m_sourceString = new Utf8String (m_geodeticTransformDef->source);

    return m_sourceString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetSource (Utf8CP value)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    Utf8String mbDescription (value);
    if (mbDescription.length() >= _countof (m_geodeticTransformDef->source))
        return GEOCOORDERR_StringTooLong;

    CS_stncp (m_geodeticTransformDef->source, mbDescription.c_str(), _countof (m_geodeticTransformDef->source));
    DELETE_AND_CLEAR (m_sourceString);
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             GeodeticTransform::GetSourceDatumName() const
    {
    if (NULL == m_geodeticTransformDef)
        return "";

    if (NULL == m_sourceDatumString)
        m_sourceDatumString = new Utf8String(m_geodeticTransformDef->srcDatum);

    return m_sourceDatumString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetSourceDatumName (Utf8CP value)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    Utf8String mbDescription (value);
    if (mbDescription.length() >= _countof (m_geodeticTransformDef->srcDatum))
        return GEOCOORDERR_StringTooLong;

    CS_stncp (m_geodeticTransformDef->srcDatum, mbDescription.c_str(), _countof (m_geodeticTransformDef->srcDatum));

    if (nullptr != m_fallback)
        m_fallback->SetSourceDatumName(value);

    DELETE_AND_CLEAR (m_sourceDatumString);

    Utf8String xfrmName(m_geodeticTransformDef->xfrmName);
    if (xfrmName == "" || xfrmName == "Unnamed")
        {
        xfrmName = Utf8String(m_geodeticTransformDef->srcDatum) + "_to_" + m_geodeticTransformDef->trgDatum;
        if (xfrmName != "")
            CS_stncp(m_geodeticTransformDef->xfrmName, xfrmName.c_str(), _countof(m_geodeticTransformDef->xfrmName));
        }

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP             GeodeticTransform::GetTargetDatumName() const
    {
    if (NULL == m_geodeticTransformDef)
        return "";

    if (NULL == m_destDatumString)
        m_destDatumString = new Utf8String(m_geodeticTransformDef->trgDatum);

    return m_destDatumString->c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetTargetDatumName (Utf8CP value)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    Utf8String mbDescription (value);
    if (mbDescription.length() >= _countof (m_geodeticTransformDef->trgDatum))
        return GEOCOORDERR_StringTooLong;

    CS_stncp (m_geodeticTransformDef->trgDatum, mbDescription.c_str(), _countof (m_geodeticTransformDef->trgDatum));


    if (nullptr != m_fallback)
        m_fallback->SetTargetDatumName(value);

    DELETE_AND_CLEAR (m_destDatumString);

    Utf8String xfrmName(m_geodeticTransformDef->xfrmName);
    if (xfrmName == "" || xfrmName == "Unnamed")
        {
        xfrmName = Utf8String(m_geodeticTransformDef->srcDatum) + "_to_" + Utf8String(m_geodeticTransformDef->trgDatum);
        if (xfrmName != "")
            CS_stncp(m_geodeticTransformDef->xfrmName, xfrmName.c_str(), _countof(m_geodeticTransformDef->xfrmName));
        }

    CS_stncp(m_geodeticTransformDef->xfrmName, "Unnamed", _countof(m_geodeticTransformDef->xfrmName));

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidCP             GeodeticTransform::GetSourceEllipsoid() const
    {
    if (NULL == m_geodeticTransformDef)
        return NULL;

    if (nullptr == m_sourceEllipsoid)
        {
        CSDatumDef* datumDef;

        if (NULL != (datumDef = CSMap::CS_dtdef(m_geodeticTransformDef->srcDatum)))
            {
            m_sourceEllipsoid = Ellipsoid::CreateEllipsoid(datumDef->ell_knm);
            CSMap::CS_free (datumDef);
            }
        }

    return m_sourceEllipsoid;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetSourceEllipsoid (EllipsoidP sourceEllipsoid)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    if (nullptr != m_sourceEllipsoid)
        {
        m_sourceEllipsoid->Destroy();
        m_sourceEllipsoid = nullptr;
        }

    m_sourceEllipsoid = sourceEllipsoid;

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
EllipsoidCP             GeodeticTransform::GetTargetEllipsoid() const
    {
    if (NULL == m_geodeticTransformDef)
        return NULL;

    if (nullptr == m_targetEllipsoid)
        {
        CSDatumDef* datumDef;

        if (NULL != (datumDef = CSMap::CS_dtdef(m_geodeticTransformDef->trgDatum)))
            {
            m_targetEllipsoid = Ellipsoid::CreateEllipsoid(datumDef->ell_knm);
            CSMap::CS_free (datumDef);
            }
        }

    return m_targetEllipsoid;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetTargetEllipsoid (EllipsoidP targetEllipsoid)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    if (nullptr != m_targetEllipsoid)
        {
        m_targetEllipsoid->Destroy();
        m_targetEllipsoid = nullptr;
        }

    m_targetEllipsoid = targetEllipsoid;

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
int                 GeodeticTransform::GetEPSGCode() const
    {
    return (NULL == m_geodeticTransformDef) ? 0 : m_geodeticTransformDef->epsgCode;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GenConvertCode    GeodeticTransform::GetConvertMethodCode() const
    {
    return (GenConvertCode) ((NULL == m_geodeticTransformDef) ? 0 : m_geodeticTransformDef->methodCode);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetConvertMethodCode (GenConvertCode value)
    {
    int     intValue = (int) value;

    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    m_geodeticTransformDef->methodCode = static_cast<short>(intValue); // NEEDSWORK - is cast correct?  Can intValue be a short?
    return BSISUCCESS;;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt                GeodeticTransform::GetDelta (DPoint3dR delta) const
    {
    delta.x = delta.y = delta.z = 0.0;

    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    bool             deltaValid, rotationValid, scaleValid, translationValid, gridValid;
    ParametersValid (deltaValid, rotationValid, scaleValid, translationValid, gridValid);
    if (deltaValid)
        {
        delta.x = m_geodeticTransformDef->parameters.geocentricParameters.deltaX;
        delta.y = m_geodeticTransformDef->parameters.geocentricParameters.deltaY;
        delta.z = m_geodeticTransformDef->parameters.geocentricParameters.deltaZ;
        return SUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetDelta (DPoint3dCR delta)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    bool             deltaValid, rotationValid, scaleValid, translationValid, gridValid;
    ParametersValid (deltaValid, rotationValid, scaleValid, translationValid, gridValid);
    if (deltaValid)
        {
        m_geodeticTransformDef->parameters.geocentricParameters.deltaX = delta.x;
        m_geodeticTransformDef->parameters.geocentricParameters.deltaY = delta.y;
        m_geodeticTransformDef->parameters.geocentricParameters.deltaZ = delta.z;
        return BSISUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt                GeodeticTransform::GetRotation (DPoint3dR rotation) const
    {
    rotation.x = rotation.y = rotation.z = 0.0;

    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    bool             deltaValid, rotationValid, scaleValid, translationValid, gridValid;
    ParametersValid (deltaValid, rotationValid, scaleValid, translationValid, gridValid);
    if (rotationValid)
        {
        rotation.x = m_geodeticTransformDef->parameters.geocentricParameters.rotateX;
        rotation.y = m_geodeticTransformDef->parameters.geocentricParameters.rotateY;
        rotation.z = m_geodeticTransformDef->parameters.geocentricParameters.rotateZ;
        return SUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetRotation (DPoint3dCR rotation)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    bool             deltaValid, rotationValid, scaleValid, translationValid, gridValid;
    ParametersValid (deltaValid, rotationValid, scaleValid, translationValid, gridValid);
    if (rotationValid)
        {
        m_geodeticTransformDef->parameters.geocentricParameters.rotateX = rotation.x;
        m_geodeticTransformDef->parameters.geocentricParameters.rotateY = rotation.y;
        m_geodeticTransformDef->parameters.geocentricParameters.rotateZ = rotation.z;
        return BSISUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt                GeodeticTransform::GetTranslation (DPoint3dR translation) const
    {
    translation.x = translation.y = translation.z = 0.0;

    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    bool             deltaValid, rotationValid, scaleValid, translationValid, gridValid;
    ParametersValid (deltaValid, rotationValid, scaleValid, translationValid, gridValid);
    if (translationValid)
        {
        translation.x = m_geodeticTransformDef->parameters.geocentricParameters.translateX;
        translation.y = m_geodeticTransformDef->parameters.geocentricParameters.translateY;
        translation.z = m_geodeticTransformDef->parameters.geocentricParameters.translateZ;
        return BSISUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetTranslation (DPoint3dCR translation)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    bool             deltaValid, rotationValid, scaleValid, translationValid, gridValid;
    ParametersValid (deltaValid, rotationValid, scaleValid, translationValid, gridValid);
    if (translationValid)
        {
        m_geodeticTransformDef->parameters.geocentricParameters.translateX = translation.x;
        m_geodeticTransformDef->parameters.geocentricParameters.translateY = translation.y;
        m_geodeticTransformDef->parameters.geocentricParameters.translateZ = translation.z;
        return BSISUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              GeodeticTransform::GetScale () const
    {
    if (NULL == m_geodeticTransformDef)
        return 0.0;

    bool             deltaValid, rotationValid, scaleValid, translationValid, gridValid;
    ParametersValid (deltaValid, rotationValid, scaleValid, translationValid, gridValid);
    return (scaleValid ? m_geodeticTransformDef->parameters.geocentricParameters.scale : 0.0);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetScale (double value)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    bool             deltaValid, rotationValid, scaleValid, translationValid, gridValid;
    ParametersValid (deltaValid, rotationValid, scaleValid, translationValid, gridValid);
    if (scaleValid)
        {
        m_geodeticTransformDef->parameters.geocentricParameters.scale = value;
        return BSISUCCESS;
        }
    return GEOCOORDERR_ParameterNotUsed;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
double              GeodeticTransform::GetAccuracy () const
    {
    if (NULL == m_geodeticTransformDef)
        return 0.0;

    return m_geodeticTransformDef->accuracy;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt           GeodeticTransform::SetAccuracy (double value)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    m_geodeticTransformDef->accuracy = value;
    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
size_t      GeodeticTransform::GetGridFileDefinitionCount () const
    {
    if (NULL == m_geodeticTransformDef)
        return (size_t)0;

    if (GetConvertMethodCode() != GenConvertCode::GenConvertType_GFILE)
        return (size_t)0;

    return (size_t)m_geodeticTransformDef->parameters.fileParameters.fileReferenceCount;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GridFileDefinition   GeodeticTransform::GetGridFileDefinition (size_t index) const
    {
    if (NULL == m_geodeticTransformDef)
        return GridFileDefinition("", GridFileFormat::FORMAT_NONE, GridFileDirection::DIRECTION_NONE);

    if (index < 0 || index > GetGridFileDefinitionCount() - 1)
        return GridFileDefinition("", GridFileFormat::FORMAT_NONE, GridFileDirection::DIRECTION_NONE);

    if (GetConvertMethodCode() != GenConvertCode::GenConvertType_GFILE)
        return GridFileDefinition("", GridFileFormat::FORMAT_NONE, GridFileDirection::DIRECTION_NONE);

    return GridFileDefinition(m_geodeticTransformDef->parameters.fileParameters.fileNames[index].fileName,
                              (GridFileFormat)m_geodeticTransformDef->parameters.fileParameters.fileNames[index].fileFormat,
                              (GridFileDirection)m_geodeticTransformDef->parameters.fileParameters.fileNames[index].direction);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt   GeodeticTransform::AddGridFileDefinition (const GridFileDefinition& definition)
    {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    if (GetConvertMethodCode() != GenConvertCode::GenConvertType_GFILE)
        return ERROR;

    if (m_geodeticTransformDef->parameters.fileParameters.fileReferenceCount >= csGRIDI1_FILEMAX)
        return ERROR; // TODO (too many grid files) ... introduce specific error.

    // Verify length of path
    if (definition.GetFileName().length() > csGRIDI1_FLNMSZ)
        return GEOCOORDERR_BadArg;

    // If on Windows the path separators must be windows style in the CSMAP structure even though definition always uses UNIX style
    Utf8String tempString(definition.GetFileName().c_str());

    if ('\\' == cs_DirsepC)
        {
        size_t location;
        while ((location = tempString.find("/")) != std::string::npos)
            tempString.replace(location, 1, "\\");
        }

    CS_stncp (m_geodeticTransformDef->parameters.fileParameters.fileNames[m_geodeticTransformDef->parameters.fileParameters.fileReferenceCount].fileName, tempString.c_str(), csGRIDI1_FLNMSZ);
    m_geodeticTransformDef->parameters.fileParameters.fileNames[m_geodeticTransformDef->parameters.fileParameters.fileReferenceCount].fileFormat = (unsigned char)definition.GetFormat();
    m_geodeticTransformDef->parameters.fileParameters.fileNames[m_geodeticTransformDef->parameters.fileParameters.fileReferenceCount].direction = (unsigned char)definition.GetDirection();

    m_geodeticTransformDef->parameters.fileParameters.fileReferenceCount++;

    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool GeodeticTransform::GetFallback(DPoint3dR delta, DPoint3dR rotation, double& scalePPM) const {
    if (nullptr == m_fallback)
        return false;

    m_fallback->GetRotation(rotation);
    m_fallback->GetDelta(delta);
    scalePPM = m_fallback->GetScale();
    return true;
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
StatusInt GeodeticTransform::SetFallback(DPoint3dCR delta, DPoint3dCR rotation, double scalePPM) {
    if (nullptr != m_fallback) {
        m_fallback->Destroy();
        m_fallback = nullptr;
    }

    m_fallback = GeodeticTransform::CreateGeodeticTransform();
    m_fallback->SetConvertMethodCode(GenConvertCode::GenConvertType_7PARM);
    m_fallback->SetRotation(rotation);
    m_fallback->SetDelta(delta);
    m_fallback->SetScale(scalePPM);

    m_fallback->SetSourceDatumName(GetSourceDatumName());
    m_fallback->SetTargetDatumName(GetTargetDatumName());

    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformDataAvailability GeodeticTransform::GetDataAvailability(bool recheck) const {
    GenConvertCode method = GetConvertMethodCode();

    // Only Grid Files and Multiple Regression require additional checking.
    if (GenConvertCode::GenConvertType_GFILE != method && GenConvertCode::GenConvertType_MREG != method)
        return GeodeticTransformDataAvailability::DataAvailable;

    if ((GenConvertCode::GenConvertType_GFILE == method) && (GetGridFileDefinitionCount() < 1))
        return GeodeticTransformDataAvailability::DataUnavailable;

    if (GenConvertCode::GenConvertType_GFILE == method || GenConvertCode::GenConvertType_MREG == method) {
        if (GeodeticTransformDataAvailability::AvailabilityUnknown == m_dataAvailability || recheck) {
            // We do not know yet if the grid files are available ... we check if the files are present
            int err_list[12];
            int errorCount = CS_gxfastchk(m_geodeticTransformDef, 0, err_list, 12);

            if (errorCount != 0) {
                m_dataAvailability = GeodeticTransformDataAvailability::DataUnavailable;
            } else {
                m_dataAvailability = GeodeticTransformDataAvailability::DataAvailable;
            }
        }
    }

    return m_dataAvailability;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt GeodeticTransform::SetDataAvailability(GeodeticTransformDataAvailability dataAvailability) {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    m_dataAvailability = dataAvailability;
    return BSISUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt GeodeticTransform::FromJson(BeJsConst jsonValue, Utf8StringR errorMessage) {
    // Error processing lambda definitions
    auto BadProperty = [&errorMessage](Utf8CP name, StatusInt status = GEOCOORDERR_BadArg) {
        errorMessage.Sprintf("'%s' is invalid", name);
        return status;
    };

    auto MissingProperty = [&errorMessage](Utf8CP name) {
        errorMessage.Sprintf("'%s' is missing", name);
        return GEOCOORDERR_MissingPropertyOrParameter;
    };

    if (NULL == m_geodeticTransformDef)
        m_geodeticTransformDef = (CSGeodeticTransformDef*)CS_malc(sizeof(CSGeodeticTransformDef));

    // Clear parameters
    memset(m_geodeticTransformDef, 0, sizeof(CSGeodeticTransformDef));
    CS_stncp(m_geodeticTransformDef->xfrmName, "Unnamed", _countof(m_geodeticTransformDef->xfrmName));
    m_geodeticTransformDef->cnvrgValue = 1e-09;
    m_geodeticTransformDef->errorValue = 1e-06;
    m_geodeticTransformDef->accuracy = 1.0;
    m_geodeticTransformDef->maxIterations = 20;

    // Clear cache parameters
    m_nameString = NULL;
    m_descriptionString = NULL;
    m_sourceString = NULL;
    m_sourceDatumString = NULL;
    m_destDatumString = NULL;

    // This property is optional but may be required for multiple transforms chained that must know the shape of ellipsoid
    // If set it must be a system library datum or the first in a chain of datum definitions (from which will be obtained the ellipsoid).
    if (!jsonValue["sourceDatumId"].isNull()) {
        SetSourceDatumName(jsonValue["sourceDatumId"].asString().c_str());
    }

    // This property is optional but may be required for multiple transforms chained that must know the shape of ellipsoid
    // If set it must be a system library datum.
    if (!jsonValue["targetDatumId"].isNull()) {
        SetTargetDatumName(jsonValue["targetDatumId"].asString().c_str());
    }

    if (!jsonValue["sourceEllipsoid"].isNull()) {
        EllipsoidP srcEllipsoid = nullptr;

        auto theEllipsoid = jsonValue["sourceEllipsoid"];

        if (!theEllipsoid["id"].isNull()) {
            srcEllipsoid = const_cast<EllipsoidP>(Ellipsoid::CreateEllipsoid(theEllipsoid["id"].asString().c_str()));

            if (nullptr != srcEllipsoid) {
                if (!srcEllipsoid->IsValid()) {
                    srcEllipsoid->Destroy();
                    srcEllipsoid = nullptr;
                }
            }
        }

        if (nullptr == srcEllipsoid) {
            // Last chance is for the ellipsoid to be fully custom
            srcEllipsoid = Ellipsoid::CreateEllipsoid();
            if (SUCCESS != srcEllipsoid->FromJson(theEllipsoid, errorMessage)) {
                // Could not obtain a custom made ellipsoid ...
                srcEllipsoid->Destroy();
                return BadProperty("ellipsoid");
            }
        }

        // Set the self-defined fully custom ellipsoid
        SetSourceEllipsoid(srcEllipsoid);
    }

    if (!jsonValue["targetEllipsoid"].isNull()) {
        EllipsoidP trgEllipsoid = nullptr;

        auto theEllipsoid = jsonValue["targetEllipsoid"];

        if (!theEllipsoid["id"].isNull()) {
            trgEllipsoid = const_cast<EllipsoidP>(Ellipsoid::CreateEllipsoid(theEllipsoid["id"].asString().c_str()));

            if (nullptr != trgEllipsoid) {
                if (!trgEllipsoid->IsValid()) {
                    trgEllipsoid->Destroy();
                    trgEllipsoid = nullptr;
                }
            }
        }

        if (nullptr == trgEllipsoid) {
            // Last chance is for the ellipsoid to be fully custom
            trgEllipsoid = Ellipsoid::CreateEllipsoid();
            if (SUCCESS != trgEllipsoid->FromJson(theEllipsoid, errorMessage)) {
                // Could not obtain a custom made ellipsoid ...
                trgEllipsoid->Destroy();
                return BadProperty("ellipsoid");
            }
        }

        // Set the self-defined fully custom ellipsoid
        SetTargetEllipsoid(trgEllipsoid);
    }

    if (jsonValue["method"].isNull())
        return MissingProperty("method");

    Utf8String methodString = jsonValue["method"].asString();

    if (methodString == "None") {
        SetConvertMethodCode(GenConvertCode::GenConvertType_NONE);
    } else if (methodString == "Geocentric") {
        SetConvertMethodCode(GenConvertCode::GenConvertType_GEOCTR);
        if (jsonValue["geocentric"].isNull())
            return MissingProperty("geocentric");

        if (jsonValue["geocentric"]["delta"].isNull())
            return MissingProperty("delta");

        auto deltaVal = jsonValue["geocentric"]["delta"];

        if (deltaVal["x"].isNull() ||
            deltaVal["y"].isNull() ||
            deltaVal["z"].isNull())
            return MissingProperty("x,y,x");

        DPoint3d delta;
        delta.Init(deltaVal["x"].asDouble(), deltaVal["y"].asDouble(), deltaVal["z"].asDouble());
        if (SUCCESS != SetDelta(delta))
            return BadProperty("delta");
    } else if (methodString == "PositionalVector") {
        SetConvertMethodCode(GenConvertCode::GenConvertType_7PARM);
        if (jsonValue["positionalVector"].isNull())
            return MissingProperty("positionalVector");

        auto posVecVal = jsonValue["positionalVector"];

        if (posVecVal["delta"].isNull())
            return MissingProperty("delta");

        auto deltaVal = posVecVal["delta"];

        if (deltaVal["x"].isNull() ||
            deltaVal["y"].isNull() ||
            deltaVal["z"].isNull())
            return MissingProperty("x,y,z");

        DPoint3d delta;
        delta.Init(deltaVal["x"].asDouble(), deltaVal["y"].asDouble(), deltaVal["z"].asDouble());

        if (SUCCESS != SetDelta(delta))
            return BadProperty("delta");

        if (posVecVal["rotation"].isNull())
            return MissingProperty("rotation");

        auto rotationVal = posVecVal["rotation"];

        if (rotationVal["x"].isNull() ||
            rotationVal["y"].isNull() ||
            rotationVal["z"].isNull())
            return MissingProperty("rotation x,y or z");

        DPoint3d rotation;
        // Rotation signs are changed from Position Vector (epsg:9606) to Coordinate Frame (epsg:9607) used by CSMAP
        rotation.Init(-rotationVal["x"].asDouble(), -rotationVal["y"].asDouble(), -rotationVal["z"].asDouble());

        if (SUCCESS != SetRotation(rotation))
            return BadProperty("rotation");

        if (posVecVal["scalePPM"].isNull() || SUCCESS != SetScale(posVecVal["scalePPM"].asDouble()))
            return MissingProperty("scalePPM");
        }
    else if (methodString == "MolodenskiBadekas")
        {
        SetConvertMethodCode(GenConvertCode::GenConvertType_BDKAS);
        if (jsonValue["molodenskiBadekas"].isNull())
            return MissingProperty("molodenskiBadekas");

        auto moloBdkasVecVal = jsonValue["molodenskiBadekas"];

        if (moloBdkasVecVal["delta"].isNull())
            return MissingProperty("delta");

        auto deltaVal = moloBdkasVecVal["delta"];

        if (deltaVal["x"].isNull() ||
            deltaVal["y"].isNull() ||
            deltaVal["z"].isNull())
            return MissingProperty("x,y,z");

        DPoint3d delta;
        delta.Init(deltaVal["x"].asDouble(), deltaVal["y"].asDouble(), deltaVal["z"].asDouble());

        if (SUCCESS != SetDelta(delta))
            return BadProperty("delta");

        if (moloBdkasVecVal["rotation"].isNull())
            return MissingProperty("rotation");

        auto rotationVal = moloBdkasVecVal["rotation"];

        if (rotationVal["x"].isNull() ||
            rotationVal["y"].isNull() ||
            rotationVal["z"].isNull())
            return MissingProperty("rotation x,y or z");

        DPoint3d rotation;
        // Rotation signs are changed from Position Vector (epsg:9606) to Coordinate Frame (epsg:9607) used by CSMAP
        rotation.Init(-rotationVal["x"].asDouble(), -rotationVal["y"].asDouble(), -rotationVal["z"].asDouble());

        if (SUCCESS != SetRotation(rotation))
            return BadProperty("rotation");

        auto translationVal = moloBdkasVecVal["translation"];

        if (translationVal["x"].isNull() ||
            translationVal["y"].isNull() ||
            translationVal["z"].isNull())
            return MissingProperty("x,y,z");

        DPoint3d translation;
        translation.Init(translationVal["x"].asDouble(), translationVal["y"].asDouble(), translationVal["z"].asDouble());

        if (SUCCESS != SetTranslation(translation))
            return BadProperty("tranlation");

        if (moloBdkasVecVal["scalePPM"].isNull() || SUCCESS != SetScale(moloBdkasVecVal["scalePPM"].asDouble()))
            return MissingProperty("scalePPM");
        }
    else if (methodString == "GridFiles")
        {
        SetConvertMethodCode(GenConvertCode::GenConvertType_GFILE);

        if (jsonValue["gridFile"].isNull())
            return MissingProperty("gridFile");

        auto gridFilesVal = jsonValue["gridFile"];

        if (!gridFilesVal["fallback"].isNull()) {
            // fallback is specified
            auto fallbackValue = gridFilesVal["fallback"];

            m_fallback = GeodeticTransform::CreateGeodeticTransform();

            m_fallback->SetConvertMethodCode(GenConvertCode::GenConvertType_7PARM);

            if (fallbackValue["delta"].isNull()) {
                m_fallback->Destroy();
                m_fallback = nullptr;
                return MissingProperty("delta");
            }

            auto deltaVal = fallbackValue["delta"];

            if (deltaVal["x"].isNull() ||
                deltaVal["y"].isNull() ||
                deltaVal["z"].isNull()) {
                m_fallback->Destroy();
                m_fallback = nullptr;
                return MissingProperty("x,y,z");
            }

            DPoint3d delta;
            delta.Init(deltaVal["x"].asDouble(), deltaVal["y"].asDouble(), deltaVal["z"].asDouble());

            if (SUCCESS != m_fallback->SetDelta(delta)) {
                m_fallback->Destroy();
                m_fallback = nullptr;
                return BadProperty("delta");
            }

            if (fallbackValue["rotation"].isNull()) {
                m_fallback->Destroy();
                m_fallback = nullptr;
                return MissingProperty("rotation");
            }

            auto rotationVal = fallbackValue["rotation"];

            if (rotationVal["x"].isNull() ||
                rotationVal["y"].isNull() ||
                rotationVal["z"].isNull()) {
                m_fallback->Destroy();
                m_fallback = nullptr;
                return MissingProperty("rotation x,y or z");
            }

            DPoint3d rotation;
            // Rotation signs are changed from Position Vector (epsg:9606) to Coordinate Frame (epsg:9607) used by CSMAP
            rotation.Init(-rotationVal["x"].asDouble(), -rotationVal["y"].asDouble(), -rotationVal["z"].asDouble());

            if (SUCCESS != m_fallback->SetRotation(rotation)) {
                m_fallback->Destroy();
                m_fallback = nullptr;
                return BadProperty("rotation");
            }

            if (fallbackValue["scalePPM"].isNull() || SUCCESS != m_fallback->SetScale(fallbackValue["scalePPM"].asDouble())) {
                m_fallback->Destroy();
                m_fallback = nullptr;
                return MissingProperty("scalePPM");
            }
        }

        if (gridFilesVal["files"].isNull())
            return MissingProperty("files");

        auto gridFilesFilesVal = gridFilesVal["files"];

        if (gridFilesFilesVal.size() == 0)
            return MissingProperty("files");

        if (gridFilesFilesVal[0].isNull())
            return MissingProperty("files");

        int index = 0;
        while (!gridFilesFilesVal[index].isNull()) {
            auto theGridFileVal = gridFilesFilesVal[index];

            if (theGridFileVal["fileName"].isNull() || theGridFileVal["format"].isNull() || theGridFileVal["direction"].isNull())
                return MissingProperty("fileName,format,direction");

            GridFileFormat theFormat;

            Utf8String formatString = theGridFileVal["format"].asString();

            if (formatString == "NTv1")
                theFormat = GridFileFormat::FORMAT_NTv1;
            else if (formatString == "NTv2")
                theFormat = GridFileFormat::FORMAT_NTv2;
            else if (formatString == "NADCON")
                theFormat = GridFileFormat::FORMAT_NADCON;
            else if (formatString == "FRENCH")
                theFormat = GridFileFormat::FORMAT_FRENCH;
            else if (formatString == "JAPAN")
                theFormat = GridFileFormat::FORMAT_JAPAN;
            else if (formatString == "ATS77")
                theFormat = GridFileFormat::FORMAT_ATS77;
            else if (formatString == "GEOCN")
                theFormat = GridFileFormat::FORMAT_GEOCN;
            else if (formatString == "OSTN02")
                theFormat = GridFileFormat::FORMAT_OSTN02;
			else if (formatString == "OSTN15")
                theFormat = GridFileFormat::FORMAT_OSTN15;
            else
                return BadProperty("format");

            GridFileDirection theDirection;

            Utf8String directionString = theGridFileVal["direction"].asString();

            if (directionString == "Direct")
                theDirection = GridFileDirection::DIRECTION_DIRECT;
            else if (directionString == "Inverse")
                theDirection = GridFileDirection::DIRECTION_INVERSE;
            else
                return BadProperty("direction");

            GridFileDefinition newFile(theGridFileVal["fileName"].asString().c_str(), theFormat, theDirection);

            AddGridFileDefinition(newFile);

            index++;
        }
    } else if (methodString == "MultipleRegression") {
        SetConvertMethodCode(GenConvertCode::GenConvertType_MREG);
        // We cannot store multiple regression parameters so we leave them unitialized.
    } else
        return BadProperty("method");

    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt GeodeticTransform::ToJson(BeJsValue jsonValue) const {
    if (NULL == m_geodeticTransformDef)
        return GEOCOORDERR_InvalidGeodeticTransform;

    EllipsoidCP srcEllipsoid = GetSourceEllipsoid();
    if (nullptr != srcEllipsoid)
        srcEllipsoid->ToJson(jsonValue["sourceEllipsoid"], true);
    else
        {
        // Fallback ... not normally used
        Utf8String srcDatum = GetSourceDatumName();
        if (srcDatum != "")
            jsonValue["sourceDatumId"] = srcDatum.c_str();
        }

    EllipsoidCP trgEllipsoid = GetTargetEllipsoid();
    if (nullptr != trgEllipsoid)
        trgEllipsoid->ToJson(jsonValue["targetEllipsoid"], true);

    Utf8String trgDatum = Utf8String(GetTargetDatumName());
    if (trgDatum != "")
        jsonValue["targetDatumId"] = trgDatum.c_str();

    switch (GetConvertMethodCode())
        {
        case GeoCoordinates::GenConvertCode::GenConvertType_NONE:
            {
            jsonValue["method"] = "None";
            break;
            }

        case GeoCoordinates::GenConvertCode::GenConvertType_3PARM:
        case GeoCoordinates::GenConvertCode::GenConvertType_GEOCTR:
        case GeoCoordinates::GenConvertCode::GenConvertType_MOLO:
            {
            jsonValue["method"] = "Geocentric";

            BeJsValue geocentricVal(jsonValue["geocentric"]);
            geocentricVal.toObject();

            BeJsValue deltaVal(geocentricVal["delta"]);

            DPoint3d delta;
            GetDelta(delta);
            deltaVal["x"] = delta.x;
            deltaVal["y"] = delta.y;
            deltaVal["z"] = delta.z;
            }
            break;

        case GeoCoordinates::GenConvertCode::GenConvertType_4PARM:
            {
            jsonValue["method"] = "PositionalVector";

            BeJsValue posVecVal(jsonValue["positionalVector"]);
            posVecVal.toObject();

            BeJsValue deltaVal(posVecVal["delta"]);

            DPoint3d delta;
            GetDelta(delta);
            deltaVal["x"] = delta.x;
            deltaVal["y"] = delta.y;
            deltaVal["z"] = delta.z;

            BeJsValue rotationVal(posVecVal["rotation"]);
            rotationVal["x"] = 0.0;
            rotationVal["y"] = 0.0;
            rotationVal["z"] = 0.0;

            posVecVal["scalePPM"] = GetScale();
            }
            break;

        case GeoCoordinates::GenConvertCode::GenConvertType_6PARM:
            {
            jsonValue["method"] = "PositionalVector";

            BeJsValue posVecVal(jsonValue["positionalVector"]);
            posVecVal.toObject();

            BeJsValue deltaVal(posVecVal["delta"]);

            DPoint3d delta, rotation;
            GetDelta(delta);
            deltaVal["x"] = delta.x;
            deltaVal["y"] = delta.y;
            deltaVal["z"] = delta.z;

            BeJsValue rotationVal(posVecVal["rotation"]);
            GetRotation(rotation);
            // Rotation signs are changed from Coordinate Frame (epsg:9607) to Position Vector (epsg:9606)
            rotationVal["x"] = -rotation.x;
            rotationVal["y"] = -rotation.y;
            rotationVal["z"] = -rotation.z;

            posVecVal["scalePPM"] = 0.0;
            }
            break;
        case GeoCoordinates::GenConvertCode::GenConvertType_BURS:
        case GeoCoordinates::GenConvertCode::GenConvertType_7PARM:
            {
            jsonValue["method"] = "PositionalVector";

            BeJsValue posVecVal(jsonValue["positionalVector"]);
            posVecVal.toObject();

            BeJsValue deltaVal(posVecVal["delta"]);

            DPoint3d delta, rotation;
            GetDelta(delta);
            deltaVal["x"] = delta.x;
            deltaVal["y"] = delta.y;
            deltaVal["z"] = delta.z;

            BeJsValue rotationVal(posVecVal["rotation"]);
            GetRotation(rotation);
            // Rotation signs are changed from Coordinate Frame (epsg:9607) to Position Vector (epsg:9606)
            rotationVal["x"] = -rotation.x;
            rotationVal["y"] = -rotation.y;
            rotationVal["z"] = -rotation.z;

            posVecVal["scalePPM"] = GetScale();
            }
            break;

        case GeoCoordinates::GenConvertCode::GenConvertType_BDKAS:
            {
            jsonValue["method"] = "MolodenskiBadekas";
            BeJsValue moloBdkasVecVal(jsonValue["molodenskiBadekas"]);
            moloBdkasVecVal.toObject();

            BeJsValue deltaVal(moloBdkasVecVal["delta"]);

            DPoint3d delta, rotation, tranlation;
            GetDelta(delta);
            deltaVal["x"] = delta.x;
            deltaVal["y"] = delta.y;
            deltaVal["z"] = delta.z;

            BeJsValue rotationVal(moloBdkasVecVal["rotation"]);
            GetRotation(rotation);
            // Rotation signs are changed from Coordinate Frame (epsg:9607) to Position Vector (epsg:9606)
            rotationVal["x"] = -rotation.x;
            rotationVal["y"] = -rotation.y;
            rotationVal["z"] = -rotation.z;

            BeJsValue translationVal(moloBdkasVecVal["translation"]);
            GetTranslation(tranlation);
            translationVal["x"] = tranlation.x;
            translationVal["y"] = tranlation.y;
            translationVal["z"] = tranlation.z;

            moloBdkasVecVal["scalePPM"] = GetScale();
            }
            break;

        case GeoCoordinates::GenConvertCode::GenConvertType_WGS72:
            {
            jsonValue["method"] = "Undefined";
            // TO DO ... not supported results in error
            return ERROR;
            }
            break;

        case GeoCoordinates::GenConvertCode::GenConvertType_MREG:
            {
            // We indicate the method but parameters are too complex to serialize
            jsonValue["method"] = "MultipleRegression";
            }
            break;
        case GeoCoordinates::GenConvertCode::GenConvertType_GFILE:
            {
            jsonValue["method"] = "GridFiles";

            BeJsValue gridFilesVal(jsonValue["gridFile"]);
            gridFilesVal.toObject();

            BeJsValue fileArrayVal(gridFilesVal["files"]);
            fileArrayVal.toArray();

            // A grid file transform must have one file at least specified.
            if (GetGridFileDefinitionCount() < 1)
                return GEOCOORDERR_InvalidGeodeticTransform;

            for (size_t indexGridFile = 0; indexGridFile < GetGridFileDefinitionCount(); indexGridFile++)
                {
                GeoCoordinates::GridFileDefinition currentDefinition = GetGridFileDefinition(indexGridFile);
                BeJsValue gridFileVal(fileArrayVal[(int)indexGridFile]);

                Utf8String tempString(currentDefinition.GetFileName().c_str());
                // Change windows slash into unix slashes.
                size_t location;
                while ((location = tempString.find("\\")) != std::string::npos) {
                    tempString.replace(location, 1, "/");
                }

                gridFileVal["fileName"] = tempString;

                GridFileFormat theFormat = currentDefinition.GetFormat();

                if (theFormat == GridFileFormat::FORMAT_NTv1)
                    gridFileVal["format"] = "NTv1";
                else if (theFormat == GridFileFormat::FORMAT_NTv2)
                    gridFileVal["format"] = "NTv2";
                else if (theFormat == GridFileFormat::FORMAT_NADCON)
                    gridFileVal["format"] = "NADCON";
                else if (theFormat == GridFileFormat::FORMAT_FRENCH)
                    gridFileVal["format"] = "FRENCH";
                else if (theFormat == GridFileFormat::FORMAT_JAPAN)
                    gridFileVal["format"] = "JAPAN";
                else if (theFormat == GridFileFormat::FORMAT_GEOCN)
                    gridFileVal["format"] = "GEOCN";
                else if (theFormat == GridFileFormat::FORMAT_ATS77)
                    gridFileVal["format"] = "ATS77";
                else if (theFormat == GridFileFormat::FORMAT_OSTN02)
                    gridFileVal["format"] = "OSTN02";
                else if (theFormat == GridFileFormat::FORMAT_OSTN15)
                    gridFileVal["format"] = "OSTN15";
                else
                    return ERROR;

                if (currentDefinition.GetDirection() == GridFileDirection::DIRECTION_DIRECT)
                    gridFileVal["direction"] = "Direct";
                else if (currentDefinition.GetDirection() == GridFileDirection::DIRECTION_INVERSE)
                    gridFileVal["direction"] = "Inverse";
                else
                    return ERROR;
                }

            // Add fallback if one is present
            if (nullptr != m_fallback)
                {
                BeJsValue fallbackVal(gridFilesVal["fallback"]);
                fallbackVal.toObject();
                BeJsValue deltaVal(fallbackVal["delta"]);
                DPoint3d delta, rotation;
                m_fallback->GetDelta(delta);
                deltaVal["x"] = delta.x;
                deltaVal["y"] = delta.y;
                deltaVal["z"] = delta.z;

                BeJsValue rotationVal(fallbackVal["rotation"]);
                m_fallback->GetRotation(rotation);
                // Rotation signs are changed from Coordinate Frame (epsg:9607) to Position Vector (epsg:9606)
                rotationVal["x"] = -rotation.x;
                rotationVal["y"] = -rotation.y;
                rotationVal["z"] = -rotation.z;

                fallbackVal["scalePPM"] = m_fallback->GetScale();

                }
            }
            break;
        }

    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void GeodeticTransform::ParametersValid(bool& deltaValid, bool& rotationValid, bool& scaleValid, bool& translationValid, bool& gridValid) const {
    // initialize to defaults.
    deltaValid = rotationValid = scaleValid = translationValid = gridValid = false;
    switch (GetConvertMethodCode()) {
    case GenConvertCode::GenConvertType_MOLO:
    case GenConvertCode::GenConvertType_3PARM:
    case GenConvertCode::GenConvertType_GEOCTR:
        deltaValid = true;
        break;

    case GenConvertCode::GenConvertType_BURS:
    case GenConvertCode::GenConvertType_7PARM:
        deltaValid = rotationValid = scaleValid = true;
        break;

    case GenConvertCode::GenConvertType_6PARM:
        deltaValid = rotationValid = true;
        break;

    case GenConvertCode::GenConvertType_4PARM:
        deltaValid = scaleValid = true;
        break;

    case GenConvertCode::GenConvertType_BDKAS:
        deltaValid = rotationValid = scaleValid = translationValid = true;
        break;

    case GenConvertCode::GenConvertType_GFILE:
        gridValid = true;
        break;
    }
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransform::~GeodeticTransform()
    {
    if (NULL != m_geodeticTransformDef)
        CSMap::CS_free (m_geodeticTransformDef);

    if (nullptr != m_fallback) {
        m_fallback->Destroy();
        m_fallback = nullptr;
    }

    if (nullptr != m_sourceEllipsoid)
        m_sourceEllipsoid->Destroy();

    if (nullptr != m_targetEllipsoid)
        m_targetEllipsoid->Destroy();

    DELETE_AND_CLEAR (m_nameString);
    DELETE_AND_CLEAR (m_descriptionString);
    DELETE_AND_CLEAR (m_sourceString);
    DELETE_AND_CLEAR (m_sourceDatumString);
    DELETE_AND_CLEAR (m_destDatumString);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
void            GeodeticTransform::Destroy () const { delete this; }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
CSGeodeticTransformDef const*        GeodeticTransform::GetCSGeodeticTransformDef() const
    {
    // If name is empty we set it to unnamed (A transform def cannot be unnamed according to CSMAP rules)
    if (m_geodeticTransformDef->xfrmName[0] == '\0')
        CS_stncp(m_geodeticTransformDef->xfrmName, "Unnamed", _countof(m_geodeticTransformDef->xfrmName));

    return m_geodeticTransformDef;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
CSGeodeticTransformDef const*        GeodeticTransform::GetFallbackCSGeodeticTransformDef() const
    {
    if (nullptr == m_fallback)
        return nullptr;

    if (GetConvertMethodCode() != GenConvertCode::GenConvertType_GFILE)
        return nullptr;

    return m_fallback->GetCSGeodeticTransformDef();
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPathP GeodeticTransformPath::Create() {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    return new GeodeticTransformPath();
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPath::GeodeticTransformPath() {
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPath::GeodeticTransformPath(CSDatumConvert* datumConvert) {
    if (!BaseGCS::IsLibraryInitialized())
        return;

    if (NULL == datumConvert)
        return;

    FillListOfTransformsFromCSDatumConvert(m_listOfGeodeticTransforms, *datumConvert);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPathP GeodeticTransformPath::Create(BaseGCSCR from, BaseGCSCR to) {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    if (!from.IsValid() || !to.IsValid())
        return NULL;

    CSDatumConvert* datumConvert = CSMap::CS_dtcsuDefOnly(from.GetCSParameters(), to.GetCSParameters());

    if (NULL != datumConvert)
        {
        GeodeticTransformPathP returnPath = new GeodeticTransformPath(datumConvert);
        CS_dtclsDefOnly(datumConvert);
        return returnPath;
        }
    else {
        // Obtain the datum and check if there are some stored geodetic transforms...
        DatumCP fromDatum = from.GetDatum();
        DatumCP toDatum = to.GetDatum();

        if ((nullptr == fromDatum) || (nullptr == toDatum))
            return nullptr;

        return GeodeticTransformPath::Create(*fromDatum, *toDatum);
    }
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPathP GeodeticTransformPath::Create(DatumCR from, DatumCR to) {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    if (!from.IsValid() || !to.IsValid())
        return NULL;

    CSDatum* srcCSDatum = from.GetCSDatum();
    CSDatum* dstCSDatum = to.GetCSDatum();
    if ((NULL == srcCSDatum) || (NULL == dstCSDatum))
        return NULL;

    CSDatumConvert* datumConvert = CSMap::CSdtcsuDefOnly(srcCSDatum, dstCSDatum);

    if (NULL != datumConvert)
        {
        GeodeticTransformPathP returnPath = new GeodeticTransformPath(datumConvert);
        CS_dtclsDefOnly(datumConvert);
        return returnPath;
        }

    // check if from datum has additional transform paths in from datum
    for (auto fromPath : from.GetAdditionalGeodeticTransformPaths())
        {
        // Check if path contains transform to target
        if (nullptr != fromPath && fromPath->ContainsTransformPathTo(to.GetName()))
            {
            GeodeticTransformPath* newPath = fromPath->CreateTransformPathTo(to.GetName());
            if (newPath == nullptr)
                return NULL; // Something went wrong.

            return newPath;
            }
        }

    // check if from datum has additional transform paths in to datum
    for (auto toPath : to.GetAdditionalGeodeticTransformPaths())
        {
        // Check if path contains transform to target
        if (nullptr != toPath && toPath->ContainsTransformPathTo(from.GetName()))
            {
            GeodeticTransformPath* newPath = toPath->CreateTransformPathTo(from.GetName());
            if (newPath == nullptr)
                return NULL; // Something went wrong.

            // Reverse path so input becomes fromDatum
            if (SUCCESS != newPath->Reverse())
                {
                // Path is not reversible
                newPath->Destroy();
                return NULL;
                }

            return newPath;
            }
        }

    // check if from datum has stored transforms.
    GeodeticTransformPathCP fromPath = from.GetStoredGeodeticTransformPath();

    // Check if path contains transform to target
    if (nullptr != fromPath && fromPath->ContainsTransformPathTo(to.GetName())) {
        GeodeticTransformPath* newPath = fromPath->CreateTransformPathTo(to.GetName());
        if (newPath == nullptr)
            return NULL; // Something went wrong.

        return newPath;
    }

    // check if to datum has stored transforms.
    GeodeticTransformPathCP toPath = to.GetStoredGeodeticTransformPath();

    // Check if path contains transform to source
    if (nullptr != toPath && toPath->ContainsTransformPathTo(from.GetName())) {
        GeodeticTransformPath* newPath = toPath->CreateTransformPathTo(from.GetName());
        if (nullptr == newPath)
            return NULL; // Something went wrong.

        // Reverse path so input becomes fromDatum
        if (SUCCESS != newPath->Reverse()) {
            // Path is not reversible
            newPath->Destroy();
            return NULL;
        }

        return newPath;
    }

    // Chain both geodetic paths to WGS84
    fromPath = from.GetGeodeticTransformPathToWGS84();
    toPath = to.GetGeodeticTransformPathToWGS84();

    if ((nullptr == fromPath) || (nullptr == toPath))
        return NULL; // Something went wrong.

    GeodeticTransformPathP toPathReversed = toPath->Clone();

    if (nullptr == toPathReversed)
        return NULL;

    if (SUCCESS != toPathReversed->Reverse()) {
        toPathReversed->Destroy();
        return NULL; // Not reversible
    }

    GeodeticTransformPathP fullPath;
    fullPath = GeodeticTransformPath::CreateMerged(*fromPath, *toPathReversed);

    toPathReversed->Destroy();

    return fullPath;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPathP         GeodeticTransformPath::CreateToWgs84
(
    DatumCR     from
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return NULL;

    static DatumCP wgs84Datum = Datum::CreateDatum("WGS84");
    if (nullptr == wgs84Datum)
        return nullptr;

    CSDatum* srcCSDatum = from.GetCSDatum();
    if (NULL == srcCSDatum)
        return NULL;

    CSDatum* wgs84CSDatum = wgs84Datum->GetCSDatum();
    if (NULL == wgs84CSDatum)
        return NULL;

    CSDatumConvert  *datumConvert = CSMap::CSdtcsuDefOnly(srcCSDatum, wgs84CSDatum);

    if (NULL != datumConvert)
        {
        GeodeticTransformPathP returnPath = new GeodeticTransformPath(datumConvert);
        CS_dtclsDefOnly(datumConvert);
        return returnPath;
        }

    // check if this datum has stored transforms.
    GeodeticTransformPathCP fromPath = from.GetStoredGeodeticTransformPath();

    // Check if path contains transform to target
    if (nullptr != fromPath)
        {
        if (fromPath->ContainsTransformPathTo("WGS84"))
            {
            GeodeticTransformPath* newPath = fromPath->CreateTransformPathTo("WGS84");
            if (nullptr == newPath)
                return NULL; // Something went wrong.

            return newPath;
            }

        // The dictionary does not how to get to WGS84 and the datum has no transform to WGS84 ... we check from target datum to path
        // Obtain the destination datum
        Utf8String pathTargetName = fromPath->GetTargetDatumName();
        if (pathTargetName != "") // An empty target name would have been interpreted as WGS84 above
            {
            CSDatum* pathTargetCSDatum = CS_dtloc(pathTargetName.c_str());
            if (nullptr != pathTargetCSDatum)
                {
                datumConvert = CSMap::CSdtcsuDefOnly(pathTargetCSDatum, wgs84CSDatum);

                if (NULL != datumConvert)
                    {
                    GeodeticTransformPath* newPath = new GeodeticTransformPath(datumConvert);

                    CS_dtclsDefOnly(datumConvert);

                    if (nullptr != newPath)
                        {
                        GeodeticTransformPathP fullPath;
                        fullPath = GeodeticTransformPath::CreateMerged(*fromPath, *newPath);
                        newPath->Destroy();
                        CS_free(pathTargetCSDatum);

                        return fullPath;
                        }
                    }

                CS_free(pathTargetCSDatum);
                }
            }
        }

    // If we get here something went wrong at one of the various checks
    return nullptr;
}

/*---------------------------------------------------------------------------------**//**
* Returns a new geodetic path as the concatenation of the two paths given.
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPathP      GeodeticTransformPath::CreateMerged(GeodeticTransformPathCR firstPath, GeodeticTransformPathCR secondPath)
    {
    GeodeticTransformPath* resultPath = firstPath.Clone();

    // Append second path
    for (auto transform : secondPath.m_listOfGeodeticTransforms)
        {
        resultPath->AddGeodeticTransform(transform->Clone());
        }

    return resultPath;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformP      GeodeticTransformPath::CreateSimplifiedGeocentricTransform() const
    {
    GeodeticTransformP result = nullptr;

    // If the path contains a single transform and this transform is one of the various geocentric types
    // then we return a copy of this transform
    // If the path is long or contains a complex (grid file) transform then we return NULL

    if (m_listOfGeodeticTransforms.size() >= 1)
        {
        int numberNonNull = 0;
        size_t indexNonNull = 0;

        for (size_t index = 0 ; index < m_listOfGeodeticTransforms.size() ; index++)
            {
            if (!m_listOfGeodeticTransforms[index]->IsNullTransform())
                {
                numberNonNull++;
                if (numberNonNull == 1)
                    {
                    indexNonNull = index;
                    }
                else
                    {
                    // Too many non null; we break
                    break;
                    }
                }
            }

        if (numberNonNull == 0)
            {
            // All transforms are null ... we return a null transform
            result = GeodeticTransform::CreateGeodeticTransform();
            if (nullptr != result)
                {
                result->SetConvertMethodCode(GenConvertCode::GenConvertType_NONE);
                }
            }
        else if (1 == numberNonNull)
            {
            GeodeticTransformCP firstTransform = m_listOfGeodeticTransforms[indexNonNull];

            if ((firstTransform->GetConvertMethodCode() == GenConvertCode::GenConvertType_GEOCTR) ||
                (firstTransform->GetConvertMethodCode() == GenConvertCode::GenConvertType_7PARM) ||
                (firstTransform->GetConvertMethodCode() == GenConvertCode::GenConvertType_NONE))
                {
                result = firstTransform->Clone();
                }
            }
        }

    return result;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool              GeodeticTransformPath::HasMissingGridFiles(bvector<Utf8String>& listOfFiles, bool includeFilesToDeprecatedDatums) const
    {
    // If we are not to return files to deprecated datums we must first check if the path is for fully deprecated chain
    // If any target datum is not deprecated then we return all files.
    if (!includeFilesToDeprecatedDatums)
        {
        // If all intermediate target datums are deprecated then we bypass
        bool deprecated = true;
        for (size_t index = 0; deprecated && (index < GetGeodeticTransformCount()); index++)
            {
            GeodeticTransformCP currentTransform = GetGeodeticTransform(index);

            if (Utf8String("") != currentTransform->GetTargetDatumName())
                {
                DatumCP targetDatum = Datum::CreateDatum(currentTransform->GetTargetDatumName());
                if (nullptr != targetDatum)
                    {
                    if (!targetDatum->IsDeprecated())
                        deprecated = false;
                    targetDatum->Destroy();
                    }
                }
            }
        if (deprecated)
            return false; // If target is deprecated we bypass.
        }


    bool missing = false;

    for (auto transform: m_listOfGeodeticTransforms)
        {
        if (GeodeticTransformDataAvailability::DataUnavailable == transform->GetDataAvailability(true))
            {
            for (size_t indexGridFile = 0 ; indexGridFile < transform->GetGridFileDefinitionCount(); indexGridFile++)
                {
                missing = true;
                GridFileDefinition fileDef = transform->GetGridFileDefinition(indexGridFile);
                listOfFiles.push_back(fileDef.GetFileName());
                }
            }
        }

    return missing;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPath::~GeodeticTransformPath
(
)
    {
    if (!BaseGCS::IsLibraryInitialized())
        return ;

    for (auto transform : m_listOfGeodeticTransforms)
        transform->Destroy();

    m_listOfGeodeticTransforms.clear();
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt         GeodeticTransformPath::FromJson (BeJsConst jsonValue, Utf8StringR errorMessage)
    {
    StatusInt status;

    // Error processing lambda definitions
    auto BadArg = [&errorMessage](Utf8CP message)
        {
        errorMessage = message;
        return GEOCOORDERR_BadArg;
        };

    for (auto transform : m_listOfGeodeticTransforms)
        transform->Destroy();

    m_listOfGeodeticTransforms.clear();

    Utf8String sourceDatumId;
    Utf8String targetDatumId;
    if (!jsonValue["sourceDatumId"].isNull())
        sourceDatumId = jsonValue["sourceDatumId"].asString();

    if (!jsonValue["targetDatumId"].isNull())
        targetDatumId = jsonValue["targetDatumId"].asString();

    // If there is a single transform and it is storable in the datum then we extract it.
    if (!jsonValue["transforms"].isNull())
        {
        auto transformsValue = jsonValue["transforms"];

        // Add all transforms to path
        for (unsigned int index = 0; index < transformsValue.size() && !transformsValue[index].isNull() ; index++)
            {
            GeodeticTransform* theTransform2 = GeodeticTransform::CreateGeodeticTransform();
            if (nullptr == theTransform2)
                return BadArg("Bad Transform");

            if (SUCCESS != (status = theTransform2->FromJson(transformsValue[index], errorMessage)))
                return status;

            AddGeodeticTransform(theTransform2);
            }

        if (GetGeodeticTransformCount() > 0)
            {
            // We set the final source and target name if needed
            if (Utf8String(GetSourceDatumName()) == "" && sourceDatumId.length() > 0)
                GetGeodeticTransform(0)->SetSourceDatumName(sourceDatumId.c_str());

            if (Utf8String(GetTargetDatumName()) == "" && targetDatumId.length() > 0)
                GetGeodeticTransform(GetGeodeticTransformCount() - 1)->SetTargetDatumName(targetDatumId.c_str());
            }
        }

    return SUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt         GeodeticTransformPath::ToJson(BeJsValue jsonValue) const
    {
    Utf8String errorMessage = "";

    // Error processing lambda definitions
    auto BadProperty = [&errorMessage](Utf8CP name, StatusInt status = GEOCOORDERR_BadArg)
        {
        errorMessage.Sprintf("'%s' is invalid", name);
        return status;
        };

    StatusInt result = SUCCESS;

    jsonValue["sourceDatumId"] = Utf8String(GetSourceDatumName());
    jsonValue["targetDatumId"] = Utf8String(GetTargetDatumName());

    int indexTransforms = 0;
    BeJsValue geodeticTransformsArrayVal(jsonValue["transforms"]);
    geodeticTransformsArrayVal.toArray();

    for (size_t index = 0; index < GetGeodeticTransformCount(); index++)
        {
        GeodeticTransformCP geodeticTransform = GetGeodeticTransform(index);

        if (geodeticTransform != nullptr)
            {
            if (!geodeticTransform->IsNullTransform())
                {
                BeJsValue geodeticTransformVal(geodeticTransformsArrayVal[indexTransforms]);

                if (SUCCESS != (result = geodeticTransform->ToJson(geodeticTransformVal)))
                    return BadProperty("GeodeticTransform", result);
                indexTransforms++;
                }
            }
        }

    // If there were no transform we add a NONE to indicate conversion is null (same as WGS84)
    // An empty list of transform is interpreted as transform undefined (which is different than no transform)
    if (indexTransforms == 0)
        {
        BeJsValue nullTrfVal(geodeticTransformsArrayVal[0]);
        nullTrfVal["method"] = "None";
        }

    return SUCCESS;
}
void GeodeticTransformPath::Destroy() const { delete this; }

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP GeodeticTransformPath::GetSourceDatumName() const {
    if (0 < m_listOfGeodeticTransforms.size())
        return m_listOfGeodeticTransforms[0]->GetSourceDatumName();

    return "";
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP GeodeticTransformPath::GetTargetDatumName() const {
    if (0 < m_listOfGeodeticTransforms.size())
        return m_listOfGeodeticTransforms[m_listOfGeodeticTransforms.size() - 1]->GetTargetDatumName();

    return "";
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
size_t GeodeticTransformPath::GetGeodeticTransformCount() const {
    return m_listOfGeodeticTransforms.size();
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformCP GeodeticTransformPath::GetGeodeticTransform(size_t index) const {
    if (index < 0 || index > (size_t)(m_listOfGeodeticTransforms.size() - 1))
        return NULL;

    // if (directApply != NULL)
        // *directApply = (m_datumConvert->xforms[index]->userDirection == 1);

    return m_listOfGeodeticTransforms[index];
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformP GeodeticTransformPath::GetGeodeticTransform(size_t index) {
    if (index < 0 || index >(size_t)(m_listOfGeodeticTransforms.size() - 1))
        return NULL;

    // if (directApply != NULL)
        // *directApply = (m_datumConvert->xforms[index]->userDirection == 1);

    return m_listOfGeodeticTransforms[index];
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt GeodeticTransformPath::AddGeodeticTransform(GeodeticTransformP newTransform) {
    if (nullptr == newTransform)
        return ERROR;

    m_listOfGeodeticTransforms.push_back(newTransform);

    return SUCCESS;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool GeodeticTransformPath::IsNullTransform() const {
    return RepresentsNullTransform(m_listOfGeodeticTransforms);
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   GeodeticTransformPath::IsEquivalent(GeodeticTransformPathCR compareTo, bool looselyCompare) const
    {
    // If both are null transforms ... then that is it
    if (IsNullTransform() && compareTo.IsNullTransform())
        return true;

    return GeodeticTransformPathAreEquivalent(m_listOfGeodeticTransforms, compareTo.m_listOfGeodeticTransforms, looselyCompare);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   GeodeticTransformPath::IsVerticallyNeutral() const
    {
    // If both are null transforms ... then that is it
    if (RepresentsNullTransform(m_listOfGeodeticTransforms))
        return true;

    for (size_t index = 0; index < m_listOfGeodeticTransforms.size(); ++index)
        {
        GeodeticTransformCP currentTransform = m_listOfGeodeticTransforms[index];

        if (nullptr == currentTransform)
            return false;

        if (!currentTransform->IsNullTransform())
            {
            if (!currentTransform->IsVerticallyNeutral())
                return false;
            }
        }

    return true;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
bool   GeodeticTransformPath::ContainsTransformPathTo(Utf8CP datumName) const
    {
    // An empty datumName returns false immediately
    if (datumName[0] == L'\0')
        return false;

    for (auto transform : m_listOfGeodeticTransforms)
        {
        // We consider both source and target names since sometimes
        // chained source and target can be different when null transforms have been removed.
        if (Utf8String(transform->GetSourceDatumName()) == Utf8String(datumName) ||
            Utf8String(transform->GetTargetDatumName()) == Utf8String(datumName))
            {
            return true;
            }
        }

    return false;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPath*   GeodeticTransformPath::CreateTransformPathTo(Utf8CP datumName) const
    {
    // An empty datumName returns false immediately
    if (datumName[0] == L'\0')
        return NULL;

    GeodeticTransformPath* resultPath = GeodeticTransformPath::Create();
    auto targetFound = false;

    for (auto transform : m_listOfGeodeticTransforms)
        {
        // We consider both source and target names since sometimes
        // chained source and target can be different when null transforms have been removed.
        if (Utf8String(transform->GetSourceDatumName()) == Utf8String(datumName))
            {
            // Since source of next is requested last one added was the last
            targetFound = true;
            break;
            }

        if (Utf8String(transform->GetTargetDatumName()) == Utf8String(datumName))
            {
            resultPath->AddGeodeticTransform(transform->Clone());
            targetFound = true;
            break;
            }

        // requested datum not located ... we add transform to path and go on
        resultPath->AddGeodeticTransform(transform->Clone());
        }

    if (!targetFound)
        {
        resultPath->Destroy();
        resultPath = nullptr;
        }

    // NOTE: The result path may have no transform indicating none is required to target or be null
    // if no path exists.

    // Set the target datum name (could be different from name given)
    if ((nullptr != resultPath) && (resultPath->GetGeodeticTransformCount() > 0))
        {
        resultPath->GetGeodeticTransform(resultPath->GetGeodeticTransformCount() - 1)->SetTargetDatumName(datumName);
        }

    return resultPath;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
StatusInt             GeodeticTransformPath::Reverse()
    {
    StatusInt result = SUCCESS;

    bvector<GeodeticTransformP> tempList;

    for (size_t index = m_listOfGeodeticTransforms.size() ; index != 0 ; index--)
        {
        GeodeticTransformP newT = m_listOfGeodeticTransforms[index - 1]->Clone();

        if (nullptr == newT)
            {
            result = ERROR;
            break;
            }

        if (SUCCESS != newT->Reverse())
            {
            newT->Destroy();
            result = ERROR;
            break;
            }

        tempList.push_back(newT);
        }

    if (SUCCESS == result)
        {
        // We replace current list with reversed list.
        for (auto transform : m_listOfGeodeticTransforms)
            transform->Destroy();

        m_listOfGeodeticTransforms.clear();

        for (auto transform2: tempList)
            m_listOfGeodeticTransforms.push_back(transform2);
        }
    else
        {
        // Something went wrong ... we clean up
        for (auto transform3 : tempList)
            transform3->Destroy();
        }

    return result;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
GeodeticTransformPathP             GeodeticTransformPath::Clone() const
    {
    GeodeticTransformPathP theNewPath = GeodeticTransformPath::Create();

    for (size_t index = 0 ; index < GetGeodeticTransformCount() ; index++)
        {
        theNewPath->AddGeodeticTransform(GetGeodeticTransform(index)->Clone());
        }

    return theNewPath;
    }

/*=================================================================================**//**
* This class has only static methods that map directly to CSMap functions.
+===============+===============+===============+===============+===============+======*/
typedef const double PointArray[3];

int             CSMap::CS_csGrpEnum (int index,char *grpName,int nameSize,char *descr,int descrSize) {return ::CS_csGrpEnum (index, grpName, nameSize, descr, descrSize);}
int             CSMap::CS_csEnum (int index,char *keyName,int nameSize) {return ::CS_csEnum (index, keyName, nameSize);}
CSParameters*   CSMap::CScsloc2 (CSDefinition* csDef, CSDatumDef* dtDef, CSEllipsoidDef* elDef) {return ::CScsloc2 (csDef, dtDef, elDef);}
CSParameters*   CSMap::CScsloc1 (CSDefinition* csDef) {return ::CScsloc1 (csDef);}
CSParameters*   CSMap::CS_csloc (Const char *keyName) {return ::CS_csloc (keyName);}
char*           CSMap::CS_stncp (char *out, const char *in, int count) {return ::CS_stncp (out, in, count);}
void            CSMap::CS_errmsg (char *out, int bufSize) {::CS_errmsg (out, bufSize);}
int             CSMap::CS_cs3ll (const CSParameters* csprm, GeoPointP ll, DPoint3dCP xy) {return ::CS_cs3ll (csprm, (double*)ll, (const double*)xy);}
int             CSMap::CS_ll3cs (const CSParameters* csprm, DPoint3dP xy, GeoPointCP ll) {return ::CS_ll3cs (csprm, (double*)xy, (const double*)ll);}
int             CSMap::CS_dtcvt3D (CSDatumConvert* dtcvt, GeoPointCP ll_in, GeoPointP ll_out) {return ::CS_dtcvt3D (dtcvt, (const double*)ll_in, (double *)ll_out);}
int             CSMap::CS_cs2ll (const CSParameters* csprm, GeoPointP ll, DPoint3dCP xy) {return ::CS_cs2ll (csprm, (double*)ll, (const double*)xy);}
int             CSMap::CS_ll2cs (const CSParameters* csprm, DPoint3dP xy, GeoPointCP ll) {return ::CS_ll2cs (csprm, (double*)xy, (const double*)ll);}
int             CSMap::CS_dtcvt (CSDatumConvert* dtcvt, GeoPointCP ll_in, GeoPointP ll_out) {return ::CS_dtcvt (dtcvt, (const double*)ll_in, (double *)ll_out);}
CSDatumConvert* CSMap::CS_dtcsu (const CSParameters* src, const CSParameters* dest) {return ::CS_dtcsu (src, dest, cs_DTCFLG_DAT_F, cs_DTCFLG_BLK_F);}
#ifdef GEOCOORD_ENHANCEMENT
// Calls CSMAP CS_dtcsu with a newly introduced flag by us. The returned object must be destroyed using dtclsDefOnly() and NOT dtcls().
CSDatumConvert* CSMap::CS_dtcsuDefOnly (const CSParameters* src, const CSParameters* dest) {return ::CS_dtcsu (src, dest, cs_DTCFLG_DAT_DEFONLY, cs_DTCFLG_BLK_F);}
int             CSMap::CS_gpdefFrom(CSGeodeticPath **array, int numArray, Const char *srcDatum) {return ::CS_gpdefFrom(array, numArray, srcDatum);}
int             CSMap::CS_gxdefFrom(CSGeodeticTransformDef **array, int numArray, Const char *srcDatum) {return ::CS_gxdefFrom(array, numArray, srcDatum);}
void            CSMap::CS_dtclsDefOnly (CSDatumConvert* datumConvert) {::CS_dtclsDefOnly (datumConvert);}
#endif

int             CSMap::CS_gxdefAll (CSGeodeticTransformDef **pDefArray[]) {return ::CS_gxdefAll(pDefArray);}
int             CSMap::CS_gpdefAll (CSGeodeticPath **pDefArray[]) {return ::CS_gpdefAll(pDefArray);}

void            CSMap::CS_dtcls (CSDatumConvert* datumConvert) {::CS_dtcls (datumConvert);}
double          CSMap::CS_cscnv (const CSParameters* csprm, GeoPointCP ll) {return ::CS_cscnv (csprm, (const double *)ll);}
double          CSMap::CS_cssch (const CSParameters* csprm, GeoPointCP ll) {return ::CS_cssch (csprm, (const double *)ll);}
double          CSMap::CS_cssck (const CSParameters* csprm, GeoPointCP ll) {return ::CS_cssck (csprm, (const double *)ll);}
double          CSMap::CS_csscl (const CSParameters* csprm, GeoPointCP ll) {return ::CS_csscl (csprm, (const double *)ll);}
void            CSMap::CS_fillIn (CSDefinition* csdef) {::CS_fillIn (csdef);}
int             CSMap::CSerpt (char *mesg,int size,int err_num) {return ::CSerpt (mesg, size, err_num);}
int             CSMap::CS_wktToCsEx (CSDefinition *csDef, CSDatumDef *dtDef, CSEllipsoidDef *elDef, GeoCoordinates::BaseGCS::WktFlavor flavor, CharCP wellKnownText) {return ::CS_wktToCsEx (csDef, dtDef, elDef, (ErcWktFlavor)flavor, wellKnownText, 1);}
bool            CSMap::CS_prjprm (CSParamInfo *info, int projectionCode, int paramNum) {return 0 < ::CS_prjprm (info, (short)projectionCode, paramNum);}
CSEllipsoidDef* CSMap::CS_eldef (const char * keyName) {return ::CS_eldef (keyName);}
CSDatumDef*     CSMap::CS_dtdef (const char * keyName) {return ::CS_dtdef (keyName);}
CSDefinition*   CSMap::CS_csdef (const char * keyName) {return ::CS_csdef (keyName);}
CSGeodeticTransformDef*   CSMap::CS_gxdef (const char * keyName) {return ::CS_gxdef (keyName);}
void            CSMap::CS_free  (void * mem) {::CS_free (mem);}
int             CSMap::CS_dtEnum (int index, char *key_name, int name_sz) {return ::CS_dtEnum (index, key_name, name_sz);}
int             CSMap::CS_elEnum (int index, char *key_name, int name_sz) {return ::CS_elEnum (index, key_name, name_sz);}
CSDatum*        CSMap::CS_dtloc (char *key_name) {return ::CS_dtloc (key_name);}
double          CSMap::CS_llazdd (double eRad, double eSq, GeoPointCP startPoint, GeoPointCP endPoint, double *distance) {return ::CS_llazdd (eRad, eSq, (const double *)startPoint, (const double *) endPoint, distance);}
int             CSMap::CS_llchk (const CSParameters* csprm, int numPoints, GeoPointCP ll) {return ::CS_llchk (csprm, numPoints, (PointArray*)ll);}
int             CSMap::CS_xychk (const CSParameters* csprm, int numPoints, DPoint3dCP xy) {return ::CS_llchk (csprm, numPoints, (PointArray*)xy);}
CSDatumConvert* CSMap::CSdtcsu (const CSDatum* src, const CSDatum* dest) {return ::CSdtcsu (src, dest, cs_DTCFLG_DAT_F, cs_DTCFLG_BLK_F);}
#ifdef GEOCOORD_ENHANCEMENT
CSDatumConvert* CSMap::CSdtcsuDefOnly (const CSDatum* src, const CSDatum* dest) {return ::CSdtcsu (src, dest, cs_DTCFLG_DAT_DEFONLY, cs_DTCFLG_BLK_F);}
#endif
CSDatum*        CSMap::CSdtloc1 (const CSDatumDef* datumDef) {return ::CSdtloc1 (datumDef);}
CSUnitInfo const * CSMap::GetCSUnitInfo (int unitIndex)
    {
    CSUnitInfo const*    csUnitInfo = &cs_Unittab[unitIndex];
    return (cs_UTYP_END == csUnitInfo->type) ? NULL : csUnitInfo;
    }

CSMilitaryGrid* CSMap::CSnewMgrs (double e_rad, double e_sq, short bessel) {return ::CSnewMgrs (e_rad, e_sq, bessel); }
int             CSMap::CScalcMgrsFromLl (CSMilitaryGrid* mg, char* result, int size, GeoPoint2dP ll, int precision) {return ::CScalcMgrsFromLl (mg, result, size, (double *)ll, precision); }
int             CSMap::CScalcLlFromMgrs (CSMilitaryGrid* mg, GeoPoint2dP ll, const char* mgrsString) {return ::CScalcLlFromMgrs (mg, (double *)ll, mgrsString); }
void            CSMap::CSdeleteMgrs (CSMilitaryGrid* mg) {::CSdeleteMgrs (mg);}
void            CSMap::CS_llhToXyz (DPoint3dP xyz,const GeoPointCP llh, double e_rad, double e_sq) {::CS_llhToXyz((double*)xyz, (const double*)llh, e_rad, e_sq);}
int             CSMap::CS_xyzToLlh (GeoPointP llh,const DPoint3dCP xyz, double e_rad, double e_sq) {return ::CS_xyzToLlh((double*)llh, (const double*)xyz, e_rad, e_sq);}
double          CSMap::CSmrcatPhiFromK (double e_sq,double scl_red) {return ::CSmrcatPhiFromK(e_sq, scl_red);}


/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
MilitaryGridConverter::MilitaryGridConverter(BaseGCSR baseGCS, bool useBessel, bool useWGS84Datum) {
    m_toWGS84Converter = NULL;
    m_fromWGS84Converter = NULL;

    // can't have both useBessel and useWGS84Datum.
    BeAssert(!useBessel || !useWGS84Datum);

    if (!baseGCS.IsValid()) {
        m_csMgrs = NULL;
        return;
    }

    if (useBessel) {
        // we use the GCS only to get the ellipsoid information.
        // we do not convert the LL to a different datum in this case.

        // use Bessel version of the grid labels for Clarke and Bessel ellipsoids.
        Utf8CP ellipsoidName = baseGCS.GetEllipsoidName();
        bool besselEllipsoid = (0 == BeStringUtilities::Strnicmp("CLRK", ellipsoidName, 4)) || (0 == BeStringUtilities::Strnicmp("BES", ellipsoidName, 4)) ||
                               (0 == BeStringUtilities::Strnicmp("BESSEL", ellipsoidName, 6));
        UNUSED_VARIABLE(besselEllipsoid);
        BeAssert(besselEllipsoid);

        double eccentricity = baseGCS.GetEllipsoidEccentricity();
        m_csMgrs = CSMap::CSnewMgrs(baseGCS.GetEllipsoidEquatorialRadius(), eccentricity * eccentricity, useBessel);
    } else {
        // this version converts the LL in the GCS to WGS84, and then uses the WGS84-based LL to get the Military Grid Coordinates.
        CSDatum* sourceDatum = NULL;
        CSParameters* sourceCSParams;
        if (NULL != (sourceCSParams = baseGCS.GetCSParameters()))
            sourceDatum = &sourceCSParams->datum;

        if (nullptr == sourceDatum) {
            m_csMgrs = NULL;
            return;
        }

        double eccentricity = sourceDatum->ecent;
        double equatorialRadius = sourceDatum->e_rad;

        DatumCP wgs84Datum = NULL;
        CSDatum* wgs84CSDatum = NULL;
        if (useWGS84Datum) {
            // getting WGS84 should never fail.
            if (NULL == (wgs84Datum = GeoCoordinates::Datum::CreateDatum("WGS84"))) {
                BeAssert(false);
                return;
            }

            if (NULL == (wgs84CSDatum = wgs84Datum->GetCSDatum())) {
                BeAssert(false);
                wgs84Datum->Destroy();
                return;
            }
            eccentricity = wgs84CSDatum->ecent;
            equatorialRadius = wgs84CSDatum->e_rad;
        }

        m_csMgrs = CSMap::CSnewMgrs(equatorialRadius, eccentricity * eccentricity, false);

        if ((NULL != sourceDatum) && (NULL != wgs84CSDatum)) {
            CSDatumConvert* toWGS84CSDatumConvert = CSMap::CSdtcsu(sourceDatum, wgs84CSDatum);
            if (NULL != toWGS84CSDatumConvert)
                m_toWGS84Converter = new DatumConverter(toWGS84CSDatumConvert, NULL);

            CSDatumConvert* fromWGS84CSDatumConvert = CSMap::CSdtcsu(wgs84CSDatum, sourceDatum);
            if (NULL != fromWGS84CSDatumConvert)
                m_fromWGS84Converter = new DatumConverter(fromWGS84CSDatumConvert, NULL);
        }

        if (nullptr != wgs84Datum)
            wgs84Datum->Destroy();

    }
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
MilitaryGridConverter::~MilitaryGridConverter() {
    if (NULL != m_toWGS84Converter)
        delete m_toWGS84Converter;
    if (NULL != m_fromWGS84Converter)
        delete m_fromWGS84Converter;
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
MilitaryGridConverterPtr MilitaryGridConverter::CreateConverter(BaseGCSR baseGCS, bool useBessel, bool useWGS84) {
    if (!baseGCS.IsValid())
        return NULL;

    return new MilitaryGridConverter(baseGCS, useBessel, useWGS84);
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
StatusInt MilitaryGridConverter::LatLongFromMilitaryGrid(GeoPoint2dR outLatLong, Utf8CP mgString) {
    StatusInt status = SUCCESS;

    GeoPoint2d tmpLatLong;

    if ((NULL != m_csMgrs) && (0 == (status = CSMap::CScalcLlFromMgrs(m_csMgrs, &tmpLatLong, mgString)))) {
        if (NULL != m_fromWGS84Converter)
            m_fromWGS84Converter->ConvertLatLong2D(outLatLong, tmpLatLong);
        else
            outLatLong = tmpLatLong;
    } else {
        outLatLong.latitude = 0.0;
        outLatLong.longitude = 0.0;
        status = ERROR;
    }
    return status;
}

/*---------------------------------------------------------------------------------**/ /**
 * @bsimethod
 +---------------+---------------+---------------+---------------+---------------+------*/
StatusInt MilitaryGridConverter::MilitaryGridFromLatLong(Utf8String& mgString, GeoPoint2dCR inLatLong, int precision) {
    char mgChar[512];

    GeoPoint2d outLatLong = inLatLong;

    if (NULL != m_toWGS84Converter)
        m_toWGS84Converter->ConvertLatLong2D(outLatLong, inLatLong);

    // 5 is the maximum precision.
    StatusInt status = SUCCESS;
    if ((NULL != m_csMgrs) && (0 == (status = CSMap::CScalcMgrsFromLl(m_csMgrs, mgChar, _countof(mgChar), &outLatLong, precision))))
        mgString = mgChar;
    else {
        mgString = "";
        status = ERROR;
    }

    return status;
}

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP    BaseGeoCoordResource::GetLocalizedProjectionName
(
Utf8StringR                        outString,
BaseGCS::ProjectionCodeValue    projectionCode
)
    {
    DgnProjectionTypes  dgnProjectionType;

    if (DgnProjectionTypes::COORDSYS_NONE == (dgnProjectionType = BaseGCS::DgnProjectionTypeFromCSMapProjectionCode (projectionCode)))
        {
        outString.clear();
        return outString.c_str();
        }

    return GetLocalizedProjectionName (outString, dgnProjectionType);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP    BaseGeoCoordResource::GetLocalizedProjectionName
(
Utf8StringR                    outString,
DgnProjectionTypes          projectionType
)
    {
    outString.clear();
    return outString.c_str();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8CP BaseGeoCoordResource::GetLocalizedString
(
Utf8StringR                outString,
DgnGeoCoordStrings      stringNum
)
    {
    return NULL;
    }
} // Ends GeoCoordinate namespace

END_BENTLEY_NAMESPACE

/*=================================================================================**//**
* Base GeoCoordinateSystem API
+===============+===============+===============+===============+===============+======*/
BEGIN_EXTERN_C



//=======================================================================================
// fopen-based GCS data file. Used only when a requested file cannot be found in a workspace, but is present in the assets dir.
// @bsiclass
//=======================================================================================
struct AssetDirFile : _csFile {
    FILE* m_file;
    AssetDirFile(FILE* file) : m_file(file) {}
    virtual size_t read(void* buffer, size_t size, size_t count) override { return fread(buffer, size, count, m_file);}
    virtual int seek(int64_t offset, int origin) override {
#ifdef _WIN32
        return _fseeki64(m_file, offset, origin);
#elif defined(ANDROID) || defined(__APPLE__)
        return fseeko(m_file, offset, origin);
#else
        return fseeko64(m_file, offset, origin);
#endif
    }
    virtual int getc() override { return fgetc(m_file); }
    virtual char* gets(char* str, int n) override { return fgets(str, n, m_file); }
    virtual int64_t tell() override {
#ifdef _WIN32
        return _ftelli64(m_file);
#elif defined(ANDROID) || defined(__APPLE__)
        return ftello(m_file);
#else
        return ftello64(m_file);
#endif
    }
    virtual int close() override { return fclose(m_file); }
    virtual int setvbuf(char* buffer, int mode, size_t size) override { return ::setvbuf(m_file, buffer, mode, size); }
    virtual int flush() override { return fflush(m_file); }
    virtual int eof() override { return feof(m_file); }
    virtual int error() override { return ferror(m_file); }
    virtual int putc(int character) override { return fputc(character, m_file); }
    virtual int puts(const char* str) override { return fputs(str, m_file); }
    virtual size_t write(const void* ptr, size_t size, size_t count) override { return fwrite(ptr, size, count, m_file); }
    virtual int truncate(long writePosition) override {
        int fileDescriptor = _fileno(m_file);
#ifdef _WIN32
        return _chsize(fileDescriptor, writePosition);
#else
#if defined(ANDROID) || defined(__APPLE__)
        return ::ftruncate(fileDescriptor, writePosition);
#else
        return ftruncate64(fileDescriptor, writePosition);
#endif
#endif
    }
    virtual int printf(Utf8CP format...) override {
        va_list args;
        va_start(args, format);
        return vfprintf(m_file, format, args);
    }
    virtual ~AssetDirFile() {}
};

size_t CS_fread(void* buffer, size_t size, size_t count, csFILE* stream) { return stream->read(buffer, size, count); }
size_t CS_fwrite(const void* ptr, size_t size, size_t count, csFILE* stream) { return stream->write(ptr, size, count); }
int CS_fclose(_csFile* stream) {
    int ret = stream->close();
    delete stream;
    return ret;
}
int CS_fseek(_csFile* stream, long int offset, int origin) { return stream->seek(offset, origin); }
long CS_ftell(_csFile* stream) { return (long) stream->tell(); }
int64_t CS_ftell64(_csFile* stream) { return stream->tell(); }
int CS_fflush(_csFile* stream) { return stream->flush(); }
int CS_feof(_csFile* stream) { return stream->eof(); }
int CS_ferror(_csFile* stream) { return stream->error(); }
int CS_fgetc(_csFile* stream) { return stream->getc(); }
int CS_fputc(int character, _csFile* stream) { return stream->putc(character); }
char* CS_fgets(char* str, int num, _csFile* stream) { return stream->gets(str, num); }
int CS_fputs(const char* str, _csFile* stream) { return stream->puts(str); }
int CS_setvbuf(_csFile* stream, char* buffer, int mode, size_t size) { return stream->setvbuf(buffer, mode, size); }
int CS_access(Utf8CP path, int mode) { return 0 == CS_fileModTime(path) ? -1 : 0; }
int CS_truncate(_csFile* stream, long writePosition) { return stream->truncate(writePosition); }
int CS_fprintf(_csFile* stream, Utf8CP format...) {
    va_list args;
    va_start(args, format);
    return stream->printf(format, args);
}
cs_Time_ CS_fileModTime(Utf8CP filePath) {
    auto row = BentleyApi::GeoCoordinates::GeoCoordWorkspaces::GetRow(filePath);
    if (row.rowId != 0)
        return 1;
    auto name = BentleyApi::GeoCoordinates::toAssetName(filePath);
    struct _stat statBufr;
    auto st = _stat(name.c_str(), &statBufr);
    return (st == 0) ? (cs_Time_)statBufr.st_mtime : 0;
}


_csFile* CS_fopen(Utf8CP filename, Utf8CP mode) {
    if (0 == strncmp(mode, "r", 1)) {
        auto wsFile = BentleyApi::GeoCoordinates::GeoCoordWorkspaces::FindResource(filename);
        if (wsFile)
            return wsFile;
    }

    if (!BentleyApi::GeoCoordinates::s_loadLocalFiles)
        return nullptr;

    auto name = BentleyApi::GeoCoordinates::toAssetName(filename);
    auto file = CS_fopen_caseInsensitive(name.c_str(), mode);
    if (file != nullptr)
        Logging::LogMessageV("GeoCoord", LOG_INFO, "Successfully loaded GCS file %s from %s", filename, name.c_str());
    else
        Logging::LogMessageV("GeoCoord", LOG_WARNING, "Unable to find GCS file %s in Workspace or locally", filename);

    return nullptr == file ? nullptr : new AssetDirFile(file);
}

END_EXTERN_C
