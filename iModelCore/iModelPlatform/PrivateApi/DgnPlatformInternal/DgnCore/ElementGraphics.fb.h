/*---------------------------------------------------------------------------------------------
* Copyright (c) Bentley Systems, Incorporated. All rights reserved.
* See LICENSE.md in the repository root for full copyright notice.
*--------------------------------------------------------------------------------------------*/
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ELEMENTGRAPHICS_BENTLEYM0200_DGN_FB_H_
#define FLATBUFFERS_GENERATED_ELEMENTGRAPHICS_BENTLEYM0200_DGN_FB_H_

#include "flatbuffers/flatbuffers.h"

namespace BentleyM0200 {
namespace Dgn {
namespace FB {

struct DPoint3d;

struct DPoint2d;

struct DVec3d;

struct RotMatrix;

struct Transform;

struct Trans2x3;

struct FaceSymbology;

struct FaceSymbologyIndex;

struct DRange1d;

struct PointPrimitive;
struct PointPrimitiveBuilder;

struct PointPrimitive2d;
struct PointPrimitive2dBuilder;

struct ArcPrimitive;
struct ArcPrimitiveBuilder;

struct BRepData;
struct BRepDataBuilder;

struct OCBRepData;
struct OCBRepDataBuilder;

struct Image;
struct ImageBuilder;

struct GeometryPart;
struct GeometryPartBuilder;

struct BasicSymbology;
struct BasicSymbologyBuilder;

struct LineStyleModifiers;
struct LineStyleModifiersBuilder;

struct Material;
struct MaterialBuilder;

struct ThematicSettings;
struct ThematicSettingsBuilder;

struct AreaFill;
struct AreaFillBuilder;

struct DwgHatchDefLine;
struct DwgHatchDefLineBuilder;

struct AreaPattern;
struct AreaPatternBuilder;

enum GradientMode {
  GradientMode_None = 0,
  GradientMode_Linear = 1,
  GradientMode_Curved = 2,
  GradientMode_Cylindrical = 3,
  GradientMode_Spherical = 4,
  GradientMode_Hemispherical = 5,
  GradientMode_MIN = GradientMode_None,
  GradientMode_MAX = GradientMode_Hemispherical
};

inline const GradientMode (&EnumValuesGradientMode())[6] {
  static const GradientMode values[] = {
    GradientMode_None,
    GradientMode_Linear,
    GradientMode_Curved,
    GradientMode_Cylindrical,
    GradientMode_Spherical,
    GradientMode_Hemispherical
  };
  return values;
}

inline const char * const *EnumNamesGradientMode() {
  static const char * const names[7] = {
    "None",
    "Linear",
    "Curved",
    "Cylindrical",
    "Spherical",
    "Hemispherical",
    nullptr
  };
  return names;
}

inline const char *EnumNameGradientMode(GradientMode e) {
  if (flatbuffers::IsOutRange(e, GradientMode_None, GradientMode_Hemispherical)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGradientMode()[index];
}

enum BoundaryType {
  BoundaryType_None = 0,
  BoundaryType_Open = 1,
  BoundaryType_Closed = 2,
  BoundaryType_MIN = BoundaryType_None,
  BoundaryType_MAX = BoundaryType_Closed
};

inline const BoundaryType (&EnumValuesBoundaryType())[3] {
  static const BoundaryType values[] = {
    BoundaryType_None,
    BoundaryType_Open,
    BoundaryType_Closed
  };
  return values;
}

inline const char * const *EnumNamesBoundaryType() {
  static const char * const names[4] = {
    "None",
    "Open",
    "Closed",
    nullptr
  };
  return names;
}

inline const char *EnumNameBoundaryType(BoundaryType e) {
  if (flatbuffers::IsOutRange(e, BoundaryType_None, BoundaryType_Closed)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBoundaryType()[index];
}

enum FillDisplay {
  FillDisplay_None = 0,
  FillDisplay_ByView = 1,
  FillDisplay_Always = 2,
  FillDisplay_Blanking = 3,
  FillDisplay_MIN = FillDisplay_None,
  FillDisplay_MAX = FillDisplay_Blanking
};

inline const FillDisplay (&EnumValuesFillDisplay())[4] {
  static const FillDisplay values[] = {
    FillDisplay_None,
    FillDisplay_ByView,
    FillDisplay_Always,
    FillDisplay_Blanking
  };
  return values;
}

inline const char * const *EnumNamesFillDisplay() {
  static const char * const names[5] = {
    "None",
    "ByView",
    "Always",
    "Blanking",
    nullptr
  };
  return names;
}

inline const char *EnumNameFillDisplay(FillDisplay e) {
  if (flatbuffers::IsOutRange(e, FillDisplay_None, FillDisplay_Blanking)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFillDisplay()[index];
}

enum GeometryClass {
  GeometryClass_Primary = 0,
  GeometryClass_Construction = 1,
  GeometryClass_Dimension = 2,
  GeometryClass_Pattern = 3,
  GeometryClass_MIN = GeometryClass_Primary,
  GeometryClass_MAX = GeometryClass_Pattern
};

inline const GeometryClass (&EnumValuesGeometryClass())[4] {
  static const GeometryClass values[] = {
    GeometryClass_Primary,
    GeometryClass_Construction,
    GeometryClass_Dimension,
    GeometryClass_Pattern
  };
  return values;
}

inline const char * const *EnumNamesGeometryClass() {
  static const char * const names[5] = {
    "Primary",
    "Construction",
    "Dimension",
    "Pattern",
    nullptr
  };
  return names;
}

inline const char *EnumNameGeometryClass(GeometryClass e) {
  if (flatbuffers::IsOutRange(e, GeometryClass_Primary, GeometryClass_Pattern)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGeometryClass()[index];
}

enum BRepType {
  BRepType_Solid = 0,
  BRepType_Sheet = 1,
  BRepType_Wire = 2,
  BRepType_MIN = BRepType_Solid,
  BRepType_MAX = BRepType_Wire
};

inline const BRepType (&EnumValuesBRepType())[3] {
  static const BRepType values[] = {
    BRepType_Solid,
    BRepType_Sheet,
    BRepType_Wire
  };
  return values;
}

inline const char * const *EnumNamesBRepType() {
  static const char * const names[4] = {
    "Solid",
    "Sheet",
    "Wire",
    nullptr
  };
  return names;
}

inline const char *EnumNameBRepType(BRepType e) {
  if (flatbuffers::IsOutRange(e, BRepType_Solid, BRepType_Wire)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBRepType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DPoint3d FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DPoint3d() {
    memset(static_cast<void *>(this), 0, sizeof(DPoint3d));
  }
  DPoint3d(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(DPoint3d, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DPoint2d FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;

 public:
  DPoint2d() {
    memset(static_cast<void *>(this), 0, sizeof(DPoint2d));
  }
  DPoint2d(double _x, double _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(DPoint2d, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DVec3d FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DVec3d() {
    memset(static_cast<void *>(this), 0, sizeof(DVec3d));
  }
  DVec3d(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(DVec3d, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) RotMatrix FLATBUFFERS_FINAL_CLASS {
 private:
  double x00_;
  double x01_;
  double x02_;
  double x10_;
  double x11_;
  double x12_;
  double x20_;
  double x21_;
  double x22_;

 public:
  RotMatrix() {
    memset(static_cast<void *>(this), 0, sizeof(RotMatrix));
  }
  RotMatrix(double _x00, double _x01, double _x02, double _x10, double _x11, double _x12, double _x20, double _x21, double _x22)
      : x00_(flatbuffers::EndianScalar(_x00)),
        x01_(flatbuffers::EndianScalar(_x01)),
        x02_(flatbuffers::EndianScalar(_x02)),
        x10_(flatbuffers::EndianScalar(_x10)),
        x11_(flatbuffers::EndianScalar(_x11)),
        x12_(flatbuffers::EndianScalar(_x12)),
        x20_(flatbuffers::EndianScalar(_x20)),
        x21_(flatbuffers::EndianScalar(_x21)),
        x22_(flatbuffers::EndianScalar(_x22)) {
  }
  double x00() const {
    return flatbuffers::EndianScalar(x00_);
  }
  double x01() const {
    return flatbuffers::EndianScalar(x01_);
  }
  double x02() const {
    return flatbuffers::EndianScalar(x02_);
  }
  double x10() const {
    return flatbuffers::EndianScalar(x10_);
  }
  double x11() const {
    return flatbuffers::EndianScalar(x11_);
  }
  double x12() const {
    return flatbuffers::EndianScalar(x12_);
  }
  double x20() const {
    return flatbuffers::EndianScalar(x20_);
  }
  double x21() const {
    return flatbuffers::EndianScalar(x21_);
  }
  double x22() const {
    return flatbuffers::EndianScalar(x22_);
  }
};
FLATBUFFERS_STRUCT_END(RotMatrix, 72);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Transform FLATBUFFERS_FINAL_CLASS {
 private:
  double x00_;
  double x01_;
  double x02_;
  double tx_;
  double x10_;
  double x11_;
  double x12_;
  double ty_;
  double x20_;
  double x21_;
  double x22_;
  double tz_;

 public:
  Transform() {
    memset(static_cast<void *>(this), 0, sizeof(Transform));
  }
  Transform(double _x00, double _x01, double _x02, double _tx, double _x10, double _x11, double _x12, double _ty, double _x20, double _x21, double _x22, double _tz)
      : x00_(flatbuffers::EndianScalar(_x00)),
        x01_(flatbuffers::EndianScalar(_x01)),
        x02_(flatbuffers::EndianScalar(_x02)),
        tx_(flatbuffers::EndianScalar(_tx)),
        x10_(flatbuffers::EndianScalar(_x10)),
        x11_(flatbuffers::EndianScalar(_x11)),
        x12_(flatbuffers::EndianScalar(_x12)),
        ty_(flatbuffers::EndianScalar(_ty)),
        x20_(flatbuffers::EndianScalar(_x20)),
        x21_(flatbuffers::EndianScalar(_x21)),
        x22_(flatbuffers::EndianScalar(_x22)),
        tz_(flatbuffers::EndianScalar(_tz)) {
  }
  double x00() const {
    return flatbuffers::EndianScalar(x00_);
  }
  double x01() const {
    return flatbuffers::EndianScalar(x01_);
  }
  double x02() const {
    return flatbuffers::EndianScalar(x02_);
  }
  double tx() const {
    return flatbuffers::EndianScalar(tx_);
  }
  double x10() const {
    return flatbuffers::EndianScalar(x10_);
  }
  double x11() const {
    return flatbuffers::EndianScalar(x11_);
  }
  double x12() const {
    return flatbuffers::EndianScalar(x12_);
  }
  double ty() const {
    return flatbuffers::EndianScalar(ty_);
  }
  double x20() const {
    return flatbuffers::EndianScalar(x20_);
  }
  double x21() const {
    return flatbuffers::EndianScalar(x21_);
  }
  double x22() const {
    return flatbuffers::EndianScalar(x22_);
  }
  double tz() const {
    return flatbuffers::EndianScalar(tz_);
  }
};
FLATBUFFERS_STRUCT_END(Transform, 96);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Trans2x3 FLATBUFFERS_FINAL_CLASS {
 private:
  double x00_;
  double x01_;
  double tx_;
  double y00_;
  double y01_;
  double ty_;

 public:
  Trans2x3() {
    memset(static_cast<void *>(this), 0, sizeof(Trans2x3));
  }
  Trans2x3(double _x00, double _x01, double _tx, double _y00, double _y01, double _ty)
      : x00_(flatbuffers::EndianScalar(_x00)),
        x01_(flatbuffers::EndianScalar(_x01)),
        tx_(flatbuffers::EndianScalar(_tx)),
        y00_(flatbuffers::EndianScalar(_y00)),
        y01_(flatbuffers::EndianScalar(_y01)),
        ty_(flatbuffers::EndianScalar(_ty)) {
  }
  double x00() const {
    return flatbuffers::EndianScalar(x00_);
  }
  double x01() const {
    return flatbuffers::EndianScalar(x01_);
  }
  double tx() const {
    return flatbuffers::EndianScalar(tx_);
  }
  double y00() const {
    return flatbuffers::EndianScalar(y00_);
  }
  double y01() const {
    return flatbuffers::EndianScalar(y01_);
  }
  double ty() const {
    return flatbuffers::EndianScalar(ty_);
  }
};
FLATBUFFERS_STRUCT_END(Trans2x3, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) FaceSymbology FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t useColor_;
  uint8_t useMaterial_;
  int16_t padding0__;
  uint32_t color_;
  int64_t materialId_;
  double transparency_;
  BentleyM0200::Dgn::FB::DPoint2d uv_;

 public:
  FaceSymbology() {
    memset(static_cast<void *>(this), 0, sizeof(FaceSymbology));
  }
  FaceSymbology(uint8_t _useColor, uint8_t _useMaterial, uint32_t _color, int64_t _materialId, double _transparency, const BentleyM0200::Dgn::FB::DPoint2d &_uv)
      : useColor_(flatbuffers::EndianScalar(_useColor)),
        useMaterial_(flatbuffers::EndianScalar(_useMaterial)),
        padding0__(0),
        color_(flatbuffers::EndianScalar(_color)),
        materialId_(flatbuffers::EndianScalar(_materialId)),
        transparency_(flatbuffers::EndianScalar(_transparency)),
        uv_(_uv) {
    (void)padding0__;
  }
  uint8_t useColor() const {
    return flatbuffers::EndianScalar(useColor_);
  }
  uint8_t useMaterial() const {
    return flatbuffers::EndianScalar(useMaterial_);
  }
  uint32_t color() const {
    return flatbuffers::EndianScalar(color_);
  }
  int64_t materialId() const {
    return flatbuffers::EndianScalar(materialId_);
  }
  double transparency() const {
    return flatbuffers::EndianScalar(transparency_);
  }
  const BentleyM0200::Dgn::FB::DPoint2d &uv() const {
    return uv_;
  }
};
FLATBUFFERS_STRUCT_END(FaceSymbology, 40);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) FaceSymbologyIndex FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t faceIndex_;
  uint32_t symbIndex_;

 public:
  FaceSymbologyIndex() {
    memset(static_cast<void *>(this), 0, sizeof(FaceSymbologyIndex));
  }
  FaceSymbologyIndex(uint32_t _faceIndex, uint32_t _symbIndex)
      : faceIndex_(flatbuffers::EndianScalar(_faceIndex)),
        symbIndex_(flatbuffers::EndianScalar(_symbIndex)) {
  }
  uint32_t faceIndex() const {
    return flatbuffers::EndianScalar(faceIndex_);
  }
  uint32_t symbIndex() const {
    return flatbuffers::EndianScalar(symbIndex_);
  }
};
FLATBUFFERS_STRUCT_END(FaceSymbologyIndex, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DRange1d FLATBUFFERS_FINAL_CLASS {
 private:
  double low_;
  double high_;

 public:
  DRange1d() {
    memset(static_cast<void *>(this), 0, sizeof(DRange1d));
  }
  DRange1d(double _low, double _high)
      : low_(flatbuffers::EndianScalar(_low)),
        high_(flatbuffers::EndianScalar(_high)) {
  }
  double low() const {
    return flatbuffers::EndianScalar(low_);
  }
  double high() const {
    return flatbuffers::EndianScalar(high_);
  }
};
FLATBUFFERS_STRUCT_END(DRange1d, 16);

struct PointPrimitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointPrimitiveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDS = 4,
    VT_BOUNDARY = 6
  };
  const flatbuffers::Vector<const BentleyM0200::Dgn::FB::DPoint3d *> *coords() const {
    return GetPointer<const flatbuffers::Vector<const BentleyM0200::Dgn::FB::DPoint3d *> *>(VT_COORDS);
  }
  BentleyM0200::Dgn::FB::BoundaryType boundary() const {
    return static_cast<BentleyM0200::Dgn::FB::BoundaryType>(GetField<int8_t>(VT_BOUNDARY, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COORDS) &&
           verifier.VerifyVector(coords()) &&
           VerifyField<int8_t>(verifier, VT_BOUNDARY) &&
           verifier.EndTable();
  }
  bool has_coords() const { return CheckField(VT_COORDS); }
  bool has_boundary() const { return CheckField(VT_BOUNDARY); }
};

struct PointPrimitiveBuilder {
  typedef PointPrimitive Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coords(flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::DPoint3d *>> coords) {
    fbb_.AddOffset(PointPrimitive::VT_COORDS, coords);
  }
  void add_boundary(BentleyM0200::Dgn::FB::BoundaryType boundary) {
    fbb_.AddElement<int8_t>(PointPrimitive::VT_BOUNDARY, static_cast<int8_t>(boundary), 0);
  }
  explicit PointPrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointPrimitiveBuilder &operator=(const PointPrimitiveBuilder &);
  flatbuffers::Offset<PointPrimitive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointPrimitive>(end);
    return o;
  }
};

inline flatbuffers::Offset<PointPrimitive> CreatePointPrimitive(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::DPoint3d *>> coords = 0,
    BentleyM0200::Dgn::FB::BoundaryType boundary = BentleyM0200::Dgn::FB::BoundaryType_None) {
  PointPrimitiveBuilder builder_(_fbb);
  builder_.add_coords(coords);
  builder_.add_boundary(boundary);
  return builder_.Finish();
}

inline flatbuffers::Offset<PointPrimitive> CreatePointPrimitiveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<BentleyM0200::Dgn::FB::DPoint3d> *coords = nullptr,
    BentleyM0200::Dgn::FB::BoundaryType boundary = BentleyM0200::Dgn::FB::BoundaryType_None) {
  auto coords__ = coords ? _fbb.CreateVectorOfStructs<BentleyM0200::Dgn::FB::DPoint3d>(*coords) : 0;
  return BentleyM0200::Dgn::FB::CreatePointPrimitive(
      _fbb,
      coords__,
      boundary);
}

struct PointPrimitive2d FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointPrimitive2dBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COORDS = 4,
    VT_BOUNDARY = 6
  };
  const flatbuffers::Vector<const BentleyM0200::Dgn::FB::DPoint2d *> *coords() const {
    return GetPointer<const flatbuffers::Vector<const BentleyM0200::Dgn::FB::DPoint2d *> *>(VT_COORDS);
  }
  BentleyM0200::Dgn::FB::BoundaryType boundary() const {
    return static_cast<BentleyM0200::Dgn::FB::BoundaryType>(GetField<int8_t>(VT_BOUNDARY, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COORDS) &&
           verifier.VerifyVector(coords()) &&
           VerifyField<int8_t>(verifier, VT_BOUNDARY) &&
           verifier.EndTable();
  }
  bool has_coords() const { return CheckField(VT_COORDS); }
  bool has_boundary() const { return CheckField(VT_BOUNDARY); }
};

struct PointPrimitive2dBuilder {
  typedef PointPrimitive2d Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coords(flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::DPoint2d *>> coords) {
    fbb_.AddOffset(PointPrimitive2d::VT_COORDS, coords);
  }
  void add_boundary(BentleyM0200::Dgn::FB::BoundaryType boundary) {
    fbb_.AddElement<int8_t>(PointPrimitive2d::VT_BOUNDARY, static_cast<int8_t>(boundary), 0);
  }
  explicit PointPrimitive2dBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointPrimitive2dBuilder &operator=(const PointPrimitive2dBuilder &);
  flatbuffers::Offset<PointPrimitive2d> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointPrimitive2d>(end);
    return o;
  }
};

inline flatbuffers::Offset<PointPrimitive2d> CreatePointPrimitive2d(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::DPoint2d *>> coords = 0,
    BentleyM0200::Dgn::FB::BoundaryType boundary = BentleyM0200::Dgn::FB::BoundaryType_None) {
  PointPrimitive2dBuilder builder_(_fbb);
  builder_.add_coords(coords);
  builder_.add_boundary(boundary);
  return builder_.Finish();
}

inline flatbuffers::Offset<PointPrimitive2d> CreatePointPrimitive2dDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<BentleyM0200::Dgn::FB::DPoint2d> *coords = nullptr,
    BentleyM0200::Dgn::FB::BoundaryType boundary = BentleyM0200::Dgn::FB::BoundaryType_None) {
  auto coords__ = coords ? _fbb.CreateVectorOfStructs<BentleyM0200::Dgn::FB::DPoint2d>(*coords) : 0;
  return BentleyM0200::Dgn::FB::CreatePointPrimitive2d(
      _fbb,
      coords__,
      boundary);
}

struct ArcPrimitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArcPrimitiveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_VECTOR0 = 6,
    VT_VECTOR90 = 8,
    VT_START = 10,
    VT_SWEEP = 12,
    VT_BOUNDARY = 14
  };
  const BentleyM0200::Dgn::FB::DPoint3d *center() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_CENTER);
  }
  const BentleyM0200::Dgn::FB::DVec3d *vector0() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DVec3d *>(VT_VECTOR0);
  }
  const BentleyM0200::Dgn::FB::DVec3d *vector90() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DVec3d *>(VT_VECTOR90);
  }
  double start() const {
    return GetField<double>(VT_START, 0.0);
  }
  double sweep() const {
    return GetField<double>(VT_SWEEP, 0.0);
  }
  BentleyM0200::Dgn::FB::BoundaryType boundary() const {
    return static_cast<BentleyM0200::Dgn::FB::BoundaryType>(GetField<int8_t>(VT_BOUNDARY, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_CENTER) &&
           VerifyField<BentleyM0200::Dgn::FB::DVec3d>(verifier, VT_VECTOR0) &&
           VerifyField<BentleyM0200::Dgn::FB::DVec3d>(verifier, VT_VECTOR90) &&
           VerifyField<double>(verifier, VT_START) &&
           VerifyField<double>(verifier, VT_SWEEP) &&
           VerifyField<int8_t>(verifier, VT_BOUNDARY) &&
           verifier.EndTable();
  }
  bool has_center() const { return CheckField(VT_CENTER); }
  bool has_vector0() const { return CheckField(VT_VECTOR0); }
  bool has_vector90() const { return CheckField(VT_VECTOR90); }
  bool has_start() const { return CheckField(VT_START); }
  bool has_sweep() const { return CheckField(VT_SWEEP); }
  bool has_boundary() const { return CheckField(VT_BOUNDARY); }
};

struct ArcPrimitiveBuilder {
  typedef ArcPrimitive Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_center(const BentleyM0200::Dgn::FB::DPoint3d *center) {
    fbb_.AddStruct(ArcPrimitive::VT_CENTER, center);
  }
  void add_vector0(const BentleyM0200::Dgn::FB::DVec3d *vector0) {
    fbb_.AddStruct(ArcPrimitive::VT_VECTOR0, vector0);
  }
  void add_vector90(const BentleyM0200::Dgn::FB::DVec3d *vector90) {
    fbb_.AddStruct(ArcPrimitive::VT_VECTOR90, vector90);
  }
  void add_start(double start) {
    fbb_.AddElement<double>(ArcPrimitive::VT_START, start, 0.0);
  }
  void add_sweep(double sweep) {
    fbb_.AddElement<double>(ArcPrimitive::VT_SWEEP, sweep, 0.0);
  }
  void add_boundary(BentleyM0200::Dgn::FB::BoundaryType boundary) {
    fbb_.AddElement<int8_t>(ArcPrimitive::VT_BOUNDARY, static_cast<int8_t>(boundary), 0);
  }
  explicit ArcPrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArcPrimitiveBuilder &operator=(const ArcPrimitiveBuilder &);
  flatbuffers::Offset<ArcPrimitive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArcPrimitive>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArcPrimitive> CreateArcPrimitive(
    flatbuffers::FlatBufferBuilder &_fbb,
    const BentleyM0200::Dgn::FB::DPoint3d *center = 0,
    const BentleyM0200::Dgn::FB::DVec3d *vector0 = 0,
    const BentleyM0200::Dgn::FB::DVec3d *vector90 = 0,
    double start = 0.0,
    double sweep = 0.0,
    BentleyM0200::Dgn::FB::BoundaryType boundary = BentleyM0200::Dgn::FB::BoundaryType_None) {
  ArcPrimitiveBuilder builder_(_fbb);
  builder_.add_sweep(sweep);
  builder_.add_start(start);
  builder_.add_vector90(vector90);
  builder_.add_vector0(vector0);
  builder_.add_center(center);
  builder_.add_boundary(boundary);
  return builder_.Finish();
}

struct BRepData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BRepDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITYTRANSFORM = 4,
    VT_BREPTYPE = 6,
    VT_ENTITYDATA = 8,
    VT_SYMBOLOGY = 10,
    VT_SYMBOLOGYINDEX = 12
  };
  const BentleyM0200::Dgn::FB::Transform *entityTransform() const {
    return GetStruct<const BentleyM0200::Dgn::FB::Transform *>(VT_ENTITYTRANSFORM);
  }
  BentleyM0200::Dgn::FB::BRepType brepType() const {
    return static_cast<BentleyM0200::Dgn::FB::BRepType>(GetField<int8_t>(VT_BREPTYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *entityData() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ENTITYDATA);
  }
  const flatbuffers::Vector<const BentleyM0200::Dgn::FB::FaceSymbology *> *symbology() const {
    return GetPointer<const flatbuffers::Vector<const BentleyM0200::Dgn::FB::FaceSymbology *> *>(VT_SYMBOLOGY);
  }
  const flatbuffers::Vector<const BentleyM0200::Dgn::FB::FaceSymbologyIndex *> *symbologyIndex() const {
    return GetPointer<const flatbuffers::Vector<const BentleyM0200::Dgn::FB::FaceSymbologyIndex *> *>(VT_SYMBOLOGYINDEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<BentleyM0200::Dgn::FB::Transform>(verifier, VT_ENTITYTRANSFORM) &&
           VerifyField<int8_t>(verifier, VT_BREPTYPE) &&
           VerifyOffset(verifier, VT_ENTITYDATA) &&
           verifier.VerifyVector(entityData()) &&
           VerifyOffset(verifier, VT_SYMBOLOGY) &&
           verifier.VerifyVector(symbology()) &&
           VerifyOffset(verifier, VT_SYMBOLOGYINDEX) &&
           verifier.VerifyVector(symbologyIndex()) &&
           verifier.EndTable();
  }
  bool has_entityTransform() const { return CheckField(VT_ENTITYTRANSFORM); }
  bool has_brepType() const { return CheckField(VT_BREPTYPE); }
  bool has_entityData() const { return CheckField(VT_ENTITYDATA); }
  bool has_symbology() const { return CheckField(VT_SYMBOLOGY); }
  bool has_symbologyIndex() const { return CheckField(VT_SYMBOLOGYINDEX); }
};

struct BRepDataBuilder {
  typedef BRepData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entityTransform(const BentleyM0200::Dgn::FB::Transform *entityTransform) {
    fbb_.AddStruct(BRepData::VT_ENTITYTRANSFORM, entityTransform);
  }
  void add_brepType(BentleyM0200::Dgn::FB::BRepType brepType) {
    fbb_.AddElement<int8_t>(BRepData::VT_BREPTYPE, static_cast<int8_t>(brepType), 0);
  }
  void add_entityData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData) {
    fbb_.AddOffset(BRepData::VT_ENTITYDATA, entityData);
  }
  void add_symbology(flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::FaceSymbology *>> symbology) {
    fbb_.AddOffset(BRepData::VT_SYMBOLOGY, symbology);
  }
  void add_symbologyIndex(flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::FaceSymbologyIndex *>> symbologyIndex) {
    fbb_.AddOffset(BRepData::VT_SYMBOLOGYINDEX, symbologyIndex);
  }
  explicit BRepDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BRepDataBuilder &operator=(const BRepDataBuilder &);
  flatbuffers::Offset<BRepData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BRepData>(end);
    return o;
  }
};

inline flatbuffers::Offset<BRepData> CreateBRepData(
    flatbuffers::FlatBufferBuilder &_fbb,
    const BentleyM0200::Dgn::FB::Transform *entityTransform = 0,
    BentleyM0200::Dgn::FB::BRepType brepType = BentleyM0200::Dgn::FB::BRepType_Solid,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData = 0,
    flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::FaceSymbology *>> symbology = 0,
    flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::FaceSymbologyIndex *>> symbologyIndex = 0) {
  BRepDataBuilder builder_(_fbb);
  builder_.add_symbologyIndex(symbologyIndex);
  builder_.add_symbology(symbology);
  builder_.add_entityData(entityData);
  builder_.add_entityTransform(entityTransform);
  builder_.add_brepType(brepType);
  return builder_.Finish();
}

inline flatbuffers::Offset<BRepData> CreateBRepDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const BentleyM0200::Dgn::FB::Transform *entityTransform = 0,
    BentleyM0200::Dgn::FB::BRepType brepType = BentleyM0200::Dgn::FB::BRepType_Solid,
    const std::vector<uint8_t> *entityData = nullptr,
    const std::vector<BentleyM0200::Dgn::FB::FaceSymbology> *symbology = nullptr,
    const std::vector<BentleyM0200::Dgn::FB::FaceSymbologyIndex> *symbologyIndex = nullptr) {
  auto entityData__ = entityData ? _fbb.CreateVector<uint8_t>(*entityData) : 0;
  auto symbology__ = symbology ? _fbb.CreateVectorOfStructs<BentleyM0200::Dgn::FB::FaceSymbology>(*symbology) : 0;
  auto symbologyIndex__ = symbologyIndex ? _fbb.CreateVectorOfStructs<BentleyM0200::Dgn::FB::FaceSymbologyIndex>(*symbologyIndex) : 0;
  return BentleyM0200::Dgn::FB::CreateBRepData(
      _fbb,
      entityTransform,
      brepType,
      entityData__,
      symbology__,
      symbologyIndex__);
}

struct OCBRepData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OCBRepDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BREPTYPE = 4,
    VT_ENTITYDATA = 6
  };
  BentleyM0200::Dgn::FB::BRepType brepType() const {
    return static_cast<BentleyM0200::Dgn::FB::BRepType>(GetField<int8_t>(VT_BREPTYPE, 0));
  }
  const flatbuffers::Vector<uint8_t> *entityData() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ENTITYDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_BREPTYPE) &&
           VerifyOffset(verifier, VT_ENTITYDATA) &&
           verifier.VerifyVector(entityData()) &&
           verifier.EndTable();
  }
  bool has_brepType() const { return CheckField(VT_BREPTYPE); }
  bool has_entityData() const { return CheckField(VT_ENTITYDATA); }
};

struct OCBRepDataBuilder {
  typedef OCBRepData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_brepType(BentleyM0200::Dgn::FB::BRepType brepType) {
    fbb_.AddElement<int8_t>(OCBRepData::VT_BREPTYPE, static_cast<int8_t>(brepType), 0);
  }
  void add_entityData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData) {
    fbb_.AddOffset(OCBRepData::VT_ENTITYDATA, entityData);
  }
  explicit OCBRepDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OCBRepDataBuilder &operator=(const OCBRepDataBuilder &);
  flatbuffers::Offset<OCBRepData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OCBRepData>(end);
    return o;
  }
};

inline flatbuffers::Offset<OCBRepData> CreateOCBRepData(
    flatbuffers::FlatBufferBuilder &_fbb,
    BentleyM0200::Dgn::FB::BRepType brepType = BentleyM0200::Dgn::FB::BRepType_Solid,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData = 0) {
  OCBRepDataBuilder builder_(_fbb);
  builder_.add_entityData(entityData);
  builder_.add_brepType(brepType);
  return builder_.Finish();
}

inline flatbuffers::Offset<OCBRepData> CreateOCBRepDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    BentleyM0200::Dgn::FB::BRepType brepType = BentleyM0200::Dgn::FB::BRepType_Solid,
    const std::vector<uint8_t> *entityData = nullptr) {
  auto entityData__ = entityData ? _fbb.CreateVector<uint8_t>(*entityData) : 0;
  return BentleyM0200::Dgn::FB::CreateOCBRepData(
      _fbb,
      brepType,
      entityData__);
}

struct Image FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DRAWBORDER = 4,
    VT_USEFILLTINT = 6,
    VT_TILECORNER0 = 8,
    VT_TILECORNER1 = 10,
    VT_TILECORNER2 = 12,
    VT_TILECORNER3 = 14,
    VT_WIDTH = 16,
    VT_HEIGHT = 18,
    VT_FORMAT = 20,
    VT_BYTEDATA = 22,
    VT_TEXTUREID = 24
  };
  uint8_t drawBorder() const {
    return GetField<uint8_t>(VT_DRAWBORDER, 0);
  }
  uint8_t useFillTint() const {
    return GetField<uint8_t>(VT_USEFILLTINT, 0);
  }
  const BentleyM0200::Dgn::FB::DPoint3d *tileCorner0() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_TILECORNER0);
  }
  const BentleyM0200::Dgn::FB::DPoint3d *tileCorner1() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_TILECORNER1);
  }
  const BentleyM0200::Dgn::FB::DPoint3d *tileCorner2() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_TILECORNER2);
  }
  const BentleyM0200::Dgn::FB::DPoint3d *tileCorner3() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_TILECORNER3);
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t format() const {
    return GetField<uint32_t>(VT_FORMAT, 0);
  }
  const flatbuffers::Vector<uint8_t> *byteData() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTEDATA);
  }
  int64_t textureId() const {
    return GetField<int64_t>(VT_TEXTUREID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DRAWBORDER) &&
           VerifyField<uint8_t>(verifier, VT_USEFILLTINT) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_TILECORNER0) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_TILECORNER1) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_TILECORNER2) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_TILECORNER3) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT) &&
           VerifyField<uint32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_BYTEDATA) &&
           verifier.VerifyVector(byteData()) &&
           VerifyField<int64_t>(verifier, VT_TEXTUREID) &&
           verifier.EndTable();
  }
  bool has_drawBorder() const { return CheckField(VT_DRAWBORDER); }
  bool has_useFillTint() const { return CheckField(VT_USEFILLTINT); }
  bool has_tileCorner0() const { return CheckField(VT_TILECORNER0); }
  bool has_tileCorner1() const { return CheckField(VT_TILECORNER1); }
  bool has_tileCorner2() const { return CheckField(VT_TILECORNER2); }
  bool has_tileCorner3() const { return CheckField(VT_TILECORNER3); }
  bool has_width() const { return CheckField(VT_WIDTH); }
  bool has_height() const { return CheckField(VT_HEIGHT); }
  bool has_format() const { return CheckField(VT_FORMAT); }
  bool has_byteData() const { return CheckField(VT_BYTEDATA); }
  bool has_textureId() const { return CheckField(VT_TEXTUREID); }
};

struct ImageBuilder {
  typedef Image Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_drawBorder(uint8_t drawBorder) {
    fbb_.AddElement<uint8_t>(Image::VT_DRAWBORDER, drawBorder, 0);
  }
  void add_useFillTint(uint8_t useFillTint) {
    fbb_.AddElement<uint8_t>(Image::VT_USEFILLTINT, useFillTint, 0);
  }
  void add_tileCorner0(const BentleyM0200::Dgn::FB::DPoint3d *tileCorner0) {
    fbb_.AddStruct(Image::VT_TILECORNER0, tileCorner0);
  }
  void add_tileCorner1(const BentleyM0200::Dgn::FB::DPoint3d *tileCorner1) {
    fbb_.AddStruct(Image::VT_TILECORNER1, tileCorner1);
  }
  void add_tileCorner2(const BentleyM0200::Dgn::FB::DPoint3d *tileCorner2) {
    fbb_.AddStruct(Image::VT_TILECORNER2, tileCorner2);
  }
  void add_tileCorner3(const BentleyM0200::Dgn::FB::DPoint3d *tileCorner3) {
    fbb_.AddStruct(Image::VT_TILECORNER3, tileCorner3);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(Image::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(Image::VT_HEIGHT, height, 0);
  }
  void add_format(uint32_t format) {
    fbb_.AddElement<uint32_t>(Image::VT_FORMAT, format, 0);
  }
  void add_byteData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> byteData) {
    fbb_.AddOffset(Image::VT_BYTEDATA, byteData);
  }
  void add_textureId(int64_t textureId) {
    fbb_.AddElement<int64_t>(Image::VT_TEXTUREID, textureId, 0);
  }
  explicit ImageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ImageBuilder &operator=(const ImageBuilder &);
  flatbuffers::Offset<Image> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Image>(end);
    return o;
  }
};

inline flatbuffers::Offset<Image> CreateImage(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t drawBorder = 0,
    uint8_t useFillTint = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *tileCorner0 = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *tileCorner1 = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *tileCorner2 = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *tileCorner3 = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    uint32_t format = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> byteData = 0,
    int64_t textureId = 0) {
  ImageBuilder builder_(_fbb);
  builder_.add_textureId(textureId);
  builder_.add_byteData(byteData);
  builder_.add_format(format);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_tileCorner3(tileCorner3);
  builder_.add_tileCorner2(tileCorner2);
  builder_.add_tileCorner1(tileCorner1);
  builder_.add_tileCorner0(tileCorner0);
  builder_.add_useFillTint(useFillTint);
  builder_.add_drawBorder(drawBorder);
  return builder_.Finish();
}

inline flatbuffers::Offset<Image> CreateImageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t drawBorder = 0,
    uint8_t useFillTint = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *tileCorner0 = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *tileCorner1 = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *tileCorner2 = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *tileCorner3 = 0,
    uint32_t width = 0,
    uint32_t height = 0,
    uint32_t format = 0,
    const std::vector<uint8_t> *byteData = nullptr,
    int64_t textureId = 0) {
  auto byteData__ = byteData ? _fbb.CreateVector<uint8_t>(*byteData) : 0;
  return BentleyM0200::Dgn::FB::CreateImage(
      _fbb,
      drawBorder,
      useFillTint,
      tileCorner0,
      tileCorner1,
      tileCorner2,
      tileCorner3,
      width,
      height,
      format,
      byteData__,
      textureId);
}

struct GeometryPart FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GeometryPartBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEOMPARTID = 4,
    VT_ORIGIN = 6,
    VT_YAW = 8,
    VT_PITCH = 10,
    VT_ROLL = 12,
    VT_SCALE = 14
  };
  int64_t geomPartId() const {
    return GetField<int64_t>(VT_GEOMPARTID, 0);
  }
  const BentleyM0200::Dgn::FB::DPoint3d *origin() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_ORIGIN);
  }
  double yaw() const {
    return GetField<double>(VT_YAW, 0.0);
  }
  double pitch() const {
    return GetField<double>(VT_PITCH, 0.0);
  }
  double roll() const {
    return GetField<double>(VT_ROLL, 0.0);
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 1.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_GEOMPARTID) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_ORIGIN) &&
           VerifyField<double>(verifier, VT_YAW) &&
           VerifyField<double>(verifier, VT_PITCH) &&
           VerifyField<double>(verifier, VT_ROLL) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
  bool has_geomPartId() const { return CheckField(VT_GEOMPARTID); }
  bool has_origin() const { return CheckField(VT_ORIGIN); }
  bool has_yaw() const { return CheckField(VT_YAW); }
  bool has_pitch() const { return CheckField(VT_PITCH); }
  bool has_roll() const { return CheckField(VT_ROLL); }
  bool has_scale() const { return CheckField(VT_SCALE); }
};

struct GeometryPartBuilder {
  typedef GeometryPart Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_geomPartId(int64_t geomPartId) {
    fbb_.AddElement<int64_t>(GeometryPart::VT_GEOMPARTID, geomPartId, 0);
  }
  void add_origin(const BentleyM0200::Dgn::FB::DPoint3d *origin) {
    fbb_.AddStruct(GeometryPart::VT_ORIGIN, origin);
  }
  void add_yaw(double yaw) {
    fbb_.AddElement<double>(GeometryPart::VT_YAW, yaw, 0.0);
  }
  void add_pitch(double pitch) {
    fbb_.AddElement<double>(GeometryPart::VT_PITCH, pitch, 0.0);
  }
  void add_roll(double roll) {
    fbb_.AddElement<double>(GeometryPart::VT_ROLL, roll, 0.0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(GeometryPart::VT_SCALE, scale, 1.0);
  }
  explicit GeometryPartBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeometryPartBuilder &operator=(const GeometryPartBuilder &);
  flatbuffers::Offset<GeometryPart> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeometryPart>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeometryPart> CreateGeometryPart(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t geomPartId = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *origin = 0,
    double yaw = 0.0,
    double pitch = 0.0,
    double roll = 0.0,
    double scale = 1.0) {
  GeometryPartBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_roll(roll);
  builder_.add_pitch(pitch);
  builder_.add_yaw(yaw);
  builder_.add_geomPartId(geomPartId);
  builder_.add_origin(origin);
  return builder_.Finish();
}

struct BasicSymbology FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BasicSymbologyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBCATEGORYID = 4,
    VT_COLOR = 6,
    VT_WEIGHT = 8,
    VT_LINESTYLEID = 10,
    VT_TRANSPARENCY = 12,
    VT_DISPLAYPRIORITY = 14,
    VT_GEOMCLASS = 16,
    VT_USECOLOR = 18,
    VT_USEWEIGHT = 20,
    VT_USESTYLE = 22
  };
  int64_t subCategoryId() const {
    return GetField<int64_t>(VT_SUBCATEGORYID, 0);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  uint32_t weight() const {
    return GetField<uint32_t>(VT_WEIGHT, 0);
  }
  int64_t lineStyleId() const {
    return GetField<int64_t>(VT_LINESTYLEID, 0);
  }
  double transparency() const {
    return GetField<double>(VT_TRANSPARENCY, 0.0);
  }
  int32_t displayPriority() const {
    return GetField<int32_t>(VT_DISPLAYPRIORITY, 0);
  }
  BentleyM0200::Dgn::FB::GeometryClass geomClass() const {
    return static_cast<BentleyM0200::Dgn::FB::GeometryClass>(GetField<int8_t>(VT_GEOMCLASS, 0));
  }
  uint8_t useColor() const {
    return GetField<uint8_t>(VT_USECOLOR, 0);
  }
  uint8_t useWeight() const {
    return GetField<uint8_t>(VT_USEWEIGHT, 0);
  }
  uint8_t useStyle() const {
    return GetField<uint8_t>(VT_USESTYLE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SUBCATEGORYID) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           VerifyField<uint32_t>(verifier, VT_WEIGHT) &&
           VerifyField<int64_t>(verifier, VT_LINESTYLEID) &&
           VerifyField<double>(verifier, VT_TRANSPARENCY) &&
           VerifyField<int32_t>(verifier, VT_DISPLAYPRIORITY) &&
           VerifyField<int8_t>(verifier, VT_GEOMCLASS) &&
           VerifyField<uint8_t>(verifier, VT_USECOLOR) &&
           VerifyField<uint8_t>(verifier, VT_USEWEIGHT) &&
           VerifyField<uint8_t>(verifier, VT_USESTYLE) &&
           verifier.EndTable();
  }
  bool has_subCategoryId() const { return CheckField(VT_SUBCATEGORYID); }
  bool has_color() const { return CheckField(VT_COLOR); }
  bool has_weight() const { return CheckField(VT_WEIGHT); }
  bool has_lineStyleId() const { return CheckField(VT_LINESTYLEID); }
  bool has_transparency() const { return CheckField(VT_TRANSPARENCY); }
  bool has_displayPriority() const { return CheckField(VT_DISPLAYPRIORITY); }
  bool has_geomClass() const { return CheckField(VT_GEOMCLASS); }
  bool has_useColor() const { return CheckField(VT_USECOLOR); }
  bool has_useWeight() const { return CheckField(VT_USEWEIGHT); }
  bool has_useStyle() const { return CheckField(VT_USESTYLE); }
};

struct BasicSymbologyBuilder {
  typedef BasicSymbology Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subCategoryId(int64_t subCategoryId) {
    fbb_.AddElement<int64_t>(BasicSymbology::VT_SUBCATEGORYID, subCategoryId, 0);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(BasicSymbology::VT_COLOR, color, 0);
  }
  void add_weight(uint32_t weight) {
    fbb_.AddElement<uint32_t>(BasicSymbology::VT_WEIGHT, weight, 0);
  }
  void add_lineStyleId(int64_t lineStyleId) {
    fbb_.AddElement<int64_t>(BasicSymbology::VT_LINESTYLEID, lineStyleId, 0);
  }
  void add_transparency(double transparency) {
    fbb_.AddElement<double>(BasicSymbology::VT_TRANSPARENCY, transparency, 0.0);
  }
  void add_displayPriority(int32_t displayPriority) {
    fbb_.AddElement<int32_t>(BasicSymbology::VT_DISPLAYPRIORITY, displayPriority, 0);
  }
  void add_geomClass(BentleyM0200::Dgn::FB::GeometryClass geomClass) {
    fbb_.AddElement<int8_t>(BasicSymbology::VT_GEOMCLASS, static_cast<int8_t>(geomClass), 0);
  }
  void add_useColor(uint8_t useColor) {
    fbb_.AddElement<uint8_t>(BasicSymbology::VT_USECOLOR, useColor, 0);
  }
  void add_useWeight(uint8_t useWeight) {
    fbb_.AddElement<uint8_t>(BasicSymbology::VT_USEWEIGHT, useWeight, 0);
  }
  void add_useStyle(uint8_t useStyle) {
    fbb_.AddElement<uint8_t>(BasicSymbology::VT_USESTYLE, useStyle, 0);
  }
  explicit BasicSymbologyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BasicSymbologyBuilder &operator=(const BasicSymbologyBuilder &);
  flatbuffers::Offset<BasicSymbology> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BasicSymbology>(end);
    return o;
  }
};

inline flatbuffers::Offset<BasicSymbology> CreateBasicSymbology(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t subCategoryId = 0,
    uint32_t color = 0,
    uint32_t weight = 0,
    int64_t lineStyleId = 0,
    double transparency = 0.0,
    int32_t displayPriority = 0,
    BentleyM0200::Dgn::FB::GeometryClass geomClass = BentleyM0200::Dgn::FB::GeometryClass_Primary,
    uint8_t useColor = 0,
    uint8_t useWeight = 0,
    uint8_t useStyle = 0) {
  BasicSymbologyBuilder builder_(_fbb);
  builder_.add_transparency(transparency);
  builder_.add_lineStyleId(lineStyleId);
  builder_.add_subCategoryId(subCategoryId);
  builder_.add_displayPriority(displayPriority);
  builder_.add_weight(weight);
  builder_.add_color(color);
  builder_.add_useStyle(useStyle);
  builder_.add_useWeight(useWeight);
  builder_.add_useColor(useColor);
  builder_.add_geomClass(geomClass);
  return builder_.Finish();
}

struct LineStyleModifiers FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LineStyleModifiersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODIFIERS = 4,
    VT_SCALE = 6,
    VT_DASHSCALE = 8,
    VT_GAPSCALE = 10,
    VT_STARTWIDTH = 12,
    VT_ENDWIDTH = 14,
    VT_DISTPHASE = 16,
    VT_FRACTPHASE = 18,
    VT_NORMAL = 20,
    VT_YAW = 22,
    VT_PITCH = 24,
    VT_ROLL = 26
  };
  uint32_t modifiers() const {
    return GetField<uint32_t>(VT_MODIFIERS, 0);
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  double dashScale() const {
    return GetField<double>(VT_DASHSCALE, 0.0);
  }
  double gapScale() const {
    return GetField<double>(VT_GAPSCALE, 0.0);
  }
  double startWidth() const {
    return GetField<double>(VT_STARTWIDTH, 0.0);
  }
  double endWidth() const {
    return GetField<double>(VT_ENDWIDTH, 0.0);
  }
  double distPhase() const {
    return GetField<double>(VT_DISTPHASE, 0.0);
  }
  double fractPhase() const {
    return GetField<double>(VT_FRACTPHASE, 0.0);
  }
  const BentleyM0200::Dgn::FB::DPoint3d *normal() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_NORMAL);
  }
  double yaw() const {
    return GetField<double>(VT_YAW, 0.0);
  }
  double pitch() const {
    return GetField<double>(VT_PITCH, 0.0);
  }
  double roll() const {
    return GetField<double>(VT_ROLL, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_MODIFIERS) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<double>(verifier, VT_DASHSCALE) &&
           VerifyField<double>(verifier, VT_GAPSCALE) &&
           VerifyField<double>(verifier, VT_STARTWIDTH) &&
           VerifyField<double>(verifier, VT_ENDWIDTH) &&
           VerifyField<double>(verifier, VT_DISTPHASE) &&
           VerifyField<double>(verifier, VT_FRACTPHASE) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_NORMAL) &&
           VerifyField<double>(verifier, VT_YAW) &&
           VerifyField<double>(verifier, VT_PITCH) &&
           VerifyField<double>(verifier, VT_ROLL) &&
           verifier.EndTable();
  }
  bool has_modifiers() const { return CheckField(VT_MODIFIERS); }
  bool has_scale() const { return CheckField(VT_SCALE); }
  bool has_dashScale() const { return CheckField(VT_DASHSCALE); }
  bool has_gapScale() const { return CheckField(VT_GAPSCALE); }
  bool has_startWidth() const { return CheckField(VT_STARTWIDTH); }
  bool has_endWidth() const { return CheckField(VT_ENDWIDTH); }
  bool has_distPhase() const { return CheckField(VT_DISTPHASE); }
  bool has_fractPhase() const { return CheckField(VT_FRACTPHASE); }
  bool has_normal() const { return CheckField(VT_NORMAL); }
  bool has_yaw() const { return CheckField(VT_YAW); }
  bool has_pitch() const { return CheckField(VT_PITCH); }
  bool has_roll() const { return CheckField(VT_ROLL); }
};

struct LineStyleModifiersBuilder {
  typedef LineStyleModifiers Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modifiers(uint32_t modifiers) {
    fbb_.AddElement<uint32_t>(LineStyleModifiers::VT_MODIFIERS, modifiers, 0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_SCALE, scale, 0.0);
  }
  void add_dashScale(double dashScale) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_DASHSCALE, dashScale, 0.0);
  }
  void add_gapScale(double gapScale) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_GAPSCALE, gapScale, 0.0);
  }
  void add_startWidth(double startWidth) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_STARTWIDTH, startWidth, 0.0);
  }
  void add_endWidth(double endWidth) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_ENDWIDTH, endWidth, 0.0);
  }
  void add_distPhase(double distPhase) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_DISTPHASE, distPhase, 0.0);
  }
  void add_fractPhase(double fractPhase) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_FRACTPHASE, fractPhase, 0.0);
  }
  void add_normal(const BentleyM0200::Dgn::FB::DPoint3d *normal) {
    fbb_.AddStruct(LineStyleModifiers::VT_NORMAL, normal);
  }
  void add_yaw(double yaw) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_YAW, yaw, 0.0);
  }
  void add_pitch(double pitch) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_PITCH, pitch, 0.0);
  }
  void add_roll(double roll) {
    fbb_.AddElement<double>(LineStyleModifiers::VT_ROLL, roll, 0.0);
  }
  explicit LineStyleModifiersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LineStyleModifiersBuilder &operator=(const LineStyleModifiersBuilder &);
  flatbuffers::Offset<LineStyleModifiers> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LineStyleModifiers>(end);
    return o;
  }
};

inline flatbuffers::Offset<LineStyleModifiers> CreateLineStyleModifiers(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t modifiers = 0,
    double scale = 0.0,
    double dashScale = 0.0,
    double gapScale = 0.0,
    double startWidth = 0.0,
    double endWidth = 0.0,
    double distPhase = 0.0,
    double fractPhase = 0.0,
    const BentleyM0200::Dgn::FB::DPoint3d *normal = 0,
    double yaw = 0.0,
    double pitch = 0.0,
    double roll = 0.0) {
  LineStyleModifiersBuilder builder_(_fbb);
  builder_.add_roll(roll);
  builder_.add_pitch(pitch);
  builder_.add_yaw(yaw);
  builder_.add_fractPhase(fractPhase);
  builder_.add_distPhase(distPhase);
  builder_.add_endWidth(endWidth);
  builder_.add_startWidth(startWidth);
  builder_.add_gapScale(gapScale);
  builder_.add_dashScale(dashScale);
  builder_.add_scale(scale);
  builder_.add_normal(normal);
  builder_.add_modifiers(modifiers);
  return builder_.Finish();
}

struct Material FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaterialBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USEMATERIAL = 4,
    VT_MATERIALID = 6,
    VT_ORIGIN = 8,
    VT_SIZE = 10,
    VT_YAW = 12,
    VT_PITCH = 14,
    VT_ROLL = 16,
    VT_TRANS2X3 = 18
  };
  uint8_t useMaterial() const {
    return GetField<uint8_t>(VT_USEMATERIAL, 0);
  }
  int64_t materialId() const {
    return GetField<int64_t>(VT_MATERIALID, 0);
  }
  const BentleyM0200::Dgn::FB::DPoint3d *origin() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_ORIGIN);
  }
  const BentleyM0200::Dgn::FB::DPoint3d *size() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_SIZE);
  }
  double yaw() const {
    return GetField<double>(VT_YAW, 0.0);
  }
  double pitch() const {
    return GetField<double>(VT_PITCH, 0.0);
  }
  double roll() const {
    return GetField<double>(VT_ROLL, 0.0);
  }
  const BentleyM0200::Dgn::FB::Trans2x3 *trans2x3() const {
    return GetStruct<const BentleyM0200::Dgn::FB::Trans2x3 *>(VT_TRANS2X3);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USEMATERIAL) &&
           VerifyField<int64_t>(verifier, VT_MATERIALID) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_ORIGIN) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_SIZE) &&
           VerifyField<double>(verifier, VT_YAW) &&
           VerifyField<double>(verifier, VT_PITCH) &&
           VerifyField<double>(verifier, VT_ROLL) &&
           VerifyField<BentleyM0200::Dgn::FB::Trans2x3>(verifier, VT_TRANS2X3) &&
           verifier.EndTable();
  }
  bool has_useMaterial() const { return CheckField(VT_USEMATERIAL); }
  bool has_materialId() const { return CheckField(VT_MATERIALID); }
  bool has_origin() const { return CheckField(VT_ORIGIN); }
  bool has_size() const { return CheckField(VT_SIZE); }
  bool has_yaw() const { return CheckField(VT_YAW); }
  bool has_pitch() const { return CheckField(VT_PITCH); }
  bool has_roll() const { return CheckField(VT_ROLL); }
  bool has_trans2x3() const { return CheckField(VT_TRANS2X3); }
};

struct MaterialBuilder {
  typedef Material Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_useMaterial(uint8_t useMaterial) {
    fbb_.AddElement<uint8_t>(Material::VT_USEMATERIAL, useMaterial, 0);
  }
  void add_materialId(int64_t materialId) {
    fbb_.AddElement<int64_t>(Material::VT_MATERIALID, materialId, 0);
  }
  void add_origin(const BentleyM0200::Dgn::FB::DPoint3d *origin) {
    fbb_.AddStruct(Material::VT_ORIGIN, origin);
  }
  void add_size(const BentleyM0200::Dgn::FB::DPoint3d *size) {
    fbb_.AddStruct(Material::VT_SIZE, size);
  }
  void add_yaw(double yaw) {
    fbb_.AddElement<double>(Material::VT_YAW, yaw, 0.0);
  }
  void add_pitch(double pitch) {
    fbb_.AddElement<double>(Material::VT_PITCH, pitch, 0.0);
  }
  void add_roll(double roll) {
    fbb_.AddElement<double>(Material::VT_ROLL, roll, 0.0);
  }
  void add_trans2x3(const BentleyM0200::Dgn::FB::Trans2x3 *trans2x3) {
    fbb_.AddStruct(Material::VT_TRANS2X3, trans2x3);
  }
  explicit MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialBuilder &operator=(const MaterialBuilder &);
  flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Material>(end);
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t useMaterial = 0,
    int64_t materialId = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *origin = 0,
    const BentleyM0200::Dgn::FB::DPoint3d *size = 0,
    double yaw = 0.0,
    double pitch = 0.0,
    double roll = 0.0,
    const BentleyM0200::Dgn::FB::Trans2x3 *trans2x3 = 0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_roll(roll);
  builder_.add_pitch(pitch);
  builder_.add_yaw(yaw);
  builder_.add_materialId(materialId);
  builder_.add_trans2x3(trans2x3);
  builder_.add_size(size);
  builder_.add_origin(origin);
  builder_.add_useMaterial(useMaterial);
  return builder_.Finish();
}

struct ThematicSettings FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ThematicSettingsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STEPCOUNT = 4,
    VT_MARGIN = 6,
    VT_MARGINCOLOR = 8,
    VT_MODE = 10,
    VT_COLORSCHEME = 12,
    VT_RANGE = 14
  };
  uint32_t stepCount() const {
    return GetField<uint32_t>(VT_STEPCOUNT, 0);
  }
  double margin() const {
    return GetField<double>(VT_MARGIN, 0.0);
  }
  uint32_t marginColor() const {
    return GetField<uint32_t>(VT_MARGINCOLOR, 0);
  }
  uint32_t mode() const {
    return GetField<uint32_t>(VT_MODE, 0);
  }
  uint32_t colorScheme() const {
    return GetField<uint32_t>(VT_COLORSCHEME, 0);
  }
  const BentleyM0200::Dgn::FB::DRange1d *range() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DRange1d *>(VT_RANGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STEPCOUNT) &&
           VerifyField<double>(verifier, VT_MARGIN) &&
           VerifyField<uint32_t>(verifier, VT_MARGINCOLOR) &&
           VerifyField<uint32_t>(verifier, VT_MODE) &&
           VerifyField<uint32_t>(verifier, VT_COLORSCHEME) &&
           VerifyField<BentleyM0200::Dgn::FB::DRange1d>(verifier, VT_RANGE) &&
           verifier.EndTable();
  }
  bool has_stepCount() const { return CheckField(VT_STEPCOUNT); }
  bool has_margin() const { return CheckField(VT_MARGIN); }
  bool has_marginColor() const { return CheckField(VT_MARGINCOLOR); }
  bool has_mode() const { return CheckField(VT_MODE); }
  bool has_colorScheme() const { return CheckField(VT_COLORSCHEME); }
  bool has_range() const { return CheckField(VT_RANGE); }
};

struct ThematicSettingsBuilder {
  typedef ThematicSettings Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_stepCount(uint32_t stepCount) {
    fbb_.AddElement<uint32_t>(ThematicSettings::VT_STEPCOUNT, stepCount, 0);
  }
  void add_margin(double margin) {
    fbb_.AddElement<double>(ThematicSettings::VT_MARGIN, margin, 0.0);
  }
  void add_marginColor(uint32_t marginColor) {
    fbb_.AddElement<uint32_t>(ThematicSettings::VT_MARGINCOLOR, marginColor, 0);
  }
  void add_mode(uint32_t mode) {
    fbb_.AddElement<uint32_t>(ThematicSettings::VT_MODE, mode, 0);
  }
  void add_colorScheme(uint32_t colorScheme) {
    fbb_.AddElement<uint32_t>(ThematicSettings::VT_COLORSCHEME, colorScheme, 0);
  }
  void add_range(const BentleyM0200::Dgn::FB::DRange1d *range) {
    fbb_.AddStruct(ThematicSettings::VT_RANGE, range);
  }
  explicit ThematicSettingsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ThematicSettingsBuilder &operator=(const ThematicSettingsBuilder &);
  flatbuffers::Offset<ThematicSettings> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ThematicSettings>(end);
    return o;
  }
};

inline flatbuffers::Offset<ThematicSettings> CreateThematicSettings(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t stepCount = 0,
    double margin = 0.0,
    uint32_t marginColor = 0,
    uint32_t mode = 0,
    uint32_t colorScheme = 0,
    const BentleyM0200::Dgn::FB::DRange1d *range = 0) {
  ThematicSettingsBuilder builder_(_fbb);
  builder_.add_margin(margin);
  builder_.add_range(range);
  builder_.add_colorScheme(colorScheme);
  builder_.add_mode(mode);
  builder_.add_marginColor(marginColor);
  builder_.add_stepCount(stepCount);
  return builder_.Finish();
}

struct AreaFill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AreaFillBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILL = 4,
    VT_COLOR = 6,
    VT_USECOLOR = 8,
    VT_BACKGROUNDFILL = 10,
    VT_TRANSPARENCY = 12,
    VT_MODE = 14,
    VT_FLAGS = 16,
    VT_ANGLE = 18,
    VT_TINT = 20,
    VT_SHIFT = 22,
    VT_COLORS = 24,
    VT_VALUES = 26,
    VT_THEMATICSETTINGS = 28
  };
  BentleyM0200::Dgn::FB::FillDisplay fill() const {
    return static_cast<BentleyM0200::Dgn::FB::FillDisplay>(GetField<int8_t>(VT_FILL, 0));
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  uint8_t useColor() const {
    return GetField<uint8_t>(VT_USECOLOR, 0);
  }
  uint8_t backgroundFill() const {
    return GetField<uint8_t>(VT_BACKGROUNDFILL, 0);
  }
  double transparency() const {
    return GetField<double>(VT_TRANSPARENCY, 0.0);
  }
  BentleyM0200::Dgn::FB::GradientMode mode() const {
    return static_cast<BentleyM0200::Dgn::FB::GradientMode>(GetField<int8_t>(VT_MODE, 0));
  }
  uint16_t flags() const {
    return GetField<uint16_t>(VT_FLAGS, 0);
  }
  double angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  double tint() const {
    return GetField<double>(VT_TINT, 0.0);
  }
  double shift() const {
    return GetField<double>(VT_SHIFT, 0.0);
  }
  const flatbuffers::Vector<uint32_t> *colors() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_COLORS);
  }
  const flatbuffers::Vector<double> *values() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VALUES);
  }
  const BentleyM0200::Dgn::FB::ThematicSettings *thematicSettings() const {
    return GetPointer<const BentleyM0200::Dgn::FB::ThematicSettings *>(VT_THEMATICSETTINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FILL) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           VerifyField<uint8_t>(verifier, VT_USECOLOR) &&
           VerifyField<uint8_t>(verifier, VT_BACKGROUNDFILL) &&
           VerifyField<double>(verifier, VT_TRANSPARENCY) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<uint16_t>(verifier, VT_FLAGS) &&
           VerifyField<double>(verifier, VT_ANGLE) &&
           VerifyField<double>(verifier, VT_TINT) &&
           VerifyField<double>(verifier, VT_SHIFT) &&
           VerifyOffset(verifier, VT_COLORS) &&
           verifier.VerifyVector(colors()) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           VerifyOffset(verifier, VT_THEMATICSETTINGS) &&
           verifier.VerifyTable(thematicSettings()) &&
           verifier.EndTable();
  }
  bool has_fill() const { return CheckField(VT_FILL); }
  bool has_color() const { return CheckField(VT_COLOR); }
  bool has_useColor() const { return CheckField(VT_USECOLOR); }
  bool has_backgroundFill() const { return CheckField(VT_BACKGROUNDFILL); }
  bool has_transparency() const { return CheckField(VT_TRANSPARENCY); }
  bool has_mode() const { return CheckField(VT_MODE); }
  bool has_flags() const { return CheckField(VT_FLAGS); }
  bool has_angle() const { return CheckField(VT_ANGLE); }
  bool has_tint() const { return CheckField(VT_TINT); }
  bool has_shift() const { return CheckField(VT_SHIFT); }
  bool has_colors() const { return CheckField(VT_COLORS); }
  bool has_values() const { return CheckField(VT_VALUES); }
  bool has_thematicSettings() const { return CheckField(VT_THEMATICSETTINGS); }
};

struct AreaFillBuilder {
  typedef AreaFill Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fill(BentleyM0200::Dgn::FB::FillDisplay fill) {
    fbb_.AddElement<int8_t>(AreaFill::VT_FILL, static_cast<int8_t>(fill), 0);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(AreaFill::VT_COLOR, color, 0);
  }
  void add_useColor(uint8_t useColor) {
    fbb_.AddElement<uint8_t>(AreaFill::VT_USECOLOR, useColor, 0);
  }
  void add_backgroundFill(uint8_t backgroundFill) {
    fbb_.AddElement<uint8_t>(AreaFill::VT_BACKGROUNDFILL, backgroundFill, 0);
  }
  void add_transparency(double transparency) {
    fbb_.AddElement<double>(AreaFill::VT_TRANSPARENCY, transparency, 0.0);
  }
  void add_mode(BentleyM0200::Dgn::FB::GradientMode mode) {
    fbb_.AddElement<int8_t>(AreaFill::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_flags(uint16_t flags) {
    fbb_.AddElement<uint16_t>(AreaFill::VT_FLAGS, flags, 0);
  }
  void add_angle(double angle) {
    fbb_.AddElement<double>(AreaFill::VT_ANGLE, angle, 0.0);
  }
  void add_tint(double tint) {
    fbb_.AddElement<double>(AreaFill::VT_TINT, tint, 0.0);
  }
  void add_shift(double shift) {
    fbb_.AddElement<double>(AreaFill::VT_SHIFT, shift, 0.0);
  }
  void add_colors(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> colors) {
    fbb_.AddOffset(AreaFill::VT_COLORS, colors);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<double>> values) {
    fbb_.AddOffset(AreaFill::VT_VALUES, values);
  }
  void add_thematicSettings(flatbuffers::Offset<BentleyM0200::Dgn::FB::ThematicSettings> thematicSettings) {
    fbb_.AddOffset(AreaFill::VT_THEMATICSETTINGS, thematicSettings);
  }
  explicit AreaFillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AreaFillBuilder &operator=(const AreaFillBuilder &);
  flatbuffers::Offset<AreaFill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AreaFill>(end);
    return o;
  }
};

inline flatbuffers::Offset<AreaFill> CreateAreaFill(
    flatbuffers::FlatBufferBuilder &_fbb,
    BentleyM0200::Dgn::FB::FillDisplay fill = BentleyM0200::Dgn::FB::FillDisplay_None,
    uint32_t color = 0,
    uint8_t useColor = 0,
    uint8_t backgroundFill = 0,
    double transparency = 0.0,
    BentleyM0200::Dgn::FB::GradientMode mode = BentleyM0200::Dgn::FB::GradientMode_None,
    uint16_t flags = 0,
    double angle = 0.0,
    double tint = 0.0,
    double shift = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> colors = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> values = 0,
    flatbuffers::Offset<BentleyM0200::Dgn::FB::ThematicSettings> thematicSettings = 0) {
  AreaFillBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_tint(tint);
  builder_.add_angle(angle);
  builder_.add_transparency(transparency);
  builder_.add_thematicSettings(thematicSettings);
  builder_.add_values(values);
  builder_.add_colors(colors);
  builder_.add_color(color);
  builder_.add_flags(flags);
  builder_.add_mode(mode);
  builder_.add_backgroundFill(backgroundFill);
  builder_.add_useColor(useColor);
  builder_.add_fill(fill);
  return builder_.Finish();
}

inline flatbuffers::Offset<AreaFill> CreateAreaFillDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    BentleyM0200::Dgn::FB::FillDisplay fill = BentleyM0200::Dgn::FB::FillDisplay_None,
    uint32_t color = 0,
    uint8_t useColor = 0,
    uint8_t backgroundFill = 0,
    double transparency = 0.0,
    BentleyM0200::Dgn::FB::GradientMode mode = BentleyM0200::Dgn::FB::GradientMode_None,
    uint16_t flags = 0,
    double angle = 0.0,
    double tint = 0.0,
    double shift = 0.0,
    const std::vector<uint32_t> *colors = nullptr,
    const std::vector<double> *values = nullptr,
    flatbuffers::Offset<BentleyM0200::Dgn::FB::ThematicSettings> thematicSettings = 0) {
  auto colors__ = colors ? _fbb.CreateVector<uint32_t>(*colors) : 0;
  auto values__ = values ? _fbb.CreateVector<double>(*values) : 0;
  return BentleyM0200::Dgn::FB::CreateAreaFill(
      _fbb,
      fill,
      color,
      useColor,
      backgroundFill,
      transparency,
      mode,
      flags,
      angle,
      tint,
      shift,
      colors__,
      values__,
      thematicSettings);
}

struct DwgHatchDefLine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DwgHatchDefLineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ANGLE = 4,
    VT_THROUGH = 6,
    VT_OFFSET = 8,
    VT_DASHES = 10
  };
  double angle() const {
    return GetField<double>(VT_ANGLE, 0.0);
  }
  const BentleyM0200::Dgn::FB::DPoint2d *through() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint2d *>(VT_THROUGH);
  }
  const BentleyM0200::Dgn::FB::DPoint2d *offset() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint2d *>(VT_OFFSET);
  }
  const flatbuffers::Vector<double> *dashes() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DASHES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_ANGLE) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint2d>(verifier, VT_THROUGH) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint2d>(verifier, VT_OFFSET) &&
           VerifyOffset(verifier, VT_DASHES) &&
           verifier.VerifyVector(dashes()) &&
           verifier.EndTable();
  }
  bool has_angle() const { return CheckField(VT_ANGLE); }
  bool has_through() const { return CheckField(VT_THROUGH); }
  bool has_offset() const { return CheckField(VT_OFFSET); }
  bool has_dashes() const { return CheckField(VT_DASHES); }
};

struct DwgHatchDefLineBuilder {
  typedef DwgHatchDefLine Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_angle(double angle) {
    fbb_.AddElement<double>(DwgHatchDefLine::VT_ANGLE, angle, 0.0);
  }
  void add_through(const BentleyM0200::Dgn::FB::DPoint2d *through) {
    fbb_.AddStruct(DwgHatchDefLine::VT_THROUGH, through);
  }
  void add_offset(const BentleyM0200::Dgn::FB::DPoint2d *offset) {
    fbb_.AddStruct(DwgHatchDefLine::VT_OFFSET, offset);
  }
  void add_dashes(flatbuffers::Offset<flatbuffers::Vector<double>> dashes) {
    fbb_.AddOffset(DwgHatchDefLine::VT_DASHES, dashes);
  }
  explicit DwgHatchDefLineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DwgHatchDefLineBuilder &operator=(const DwgHatchDefLineBuilder &);
  flatbuffers::Offset<DwgHatchDefLine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DwgHatchDefLine>(end);
    return o;
  }
};

inline flatbuffers::Offset<DwgHatchDefLine> CreateDwgHatchDefLine(
    flatbuffers::FlatBufferBuilder &_fbb,
    double angle = 0.0,
    const BentleyM0200::Dgn::FB::DPoint2d *through = 0,
    const BentleyM0200::Dgn::FB::DPoint2d *offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> dashes = 0) {
  DwgHatchDefLineBuilder builder_(_fbb);
  builder_.add_angle(angle);
  builder_.add_dashes(dashes);
  builder_.add_offset(offset);
  builder_.add_through(through);
  return builder_.Finish();
}

inline flatbuffers::Offset<DwgHatchDefLine> CreateDwgHatchDefLineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double angle = 0.0,
    const BentleyM0200::Dgn::FB::DPoint2d *through = 0,
    const BentleyM0200::Dgn::FB::DPoint2d *offset = 0,
    const std::vector<double> *dashes = nullptr) {
  auto dashes__ = dashes ? _fbb.CreateVector<double>(*dashes) : 0;
  return BentleyM0200::Dgn::FB::CreateDwgHatchDefLine(
      _fbb,
      angle,
      through,
      offset,
      dashes__);
}

struct AreaPattern FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AreaPatternBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORIGIN = 4,
    VT_ROTATION = 6,
    VT_SPACE1 = 8,
    VT_SPACE2 = 10,
    VT_ANGLE1 = 12,
    VT_ANGLE2 = 14,
    VT_SCALE = 16,
    VT_COLOR = 18,
    VT_WEIGHT = 20,
    VT_USECOLOR = 22,
    VT_USEWEIGHT = 24,
    VT_INVISIBLEBOUNDARY = 26,
    VT_SNAPPABLE = 28,
    VT_SYMBOLID = 30,
    VT_DEFLINE = 32
  };
  const BentleyM0200::Dgn::FB::DPoint3d *origin() const {
    return GetStruct<const BentleyM0200::Dgn::FB::DPoint3d *>(VT_ORIGIN);
  }
  const BentleyM0200::Dgn::FB::RotMatrix *rotation() const {
    return GetStruct<const BentleyM0200::Dgn::FB::RotMatrix *>(VT_ROTATION);
  }
  double space1() const {
    return GetField<double>(VT_SPACE1, 0.0);
  }
  double space2() const {
    return GetField<double>(VT_SPACE2, 0.0);
  }
  double angle1() const {
    return GetField<double>(VT_ANGLE1, 0.0);
  }
  double angle2() const {
    return GetField<double>(VT_ANGLE2, 0.0);
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  uint32_t color() const {
    return GetField<uint32_t>(VT_COLOR, 0);
  }
  uint32_t weight() const {
    return GetField<uint32_t>(VT_WEIGHT, 0);
  }
  uint8_t useColor() const {
    return GetField<uint8_t>(VT_USECOLOR, 0);
  }
  uint8_t useWeight() const {
    return GetField<uint8_t>(VT_USEWEIGHT, 0);
  }
  uint8_t invisibleBoundary() const {
    return GetField<uint8_t>(VT_INVISIBLEBOUNDARY, 0);
  }
  uint8_t snappable() const {
    return GetField<uint8_t>(VT_SNAPPABLE, 0);
  }
  int64_t symbolId() const {
    return GetField<int64_t>(VT_SYMBOLID, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<BentleyM0200::Dgn::FB::DwgHatchDefLine>> *defLine() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BentleyM0200::Dgn::FB::DwgHatchDefLine>> *>(VT_DEFLINE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<BentleyM0200::Dgn::FB::DPoint3d>(verifier, VT_ORIGIN) &&
           VerifyField<BentleyM0200::Dgn::FB::RotMatrix>(verifier, VT_ROTATION) &&
           VerifyField<double>(verifier, VT_SPACE1) &&
           VerifyField<double>(verifier, VT_SPACE2) &&
           VerifyField<double>(verifier, VT_ANGLE1) &&
           VerifyField<double>(verifier, VT_ANGLE2) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<uint32_t>(verifier, VT_COLOR) &&
           VerifyField<uint32_t>(verifier, VT_WEIGHT) &&
           VerifyField<uint8_t>(verifier, VT_USECOLOR) &&
           VerifyField<uint8_t>(verifier, VT_USEWEIGHT) &&
           VerifyField<uint8_t>(verifier, VT_INVISIBLEBOUNDARY) &&
           VerifyField<uint8_t>(verifier, VT_SNAPPABLE) &&
           VerifyField<int64_t>(verifier, VT_SYMBOLID) &&
           VerifyOffset(verifier, VT_DEFLINE) &&
           verifier.VerifyVector(defLine()) &&
           verifier.VerifyVectorOfTables(defLine()) &&
           verifier.EndTable();
  }
  bool has_origin() const { return CheckField(VT_ORIGIN); }
  bool has_rotation() const { return CheckField(VT_ROTATION); }
  bool has_space1() const { return CheckField(VT_SPACE1); }
  bool has_space2() const { return CheckField(VT_SPACE2); }
  bool has_angle1() const { return CheckField(VT_ANGLE1); }
  bool has_angle2() const { return CheckField(VT_ANGLE2); }
  bool has_scale() const { return CheckField(VT_SCALE); }
  bool has_color() const { return CheckField(VT_COLOR); }
  bool has_weight() const { return CheckField(VT_WEIGHT); }
  bool has_useColor() const { return CheckField(VT_USECOLOR); }
  bool has_useWeight() const { return CheckField(VT_USEWEIGHT); }
  bool has_invisibleBoundary() const { return CheckField(VT_INVISIBLEBOUNDARY); }
  bool has_snappable() const { return CheckField(VT_SNAPPABLE); }
  bool has_symbolId() const { return CheckField(VT_SYMBOLID); }
  bool has_defLine() const { return CheckField(VT_DEFLINE); }
};

struct AreaPatternBuilder {
  typedef AreaPattern Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_origin(const BentleyM0200::Dgn::FB::DPoint3d *origin) {
    fbb_.AddStruct(AreaPattern::VT_ORIGIN, origin);
  }
  void add_rotation(const BentleyM0200::Dgn::FB::RotMatrix *rotation) {
    fbb_.AddStruct(AreaPattern::VT_ROTATION, rotation);
  }
  void add_space1(double space1) {
    fbb_.AddElement<double>(AreaPattern::VT_SPACE1, space1, 0.0);
  }
  void add_space2(double space2) {
    fbb_.AddElement<double>(AreaPattern::VT_SPACE2, space2, 0.0);
  }
  void add_angle1(double angle1) {
    fbb_.AddElement<double>(AreaPattern::VT_ANGLE1, angle1, 0.0);
  }
  void add_angle2(double angle2) {
    fbb_.AddElement<double>(AreaPattern::VT_ANGLE2, angle2, 0.0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(AreaPattern::VT_SCALE, scale, 0.0);
  }
  void add_color(uint32_t color) {
    fbb_.AddElement<uint32_t>(AreaPattern::VT_COLOR, color, 0);
  }
  void add_weight(uint32_t weight) {
    fbb_.AddElement<uint32_t>(AreaPattern::VT_WEIGHT, weight, 0);
  }
  void add_useColor(uint8_t useColor) {
    fbb_.AddElement<uint8_t>(AreaPattern::VT_USECOLOR, useColor, 0);
  }
  void add_useWeight(uint8_t useWeight) {
    fbb_.AddElement<uint8_t>(AreaPattern::VT_USEWEIGHT, useWeight, 0);
  }
  void add_invisibleBoundary(uint8_t invisibleBoundary) {
    fbb_.AddElement<uint8_t>(AreaPattern::VT_INVISIBLEBOUNDARY, invisibleBoundary, 0);
  }
  void add_snappable(uint8_t snappable) {
    fbb_.AddElement<uint8_t>(AreaPattern::VT_SNAPPABLE, snappable, 0);
  }
  void add_symbolId(int64_t symbolId) {
    fbb_.AddElement<int64_t>(AreaPattern::VT_SYMBOLID, symbolId, 0);
  }
  void add_defLine(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BentleyM0200::Dgn::FB::DwgHatchDefLine>>> defLine) {
    fbb_.AddOffset(AreaPattern::VT_DEFLINE, defLine);
  }
  explicit AreaPatternBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AreaPatternBuilder &operator=(const AreaPatternBuilder &);
  flatbuffers::Offset<AreaPattern> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AreaPattern>(end);
    return o;
  }
};

inline flatbuffers::Offset<AreaPattern> CreateAreaPattern(
    flatbuffers::FlatBufferBuilder &_fbb,
    const BentleyM0200::Dgn::FB::DPoint3d *origin = 0,
    const BentleyM0200::Dgn::FB::RotMatrix *rotation = 0,
    double space1 = 0.0,
    double space2 = 0.0,
    double angle1 = 0.0,
    double angle2 = 0.0,
    double scale = 0.0,
    uint32_t color = 0,
    uint32_t weight = 0,
    uint8_t useColor = 0,
    uint8_t useWeight = 0,
    uint8_t invisibleBoundary = 0,
    uint8_t snappable = 0,
    int64_t symbolId = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BentleyM0200::Dgn::FB::DwgHatchDefLine>>> defLine = 0) {
  AreaPatternBuilder builder_(_fbb);
  builder_.add_symbolId(symbolId);
  builder_.add_scale(scale);
  builder_.add_angle2(angle2);
  builder_.add_angle1(angle1);
  builder_.add_space2(space2);
  builder_.add_space1(space1);
  builder_.add_defLine(defLine);
  builder_.add_weight(weight);
  builder_.add_color(color);
  builder_.add_rotation(rotation);
  builder_.add_origin(origin);
  builder_.add_snappable(snappable);
  builder_.add_invisibleBoundary(invisibleBoundary);
  builder_.add_useWeight(useWeight);
  builder_.add_useColor(useColor);
  return builder_.Finish();
}

inline flatbuffers::Offset<AreaPattern> CreateAreaPatternDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const BentleyM0200::Dgn::FB::DPoint3d *origin = 0,
    const BentleyM0200::Dgn::FB::RotMatrix *rotation = 0,
    double space1 = 0.0,
    double space2 = 0.0,
    double angle1 = 0.0,
    double angle2 = 0.0,
    double scale = 0.0,
    uint32_t color = 0,
    uint32_t weight = 0,
    uint8_t useColor = 0,
    uint8_t useWeight = 0,
    uint8_t invisibleBoundary = 0,
    uint8_t snappable = 0,
    int64_t symbolId = 0,
    const std::vector<flatbuffers::Offset<BentleyM0200::Dgn::FB::DwgHatchDefLine>> *defLine = nullptr) {
  auto defLine__ = defLine ? _fbb.CreateVector<flatbuffers::Offset<BentleyM0200::Dgn::FB::DwgHatchDefLine>>(*defLine) : 0;
  return BentleyM0200::Dgn::FB::CreateAreaPattern(
      _fbb,
      origin,
      rotation,
      space1,
      space2,
      angle1,
      angle2,
      scale,
      color,
      weight,
      useColor,
      useWeight,
      invisibleBoundary,
      snappable,
      symbolId,
      defLine__);
}

}  // namespace FB
}  // namespace Dgn
}  // namespace BentleyM0200

#endif  // FLATBUFFERS_GENERATED_ELEMENTGRAPHICS_BENTLEYM0200_DGN_FB_H_
