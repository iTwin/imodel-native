//---------------------------------------------------------------------------------------------
//  Copyright (c) Bentley Systems, Incorporated. All rights reserved.
//  See LICENSE.md in the repository root for full copyright notice.
//---------------------------------------------------------------------------------------------
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TEXTSTRING_BENTLEYM0200_DGN_FB_H_
#define FLATBUFFERS_GENERATED_TEXTSTRING_BENTLEYM0200_DGN_FB_H_

#include "flatbuffers/flatbuffers.h"

namespace BentleyM0200 {
namespace Dgn {
namespace FB {

struct TextStringTransform;

struct TextStringRange;

struct TextStringGlyphOrigin;

struct TextStringStyle;
struct TextStringStyleBuilder;

struct TextString;
struct TextStringBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TextStringTransform FLATBUFFERS_FINAL_CLASS {
 private:
  double form3d00_;
  double form3d01_;
  double form3d02_;
  double form3d03_;
  double form3d10_;
  double form3d11_;
  double form3d12_;
  double form3d13_;
  double form3d20_;
  double form3d21_;
  double form3d22_;
  double form3d23_;

 public:
  TextStringTransform() {
    memset(static_cast<void *>(this), 0, sizeof(TextStringTransform));
  }
  TextStringTransform(double _form3d00, double _form3d01, double _form3d02, double _form3d03, double _form3d10, double _form3d11, double _form3d12, double _form3d13, double _form3d20, double _form3d21, double _form3d22, double _form3d23)
      : form3d00_(flatbuffers::EndianScalar(_form3d00)),
        form3d01_(flatbuffers::EndianScalar(_form3d01)),
        form3d02_(flatbuffers::EndianScalar(_form3d02)),
        form3d03_(flatbuffers::EndianScalar(_form3d03)),
        form3d10_(flatbuffers::EndianScalar(_form3d10)),
        form3d11_(flatbuffers::EndianScalar(_form3d11)),
        form3d12_(flatbuffers::EndianScalar(_form3d12)),
        form3d13_(flatbuffers::EndianScalar(_form3d13)),
        form3d20_(flatbuffers::EndianScalar(_form3d20)),
        form3d21_(flatbuffers::EndianScalar(_form3d21)),
        form3d22_(flatbuffers::EndianScalar(_form3d22)),
        form3d23_(flatbuffers::EndianScalar(_form3d23)) {
  }
  double form3d00() const {
    return flatbuffers::EndianScalar(form3d00_);
  }
  double form3d01() const {
    return flatbuffers::EndianScalar(form3d01_);
  }
  double form3d02() const {
    return flatbuffers::EndianScalar(form3d02_);
  }
  double form3d03() const {
    return flatbuffers::EndianScalar(form3d03_);
  }
  double form3d10() const {
    return flatbuffers::EndianScalar(form3d10_);
  }
  double form3d11() const {
    return flatbuffers::EndianScalar(form3d11_);
  }
  double form3d12() const {
    return flatbuffers::EndianScalar(form3d12_);
  }
  double form3d13() const {
    return flatbuffers::EndianScalar(form3d13_);
  }
  double form3d20() const {
    return flatbuffers::EndianScalar(form3d20_);
  }
  double form3d21() const {
    return flatbuffers::EndianScalar(form3d21_);
  }
  double form3d22() const {
    return flatbuffers::EndianScalar(form3d22_);
  }
  double form3d23() const {
    return flatbuffers::EndianScalar(form3d23_);
  }
};
FLATBUFFERS_STRUCT_END(TextStringTransform, 96);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TextStringRange FLATBUFFERS_FINAL_CLASS {
 private:
  double lowx_;
  double lowy_;
  double highx_;
  double highy_;

 public:
  TextStringRange() {
    memset(static_cast<void *>(this), 0, sizeof(TextStringRange));
  }
  TextStringRange(double _lowx, double _lowy, double _highx, double _highy)
      : lowx_(flatbuffers::EndianScalar(_lowx)),
        lowy_(flatbuffers::EndianScalar(_lowy)),
        highx_(flatbuffers::EndianScalar(_highx)),
        highy_(flatbuffers::EndianScalar(_highy)) {
  }
  double lowx() const {
    return flatbuffers::EndianScalar(lowx_);
  }
  double lowy() const {
    return flatbuffers::EndianScalar(lowy_);
  }
  double highx() const {
    return flatbuffers::EndianScalar(highx_);
  }
  double highy() const {
    return flatbuffers::EndianScalar(highy_);
  }
};
FLATBUFFERS_STRUCT_END(TextStringRange, 32);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TextStringGlyphOrigin FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;

 public:
  TextStringGlyphOrigin() {
    memset(static_cast<void *>(this), 0, sizeof(TextStringGlyphOrigin));
  }
  TextStringGlyphOrigin(double _x, double _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(TextStringGlyphOrigin, 16);

struct TextStringStyle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextStringStyleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAJORVERSION = 4,
    VT_MINORVERSION = 6,
    VT_FONTID = 8,
    VT_ISBOLD = 10,
    VT_ISITALIC = 12,
    VT_ISUNDERLINED = 14,
    VT_HEIGHT = 16,
    VT_WIDTHFACTOR = 18
  };
  uint8_t majorVersion() const {
    return GetField<uint8_t>(VT_MAJORVERSION, 0);
  }
  uint8_t minorVersion() const {
    return GetField<uint8_t>(VT_MINORVERSION, 0);
  }
  uint32_t fontId() const {
    return GetField<uint32_t>(VT_FONTID, 0);
  }
  bool isBold() const {
    return GetField<uint8_t>(VT_ISBOLD, 0) != 0;
  }
  bool isItalic() const {
    return GetField<uint8_t>(VT_ISITALIC, 0) != 0;
  }
  bool isUnderlined() const {
    return GetField<uint8_t>(VT_ISUNDERLINED, 0) != 0;
  }
  double height() const {
    return GetField<double>(VT_HEIGHT, 0.0);
  }
  double widthFactor() const {
    return GetField<double>(VT_WIDTHFACTOR, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MAJORVERSION) &&
           VerifyField<uint8_t>(verifier, VT_MINORVERSION) &&
           VerifyField<uint32_t>(verifier, VT_FONTID) &&
           VerifyField<uint8_t>(verifier, VT_ISBOLD) &&
           VerifyField<uint8_t>(verifier, VT_ISITALIC) &&
           VerifyField<uint8_t>(verifier, VT_ISUNDERLINED) &&
           VerifyField<double>(verifier, VT_HEIGHT) &&
           VerifyField<double>(verifier, VT_WIDTHFACTOR) &&
           verifier.EndTable();
  }
  bool has_majorVersion() const { return CheckField(VT_MAJORVERSION); }
  bool has_minorVersion() const { return CheckField(VT_MINORVERSION); }
  bool has_fontId() const { return CheckField(VT_FONTID); }
  bool has_isBold() const { return CheckField(VT_ISBOLD); }
  bool has_isItalic() const { return CheckField(VT_ISITALIC); }
  bool has_isUnderlined() const { return CheckField(VT_ISUNDERLINED); }
  bool has_height() const { return CheckField(VT_HEIGHT); }
  bool has_widthFactor() const { return CheckField(VT_WIDTHFACTOR); }
};

struct TextStringStyleBuilder {
  typedef TextStringStyle Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_majorVersion(uint8_t majorVersion) {
    fbb_.AddElement<uint8_t>(TextStringStyle::VT_MAJORVERSION, majorVersion, 0);
  }
  void add_minorVersion(uint8_t minorVersion) {
    fbb_.AddElement<uint8_t>(TextStringStyle::VT_MINORVERSION, minorVersion, 0);
  }
  void add_fontId(uint32_t fontId) {
    fbb_.AddElement<uint32_t>(TextStringStyle::VT_FONTID, fontId, 0);
  }
  void add_isBold(bool isBold) {
    fbb_.AddElement<uint8_t>(TextStringStyle::VT_ISBOLD, static_cast<uint8_t>(isBold), 0);
  }
  void add_isItalic(bool isItalic) {
    fbb_.AddElement<uint8_t>(TextStringStyle::VT_ISITALIC, static_cast<uint8_t>(isItalic), 0);
  }
  void add_isUnderlined(bool isUnderlined) {
    fbb_.AddElement<uint8_t>(TextStringStyle::VT_ISUNDERLINED, static_cast<uint8_t>(isUnderlined), 0);
  }
  void add_height(double height) {
    fbb_.AddElement<double>(TextStringStyle::VT_HEIGHT, height, 0.0);
  }
  void add_widthFactor(double widthFactor) {
    fbb_.AddElement<double>(TextStringStyle::VT_WIDTHFACTOR, widthFactor, 0.0);
  }
  explicit TextStringStyleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextStringStyleBuilder &operator=(const TextStringStyleBuilder &);
  flatbuffers::Offset<TextStringStyle> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextStringStyle>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextStringStyle> CreateTextStringStyle(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t majorVersion = 0,
    uint8_t minorVersion = 0,
    uint32_t fontId = 0,
    bool isBold = false,
    bool isItalic = false,
    bool isUnderlined = false,
    double height = 0.0,
    double widthFactor = 0.0) {
  TextStringStyleBuilder builder_(_fbb);
  builder_.add_widthFactor(widthFactor);
  builder_.add_height(height);
  builder_.add_fontId(fontId);
  builder_.add_isUnderlined(isUnderlined);
  builder_.add_isItalic(isItalic);
  builder_.add_isBold(isBold);
  builder_.add_minorVersion(minorVersion);
  builder_.add_majorVersion(majorVersion);
  return builder_.Finish();
}

struct TextString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TextStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAJORVERSION = 4,
    VT_MINORVERSION = 6,
    VT_TEXT = 8,
    VT_STYLE = 10,
    VT_TRANSFORM = 12,
    VT_RANGE = 14,
    VT_GLYPHIDS = 16,
    VT_GLYPHORIGINS = 18
  };
  uint8_t majorVersion() const {
    return GetField<uint8_t>(VT_MAJORVERSION, 0);
  }
  uint8_t minorVersion() const {
    return GetField<uint8_t>(VT_MINORVERSION, 0);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  const BentleyM0200::Dgn::FB::TextStringStyle *style() const {
    return GetPointer<const BentleyM0200::Dgn::FB::TextStringStyle *>(VT_STYLE);
  }
  const BentleyM0200::Dgn::FB::TextStringTransform *transform() const {
    return GetStruct<const BentleyM0200::Dgn::FB::TextStringTransform *>(VT_TRANSFORM);
  }
  const BentleyM0200::Dgn::FB::TextStringRange *range() const {
    return GetStruct<const BentleyM0200::Dgn::FB::TextStringRange *>(VT_RANGE);
  }
  const flatbuffers::Vector<uint32_t> *glyphIds() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_GLYPHIDS);
  }
  const flatbuffers::Vector<const BentleyM0200::Dgn::FB::TextStringGlyphOrigin *> *glyphOrigins() const {
    return GetPointer<const flatbuffers::Vector<const BentleyM0200::Dgn::FB::TextStringGlyphOrigin *> *>(VT_GLYPHORIGINS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_MAJORVERSION) &&
           VerifyField<uint8_t>(verifier, VT_MINORVERSION) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffset(verifier, VT_STYLE) &&
           verifier.VerifyTable(style()) &&
           VerifyField<BentleyM0200::Dgn::FB::TextStringTransform>(verifier, VT_TRANSFORM) &&
           VerifyField<BentleyM0200::Dgn::FB::TextStringRange>(verifier, VT_RANGE) &&
           VerifyOffset(verifier, VT_GLYPHIDS) &&
           verifier.VerifyVector(glyphIds()) &&
           VerifyOffset(verifier, VT_GLYPHORIGINS) &&
           verifier.VerifyVector(glyphOrigins()) &&
           verifier.EndTable();
  }
  bool has_majorVersion() const { return CheckField(VT_MAJORVERSION); }
  bool has_minorVersion() const { return CheckField(VT_MINORVERSION); }
  bool has_text() const { return CheckField(VT_TEXT); }
  bool has_style() const { return CheckField(VT_STYLE); }
  bool has_transform() const { return CheckField(VT_TRANSFORM); }
  bool has_range() const { return CheckField(VT_RANGE); }
  bool has_glyphIds() const { return CheckField(VT_GLYPHIDS); }
  bool has_glyphOrigins() const { return CheckField(VT_GLYPHORIGINS); }
};

struct TextStringBuilder {
  typedef TextString Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_majorVersion(uint8_t majorVersion) {
    fbb_.AddElement<uint8_t>(TextString::VT_MAJORVERSION, majorVersion, 0);
  }
  void add_minorVersion(uint8_t minorVersion) {
    fbb_.AddElement<uint8_t>(TextString::VT_MINORVERSION, minorVersion, 0);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(TextString::VT_TEXT, text);
  }
  void add_style(flatbuffers::Offset<BentleyM0200::Dgn::FB::TextStringStyle> style) {
    fbb_.AddOffset(TextString::VT_STYLE, style);
  }
  void add_transform(const BentleyM0200::Dgn::FB::TextStringTransform *transform) {
    fbb_.AddStruct(TextString::VT_TRANSFORM, transform);
  }
  void add_range(const BentleyM0200::Dgn::FB::TextStringRange *range) {
    fbb_.AddStruct(TextString::VT_RANGE, range);
  }
  void add_glyphIds(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> glyphIds) {
    fbb_.AddOffset(TextString::VT_GLYPHIDS, glyphIds);
  }
  void add_glyphOrigins(flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::TextStringGlyphOrigin *>> glyphOrigins) {
    fbb_.AddOffset(TextString::VT_GLYPHORIGINS, glyphOrigins);
  }
  explicit TextStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextStringBuilder &operator=(const TextStringBuilder &);
  flatbuffers::Offset<TextString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextString>(end);
    return o;
  }
};

inline flatbuffers::Offset<TextString> CreateTextString(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t majorVersion = 0,
    uint8_t minorVersion = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<BentleyM0200::Dgn::FB::TextStringStyle> style = 0,
    const BentleyM0200::Dgn::FB::TextStringTransform *transform = 0,
    const BentleyM0200::Dgn::FB::TextStringRange *range = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> glyphIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<const BentleyM0200::Dgn::FB::TextStringGlyphOrigin *>> glyphOrigins = 0) {
  TextStringBuilder builder_(_fbb);
  builder_.add_glyphOrigins(glyphOrigins);
  builder_.add_glyphIds(glyphIds);
  builder_.add_range(range);
  builder_.add_transform(transform);
  builder_.add_style(style);
  builder_.add_text(text);
  builder_.add_minorVersion(minorVersion);
  builder_.add_majorVersion(majorVersion);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextString> CreateTextStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t majorVersion = 0,
    uint8_t minorVersion = 0,
    const char *text = nullptr,
    flatbuffers::Offset<BentleyM0200::Dgn::FB::TextStringStyle> style = 0,
    const BentleyM0200::Dgn::FB::TextStringTransform *transform = 0,
    const BentleyM0200::Dgn::FB::TextStringRange *range = 0,
    const std::vector<uint32_t> *glyphIds = nullptr,
    const std::vector<BentleyM0200::Dgn::FB::TextStringGlyphOrigin> *glyphOrigins = nullptr) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto glyphIds__ = glyphIds ? _fbb.CreateVector<uint32_t>(*glyphIds) : 0;
  auto glyphOrigins__ = glyphOrigins ? _fbb.CreateVectorOfStructs<BentleyM0200::Dgn::FB::TextStringGlyphOrigin>(*glyphOrigins) : 0;
  return BentleyM0200::Dgn::FB::CreateTextString(
      _fbb,
      majorVersion,
      minorVersion,
      text__,
      style,
      transform,
      range,
      glyphIds__,
      glyphOrigins__);
}

}  // namespace FB
}  // namespace Dgn
}  // namespace BentleyM0200

#endif  // FLATBUFFERS_GENERATED_TEXTSTRING_BENTLEYM0200_DGN_FB_H_
