/*---------------------------------------------------------------------------------------------
* Copyright (c) Bentley Systems, Incorporated. All rights reserved.
* See LICENSE.md in the repository root for full copyright notice.
*--------------------------------------------------------------------------------------------*/
#include "../BackDoor/PublicAPI/BackDoor/ECDb/BackDoor.h"
#include "ECDbPublishedTests.h"
#include <numeric>
#include "MockHubApi.h"

USING_NAMESPACE_BENTLEY_EC
USING_NAMESPACE_BENTLEY_SQLITE_EC
BEGIN_ECDBUNITTESTS_NAMESPACE
/**
 * A IModel that use shared schema channel can only update/import schema via shared schema channel.
 * IModel will not allow schema import unless shared schema channel is setup up.
 * IModel will contain be_prop that will let ECDb know to not allow direct schema import call instead
 * it will require to call ImportSchemasViaSharedChannel()
*/

auto schemaXMLBuilder = [](Utf8CP newSchemaVersion = "01.00.00")
    {
    Utf8CP schemaTemplate =
        R"xml(<?xml version="1.0" encoding="UTF-8"?>
        <ECSchema schemaName="TestSchema1" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
            <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
            <ECEntityClass typeName="Pipe1">
                <ECCustomAttributes>
                    <ClassMap xmlns="ECDbMap.02.00.00">
                        <MapStrategy>TablePerHierarchy</MapStrategy>
                    </ClassMap>
                    <DbIndexList xmlns="ECDbMap.02.00.00">
                        <Indexes>
                            <DbIndex>
                                <Name>idx_pipe1_p1</Name>
                                <IsUnique>False</IsUnique>
                                <Properties>
                                    <string>p1</string>
                                </Properties>
                            </DbIndex>
                        </Indexes>
                    </DbIndexList>
                </ECCustomAttributes>
                <ECProperty propertyName="p1" typeName="int" />
                <ECProperty propertyName="p2" typeName="int" />
            </ECEntityClass>
        </ECSchema>)xml";
    Utf8String schemaXml;
    schemaXml.Sprintf(schemaTemplate, newSchemaVersion);
    return schemaXml;
    };

// ---------------------------------------------------------------------------------------
// @bsitest
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, cache_table_updated)
    {
    auto tableEcCacheClassHasTables = "ec_cache_ClassHasTables";
    auto tableEcCacheClassHierarchy = "ec_cache_ClassHierarchy";
    auto computeHash = [](ECDbCR db, Utf8CP tableName) -> std::string {
      Statement stmt;
      EXPECT_EQ(BE_SQLITE_OK, stmt.Prepare(db, SqlPrintfString("select hex(sha3_query('SELECT * FROM [%s] ORDER BY ROWID'))", tableName).GetUtf8CP()));
      EXPECT_EQ(BE_SQLITE_ROW, stmt.Step());
      return stmt.GetValueText(0);
    };

    ECDbHub hub;
    SchemaSyncDb schemaSyncDb("sync-db");
    auto b1 = hub.CreateBriefcase();

    ASSERT_EQ(SchemaSync::Status::OK, b1->Schemas().GetSchemaSync().Init(schemaSyncDb.GetSyncDbUri(), "xxxxx", false));

    b1->SaveChanges();
    b1->PullMergePush("init");

    auto b2 = hub.CreateBriefcase();
    auto b3 = hub.CreateBriefcase();

    auto b1_tableEcCacheClassHasTables =  computeHash(*b1, tableEcCacheClassHasTables);
    auto b1_tableEcCacheClassHierarchy =  computeHash(*b1, tableEcCacheClassHierarchy);
    auto b2_tableEcCacheClassHasTables =  computeHash(*b2, tableEcCacheClassHasTables);
    auto b2_tableEcCacheClassHierarchy =  computeHash(*b2, tableEcCacheClassHierarchy);
    auto b3_tableEcCacheClassHasTables =  computeHash(*b3, tableEcCacheClassHasTables);
    auto b3_tableEcCacheClassHierarchy =  computeHash(*b3, tableEcCacheClassHierarchy);
    ASSERT_STREQ(b1_tableEcCacheClassHasTables.c_str(), b2_tableEcCacheClassHasTables.c_str());
    ASSERT_STREQ(b1_tableEcCacheClassHierarchy.c_str(), b2_tableEcCacheClassHierarchy.c_str());
    ASSERT_STREQ(b1_tableEcCacheClassHasTables.c_str(), b3_tableEcCacheClassHasTables.c_str());
    ASSERT_STREQ(b1_tableEcCacheClassHierarchy.c_str(), b3_tableEcCacheClassHierarchy.c_str());
    ASSERT_STREQ(b2_tableEcCacheClassHasTables.c_str(), b3_tableEcCacheClassHasTables.c_str());
    ASSERT_STREQ(b2_tableEcCacheClassHierarchy.c_str(), b3_tableEcCacheClassHierarchy.c_str());
    auto s1 = SchemaItem(
        R"xml(<?xml version="1.0" encoding="UTF-8"?>
        <ECSchema schemaName="TestSchema1" alias="ts" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
            <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
            <ECEntityClass typeName="Pipe1">
                <ECCustomAttributes>
                    <ClassMap xmlns="ECDbMap.02.00.00">
                        <MapStrategy>TablePerHierarchy</MapStrategy>
                    </ClassMap>
                </ECCustomAttributes>
                <ECProperty propertyName="p1" typeName="int" />
            </ECEntityClass>
        </ECSchema>)xml"
    );

    ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*b1, s1, SchemaManager::SchemaImportOptions::None, schemaSyncDb.GetSyncDbUri()));
    ASSERT_EQ(BE_SQLITE_OK, b1->SaveChanges());
    b1->PullMergePush("");

    b1_tableEcCacheClassHasTables =  computeHash(*b1, tableEcCacheClassHasTables);
    b1_tableEcCacheClassHierarchy =  computeHash(*b1, tableEcCacheClassHierarchy);
    b2_tableEcCacheClassHasTables =  computeHash(*b2, tableEcCacheClassHasTables);
    b2_tableEcCacheClassHierarchy =  computeHash(*b2, tableEcCacheClassHierarchy);
    b3_tableEcCacheClassHasTables =  computeHash(*b3, tableEcCacheClassHasTables);
    b3_tableEcCacheClassHierarchy =  computeHash(*b3, tableEcCacheClassHierarchy);
    ASSERT_STRNE(b1_tableEcCacheClassHasTables.c_str(), b2_tableEcCacheClassHasTables.c_str());
    ASSERT_STRNE(b1_tableEcCacheClassHierarchy.c_str(), b2_tableEcCacheClassHierarchy.c_str());
    ASSERT_STRNE(b1_tableEcCacheClassHasTables.c_str(), b3_tableEcCacheClassHasTables.c_str());
    ASSERT_STRNE(b1_tableEcCacheClassHierarchy.c_str(), b3_tableEcCacheClassHierarchy.c_str());
    ASSERT_STREQ(b2_tableEcCacheClassHasTables.c_str(), b3_tableEcCacheClassHasTables.c_str());
    ASSERT_STREQ(b2_tableEcCacheClassHierarchy.c_str(), b3_tableEcCacheClassHierarchy.c_str());

    // Simulate in correct cache tables
    schemaSyncDb.WithReadWrite([](ECDbR db){
        // simulate incorrect cache tables.
        EXPECT_EQ(BE_SQLITE_OK, db.TryExecuteSql("DELETE FROM ec_cache_ClassHasTables;"));
        EXPECT_EQ(BE_SQLITE_OK, db.TryExecuteSql("DELETE FROM ec_cache_ClassHierarchy;"));
        EXPECT_EQ(BE_SQLITE_OK, db.SaveChanges());
    });

    schemaSyncDb.Pull(*b2, [&]() {});
    b3->PullMergePush("");

    b1_tableEcCacheClassHasTables =  computeHash(*b1, tableEcCacheClassHasTables);
    b1_tableEcCacheClassHierarchy =  computeHash(*b1, tableEcCacheClassHierarchy);
    b2_tableEcCacheClassHasTables =  computeHash(*b2, tableEcCacheClassHasTables);
    b2_tableEcCacheClassHierarchy =  computeHash(*b2, tableEcCacheClassHierarchy);
    b3_tableEcCacheClassHasTables =  computeHash(*b3, tableEcCacheClassHasTables);
    b3_tableEcCacheClassHierarchy =  computeHash(*b3, tableEcCacheClassHierarchy);
    ASSERT_STREQ(b1_tableEcCacheClassHasTables.c_str(), b2_tableEcCacheClassHasTables.c_str());
    ASSERT_STREQ(b1_tableEcCacheClassHierarchy.c_str(), b2_tableEcCacheClassHierarchy.c_str());
    ASSERT_STREQ(b1_tableEcCacheClassHasTables.c_str(), b3_tableEcCacheClassHasTables.c_str());
    ASSERT_STREQ(b1_tableEcCacheClassHierarchy.c_str(), b3_tableEcCacheClassHierarchy.c_str());
    ASSERT_STREQ(b2_tableEcCacheClassHasTables.c_str(), b3_tableEcCacheClassHasTables.c_str());
    ASSERT_STREQ(b2_tableEcCacheClassHierarchy.c_str(), b3_tableEcCacheClassHierarchy.c_str());
}

// ---------------------------------------------------------------------------------------
// @bsitest
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, checksum_pragma)
    {
    ECDbHub hub;
    auto b1 = hub.CreateBriefcase();

    // PrintHash(*b1, "checksum for seed file");

    Test(
        "schema checksum",
        [&]()
            {
            ECSqlStatement stmt;
            EXPECT_EQ(stmt.Prepare(*b1, "PRAGMA checksum(ecdb_schema)"), ECSqlStatus::Success);
            EXPECT_EQ(stmt.Step(), BE_SQLITE_ROW);
            EXPECT_STREQ(stmt.GetValueText(0), DEFAULT_SHA3_256_ECDB_SCHEMA);
            }
    );

    Test(
        "map checksum",
        [&]()
            {
            ECSqlStatement stmt;
            EXPECT_EQ(stmt.Prepare(*b1, "PRAGMA checksum(ecdb_map)"), ECSqlStatus::Success);
            EXPECT_EQ(stmt.Step(), BE_SQLITE_ROW);
            EXPECT_STREQ(stmt.GetValueText(0), DEFAULT_SHA3_256_ECDB_MAP);
            }
    );

    Test(
        "sqlite schema checksum",
        [&]()
            {
            ECSqlStatement stmt;
            EXPECT_EQ(stmt.Prepare(*b1, "PRAGMA checksum(sqlite_schema)"), ECSqlStatus::Success);
            EXPECT_EQ(stmt.Step(), BE_SQLITE_ROW);
            EXPECT_STREQ(stmt.GetValueText(0), DEFAULT_SHA3_256_SQLITE_SCHEMA);
            }
    );
    }

// ---------------------------------------------------------------------------------------
// @bsitest
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, FullSchemaSyncWorkflow)
    {
    ECDbHub hub;
    SchemaSyncDb schemaSyncDb("sync-db");
    auto b1 = hub.CreateBriefcase();
    ASSERT_EQ(SchemaSync::Status::OK, b1->Schemas().GetSchemaSync().Init(schemaSyncDb.GetSyncDbUri(),"xxxxx", false));

    b1->PullMergePush("init");
    b1->SaveChanges();

    auto b2 = hub.CreateBriefcase();
    auto b3 = hub.CreateBriefcase();

    Test(
        "Check briefcase ids",
        [&]()
            {
            ASSERT_EQ(b1->GetBriefcaseId().GetValue(), 11);
            ASSERT_EQ(b2->GetBriefcaseId().GetValue(), 12);
            ASSERT_EQ(b3->GetBriefcaseId().GetValue(), 13);
            }
    );

    Test(
        "check syncDb, b1, b2 and b3 hashes",
        [&]()
            {
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            CheckHashes(*b1);
            CheckHashes(*b2);
            CheckHashes(*b3);
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "57df4675ccbce3493d2bb882ad3bb28f3266425c2f22fd55e57e187808b3add3";
    const auto SCHEMA1_HASH_ECDB_MAP = "8b1c6d8fa5b29e085bf94fae710527f56fa1c1792bd7404ff5775ed07f86f21f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "8608aab5fa8a874b3f9140451ab8410c785483a878c8d915f48a26ef20e8241c";
    Test(
        "import schema into b1",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, schemaSyncDb.GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, b1->SaveChanges());

            ASSERT_TRUE(b1->TableExists("ts_Pipe1"));
            ASSERT_STRCASEEQ(GetIndexDDL(*b1, "idx_pipe1_p1").c_str(), "CREATE INDEX [idx_pipe1_p1] ON [ts_Pipe1]([p1])");
            CheckHashes(*b1, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            }
    );

    Test(
        "check if sync-db has changes but not tables and index",
        [&]()
            {
            schemaSyncDb.WithReadOnly(
                [&](ECDbR syncDb)
                    {
                    auto pipe1 = syncDb.Schemas().GetClass("TestSchema1", "Pipe1");
                    ASSERT_NE(pipe1, nullptr);
                    ASSERT_EQ(pipe1->GetPropertyCount(), 2);
                    ASSERT_FALSE(syncDb.TableExists("ts_Pipe1"));
                    ASSERT_STRCASEEQ(GetIndexDDL(syncDb, "idx_pipe1_p1").c_str(), "");
                    CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); // SQLITE_SCHEMA hash should not change
                    ASSERT_TRUE(ForeignkeyCheck(syncDb));
                    }
            );
            }
    );

    Test(
        "pull changes from sync-db into b2 and verify class, table and index exists",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                schemaSyncDb.Pull(
                    *b2,
                    [&]()
                        {
                        auto pipe1 = b2->Schemas().GetClass("TestSchema1", "Pipe1");
                        ASSERT_NE(pipe1, nullptr);
                        ASSERT_EQ(pipe1->GetPropertyCount(), 2);
                        ASSERT_TRUE(b2->TableExists("ts_Pipe1"));
                        ASSERT_STRCASEEQ(GetIndexDDL(*b2, "idx_pipe1_p1").c_str(), "CREATE INDEX [idx_pipe1_p1] ON [ts_Pipe1]([p1])");
                        CheckHashes(*b2, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*b2));
                        }
                )
            ) << "Pull changes from schemaSyncDb into b2";
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "4a674e4d762c6960fa5276c7395d813c786dc4023843674e93548e9f9ad8cd62";
    const auto SCHEMA2_HASH_ECDB_MAP = "d9bb9b10a0b3745b1878eff131e692e7930d34883ae52506b5be23bd4e8d2b5f";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "a5903dad8066700b537ea5f939043e8d8cbfe1297ea6fa0c3e20d7c00e5e3d44";
    Test(
        "update schema by adding more properties and expand index in b2",
        [&]()
            {
            auto schema2 = SchemaItem(
                R"xml(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="TestSchema1" alias="ts" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Pipe1">
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <DbIndexList xmlns="ECDbMap.02.00.00">
                                <Indexes>
                                    <DbIndex>
                                        <Name>idx_pipe1_p1</Name>
                                        <IsUnique>False</IsUnique>
                                        <Properties>
                                            <string>p1</string>
                                            <string>p2</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                        <ECProperty propertyName="p1" typeName="int" />
                        <ECProperty propertyName="p2" typeName="int" />
                        <ECProperty propertyName="p3" typeName="int" />
                        <ECProperty propertyName="p4" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*b2, schema2, SchemaManager::SchemaImportOptions::None, schemaSyncDb.GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, b2->SaveChanges());

            ASSERT_TRUE(b2->TableExists("ts_Pipe1"));
            ASSERT_STRCASEEQ(GetIndexDDL(*b2, "idx_pipe1_p1").c_str(), "CREATE INDEX [idx_pipe1_p1] ON [ts_Pipe1]([p1], [p2])");
            CheckHashes(*b2, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );

    Test(
        "check if sync-db has changes but not tables and index",
        [&]()
            {
            schemaSyncDb.WithReadOnly(
                [&](ECDbR syncDb)
                    {
                    auto pipe1 = syncDb.Schemas().GetClass("TestSchema1", "Pipe1");
                    ASSERT_NE(pipe1, nullptr);
                    ASSERT_EQ(pipe1->GetPropertyCount(), 4);
                    ASSERT_STRCASEEQ(GetIndexDDL(syncDb, "idx_pipe1_p1").c_str(), "");
                    CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP);
                    ASSERT_TRUE(ForeignkeyCheck(syncDb));
                    }
            );
            }
    );

    Test(
        "pull changes from sync db into master db and check if schema changes was there and valid",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                schemaSyncDb.Pull(
                    *b1,
                    [&]()
                        {
                        auto pipe1 = b1->Schemas().GetClass("TestSchema1", "Pipe1");
                        ASSERT_NE(pipe1, nullptr);
                        ASSERT_EQ(pipe1->GetPropertyCount(), 4);

                        ASSERT_TRUE(b1->TableExists("ts_Pipe1"));
                        ASSERT_STRCASEEQ(GetIndexDDL(*b1, "idx_pipe1_p1").c_str(), "CREATE INDEX [idx_pipe1_p1] ON [ts_Pipe1]([p1], [p2])");

                        CheckHashes(*b1, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*b1));
                        }
                )
            ) << "Pull changes from schemaSyncDb into b1";
            }
    );

    Test("PullMergePush for b1", [&]() { ASSERT_EQ(BE_SQLITE_OK, b1->PullMergePush("b1 import schema")) << "b1->PullMergePush()"; });

    Test(
        "PullMergePush for b2",
        [&]()
            {
            ASSERT_EQ(BE_SQLITE_OK, b2->PullMergePush("b2 import schema")) << "b2->PullMergePush()";
            b2->SaveChanges();
            }
    );

    Test(
        "b3 pull changes from hub",
        [&]()
            {
            ASSERT_EQ(BE_SQLITE_OK, b3->PullMergePush("add new schema"))  << "b3->PullMergePush()";
            auto pipe1 = b3->Schemas().GetClass("TestSchema1", "Pipe1");
            ASSERT_NE(pipe1, nullptr);
            ASSERT_EQ(pipe1->GetPropertyCount(), 4);
            ASSERT_TRUE(b3->TableExists("ts_Pipe1"));
            ASSERT_STRCASEEQ(GetIndexDDL(*b3, "idx_pipe1_p1").c_str(), "CREATE INDEX [idx_pipe1_p1] ON [ts_Pipe1]([p1], [p2])");
            EXPECT_STREQ(SCHEMA2_HASH_ECDB_SCHEMA, GetSchemaHash(*b3).c_str());
            EXPECT_STREQ(SCHEMA2_HASH_ECDB_MAP, GetMapHash(*b3).c_str());
            EXPECT_STREQ(SCHEMA2_HASH_SQLITE_SCHEMA, GetDbSchemaHash(*b3).c_str());
            }
    );
    }

// ---------------------------------------------------------------------------------------
// @bsitest
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, PushSchemaWithoutInitializingSchemaChannel)
    {
    ECDbHub hub;
    SchemaSyncDb schemaSyncDb("sync-db");
    auto b1 = hub.CreateBriefcase();

    Utf8String schemaHash;
    Utf8String mapHash;
    Utf8String dbSchemaHash;
    schemaSyncDb.WithReadOnly([&](ECDbR syncDb) {
        schemaHash = GetSchemaHash(syncDb);
        mapHash = GetMapHash(syncDb);
        dbSchemaHash = GetDbSchemaHash(syncDb);
        });

    Test(
        "Create and import schema to schemaSyncDb without initializing schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, schemaSyncDb.GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            //use specific hash below, because schema sync db is not using a seed but creating the db with the latest profile.
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckHashes(syncDb, schemaHash.c_str(), mapHash.c_str(), dbSchemaHash.c_str()); });
            }
    );
    }

// ---------------------------------------------------------------------------------------
// @bsitest
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, InvalidSchemaChannel)
    {
    ECDbHub hub;
    auto b1 = hub.CreateBriefcase();

    Test(
        "Empty schemaSyncDb",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "57df4675ccbce3493d2bb882ad3bb28f3266425c2f22fd55e57e187808b3add3";
            const auto SCHEMA_HASH_ECDB_MAP = "8b1c6d8fa5b29e085bf94fae710527f56fa1c1792bd7404ff5775ed07f86f21f";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "8608aab5fa8a874b3f9140451ab8410c785483a878c8d915f48a26ef20e8241c";

            // Saves changes locally only
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) ""));
            CheckHashes(*b1, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA);
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            }
    );

    Test(
        "Semicolon schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) ";"));
            CheckHashes(*b1);
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            }
    );

    Test(
        "Space schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) " "));
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            }
    );

    Test(
        "Not a correct file extention schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) "Z:\\Test\\Location\\fake-file.exe"));
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            }
    );

    Test(
        "Not a filename schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) "fkj3lakjflakf90asfbnasghaklg3akglk4j;glkja;lkgj4;3lkgkanbkj4rtjak5;lkgjak4j3lktjalksdjg;lkj;lfj2qkj2qoipoa4tnb;"));
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            }
    );

    Test(
        "All illegal file characters",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) "# % & { } \\ < > * \? / $ ! \' \" : @ + ` | ="));
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            }
    );
    }
// ---------------------------------------------------------------------------------------
// @bsitest\
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Verify_SyncInfo_BeProp_Entries)
    {
    ECDbHub hub;
    auto b1 = hub.CreateBriefcase();
    auto b2 = hub.CreateBriefcase();
    SchemaSyncDb schemaSyncDb("sync-db");

    ASSERT_EQ(SchemaSync::Status::OK, b1->Schemas().GetSchemaSync().Init(schemaSyncDb.GetSyncDbUri(), "xxxxx", false));
    ASSERT_EQ(b1->Schemas().GetSchemaSync().GetModifiedRowCount(), 1397);
    b1->SaveChanges();
    b1->PullMergePush("init");


    // 1. SyncDb must only have syncDbInfo with id and dataVer properties.
    // 2. Briefcase must only have localDbInfo with id and dataVer properties.

    const auto kSyncId = "id";
    const auto kSyncDataVer = "dataVer";
    const auto kNamespace = "ec_Db";
    const auto kSyncDbInfo = "syncDbInfo";
    const auto kLocalDbInfo = "localDbInfo";
    const auto localDbInfoProp = PropertySpec(kLocalDbInfo, kNamespace);
    const auto syncDbInfoProp = PropertySpec(kSyncDbInfo, kNamespace);

    auto syncDb = schemaSyncDb.OpenReadOnly();

    Utf8String strData0;
    ASSERT_EQ(BE_SQLITE_ROW, syncDb->QueryProperty(strData0, syncDbInfoProp));

    BeJsDocument info0;
    info0.Parse(strData0);
    ASSERT_TRUE(info0.isStringMember(kSyncId));
    ASSERT_TRUE(info0.isStringMember(kSyncDataVer));
    ASSERT_STRCASEEQ(info0[kSyncDataVer].asCString(), "0x1");

    int nProp0 = 0;
    info0.ForEachProperty([&](Utf8CP name, BeJsConst){ ++nProp0 ; return false; });
    ASSERT_EQ(nProp0, 2);

    Utf8String strData1;
    ASSERT_EQ(BE_SQLITE_ERROR, syncDb->QueryProperty(strData1, localDbInfoProp));
    ASSERT_TRUE(strData1.empty());

    Utf8String strData2;
    ASSERT_EQ(BE_SQLITE_ERROR, b1->QueryProperty(strData2, syncDbInfoProp));
    ASSERT_TRUE(strData2.empty());

    Utf8String strData3;
    ASSERT_EQ(BE_SQLITE_ROW, b1->QueryProperty(strData3, localDbInfoProp));

    BeJsDocument info3;
    info3.Parse(strData3);
    ASSERT_TRUE(info3.isStringMember(kSyncId));
    ASSERT_TRUE(info3.isStringMember(kSyncDataVer));
    ASSERT_STRCASEEQ(info3[kSyncDataVer].asCString(), "0x1");

    int nProp3 = 0;
    info3.ForEachProperty([&](Utf8CP name, BeJsConst){ ++nProp3 ; return false; });
    ASSERT_EQ(nProp3, 2);

    auto schema = SchemaItem(
        R"xml(<?xml version="1.0" encoding="UTF-8"?>
        <ECSchema schemaName="TestSchema" alias="ts" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
            <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
            <ECEntityClass typeName="Pipe1">
                <ECCustomAttributes>
                    <ClassMap xmlns="ECDbMap.02.00.00">
                        <MapStrategy>TablePerHierarchy</MapStrategy>
                    </ClassMap>
                </ECCustomAttributes>
            </ECEntityClass>
        </ECSchema>)xml"
    );
    syncDb = nullptr;
    ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*b1, schema, SchemaManager::SchemaImportOptions::None, schemaSyncDb.GetSyncDbUri()));
    ASSERT_EQ(b1->Schemas().GetSchemaSync().GetModifiedRowCount(), 1405);
    b1->SaveChanges("schema import");
    b1->PullMergePush("push change");

    auto changesets = hub.Query();

    bool isSchemaSyncInfoChanged;
    bool isECDbProfileChanged;
    bool isECMetaDataChanged ;
    SchemaSync::ScanForSchemaChanges(*changesets.back(), isSchemaSyncInfoChanged, isECDbProfileChanged, isECMetaDataChanged);
    ASSERT_TRUE(isECMetaDataChanged);

    syncDb = schemaSyncDb.OpenReadOnly();
    ASSERT_EQ(BE_SQLITE_ROW, syncDb->QueryProperty(strData0, syncDbInfoProp));
    ASSERT_EQ(BE_SQLITE_ROW, b1->QueryProperty(strData3, localDbInfoProp));

    info0.Parse(strData0);
    ASSERT_TRUE(info0.isStringMember(kSyncId));
    ASSERT_TRUE(info0.isStringMember(kSyncDataVer));
    ASSERT_STRCASEEQ(info0[kSyncDataVer].asCString(), "0x2");
    ASSERT_STRCASEEQ(info0[kSyncId].asCString(), "xxxxx");

    info3.Parse(strData3);
    ASSERT_TRUE(info3.isStringMember(kSyncId));
    ASSERT_TRUE(info3.isStringMember(kSyncDataVer));
    ASSERT_STRCASEEQ(info3[kSyncDataVer].asCString(), "0x2");
    ASSERT_STRCASEEQ(info3[kSyncId].asCString(), "xxxxx");

    syncDb = nullptr;
    SchemaSyncDb schemaSyncDbNew("sync-db-new");
    ASSERT_EQ(SchemaSync::Status::ERROR_SCHEMA_SYNC_DB_ALREADY_INITIALIZED,
        b1->Schemas().GetSchemaSync().Init(schemaSyncDbNew.GetSyncDbUri(), "yyyyyy", false));

    ASSERT_EQ(SchemaSync::Status::OK, b1->Schemas().GetSchemaSync().Init(schemaSyncDbNew.GetSyncDbUri(), "yyyyyy", true));
    ASSERT_EQ(b1->Schemas().GetSchemaSync().GetModifiedRowCount(), 1411);

    syncDb = schemaSyncDbNew.OpenReadOnly();
    ASSERT_EQ(BE_SQLITE_ROW, syncDb->QueryProperty(strData0, syncDbInfoProp));
    ASSERT_EQ(BE_SQLITE_ROW, b1->QueryProperty(strData3, localDbInfoProp));

    info0.Parse(strData0);
    ASSERT_TRUE(info0.isStringMember(kSyncId));
    ASSERT_TRUE(info0.isStringMember(kSyncDataVer));
    ASSERT_STRCASEEQ(info0[kSyncDataVer].asCString(), "0x2");
    ASSERT_STRCASEEQ(info0[kSyncId].asCString(), "yyyyyy");

    info3.Parse(strData3);
    ASSERT_TRUE(info3.isStringMember(kSyncId));
    ASSERT_TRUE(info3.isStringMember(kSyncDataVer));
    ASSERT_STRCASEEQ(info3[kSyncDataVer].asCString(), "0x2");
    ASSERT_STRCASEEQ(info3[kSyncId].asCString(), "yyyyyy");

    b2->PullMergePush("");
    ASSERT_EQ(BE_SQLITE_ROW, b2->QueryProperty(strData3, localDbInfoProp));
    info3.Parse(strData3);
    ASSERT_TRUE(info3.isStringMember(kSyncId));
    ASSERT_TRUE(info3.isStringMember(kSyncDataVer));
    ASSERT_STRCASEEQ(info3[kSyncDataVer].asCString(), "0x2");
    ASSERT_STRCASEEQ(info3[kSyncId].asCString(), "xxxxx");

    b1->SaveChanges("schema import");
    b1->PullMergePush("push change");

    b2->PullMergePush("");
    ASSERT_EQ(BE_SQLITE_ROW, b2->QueryProperty(strData3, localDbInfoProp));
    info3.Parse(strData3);
    ASSERT_TRUE(info3.isStringMember(kSyncId));
    ASSERT_TRUE(info3.isStringMember(kSyncDataVer));
    ASSERT_STRCASEEQ(info3[kSyncDataVer].asCString(), "0x2");
    ASSERT_STRCASEEQ(info3[kSyncId].asCString(), "yyyyyy");
}

// ---------------------------------------------------------------------------------------
// @bsitest
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, InvalidSyncDbWithInitializedSchemaSync)
    {
    ECDbHub hub;
    auto b1 = hub.CreateBriefcase();
    SchemaSyncDb schemaSyncDb("sync-db");

    ASSERT_EQ(SchemaSync::Status::OK, b1->Schemas().GetSchemaSync().Init(schemaSyncDb.GetSyncDbUri(), "xxxxx", false));
    b1->PullMergePush("init");
    b1->SaveChanges();

    Test(
        "Initialized schema and empty schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) ""));
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            }
    );

    Test(
        "Initialized schema and semicolon schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) ";"));
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            }
    );

    Test(
        "Initialized schema and space schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) " "));
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            }
    );

    Test(
        "Initialized schema and not a correct file extention schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(
                SchemaImportResult::ERROR,
                ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, (SchemaSync::SyncDbUri) "Z:\\Test\\Location\\fake-file.exe")
            );
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            }
    );

    Test(
        "Initialized schema and not a filename schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(
                SchemaImportResult::ERROR,
                ImportSchema(
                    *b1,
                    SchemaItem(schemaXMLBuilder()),
                    SchemaManager::SchemaImportOptions::None,
                    (SchemaSync::SyncDbUri) "fkj3lakjflakf90asfbnasghaklg3akglk4j;glkja;lkgj4;3lkgkanbkj4rtjak5;lkgjak4j3lktjalksdjg;lkj;lfj2qkj2qoipoa4tnb;"
                )
            );
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            }
    );

    Test(
        "Initialized schema and all illegal file characters",
        [&]()
            {
            ASSERT_EQ(
                SchemaImportResult::ERROR,
                ImportSchema(
                    *b1,
                    SchemaItem(schemaXMLBuilder()),
                    SchemaManager::SchemaImportOptions::None,
                    (SchemaSync::SyncDbUri) "# % & { } \\ < > * \? / $ ! \' \" : @ + ` | ="
                )
            );
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            CheckHashes(*b1);
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            }
    );
    }

// ---------------------------------------------------------------------------------------
// @bsitest
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, PushSchemaToNewSchemaChannelWhenExistingSchemaChannelIsInitialized)
    {
    ECDbHub hub;
    SchemaSyncDb schemaSyncDb("sync-db");
    SchemaSync::SyncDbUri emptyUri;
    auto b1 = hub.CreateBriefcase();

    ASSERT_EQ(SchemaSync::Status::OK, b1->Schemas().GetSchemaSync().Init(schemaSyncDb.GetSyncDbUri(), "xxxx", false));
    b1->PullMergePush("init");
    b1->SaveChanges();

    Test(
        "Create and import schema with no schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b1, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, emptyUri));
            CheckHashes(*b1);
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            ASSERT_EQ(BE_SQLITE_OK, b1->AbandonChanges());
            }
    );
    }

// ---------------------------------------------------------------------------------------
// @bsitest
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, BriefcasePushesInvalidEmptyECSchema)
    {
    Test(
        "Create an invalid schema and try to import",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Pipe1">
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <DbIndexList xmlns="ECDbMap.02.00.00">
                                <Indexes>
                                    <DbIndex>
                                        <Name>idx_pipe1_p1</Name>
                                        <IsUnique>False</IsUnique>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, SetupECDb("sync-db", schema)) << "Import of invalid schema";
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            CheckHashes(*m_briefcase);
            }
    );
    }

// ---------------------------------------------------------------------------------------
// @bsitest
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, SecondBriefcasePushesSchema)
    {
    ECDbHub hub;
    SchemaSyncDb schemaSyncDb("sync-db");
    auto b1 = hub.CreateBriefcase();
    auto b2 = hub.CreateBriefcase();

    ASSERT_EQ(SchemaSync::Status::OK, b1->Schemas().GetSchemaSync().Init(schemaSyncDb.GetSyncDbUri(), "xxxx", false)) << "Initialize schemaSyncDb from b1";
    b1->PullMergePush("init");
    b1->SaveChanges();

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "57df4675ccbce3493d2bb882ad3bb28f3266425c2f22fd55e57e187808b3add3";
    const auto SCHEMA1_HASH_ECDB_MAP = "8b1c6d8fa5b29e085bf94fae710527f56fa1c1792bd7404ff5775ed07f86f21f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "8608aab5fa8a874b3f9140451ab8410c785483a878c8d915f48a26ef20e8241c";

    Test(
        "Import changes from b2 to schemaSyncDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*b2, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, schemaSyncDb.GetSyncDbUri()));
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb); });
            CheckHashes(*b1);
            CheckHashes(*b2);
            ASSERT_EQ(BE_SQLITE_OK, b2->AbandonChanges());
            }
    );

    Test(
        "b2->PullMergePush and then import changes",
        [&]()
            {
            b2->PullMergePush("second briefcase comes in");
            b2->SaveChanges();
            CheckHashes(*b2);

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*b2, SchemaItem(schemaXMLBuilder()), SchemaManager::SchemaImportOptions::None, schemaSyncDb.GetSyncDbUri()));
            schemaSyncDb.WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            CheckHashes(*b1);
            CheckHashes(*b2, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            }
    );

    Test(
        "Pull from schema Channel to b1",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                schemaSyncDb.Pull(
                    *b1,
                    [&]() { CheckHashes(*b1, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA); }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteSchema_VerifyCustomAttributesAreDeletedAsWell)
    {
    //This test simulate a case where there is orphan custom attribute instance and expect schema import to fail;
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "ff4e6e548d1566f81f33b2658c543424f2b04cef747c3bad34930f6c4ff7d29e";
    const auto SCHEMA1_HASH_ECDB_MAP = "187df5f660c246dbe2d3f2c8571b1cc1821a068bc1071d266a40bd9a570901c6";
    Test(
        "Setup ECDb",
        [&]()
            {
            auto testCa = SchemaItem(
                R"xml(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="TestCA" alias="tsca" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECCustomAttributeClass typeName="TestCA1" modifier="Sealed" appliesTo="Any"/>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schema_del", testCa));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "fd5b2c6c3aa4441c409469d6c0a61d580d0e09da594099c1d87bf8de6be81b15";
    const auto SCHEMA2_HASH_ECDB_MAP = "d925bbbadc91cccb226554a4b06e1d333aea21bcda00d10060818d19912e1b9b";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "6999f650adc04e6e20df544550cf9ebc590f4336c8283370934d5b96e8acd512";
    Test(
        "Import additional schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="TestCA" version="01.00.00" alias="tsca"/>
                    <ECCustomAttributes>
                        <TestCA1 xmlns="TestCA.01.00"/>
                    </ECCustomAttributes>
                    <ECEntityClass typeName="Pipe">
                        <ECCustomAttributes>
                            <TestCA1 xmlns="TestCA.01.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="p4" typeName="int">
                            <ECCustomAttributes>
                                <TestCA1 xmlns="TestCA.01.00"/>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    auto pipeClass = m_briefcase->Schemas().GetClass("TestSchema","Pipe");
    Test(
        "Check if classes exist",
        [&]()
            {
            auto testCA1Class = m_briefcase->Schemas().GetClass("TestCA","TestCA1");

            ASSERT_NE(nullptr, pipeClass);
            ASSERT_NE(nullptr, testCA1Class);
            }
    );

    Test(
        "Check if property exist",
        [&]()
            {
            auto p4Prop = pipeClass->GetPropertyP("p4");
            ASSERT_NE(nullptr, p4Prop);
            }
    );

    Test(
        "Drop TestSchema returns arbitrary schema changes",
        [&]()
            {
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_FALSE(DropSchema("TestSchema").IsSuccess());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteSchema_Check_Table_Drop)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "47358aeccfa438db0653fb12e16ffc3cb21716bd89313947e145edb2fa8e4049";
    const auto SCHEMA1_HASH_ECDB_MAP = "4b9b37d0d4e26e210bc2b82fbc50aaaccf31d8f9eab48d67a1fb8afbb5f6907b";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "a799d9fcacf6a62435de7f2596392c7699408bdaa9f909af4596d820d305ba10";
    Test(
        "Init bisCore",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="BisCore" alias="bis" version="01.00.12" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Element" modifier="Abstract">
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.2.0">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="p1" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract">
                        <BaseClass>Element</BaseClass>
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.2.0"/>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement3d" modifier="Abstract">
                        <BaseClass>GeometricElement</BaseClass>
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.2.0">
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName="p2" typeName="int" />
                        <ECProperty propertyName="p3" typeName="int" />
                        <ECProperty propertyName="p4" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schema_del", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "fc42180744d16fa46935591cda2c096fb2f9ab7e0c7230dcaec744e009e6e0a5";//
    const auto SCHEMA2_HASH_ECDB_MAP = "0f8225485fb52c416774152d2e56d502a93835f53d5b804421f87f4d3e61bf54";//
    Test(
        "span join table",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="BisCore" version="01.00.12" alias="bis"/>
                    <ECEntityClass typeName="Pipe">
                        <BaseClass>bis:GeometricElement3d</BaseClass>
                        <ECProperty propertyName="p2" typeName="int" />
                        <ECProperty propertyName="p3" typeName="int" />
                        <ECProperty propertyName="p4" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "d4c7a15cde6dfd5e60b57e0ae386b2169e33f5570f47fe477c8050919fef1f38";
    const auto SCHEMA3_HASH_ECDB_MAP = "463751fe6f014849006724c9cac4bb280ed680df9cee7a104090830157fc65d2";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "3f8ad1c7d151794e8d267f22f8ff63acbb10625fed9ef122130e5c2191add5c9";
    Test(
        "span overflow table",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="TestSchema1" alias="ts1" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="BisCore" version="01.00.12" alias="bis"/>
                    <ECEntityClass typeName="Pipe1">
                        <BaseClass>bis:GeometricElement3d</BaseClass>
                        <ECProperty propertyName="p2" typeName="int" />
                        <ECProperty propertyName="p3" typeName="int" />
                        <ECProperty propertyName="p4" typeName="int" />
                        <ECProperty propertyName="p5" typeName="int" />
                        <ECProperty propertyName="p6" typeName="int" />
                        <ECProperty propertyName="p7" typeName="int" />
                        <ECProperty propertyName="p8" typeName="int" />
                        <ECProperty propertyName="p9" typeName="int" />
                        <ECProperty propertyName="pa" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check tables",
        [&]()
            {
            ASSERT_TRUE(m_briefcase->TableExists("bis_Element"));
            ASSERT_TRUE(m_briefcase->TableExists("bis_GeometricElement3d"));
            ASSERT_TRUE(m_briefcase->TableExists("bis_GeometricElement3d_Overflow"));
            }
    );

    const auto SCHEMA4_HASH_ECDB_MAP = "5fab223124703ec61be047e2e4154f8bdac711a162e12c8a1b2d8737132b0857";
    Test(
        "Drop TestSchema1",
        [&]()
            {
            ASSERT_TRUE(DropSchema("TestSchema1").IsSuccess());
            ASSERT_TRUE(m_briefcase->TableExists("bis_Element")) << "bis_Element table should not be dropped";
            ASSERT_TRUE(m_briefcase->TableExists("bis_GeometricElement3d")) << "bis_GeometricElement3d table should not be dropped";
            ASSERT_TRUE(m_briefcase->TableExists("bis_GeometricElement3d_Overflow")) << "bis_GeometricElement3d_Overflow table should not be dropped";
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA4_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            }
    );

    const auto SCHEMA5_HASH_ECDB_MAP = "bde4d99746cf01acdd04e69c2b39133e92a2ed53858f787450fa7ecdd7cf1675";
    Test(
        "Drop TestSchema",
        [&]()
            {
            ASSERT_TRUE(DropSchema("TestSchema").IsSuccess());
            ASSERT_TRUE(m_briefcase->TableExists("bis_Element")) << "bis_Element table should not be dropped";
            ASSERT_TRUE(m_briefcase->TableExists("bis_GeometricElement3d")) << "bis_GeometricElement3d table should not be dropped";
            ASSERT_TRUE(m_briefcase->TableExists("bis_GeometricElement3d_Overflow")) << "bis_GeometricElement3d_Overflow table should not be dropped";
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA5_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            }
    );

    Test(
        "Drop BisCore returns arbitrary schema changes",
        [&]()
            {
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_FALSE(DropSchema("BisCore").IsSuccess());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA5_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            }
    );

    // TODO: push to shared channel
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteSchema)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "ea4c2210c4f6f02bf3063126c8fde7a9244a58d4b9b2e4297891a3ee689e9851";
    const auto SCHEMA1_HASH_ECDB_MAP = "33c1134c50fde34896259ee41d842d71b26591cd6f5061cfb91241e1a324e493";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "69d6d5fdf9b5f7d93634514f6e40357fea3cf41f82dbb301e3567ed0facd519a";
    Test(
        "Setup delete schemaDb",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='PA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'/>
                            <DbIndexList xmlns='ECDbMap.02.00'>
                                <Indexes>
                                    <DbIndex>
                                        <Name>IDX_Partial</Name>
                                        <IsUnique>False</IsUnique>
                                        <Properties>
                                            <string>AFk.Id</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                        <ECProperty propertyName='PB' typeName='int' />
                        <ECNavigationProperty propertyName='AFk' relationshipName='AHasB' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='AHasB' strength='Embedding'>
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class ='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class ='B' />
                        </Target>
                    </ECRelationshipClass>
                    <ECRelationshipClass typeName='ARefB'  modifier='Sealed' strength='referencing' strengthDirection='forward'>
                        <ECCustomAttributes>
                            <LinkTableRelationshipMap xmlns='ECDbMap.2.0'>
                                <CreateForeignKeyConstraints>False</CreateForeignKeyConstraints>
                            </LinkTableRelationshipMap>
                        </ECCustomAttributes>
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class ='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class ='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schema_del", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "a6890ae18a24d53cce29ce3e998b357b4e9244b34460fab3d6f44f715e8d4a0c";
    const auto SCHEMA2_HASH_ECDB_MAP = "cf097419aece66e31041acb2e3569a6903cf7d660b3277fc2df058da5dc298d3";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "02076e3d9a50766f055920f9c9f629ea553c778e816c4c5d09121aed0e7e2140";
    Test(
        "Import a schema change",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema1' nameSpacePrefix='ts1' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'TestSchema' version='01.00' prefix = 'ts' />
                    <ECEntityClass typeName='C'>
                        <BaseClass>ts:A</BaseClass>
                        <ECProperty propertyName='PC' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='D' modifier='Sealed'>
                        <BaseClass>ts:B</BaseClass>
                        <ECProperty propertyName='PD' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    ECInstanceKey a0;
    Test(
        "insert instance of A",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.A(PA) VALUES(100)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(a0));
            }
    );

    ECInstanceKey b0;
    Test(
        "insert instance of B",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.B(PB, AFk) VALUES(200, ?)"));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindNavigationValue(1, a0.GetInstanceId()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(b0));
            }
    );

    ECInstanceKey c0;
    Test(
        "insert instance of C",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts1.C(PA, PC) VALUES(100, 200)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(c0));
            }
    );

    ECInstanceKey d0;
    Test(
        "insert instance of D",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts1.D(PB, PD, AFk) VALUES(200, 300, ?)"));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindNavigationValue(1, c0.GetInstanceId()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(d0));
            }
    );

    ECInstanceKey d1;
    Test(
        "insert second instance of D",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts1.D(PB, PD, AFk) VALUES(300, 400, ?)"));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindNavigationValue(1, a0.GetInstanceId()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(d1));
            }
    );

    ECInstanceKey aRefB0;
    Test(
        "insert instance of ARefB",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.ARefB(SourceECInstanceId, SourceECClassId, TargetECInstanceId, TargetECClassId) VALUES (?,?,?,?)"));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(1, a0.GetInstanceId()));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(2, a0.GetClassId()));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(3, b0.GetInstanceId()));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(4, b0.GetClassId()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(aRefB0));
            }
    );

    ECInstanceKey aRefB1;
    Test(
        "insert second instance of ARefB",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.ARefB(SourceECInstanceId, SourceECClassId, TargetECInstanceId, TargetECClassId) VALUES (?,?,?,?)"));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(1, c0.GetInstanceId()));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(2, c0.GetClassId()));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(3, d0.GetInstanceId()));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(4, d0.GetClassId()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(aRefB1));
            }
    );

    ECInstanceKey aRefB2;
    Test(
        "insert third instance of ARefB",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.ARefB(SourceECInstanceId, SourceECClassId, TargetECInstanceId, TargetECClassId) VALUES (?,?,?,?)"));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(1, a0.GetInstanceId()));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(2, a0.GetClassId()));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(3, d0.GetInstanceId()));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(4, d0.GetClassId()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(aRefB2));
            }
    );

    Test(
        "Save all instance changes",
        [&]()
            {
            m_briefcase->SaveChanges();
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );

    Test(
        "Try to delete TestSchema",
        [&]()
            {
            auto rc = DropSchema("TestSchema");
            ASSERT_FALSE(rc.IsSuccess());
            ASSERT_TRUE(rc.HasDependendSchemas());
            }
    );

    std::unique_ptr<DropSchemaResult> rc1;
    Test(
        "Try to delete TestSchema1",
        [&]()
            {
            rc1 = std::make_unique<DropSchemaResult>(DropSchema("TestSchema1"));
            ASSERT_FALSE(rc1->IsSuccess());
            ASSERT_TRUE(rc1->HasInstances());
            }
    );

    const auto SCHEMA3_HASH_ECDB_MAP = "58bf6103669910b463f4c230d7eb61d3d9fe996de7fc9b151a81e83e618f888e";
    Test(
        "Delete instances from TestSchema1 and then delete TestSchema1",
        [&]()
            {
            for(auto& kp : rc1->GetInstances().GetEntityKeyMap())
                {
                auto baseClassId = kp.first;
                std::shared_ptr<IdSet<BeInt64Id>> idToDelete = std::make_shared<IdSet<BeInt64Id>>();
                for (auto key: kp.second)
                    idToDelete->insert(key.GetInstanceId());

                Utf8String className = m_briefcase->Schemas().GetClass(baseClassId)->GetFullName();
                ECSqlStatement stmt;
                ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("DELETE FROM %s WHERE InVirtualSet(?, ECInstanceId)", className.c_str())));
                ASSERT_EQ(ECSqlStatus::Success, stmt.BindVirtualSet(1, idToDelete));
                ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
                ASSERT_EQ(m_briefcase->GetModifiedRowCount(), idToDelete->size());
                }

            ASSERT_TRUE(DropSchema("TestSchema1").IsSuccess());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );

    std::unique_ptr<DropSchemaResult> rc0;
    Test(
        "Try to delete TestSchema again, should give different error",
        [&]()
            {
            rc0 = std::make_unique<DropSchemaResult>(DropSchema("TestSchema"));
            ASSERT_FALSE(rc0->IsSuccess());
            ASSERT_TRUE(rc0->HasInstances());
            }
    );

    Test(
        "Delete detected instances from TestSchema",
        [&]()
            {
            for(auto& kp : rc0->GetInstances().GetEntityKeyMap())
                {
                auto baseClassId = kp.first;
                std::shared_ptr<IdSet<BeInt64Id>> idToDelete = std::make_shared<IdSet<BeInt64Id>>();
                for (auto key: kp.second)
                    idToDelete->insert(key.GetInstanceId());

                Utf8String className = m_briefcase->Schemas().GetClass(baseClassId)->GetFullName();
                ECSqlStatement stmt;
                ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("DELETE FROM %s WHERE InVirtualSet(?, ECInstanceId)", className.c_str())));
                ASSERT_EQ(ECSqlStatus::Success, stmt.BindVirtualSet(1, idToDelete));
                ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
                ASSERT_EQ(m_briefcase->GetModifiedRowCount(), idToDelete->size());
                ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                }
            }
    );

    Test(
        "Delete TestSchema returns arbitrary schema changes",
        [&]()
            {
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_FALSE(DropSchema("TestSchema").IsSuccess());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );
    // TODO: push to shared channel
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateECSchemaAttributes)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "700742be350b58268aeb3fd138322ffade0ee2d45b632cf9e086446c49c005ec";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UpdateECSchemaAttributes", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "4c664dc4c288e9396a965c3a3abff1946a129582e58d812504bbcf4a269aab6d";
    Test(
        "Modifying display label and description is expected to be supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='New Test Schema' description='This is a New Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "After modifying display label and description",
        [&]()
            {
            auto expected = JsonValue(R"json([{"DisplayLabel":"New Test Schema", "Description":"This is a New Test Schema", "Alias":"ts"}])json");
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT DisplayLabel, Description, Alias FROM meta.ECSchemaDef WHERE Name='TestSchema'"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            }
    );

    Test(
        "Modifying alias is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts2' displayLabel='New Test Schema' description='This is a New Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifySchemaVersion)
    {
    auto schemaXml = [&](Utf8CP newSchemaVersion = "10.10.10")
        {
        Utf8CP schemaTemplate =
            R"xml(<?xml version='1.0' encoding='utf-8'?>
            <ECSchema schemaName='TestSchema1' alias='ts1' version='%s' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                <ECEntityClass typeName='TestClassA' >
                    <ECProperty propertyName='L1' typeName='double'/>
                </ECEntityClass>
            </ECSchema>)xml";
        Utf8String schemaXml;
        schemaXml.Sprintf(schemaTemplate, newSchemaVersion);
        return schemaXml;
        };
    auto assertVersion = [&](ECSchemaCP schemaPointer, uint32_t readVersion, uint32_t writeVersion, uint32_t minorVersion)
        {
        ASSERT_EQ(readVersion, schemaPointer->GetVersionRead());
        ASSERT_EQ(writeVersion, schemaPointer->GetVersionWrite());
        ASSERT_EQ(minorVersion, schemaPointer->GetVersionMinor());
        };

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "383c0adf0ddf6bfe396c6caf6e8020defe446640a2bf1fedd3ef174a0ca7301b";
    const auto SCHEMA1_HASH_ECDB_MAP = "a3a4f4bd3e7c375e583bb9d5dde2d4ee593dab571dd1ab2bae88d5c531753137";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "2821726bf97bd871e7e7ca78101175541782ba81be1b692eee2a68547f403a48";
    Test(
        "Init ECDb",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("SchemaUpgrade_ModifySchemaVersion", SchemaItem(schemaXml("10.10.10"))));
            assertVersion(m_briefcase->Schemas().GetSchema("TestSchema1"), 10, 10, 10);
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Decreasing minor version when write version was incremented is supported",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "f413afe76940f366025b12179084a67d883a6ab292ca54158575548e67bedc07";
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(SchemaItem(schemaXml("10.11.9"))));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            assertVersion(m_briefcase->Schemas().GetSchema("TestSchema1"), 10, 11, 9);
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Decreasing write version when read version was incremented is supported",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "490264cc2f8bb3a1252cbf9a6878eae6611c45bd7f92e41b37b73fe780ec8a0b";
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(SchemaItem(schemaXml("11.10.9"))));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            assertVersion(m_briefcase->Schemas().GetSchema("TestSchema1"), 11, 10, 9);
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Decreasing minor version when read version was incremented is supported",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "2aee1c0a40c8a3f26fc11de65144dca1cf74935ceec64ff96026cce85769388f";
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(SchemaItem(schemaXml("12.10.8"))));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            assertVersion(m_briefcase->Schemas().GetSchema("TestSchema1"), 12, 10, 8);
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "fd8871094a4cdffcc543aa3193d154a3ce771adddff752657460ca40511a92cc";
    Test(
        "Decreasing minor and write version when read version was incremented is supported",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(SchemaItem(schemaXml("13.1.7"))));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            assertVersion(m_briefcase->Schemas().GetSchema("TestSchema1"), 13, 1, 7);
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Decreasing read version is not supported",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem(schemaXml("12.1.7"))));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            assertVersion(m_briefcase->Schemas().GetSchema("TestSchema1"), 13, 1, 7);
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Decreasing write version is not supported",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem(schemaXml("13.0.7"))));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            assertVersion(m_briefcase->Schemas().GetSchema("TestSchema1"), 13, 1, 7);
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Decreasing minor version is supported but skipped",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(SchemaItem(schemaXml("13.1.6"))));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            assertVersion(m_briefcase->Schemas().GetSchema("TestSchema1"), 13, 1, 7);
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, SchemaDowngrade_MoreComplex)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "90d7d4b0e6fa42bbca30909358a5f4453e5fbf23dc04180586b7e708c8046eab";
    const auto SCHEMA1_HASH_ECDB_MAP = "aad4ba89e506aa58452c801120bf1e662ad761a14332932283eab33113e7d419";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "616136b709172fd8b18c5d9213f3c87b5c3d05a852787260324b52e009c45ae4";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="2.4.3" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("SchemaDowngrade", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Import schema with smaller read version",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.9.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="Sub2Prop" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Import schema with smaller write version",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="2.2.78" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Import schema with smaller minor version",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="2.4.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check schema atributes",
        [&]()
            {
            ASSERT_TRUE(m_briefcase->Schemas().GetClass("TestSchema", "Sub") != nullptr) << "Class Sub is still expected to exist as schema minor version downgrade is skipped.";
            ECClassCP parentClass = m_briefcase->Schemas().GetClass("TestSchema", "Parent");
            ASSERT_TRUE(parentClass != nullptr);
            ASSERT_TRUE(parentClass->GetPropertyP("Val") != nullptr) << "Property Val in class Parent is still expected to exist as schema minor version downgrade is skipped.";
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ECVersions)
    {
    auto verifySchemaVersion = [] (ECDbCR ecdb, Utf8CP schemaName, uint32_t expectedOriginalXmlVersionMajor, uint32_t expectedOriginalXmlVersionMinor)
        {
        ECSqlStatement stmt;
        ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(ecdb, "SELECT OriginalECXmlVersionMajor, OriginalECXmlVersionMinor FROM meta.ECSchemaDef WHERE Name=?"));
        stmt.BindText(1, schemaName, IECSqlBinder::MakeCopy::No);
        ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
        ASSERT_EQ(expectedOriginalXmlVersionMajor, (uint32_t) stmt.GetValueInt(0));
        ASSERT_EQ(expectedOriginalXmlVersionMinor, (uint32_t) stmt.GetValueInt(1));
        };


    const auto SCHEMA1_HASH_ECDB_SCHEMA = "48f524bc0ff9862b036f277eddb9e089d2cd150795e16b39c83905b63a2468f5";
    Test(
        "Import initial schema",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("SchemaOriginalECXmlVersion", SchemaItem(
                "<?xml version='1.0' encoding='utf-8'?>"
                    "<ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>"
                "</ECSchema>")));
            verifySchemaVersion(*m_briefcase, "TestSchema", 3, 0);
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Upgrade of ECXml version to 3.1",
        [&]()
            {
            ReopenECDb();
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(SchemaItem(
                "<?xml version='1.0' encoding='utf-8'?>"
                    "<ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>"
                "</ECSchema>")));
            verifySchemaVersion(*m_briefcase, "TestSchema", 3, 1);
            // CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            // m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Upgrade of ECXml version to 3.2",
        [&]()
            {
            ReopenECDb();
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(SchemaItem(
                "<?xml version='1.0' encoding='utf-8'?>"
                    "<ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>"
                "</ECSchema>")));
            verifySchemaVersion(*m_briefcase, "TestSchema", 3, 2);
            // CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA);
            // m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Downgrade of ECXml version is not supported",
        [&]()
            {
            ReopenECDb();
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem(
                "<?xml version='1.0' encoding='utf-8'?>"
                    "<ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>"
                "</ECSchema>")));
            verifySchemaVersion(*m_briefcase, "TestSchema", 3, 2);
            // CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA);
            // m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateECClassAttributes)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "9b5ea082cc9f973856cc6f017e5ba8f01c02fc5c9ed4763cf1f04c6570c26d8e";
    const auto SCHEMA1_HASH_ECDB_MAP = "32608ea390282589dafbb36721fb70a9336a359434d056ab67dd245415c0f814";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "533fbcc8fc6a9a9efdb25aff7db7bdb91856955e6b8c236b3f5218b64361d533";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='Test Class' modifier='None' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UpdateECClassAttributes", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "660cefcd3dbf7e7dfac63f22bbacd5ecbb286efe731398fb18c9ece613d8c70d";
    Test(
        "Modifying ECClass display label and description is expected to be supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='New Test Schema' description='This is a New Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEntityClass typeName='TestClass' displayLabel='My Test Class' description='My Test Class' modifier='None' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "After modifying display label and description",
        [&]()
            {
            auto expected = JsonValue(R"json([{"DisplayLabel":"My Test Class", "Description":"My Test Class"}])json");
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECClassDef WHERE Name='TestClass'"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddingUpdatingAndDeletingMinMax)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "c7ec8926fc236afc54f73bebac83f04c5dbbf7954bbaf5cf584e5424131063d4";
    const auto SCHEMA1_HASH_ECDB_MAP = "d1740d0775bf9c18eeff71fda2a0147774d84b95425b45e940ab1f102c26bdc2";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "011907794910d5af09f0c44b54319b9b10f7bfa329fbe3323873b780d6ab575e";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEntityClass typeName='Foo'>
                        <ECProperty propertyName='P1' typeName='long'   minimumValue  = '1'     maximumValue   = '200'    />
                        <ECProperty propertyName='P2' typeName='double' minimumValue  = '1.22'  maximumValue   = '100.22' />
                        <ECProperty propertyName='P3' typeName='string' minimumLength = '1'     maximumLength  = '1000'   />
                        <ECProperty propertyName='P4' typeName='long'   maximumValue  = '1200'                            />
                        <ECProperty propertyName='P5' typeName='double' maximumValue  = '1200.12'                         />
                        <ECProperty propertyName='P6' typeName='string' maximumLength = '1000'                            />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schema_update_minMax", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check min max values of the imported schema",
        [&]()
            {
            ECClassCP foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(nullptr, foo);

            ECValue minV, maxV;
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P1")->GetMinimumValue(minV));
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P1")->GetMaximumValue(maxV));
            ASSERT_EQ(1, minV.GetLong());
            ASSERT_EQ(200, maxV.GetLong());

            minV = maxV = ECValue();
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P2")->GetMinimumValue(minV));
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P2")->GetMaximumValue(maxV));
            ASSERT_EQ(1.22, minV.GetDouble());
            ASSERT_EQ(100.22, maxV.GetDouble());

            ASSERT_EQ(1, foo->GetPropertyP("P3")->GetMinimumLength());
            ASSERT_EQ(1000, foo->GetPropertyP("P3")->GetMaximumLength());

            minV = maxV = ECValue();
            ASSERT_EQ(ECObjectsStatus::Error, foo->GetPropertyP("P4")->GetMinimumValue(minV));
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P4")->GetMaximumValue(maxV));
            ASSERT_TRUE(minV.IsNull());
            ASSERT_EQ(1200, maxV.GetLong());

            minV = maxV = ECValue();
            ASSERT_EQ(ECObjectsStatus::Error, foo->GetPropertyP("P5")->GetMinimumValue(minV));
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P5")->GetMaximumValue(maxV));
            ASSERT_TRUE(minV.IsNull());
            ASSERT_EQ(1200.12, maxV.GetDouble());

            ASSERT_EQ(0, foo->GetPropertyP("P6")->GetMinimumLength());
            ASSERT_EQ(1000, foo->GetPropertyP("P6")->GetMaximumLength());
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "e0d3f984c96d9e974948b12ce77c729566769f5e9f462966871ea6a3b30eeee4";
    Test(
        "Import edited schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEntityClass typeName='Foo'>
                        <ECProperty propertyName='P1' typeName='long'   />
                        <ECProperty propertyName='P2' typeName='double' />
                        <ECProperty propertyName='P3' typeName='string' />
                        <ECProperty propertyName='P4' typeName='long'   minimumValue  = '12'   maximumValue   = '2200'    />
                        <ECProperty propertyName='P5' typeName='double' minimumValue  = '1.33' maximumValue   = '2200.12' />
                        <ECProperty propertyName='P6' typeName='string' minimumLength = '11'   maximumLength  = '9000'    />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check min max values of the edited schema",
        [&]()
            {
            ECClassCP foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(nullptr, foo);

            ECValue minV, maxV;
            ASSERT_EQ(ECObjectsStatus::Error, foo->GetPropertyP("P1")->GetMinimumValue(minV));
            ASSERT_EQ(ECObjectsStatus::Error, foo->GetPropertyP("P1")->GetMaximumValue(maxV));
            ASSERT_TRUE(minV.IsNull());
            ASSERT_TRUE(maxV.IsNull());

            minV = maxV = ECValue();
            ASSERT_EQ(ECObjectsStatus::Error, foo->GetPropertyP("P2")->GetMinimumValue(minV));
            ASSERT_EQ(ECObjectsStatus::Error, foo->GetPropertyP("P2")->GetMaximumValue(maxV));
            ASSERT_TRUE(minV.IsNull());
            ASSERT_TRUE(maxV.IsNull());

            ASSERT_EQ(0, foo->GetPropertyP("P3")->GetMinimumLength());
            ASSERT_EQ(0, foo->GetPropertyP("P3")->GetMaximumLength());

            minV = maxV = ECValue();
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P4")->GetMinimumValue(minV));
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P4")->GetMaximumValue(maxV));
            ASSERT_EQ(12, minV.GetLong());
            ASSERT_EQ(2200, maxV.GetLong());

            minV = maxV = ECValue();
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P5")->GetMinimumValue(minV));
            ASSERT_EQ(ECObjectsStatus::Success, foo->GetPropertyP("P5")->GetMaximumValue(maxV));
            ASSERT_EQ(1.33, minV.GetDouble());
            ASSERT_EQ(2200.12, maxV.GetDouble());

            ASSERT_EQ(11, foo->GetPropertyP("P6")->GetMinimumLength());
            ASSERT_EQ(9000, foo->GetPropertyP("P6")->GetMaximumLength());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddingUpdatingAndDeletingPriority)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "a52fd4e987f48355050617030d7e95942d3aaadfc651e51af142c3992a672b4b";
    const auto SCHEMA1_HASH_ECDB_MAP = "eab09cbcdaa4b10e915d33e1c4cb6d389fd0b9ed39a0aa2e5c24357cbbf263eb";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "5fd180ad4deca14bc3188321140c63a077f54c2e61a22facbb4d9bb4d29341aa";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                   <ECEntityClass typeName='Foo'>
                       <ECProperty propertyName='P1' typeName='string' priority='1010' />
                       <ECProperty propertyName='P2' typeName='string' priority='1020' />
                       <ECProperty propertyName='P3' typeName='string' priority='1030' />
                       <ECProperty propertyName='P4' typeName='string' />
                       <ECProperty propertyName='P5' typeName='string' />
                   </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schema_update_priority", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check property priorities of initial schema",
        [&]()
            {
            ECClassCP foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(nullptr, foo);
            ASSERT_EQ(1010, foo->GetPropertyP("P1")->GetPriority());
            ASSERT_EQ(1020, foo->GetPropertyP("P2")->GetPriority());
            ASSERT_EQ(1030, foo->GetPropertyP("P3")->GetPriority());
            ASSERT_EQ(0, foo->GetPropertyP("P4")->GetPriority());
            ASSERT_EQ(0, foo->GetPropertyP("P5")->GetPriority());
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "6eafc69781e919129c81eda84603e0034bb37ff03f3655447864bb841fb5d6c2";
    Test(
        "Import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                   <ECEntityClass typeName='Foo'>
                       <ECProperty propertyName='P1' typeName='string' priority='2010' />
                       <ECProperty propertyName='P2' typeName='string' priority='2020' />
                       <ECProperty propertyName='P3' typeName='string'                 />
                       <ECProperty propertyName='P4' typeName='string' priority='1040' />
                       <ECProperty propertyName='P5' typeName='string' priority='1050' />
                   </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check property priorities of edited schema",
        [&]()
            {
            ECClassCP foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(nullptr, foo);
            ASSERT_EQ(2010, foo->GetPropertyP("P1")->GetPriority());
            ASSERT_EQ(2020, foo->GetPropertyP("P2")->GetPriority());
            ASSERT_EQ(0, foo->GetPropertyP("P3")->GetPriority());
            ASSERT_EQ(1040, foo->GetPropertyP("P4")->GetPriority());
            ASSERT_EQ(1050, foo->GetPropertyP("P5")->GetPriority());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_Update_Mixin_AppliesToEntityClass_Generalized)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "81320154f7b3eb5b59c806681d1062d3a096f10e87944e980bed6babf133a418";
    const auto SCHEMA1_HASH_ECDB_MAP = "f2bf4b1c37302fe3ec09e892c2547eb3ad9fb4879eba48e5d8b89ae9097d728f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "82488d5828102fb18314b74fe31a1e20f8bc3087cc83475974ecf0980abcfed5";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>"
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>"
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>"
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>"
                        <ECCustomAttributes>"
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>"
                                <AppliesToEntityClass>SubElement</AppliesToEntityClass>"
                            </IsMixin>"
                        </ECCustomAttributes>"
                    </ECEntityClass>"
                    <ECEntityClass typeName='Element'>"
                        <ECProperty propertyName='Code' typeName='string' />"
                    </ECEntityClass>"
                    <ECEntityClass typeName='SubElement'>"
                        <BaseClass>Element</BaseClass>"
                        <ECProperty propertyName='Text' typeName='string' />"
                    </ECEntityClass>"
                    <ECEntityClass typeName='SupportOption' modifier='None' >"
                        <BaseClass>SubElement</BaseClass>"
                        <BaseClass>IOptionA</BaseClass>"
                        <ECProperty propertyName='P1' typeName='string' />"
                    </ECEntityClass>"
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("appliesToEntityClass", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check value of AppliesToEntityClass of initial schema",
        [&]()
            {
            auto mixIn = m_briefcase->Schemas().GetClass("TestSchema", "IOptionA");
            auto ca = mixIn->GetCustomAttributeLocal("CoreCustomAttributes", "IsMixin");
            ECValue appliesToValue;
            ca->GetValue(appliesToValue, "AppliesToEntityClass");
            ASSERT_FALSE(appliesToValue.IsNull() || !appliesToValue.IsString());
            ASSERT_STRCASEEQ(appliesToValue.GetUtf8CP(), "SubElement");
            }
    );

    Test(
        "Import edited schema with some changes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "6ad6345a02348b9b4bbca7e8eefd6aaccf86b9fa8b7e0788561def84fdbe8af6";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SubElement'>
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='Text' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>SubElement</BaseClass>
                        <BaseClass>IOptionA</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check value of AppliesToEntityClass of edited schema",
        [&]()
            {
            auto mixIn = m_briefcase->Schemas().GetClass("TestSchema", "IOptionA");
            auto ca = mixIn->GetCustomAttributeLocal("CoreCustomAttributes", "IsMixin");
            ECValue appliesToValue;
            ca->GetValue(appliesToValue, "AppliesToEntityClass");
            ASSERT_FALSE(appliesToValue.IsNull() || !appliesToValue.IsString());
            ASSERT_STRCASEEQ(appliesToValue.GetUtf8CP(), "Element");
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_Update_Mixin_AppliesToEntityClass_Specialized)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "81320154f7b3eb5b59c806681d1062d3a096f10e87944e980bed6babf133a418";
    const auto SCHEMA1_HASH_ECDB_MAP = "f2bf4b1c37302fe3ec09e892c2547eb3ad9fb4879eba48e5d8b89ae9097d728f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "82488d5828102fb18314b74fe31a1e20f8bc3087cc83475974ecf0980abcfed5";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>SubElement</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SubElement'>
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='Text' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>SubElement</BaseClass>
                        <BaseClass>IOptionA</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("appliesToEntityClass_props", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check value of initial schema",
        [&]()
            {
            auto mixIn = m_briefcase->Schemas().GetClass("TestSchema", "IOptionA");
            auto ca = mixIn->GetCustomAttributeLocal("CoreCustomAttributes", "IsMixin");
            ECValue appliesToValue;
            ca->GetValue(appliesToValue, "AppliesToEntityClass");
            ASSERT_FALSE(appliesToValue.IsNull() || !appliesToValue.IsString());
            ASSERT_STRCASEEQ(appliesToValue.GetUtf8CP(), "SubElement");
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>SupportOption</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SubElement'>
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='Text' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>SubElement</BaseClass>
                        <BaseClass>IOptionA</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            // ERROR ECDb - ECSchema Upgrade failed. MixIn TestSchema:IOptionA: Modifing 'AppliesToEntityClass' from TestSchema:SubElement to TestSchema:SupportOption is only
            // supported TestSchema:SubElement derived from TestSchema:SupportOption.ERROR ECDb - ECSchema Upgrade failed. MixIn TestSchema:IOptionA: Modifing 'AppliesToEntityClass'
            // from TestSchema:SubElement to TestSchema:SupportOption is only supported TestSchema:SubElement derived from TestSchema:SupportOption.
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_UpdateEmptyMixinBaseClass) //TFS#917566
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "5c08db0df328833f8f0c6d78bf9fc158f2d6070505cba41c94678787fefe883b";
    const auto SCHEMA1_HASH_ECDB_MAP = "0f051fda13a804dd21c322a60eac58c11e8eed22fe708473e0f67e1a0fe72dd3";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b78e32379a70eae0f45eedbf149e17397796681525ae2aaa61602ea48ee60e60";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IOptionA</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of initial schema",
        [&]()
            {
            ECClassCP supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(1)->GetFullName(), "TestSchema:IOptionA");
            ASSERT_EQ(2, supportOption->GetBaseClasses().size());
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "759d70b1d3c691b8302d592f45a832f6e5db6a7022973f25da243866ce1b9e53";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IOptionB</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of edited schema",
        [&]()
            {
            ECClassCP supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(1)->GetFullName(), "TestSchema:IOptionB");
            ASSERT_EQ(2, supportOption->GetBaseClasses().size());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_UpdateEmptyMixinBaseClassWithNoneEmptyBaseClass) //TFS#917566
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "7ad20eacf7056b74415b761025f995bea76bd02f2d17f832da69180a19580819";
    const auto SCHEMA1_HASH_ECDB_MAP = "a8edf6c2bcf15cf34f9d9d5ca682f8c5b91e5a7c1d5ed2f43b766a46874c048a";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b78e32379a70eae0f45eedbf149e17397796681525ae2aaa61602ea48ee60e60";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IOptionA</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of initial schema",
        [&]()
            {
            ECClassCP supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(1)->GetFullName(), "TestSchema:IOptionA");
            ASSERT_EQ(2, supportOption->GetBaseClasses().size());
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "ae101d24c863665396cb8c18fd3fd133a2f8c4e476097c373544f4b85a15ad23";
    const auto SCHEMA2_HASH_ECDB_MAP = "ceeeb3903bb98b53a41d7d645e4458e500548906acf45e9703a29f1ee5becf2d";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "d26da3680fbcd83f8503e623223ef61a3158b896b8b951ff49f8e14433392d29";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IOptionB</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify we can insert and select",
        [&]()
            {
            auto expected = JsonValue(R"json([{"Code":"code", "P2":"p2", "P1":"p1"}])json");
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.SupportOption (Code,P2,P1) VALUES ('code', 'p2', 'p1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code, P2, P1 FROM TestSchema.SupportOption WHERE Code='code'")) << "After swapping baseclass to none-empty mixin";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_AddMixinBaseClassWithProperties)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "a6a88b77528fe032a16b14ecce797348bd6780078f19328e87a3ef0574e32b93";
    const auto SCHEMA1_HASH_ECDB_MAP = "99db48b2ff01d60e90d407ce7613814e7f643f45e338b4fddc4631c791216290";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b78e32379a70eae0f45eedbf149e17397796681525ae2aaa61602ea48ee60e60";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IMyMixin' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                         <ECProperty propertyName='M1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of initial schema",
        [&]()
            {
            auto supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, supportOption->GetBaseClasses().size());
            ASSERT_EQ(2, supportOption->GetPropertyCount(true));
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "5f8d9bf6748719824e8759fd9f77c8cecf2f3b8cf67354f09e8b91b7caebbd98";
    const auto SCHEMA2_HASH_ECDB_MAP = "91059936ff9b0929c90d9b3f7fdfb07506a1af00d8aea6c8c986e543be2e75da";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "af059399e4d3f393a1229ae6ce5570ca36e1ba300462ea544fbaad6b7b0fdf99";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IMyMixin' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='M1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IMyMixin</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of edited schema",
        [&]()
            {
            auto supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(1)->GetFullName(), "TestSchema:IMyMixin");
            ASSERT_EQ(2, supportOption->GetBaseClasses().size());
            ASSERT_EQ(3, supportOption->GetPropertyCount(true));
            }
    );

    Test(
        "Verify we can insert and select",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.SupportOption (Code,M1,P1) VALUES ('code1', 'm1', 'p1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            auto expected = JsonValue(R"json([{"Code":"code1", "M1":"m1", "P1":"p1"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code, M1, P1 FROM TestSchema.SupportOption WHERE Code='code1'")) << "Verify inserted instance";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"Code":"code1"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code FROM TestSchema.Element")) << "Verify polymorphic query by base class";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"M1":"m1"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT M1 FROM TestSchema.IMyMixin")) << "Verify polymorphic query by mixin";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_AddPropertiesToEmptyMixinBaseClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "91fd10fedd38dbd45d6960eeff6495477b75e76621ced242d03774f8d32c80d1";
    const auto SCHEMA1_HASH_ECDB_MAP = "c9270d435d7befb4a9d5ff6c7de4bdc04bbcd68c479186516f6b623742f82e3f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b78e32379a70eae0f45eedbf149e17397796681525ae2aaa61602ea48ee60e60";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IMyMixin' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IMyMixin</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of initial schema",
        [&]()
            {
            auto supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(1)->GetFullName(), "TestSchema:IMyMixin");
            ASSERT_EQ(2, supportOption->GetBaseClasses().size());
            ASSERT_EQ(2, supportOption->GetPropertyCount(true));
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "dbf8d623a723894133b50b3b0dcf5fac6e06904b430e6e0e8471437b8754178b";
    const auto SCHEMA2_HASH_ECDB_MAP = "5008b146ff9854e5920126032c5596befb30290a8e6808633c6f088c5b7daa2d";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "af059399e4d3f393a1229ae6ce5570ca36e1ba300462ea544fbaad6b7b0fdf99";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IMyMixin' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='M1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IMyMixin</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of edited schema",
        [&]()
            {
            auto supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_EQ(2, supportOption->GetBaseClasses().size());
            ASSERT_EQ(3, supportOption->GetPropertyCount(true));
            }
    );

    Test(
        "Verify we can insert and select",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.SupportOption (Code,M1,P1) VALUES ('code2', 'm1', 'p1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            auto expected = JsonValue(R"json([{"Code":"code2", "M1":"m1", "P1":"p1"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code, M1, P1 FROM TestSchema.SupportOption WHERE Code='code2'")) << "Verify inserted instance";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            // select polymorphically
            expected = JsonValue(R"json([{"Code":"code2"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code FROM TestSchema.Element")) << "Verify polymorphic query by base class";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"M1":"m1"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT M1 FROM TestSchema.IMyMixin")) << "Verify polymorphic query by mixin";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_AddMixinWithPropertiesUsingTablePerHierarchy)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "e9f1488e9107a2bc6380f5ed4bfa6c8b05ce2c4b5168326054eca99eb94b2803";
    const auto SCHEMA1_HASH_ECDB_MAP = "b3c6024a0acb7774cde582406785f87759a9aafb04272b270cc88373fadd7dec";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "f11074eeef9a6137eb320fe95a7ec22c0286a000d8c146bbfd5fdbaa4c4d263c";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='Element'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.2.0'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='ElementProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Pipe' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='PipeProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Valve' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='ValveProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of initial schema",
        [&]()
            {
            auto pipe = m_briefcase->Schemas().GetClass("TestSchema", "Pipe");
            ASSERT_NE(pipe, nullptr);
            ASSERT_STREQ(pipe->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, pipe->GetBaseClasses().size());
            ASSERT_EQ(2, pipe->GetPropertyCount(true));

            auto valve = m_briefcase->Schemas().GetClass("TestSchema", "Valve");
            ASSERT_NE(valve, nullptr);
            ASSERT_STREQ(valve->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, valve->GetBaseClasses().size());
            ASSERT_EQ(2, valve->GetPropertyCount(true));
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "a0297ff0a92740d9fb9ec7d60ee31af2b97d7fce893874b490fdcd257805ae99";
    const auto SCHEMA2_HASH_ECDB_MAP = "933de8c603f3d1ad3fc2681482527febff72b521d5c0be81d77ab0f5cbd3ac86";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "1758836c9d933f4f73d60dfe3c4e42d2a2657a19534c6d0760a492b130bc8c40";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='TaggedPhysicalElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='MixinProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.2.0'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='ElementProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Pipe' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>TaggedPhysicalElement</BaseClass>
                        <ECProperty propertyName='PipeProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Valve' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>TaggedPhysicalElement</BaseClass>
                        <ECProperty propertyName='ValveProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of edited schema",
        [&]()
            {
            auto pipe = m_briefcase->Schemas().GetClass("TestSchema", "Pipe");
            ASSERT_NE(pipe, nullptr);
            ASSERT_EQ(2, pipe->GetBaseClasses().size());
            ASSERT_STREQ(pipe->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(pipe->GetBaseClasses().at(1)->GetFullName(), "TestSchema:TaggedPhysicalElement");
            ASSERT_EQ(3, pipe->GetPropertyCount(true));

            auto valve = m_briefcase->Schemas().GetClass("TestSchema", "Valve");
            ASSERT_NE(valve, nullptr);
            ASSERT_EQ(2, valve->GetBaseClasses().size());
            ASSERT_STREQ(valve->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(pipe->GetBaseClasses().at(1)->GetFullName(), "TestSchema:TaggedPhysicalElement");
            ASSERT_EQ(3, valve->GetPropertyCount(true));
            }
    );

    Test(
        "Verify we can insert and select",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Pipe (ElementProperty,MixinProperty,PipeProperty) VALUES ('elem', 'mix', 'pipe')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            auto expected = JsonValue(R"json([{"ElementProperty":"elem", "MixinProperty":"mix", "PipeProperty":"pipe"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ElementProperty, MixinProperty, PipeProperty FROM TestSchema.Pipe")) << "Verify inserted pipe";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Valve (ElementProperty,MixinProperty,ValveProperty) VALUES ('elem2', 'mix', 'valve')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            expected = JsonValue(R"json([{"ElementProperty":"elem2", "MixinProperty":"mix", "ValveProperty":"valve"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ElementProperty, MixinProperty, ValveProperty FROM TestSchema.Valve")) << "Verify inserted valve";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            // select polymorphically
            expected = JsonValue(R"json([{"ElementProperty":"elem"}, {"ElementProperty":"elem2"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ElementProperty FROM TestSchema.Element")) << "Verify polymorphic query by base class";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"MixinProperty":"mix"}, {"MixinProperty":"mix"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT MixinProperty FROM TestSchema.TaggedPhysicalElement")) << "Verify polymorphic query by mixin";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_AddMixinWithPropertiesUsingJoinedTablePerDirectSubclass)
    {
    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "29e8b92ebabe53a1993728b5e525374efd5b826f22631d0ab9c1753c79faed7f";
            const auto SCHEMA_HASH_ECDB_MAP = "cfb2e86d3499bc9ff634db79f2a28af36fd08edb590f1cb303b5c592406a327e";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "a477bab64de1d64aab3397e547b9bf8a7b54097147cab95ac4ce3f6c630fb109";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='Element'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.2.0'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.2.0'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='ElementProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Pipe' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='PipeProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Valve' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='ValveProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of initial schema",
        [&]()
            {
            ECClassCP pipe = m_briefcase->Schemas().GetClass("TestSchema", "Pipe");
            ASSERT_NE(pipe, nullptr);
            ASSERT_STREQ(pipe->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, pipe->GetBaseClasses().size());
            ASSERT_EQ(2, pipe->GetPropertyCount(true));

            ECClassCP valve = m_briefcase->Schemas().GetClass("TestSchema", "Valve");
            ASSERT_NE(valve, nullptr);
            ASSERT_STREQ(valve->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, valve->GetBaseClasses().size());
            ASSERT_EQ(2, valve->GetPropertyCount(true));
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "641c7582e52f303c190d69cedf1a2444a7a46edda8659a631fa3d2a3b6d1f4d8";
    const auto SCHEMA1_HASH_ECDB_MAP = "9562cfcfc61207ce64ab8655aa4ee952a0ba61f03df74d14bb48cf9dd09cd299";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "9a07435a3fd6822c10ccedc5b2153eebb7356a8e2b2d1f7aae58ecd4d3ff8bb3";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='TaggedPhysicalElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='MixinProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.2.0'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.2.0'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='ElementProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Pipe' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>TaggedPhysicalElement</BaseClass>
                        <ECProperty propertyName='PipeProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Valve' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>TaggedPhysicalElement</BaseClass>
                        <ECProperty propertyName='ValveProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of edited schema",
        [&]()
            {
            auto pipe = m_briefcase->Schemas().GetClass("TestSchema", "Pipe");
            ASSERT_NE(pipe, nullptr);
            ASSERT_EQ(2, pipe->GetBaseClasses().size());
            ASSERT_STREQ(pipe->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(pipe->GetBaseClasses().at(1)->GetFullName(), "TestSchema:TaggedPhysicalElement");
            ASSERT_EQ(3, pipe->GetPropertyCount(true));

            auto valve = m_briefcase->Schemas().GetClass("TestSchema", "Valve");
            ASSERT_NE(valve, nullptr);
            ASSERT_EQ(2, valve->GetBaseClasses().size());
            ASSERT_STREQ(valve->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(pipe->GetBaseClasses().at(1)->GetFullName(), "TestSchema:TaggedPhysicalElement");
            ASSERT_EQ(3, valve->GetPropertyCount(true));
            }
    );

    Test(
        "Verify we can insert and select",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Pipe (ElementProperty,MixinProperty,PipeProperty) VALUES ('elem', 'mix', 'pipe')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            auto expected = JsonValue(R"json([{"ElementProperty":"elem", "MixinProperty":"mix", "PipeProperty":"pipe"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ElementProperty, MixinProperty, PipeProperty FROM TestSchema.Pipe WHERE ElementProperty='elem'")) << "Verify inserted pipe";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Valve (ElementProperty,MixinProperty,ValveProperty) VALUES ('elem2', 'mix', 'valve')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            expected = JsonValue(R"json([{"ElementProperty":"elem2", "MixinProperty":"mix", "ValveProperty":"valve"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ElementProperty, MixinProperty, ValveProperty FROM TestSchema.Valve WHERE ElementProperty='elem2'")) << "Verify inserted valve";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            // select polymorphically
            expected = JsonValue(R"json([{"ElementProperty":"elem"}, {"ElementProperty":"elem2"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ElementProperty FROM TestSchema.Element")) << "Verify polymorphic query by base class";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"MixinProperty":"mix"}, {"MixinProperty":"mix"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT MixinProperty FROM TestSchema.TaggedPhysicalElement")) << "Verify polymorphic query by mixin";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_AddMixinWithPropertiesToMultipleClasses)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "58df4c7928036dee4aa71b4ff6e76e5820fd098833fe06c76502e28d06ef5387";
            const auto SCHEMA_HASH_ECDB_MAP = "bb15a5b43f57f0ccba568db5affb7b2711cccb177821d376b5a39d8ebce7a21f";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "5779abf6d328a4278fa7e618328d36ba97f4d6f12a533f12ac4c46b46df7f1fb";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='ElementProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Pipe' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='PipeProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Valve' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='ValveProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check initial properties",
        [&]()
            {
            auto pipe = m_briefcase->Schemas().GetClass("TestSchema", "Pipe");
            ASSERT_NE(pipe, nullptr);
            ASSERT_STREQ(pipe->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, pipe->GetBaseClasses().size());
            ASSERT_EQ(2, pipe->GetPropertyCount(true));

            auto valve = m_briefcase->Schemas().GetClass("TestSchema", "Valve");
            ASSERT_NE(valve, nullptr);
            ASSERT_STREQ(valve->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, valve->GetBaseClasses().size());
            ASSERT_EQ(2, valve->GetPropertyCount(true));
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "fcb155b1eb25aa98560862415c59ed5e224c28ae0aaa7e93891c359d42fbc9ce";
    const auto SCHEMA1_HASH_ECDB_MAP = "8d5816e120c6d474b02db290daa2a68c1de0cc7765c3b926c41b815800a296da";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "8458e9fd519f11eab5bc2aa519df630fdc24d76709350ece4403d2b74af456a4";
    Test(
        "import edited schema with some changes",
        [&]()
            {

            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='TaggedPhysicalElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='MixinProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='ElementProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Pipe' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>TaggedPhysicalElement</BaseClass>
                        <ECProperty propertyName='PipeProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Valve' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>TaggedPhysicalElement</BaseClass>
                        <ECProperty propertyName='ValveProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check edited properties",
        [&]()
            {
            auto pipe = m_briefcase->Schemas().GetClass("TestSchema", "Pipe");
            ASSERT_NE(pipe, nullptr);
            ASSERT_EQ(2, pipe->GetBaseClasses().size());
            ASSERT_STREQ(pipe->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(pipe->GetBaseClasses().at(1)->GetFullName(), "TestSchema:TaggedPhysicalElement");
            ASSERT_EQ(3, pipe->GetPropertyCount(true));

            auto valve = m_briefcase->Schemas().GetClass("TestSchema", "Valve");
            ASSERT_NE(valve, nullptr);
            ASSERT_EQ(2, valve->GetBaseClasses().size());
            ASSERT_STREQ(valve->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(pipe->GetBaseClasses().at(1)->GetFullName(), "TestSchema:TaggedPhysicalElement");
            ASSERT_EQ(3, valve->GetPropertyCount(true));
            }
    );

    Test(
        "Verify we can insert and select",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Pipe (ElementProperty,MixinProperty,PipeProperty) VALUES ('elem', 'mix', 'pipe')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            auto expected = JsonValue(R"json([{"ElementProperty":"elem", "MixinProperty":"mix", "PipeProperty":"pipe"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ElementProperty, MixinProperty, PipeProperty FROM TestSchema.Pipe WHERE ElementProperty='elem'")) << "Verify inserted pipe";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Valve (ElementProperty,MixinProperty,ValveProperty) VALUES ('elem2', 'mix', 'valve')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            expected = JsonValue(R"json([{"ElementProperty":"elem2", "MixinProperty":"mix", "ValveProperty":"valve"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ElementProperty, MixinProperty, ValveProperty FROM TestSchema.Valve WHERE ElementProperty='elem2'")) << "Verify inserted valve";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            // select polymorphically
            expected = JsonValue(R"json([{"ElementProperty":"elem"}, {"ElementProperty":"elem2"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ElementProperty FROM TestSchema.Element")) << "Verify polymorphic query by base class";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"MixinProperty":"mix"}, {"MixinProperty":"mix"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT MixinProperty FROM TestSchema.TaggedPhysicalElement")) << "Verify polymorphic query by mixin";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateClass_ChangeAbstractIntoConcreteClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "3cbb5c2f7efe8bcf3d2397470e9e6f68616db3858ca44361d3dea94414359eb1";
    const auto SCHEMA1_HASH_ECDB_MAP = "f36e370f003c951538b8aa6e2091d10a8bf0ab9a41c9ff4d0a4635de2e1db79b";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "65cde579ee0a43a9fc97e38e93f8fc99ab5654a66b1f7b9f9a3ce6ba815d1709";
    Test(
        "import initial schema",
        [&]()
            {

            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECProperty propertyName='BaseProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='MyClass' modifier='Abstract'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='MyProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Subclass' modifier='None' >
                        <BaseClass>MyClass</BaseClass>
                        <ECProperty propertyName='SubclassProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify initial state of the class is abstract",
        [&]()
            {
            auto subclass = m_briefcase->Schemas().GetClass("TestSchema", "Subclass");
            ASSERT_NE(subclass, nullptr);
            ASSERT_STREQ(subclass->GetBaseClasses().at(0)->GetFullName(), "TestSchema:MyClass");
            ASSERT_EQ(1, subclass->GetBaseClasses().size());
            ASSERT_EQ(3, subclass->GetPropertyCount(true));
            auto myClass = m_briefcase->Schemas().GetClass("TestSchema", "MyClass");
            ASSERT_NE(myClass, nullptr);
            ASSERT_EQ(ECClassModifier::Abstract, myClass->GetClassModifier()) << "Verify initial state of the class is abstract";
            }
    );

    Test(
        "Importing schema should fail because abstract to concrete class requires Table per Hierarchy mapping strategy",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECProperty propertyName='BaseProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='MyClass' modifier='None'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='MyProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Subclass' modifier='None' >
                        <BaseClass>MyClass</BaseClass>
                        <ECProperty propertyName='SubclassProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateClass_ChangeAbstractIntoConcreteClassUsingTablePerHierarchy)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "02ad8f8f5b0afdbb27a0949e18ba3358a7daeba865a1cb7da5621ee13246527d";
    const auto SCHEMA1_HASH_ECDB_MAP = "d3f5e8be598cf2bb98baa4e0db59e3f9105a4d5a7acf4d61551c7ed425f1fc23";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "6aa2dbfb84f8ac973166c4b3f1ecd49072539312f46945f8ec895f6472af5dae";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='BaseProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='MyClass' modifier='Abstract'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='MyProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Subclass' modifier='None' >
                        <BaseClass>MyClass</BaseClass>
                        <ECProperty propertyName='SubclassProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check initial properties",
        [&]()
            {
            auto subclass = m_briefcase->Schemas().GetClass("TestSchema", "Subclass");
            ASSERT_NE(subclass, nullptr);
            ASSERT_STREQ(subclass->GetBaseClasses().at(0)->GetFullName(), "TestSchema:MyClass");
            ASSERT_EQ(1, subclass->GetBaseClasses().size());
            ASSERT_EQ(3, subclass->GetPropertyCount(true));
            auto myClass = m_briefcase->Schemas().GetClass("TestSchema", "MyClass");
            ASSERT_NE(myClass, nullptr);
            ASSERT_EQ(ECClassModifier::Abstract, myClass->GetClassModifier()) << "Verify initial state of the class is abstract";
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "61da328291706941c2411483bd902b7f292a285fb48be8707b2ef15cffc194aa";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='BaseProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='MyClass' modifier='None'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='MyProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Subclass' modifier='None' >
                        <BaseClass>MyClass</BaseClass>
                        <ECProperty propertyName='SubclassProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check edited properties",
        [&]()
            {
            auto subclass = m_briefcase->Schemas().GetClass("TestSchema", "Subclass");
            ASSERT_NE(subclass, nullptr);
            ASSERT_STREQ(subclass->GetBaseClasses().at(0)->GetFullName(), "TestSchema:MyClass");
            ASSERT_EQ(1, subclass->GetBaseClasses().size());
            ASSERT_EQ(3, subclass->GetPropertyCount(true));
            auto myClass = m_briefcase->Schemas().GetClass("TestSchema", "MyClass");
            ASSERT_NE(myClass, nullptr);
            ASSERT_EQ(ECClassModifier::None, myClass->GetClassModifier()) << "Verify new state of the class is abstract";
            }
    );

    Test(
        "Verify we can insert and select",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.MyClass (BaseProperty,MyProperty) VALUES ('base', 'value')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            auto expected = JsonValue(R"json([{"BaseProperty":"base", "MyProperty":"value"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT BaseProperty, MyProperty FROM TestSchema.MyClass WHERE MyProperty='value'")) << "Verify inserted instance";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            // select polymorphically
            expected = JsonValue(R"json([{"BaseProperty":"base"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT BaseProperty FROM TestSchema.Base")) << "Verify polymorphic query by base class";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateClass_ChangeAbstractIntoConcreteClassWithAbstractSubclass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "ef7df83e0166bd2d4c27a1f6be29ad5066c0c379cf04f2c5755eab4948c2d5eb";
    const auto SCHEMA1_HASH_ECDB_MAP = "810cf1c4e8e145a16b78f6397de980046bbebdfb798d929a0fd22de86760badf";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "438204e1fab816e0580192172d6aee534a6d38c387c4ff21cf72899abb81f659";
    Test(
        "import initial schema",
        [&]()
            {

            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='BaseProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='MyClass' modifier='Abstract'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='MyProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Subclass' modifier='None' >
                        <BaseClass>MyClass</BaseClass>
                        <ECProperty propertyName='SubclassProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='AbstractSubclass' modifier='Abstract' >
                        <BaseClass>MyClass</BaseClass>
                        <ECProperty propertyName='AbstractSubclassProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify initial state of the class is abstract",
        [&]()
            {
            auto subclass = m_briefcase->Schemas().GetClass("TestSchema", "Subclass");
            ASSERT_NE(subclass, nullptr);
            ASSERT_STREQ(subclass->GetBaseClasses().at(0)->GetFullName(), "TestSchema:MyClass");
            ASSERT_EQ(1, subclass->GetBaseClasses().size());
            ASSERT_EQ(3, subclass->GetPropertyCount(true));
            auto myClass = m_briefcase->Schemas().GetClass("TestSchema", "MyClass");
            ASSERT_NE(myClass, nullptr);
            ASSERT_EQ(ECClassModifier::Abstract, myClass->GetClassModifier()) << "Verify initial state of the class is abstract";
            }
    );

    Test(
        "Import should fail because class has an abstract subclass",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='BaseProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='MyClass' modifier='None'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='MyProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Subclass' modifier='None' >
                        <BaseClass>MyClass</BaseClass>
                        <ECProperty propertyName='SubclassProperty' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='AbstractSubclass' modifier='Abstract' >
                        <BaseClass>MyClass</BaseClass>
                        <ECProperty propertyName='AbstractSubclassProperty' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_AddNewEmptyMixinBaseClasses) //TFS#917566
    {
    const auto SCHEMA1_HASH_ECDB_MAP = "0f051fda13a804dd21c322a60eac58c11e8eed22fe708473e0f67e1a0fe72dd3";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b78e32379a70eae0f45eedbf149e17397796681525ae2aaa61602ea48ee60e60";
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "b80b1572b2d7ee361b0ea3b4c8e391b306c99c871b518fdb572a59bfea0f48f8";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check initial base classes",
        [&]()
            {
            ECClassCP supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, supportOption->GetBaseClasses().size());
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "bcc0e54e76ae8d56242bce0f21127ad6705c3b56c39cfbd2e5334d24a44cca21";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IOptionA</BaseClass>
                        <BaseClass>IOptionB</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check changed base classes",
        [&]()
            {
            auto supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(1)->GetFullName(), "TestSchema:IOptionA");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(2)->GetFullName(), "TestSchema:IOptionB");
            ASSERT_EQ(3, supportOption->GetBaseClasses().size());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_AddNewNoneEmptyMixinBaseClasses) //TFS#917566
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "12a54c2055905d404d6003aba4fa385f715e958ed7346def372812f12bd452ff";
    const auto SCHEMA1_HASH_ECDB_MAP = "a8edf6c2bcf15cf34f9d9d5ca682f8c5b91e5a7c1d5ed2f43b766a46874c048a";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b78e32379a70eae0f45eedbf149e17397796681525ae2aaa61602ea48ee60e60";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check base classes",
        [&]()
            {
            ECClassCP supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, supportOption->GetBaseClasses().size());
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IOptionA</BaseClass>
                        <BaseClass>IOptionB</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_RemoveNoneEmptyMixinBaseClasses) //TFS#917566
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "7a24c6ccf285cbbb05c24ba11bf2cb9dda9ef03d268d8f653afecd00daf855d6";
    const auto SCHEMA1_HASH_ECDB_MAP = "9c38626b24eb982d979cc6fdd6beea9ef3d7cce5f7a4269e293ee65bc70a585f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "02e3675f2f7dbdce7f0fd584f39452d0befaacda3f39a3cecd454452916118f4";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IOptionA</BaseClass>
                        <BaseClass>IOptionB</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check base classes",
        [&]()
            {
            auto supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(1)->GetFullName(), "TestSchema:IOptionA");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(2)->GetFullName(), "TestSchema:IOptionB");
            ASSERT_EQ(3, supportOption->GetBaseClasses().size());
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                         <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateBaseClass_RemoveEmptyMixinBaseClasses) //TFS#917566
    {
    const auto SCHEMA1_HASH_ECDB_MAP = "9c38626b24eb982d979cc6fdd6beea9ef3d7cce5f7a4269e293ee65bc70a585f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "02e3675f2f7dbdce7f0fd584f39452d0befaacda3f39a3cecd454452916118f4";
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "7a24c6ccf285cbbb05c24ba11bf2cb9dda9ef03d268d8f653afecd00daf855d6";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <BaseClass>IOptionA</BaseClass>
                        <BaseClass>IOptionB</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check initial base classes",
        [&]()
            {
            auto supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(1)->GetFullName(), "TestSchema:IOptionA");
            ASSERT_STREQ(supportOption->GetBaseClasses().at(2)->GetFullName(), "TestSchema:IOptionB");
            ASSERT_EQ(3, supportOption->GetBaseClasses().size());
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "1b6881906ec11265fce16e7458b341dfe4e95f05505a9d438f9a0f8093c46d73";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='IOptionA' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='IOptionB' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element'>
                        <ECProperty propertyName='Code' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='SupportOption' modifier='None' >
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='P1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check changed base classes",
        [&]()
            {
            auto supportOption = m_briefcase->Schemas().GetClass("TestSchema", "SupportOption");
            ASSERT_NE(supportOption, nullptr);
            ASSERT_STREQ(supportOption->GetBaseClasses().at(0)->GetFullName(), "TestSchema:Element");
            ASSERT_EQ(1, supportOption->GetBaseClasses().size());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, TryRemoveMixinCustomAttribute_Simple) //TFS#917566
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "6562bc3c968eab4d84592a41aa2e962efbe8ef1f802e65520357b93626139538";
    const auto SCHEMA1_HASH_ECDB_MAP = "d999bff4980bcf59dde6e6ab7c005fce26e9f73427da1bbed253dd8d804f8b54";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='ISourceEnd' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>TestClass</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import not allowed edited schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts_modified' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='ISourceEnd' modifier='Abstract'/>
                    <ECEntityClass typeName='TestClass' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Modified Test Property' description='this is modified property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, TryAddMixinCustomAttribute_Simple) //TFS#917566
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "a4753f921912d121e4cfa807c7dd52abc20aa36d7bc2c94f42f4db39bb0f4503";
    const auto SCHEMA1_HASH_ECDB_MAP = "b03dde17dc37b789b8ee05ec452e340624a55926e4ff922b407483a08eee60ac";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "c2290bfec905956783ae44b90262c073cb92a3fc20bd4966cdd29cef79242384";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts_modified' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='ISourceEnd' modifier='Abstract'/>
                    <ECEntityClass typeName='TestClass' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Modified Test Property' description='this is modified property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import not allowed edited schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='ISourceEnd' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>TestClass</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, TryRemoveMixinCustomAttribute_Complex) //TFS#917566
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "24ef7e7c2b9c0242a6c92c50f8d39766be5b56fb8f18122c112456d5a8a57f70";
    const auto SCHEMA1_HASH_ECDB_MAP = "d999bff4980bcf59dde6e6ab7c005fce26e9f73427da1bbed253dd8d804f8b54";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='ISourceEnd' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>TestClass</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <BaseClass>ISourceEnd</BaseClass>
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import not allowed edited schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts_modified' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' prefix='CoreCA'/>
                    <ECEntityClass typeName='ISourceEnd' modifier='Abstract'>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00'>
                                <AppliesToEntityClass>TestClassA</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='TestClassA' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                        <BaseClass>ISourceEnd</BaseClass>
                        <ECProperty propertyName='TestProperty' displayLabel='Modified Test Property' description='this is modified property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateECPropertyAttributes)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "349db63db10ca6797014ccae53a798eecacf449f4ad6df718b900f9c92e83069";
    const auto SCHEMA1_HASH_ECDB_MAP = "82a4f93a397725447cf558de379c6f5a4c044c2de789edf25e9f889fbaf52a43";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='Test Property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UpdateECClassAttributes", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "955bd52f9972f919d018453691cea75d986f12fb4d7266a34347f200fafbfa74";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='New Test Schema' description='This is a New Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='My Test Property' description='My Test Property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema)) << "Modifying ECProperty display label and description is expected to be supported";
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify we can insert and select",
        [&]()
            {
            ECSqlStatement stmt;
            auto expected = JsonValue(R"json([{"DisplayLabel":"My Test Property", "Description":"My Test Property"}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECPropertyDef WHERE Name='TestProperty'")) << "After modifying display label and description";
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdatingECDbMapCAIsNotSupported)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "562ab49478e43dd3a03b0de8eb098700754fcf4c1978d2d008e5986d1a5ab0cc";
    const auto SCHEMA1_HASH_ECDB_MAP = "3bb311a6b4f0d149920e1f6104bef90ca2da52e91a5942a78b3e537dbc56ba2c";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "1b91d646402a1bb5aeee79121711565bbd6de62b952d7acdb376a77348ec19e1";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' >
                            <ECCustomAttributes>
                                <PropertyMap xmlns='ECDbMap.02.00'>
                                    <IsNullable>false</IsNullable>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import not allowed edited schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts_modified' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='TestClass' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Modified Test Property' description='this is modified property' typeName='string' >
                            <ECCustomAttributes>
                                <PropertyMap xmlns='ECDbMap.02.00'>
                                    <IsNullable>true</IsNullable>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ClassModifier)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "ee7e9dd70d06ee3b800630fdb4ba49dfeb9064aa4450d59a1feac5dec06c8668";
    const auto SCHEMA1_HASH_ECDB_MAP = "2d75103ef619198e771a6760f9b2169630e4746a230746084b742a815914b93a";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "f3b0934f2e24da442a3d609e1760192c8c0609761d01d3f2ecf8584f82db6d78";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='ECDbMap' version='02.00' prefix='ecdbmap' />
                    <ECEntityClass typeName='Koo' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='Sealed' >
                        <BaseClass>Koo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='Abstract' >
                        <ECProperty propertyName='L3' typeName='long' />
                        <ECProperty propertyName='S3' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Boo' modifier='None' >
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='L4' typeName='long' />
                        <ECProperty propertyName='S4' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Moo' modifier='Sealed' >
                        <BaseClass>Boo</BaseClass>
                        <ECProperty propertyName='L5' typeName='long' />
                        <ECProperty propertyName='S5' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify insertion",
        [&]()
            {
            //! We only like to see if insertion works. If data is left then import will fail for second schema as we do not allow rows
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Koo (L1, S1) VALUES (1, 't1')")); //Abstract
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Foo (L2, S2) VALUES (2, 't2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Goo (L3, S3) VALUES (3, 't3')")); //Abstract
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Boo (L4, S4) VALUES (4, 't4')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Moo (L5, S5) VALUES (5, 't5')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete some properties returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Koo' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <BaseClass>Koo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Voo' modifier='Sealed' >
                        <BaseClass>Koo</BaseClass>
                        <ECProperty propertyName='L6' typeName='long' />
                        <ECProperty propertyName='S6' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='Abstract' >
                        <ECProperty propertyName='L3' typeName='long' />
                        <ECProperty propertyName='S3' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Boo' modifier='Sealed' >
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='L4' typeName='long' />
                        <ECProperty propertyName='S4' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateECClassModifierToAbstract)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "c7de1e4aa5931e37184e9a9721d75beba4c9beb69e864e21a19948fe36408a11";
    const auto SCHEMA1_HASH_ECDB_MAP = "e17f55418ebef8c9bef4d3ddad32ede1da12ef4be0c12590b0a7791cf98626a5";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "1841a00c77366e8a564659a76bb6bc962ae8dab25e94ba8e10e72e74163762af";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Koo' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='Sealed' >
                        <BaseClass>Koo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify insertion",
        [&]()
            {
            //! We only like to see if insertion works. If data is left then import will fail for second schema as we do not allow rows
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Koo (L1, S1) VALUES (1, 't1')")) << "Should be invalidECSql because Koo is abstract"; //Abstract
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step()); // Original tests have this set to BE_SQLITE_DONE
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Foo (L2, S2) VALUES (2, 't2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete some properties",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Koo' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='Abstract' >
                        <BaseClass>Koo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyECClassModifierFromAbstract)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "bf9aa4ff08cae9b421fabee7d46daf5fab2cd6d16c5f28a39646fe6e506430ce";
    const auto SCHEMA1_HASH_ECDB_MAP = "13b955ae789dfff78ff1960ab1743a130b8fe229c55bb1c26c264ab30e3c20f6";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                   <ECEntityClass typeName="Foo" modifier="Abstract">
                       <ECProperty propertyName="L1" typeName="long" />
                       <ECProperty propertyName="S1" typeName="string"/>
                   </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate_modifyclassmodifiertoabstract", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Change Abstract to Sealed is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                   <ECEntityClass typeName="Foo" modifier="Sealed">
                       <ECProperty propertyName="L1" typeName="long" />
                       <ECProperty propertyName="S1" typeName="string"/>
                   </ECEntityClass>
                </ECSchema>)xml"
            );
            auto newBriefcase = m_hub->CreateBriefcase();

            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Change Abstract to None is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                   <ECEntityClass typeName="Foo" modifier="None">
                       <ECProperty propertyName="L1" typeName="long" />
                       <ECProperty propertyName="S1" typeName="string"/>
                   </ECEntityClass>
                </ECSchema>)xml"
            );
            auto newBriefcase = m_hub->CreateBriefcase();

            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UnsealingClasses)
    {
    Test(
        "index on sealed class",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "8d813b715570258426e6ef865c334cb85f31d7d6c875937bf476b76d4f20ee1d";
            const auto SCHEMA_HASH_ECDB_MAP = "d9821d2695c24184c473dd50d0ab2bf871e5d75973b4fe8769ddee4c17147f4f";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "c28a6999c16ddb5345755ba262ff87ff25b749904d1172f5eb9cb0fe84436a15";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECEntityClass typeName="Foo" modifier="Sealed">
                        <ECProperty propertyName="Prop" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UnsealingClasses", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Class modifier changed from Sealed to None",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "996b40e522d4aae62e9bce7327cc0144c48aa08dbaf3ec298d3040a7ba042701";
            const auto SCHEMA_HASH_ECDB_MAP = "2876a1a05f4ce5abfd1aa6e5e120c3875bf3e602c6653ed68dc574ad4c2030ff";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "fe79f0372911254f2d389f7f6cda4f5156323aa27a012dae5dfafead03356e5c";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Foo" modifier="None">
                        <ECProperty propertyName="Prop" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" modifier="None">
                        <BaseClass>Foo</BaseClass>
                        <ECProperty propertyName="Prop" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA1_HASH_ECDB_MAP = "e6a37ef1d3385534c16c6d0fbe860ee8574573dd4679b4466817045914880795";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "54a752668d77998991b81d3b20d62e736987c417b4700f143a8b8d25e35cffe2";
    Test(
        "sealed sub class (TPH)",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "35423da602d7c562aa0f9d3bab033fce84d446368265e6563309bafed230f77c";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Base" modifier="None">
                            <ECCustomAttributes>
                                <ClassMap xmlns="ECDbMap.02.00">
                                    <MapStrategy>TablePerHierarchy</MapStrategy>
                                </ClassMap>
                            </ECCustomAttributes>
                        <ECProperty propertyName="Prop" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" modifier="Sealed">
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UnsealingClasses", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Unsealing subclass (TPH)",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "04890ea5d0f5f98ac0259aa6d93eb8e4390a4070f248371f366895130aac3147";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Base" modifier="None">
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Prop" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" modifier="None">
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteProperty_OwnTable)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "fe10b63d32993ad2e31dd837354ece078653038df6f3efaf8eb393054f46d80b";
    const auto SCHEMA1_HASH_ECDB_MAP = "cd50ebc7301ff18e1fde52155610c1b4ae9e499fade8addd2a113894732ed4b5";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "9e2ae803e7d0f7bdc493ad26b31d668d40dee102d5812ce4ec395ae6baf684e9";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Foo' modifier='Abstract' >
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None' >
                        <BaseClass>Foo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete some properties",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <ECProperty propertyName='L1' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None' >
                        <BaseClass>Foo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            auto newBriefcase = m_hub->CreateBriefcase();

            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteProperties_TPH)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "65ddc9359aa2880b15d9f44ce347e57c8b30d4694321b355e352278fb25a0ad9";
    const auto SCHEMA1_HASH_ECDB_MAP = "ac96fd49a53bf356e7daa58ec225adc4f3b90d7d29102ce344b03afe39a02855";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "1225552890cfc5ee217bed5541d8b8ecd731a7c18b439eeefaa8cc88a23f76b2";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Koo' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <BaseClass>Koo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None' >
                        <BaseClass>Foo</BaseClass>
                        <ECProperty propertyName='L3' typeName='long' />
                        <ECProperty propertyName='S3' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Boo' modifier='None' >
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='L4' typeName='long' />
                        <ECProperty propertyName='S4' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert a row for each class",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Koo (L1, S1) VALUES (1, 't1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Foo (L1, S1, L2, S2) VALUES (2, 't2', 3, 't3')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Goo (L1, S1, L2, S2, L3, S3) VALUES (4, 't4', 5, 't5', 6,'t6')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Boo (L1, S1, L2, S2, L3, S3, L4, S4) VALUES (5, 't5', 6, 't6', 7,'t7', 8,'t8')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "fe7c215ce898bc12a15e0a637d92bd374be6e1d2644a42b843561ea6a1322890";
    const auto SCHEMA2_HASH_ECDB_MAP = "116ca5c77ee25c3b5055e2ca89c85af4c53f7e793bb26832c2ec21192f1c7e01";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "f93c3722211619a903094007405292d4a5adc61320df811a157c8e535c3e58ee";
    Test(
        "Delete some properties",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Koo' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                        <ECProperty propertyName='D1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <BaseClass>Koo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='D2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None' >
                        <BaseClass>Foo</BaseClass>
                        <ECProperty propertyName='L3' typeName='long' />
                        <ECProperty propertyName='D3' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Boo' modifier='None' >
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='L4' typeName='long' />
                        <ECProperty propertyName='D4' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "see if ECSQL fail for a property which has been deleted",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Koo (L1, S1) VALUES (1, 't1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Foo (L1, S1, L2, S2) VALUES (2, 't2',3, 't3')"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Goo (L1, S1, L2, S2, L3, S3) VALUES (4, 't4', 5, 't5', 6,'t6')"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Boo (L1, S1, L2, S2, L3, S3, L4, S4) VALUES (5, 't5', 6, 't6', 7,'t7', 8,'t8')"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Ensure new property is null for existing rows",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ECInstanceId FROM ONLY TestSchema.Koo WHERE D1 IS NULL"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ECInstanceId FROM ONLY TestSchema.Foo WHERE D1 IS NULL AND D2 IS NULL"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ECInstanceId FROM ONLY TestSchema.Goo WHERE D1 IS NULL AND D2 IS NULL AND D3 IS NULL"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ECInstanceId FROM ONLY TestSchema.Boo WHERE D1 IS NULL AND D2 IS NULL AND D3 IS NULL AND D4 IS NULL"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert new row with new value",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Koo (L1, S1, D1) VALUES (1, 't1', 'd1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Foo (L1, S1, D1, L2, D2) VALUES (2, 't2', 'd2',3, 'd3')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Goo (L1, S1, D1, L2, D2, L3, D3) VALUES (4, 't3', 'd4', 5, 'd5',6 ,'d6')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Boo (L1, S1, D1, L2, D2, L3, D3, L4, D4) VALUES (5, 't4', 'd7', 6, 'd8',7 ,'d9', 8,'d10')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteProperties_JoinedTable)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "e7728296b1f07d78473151518deedfb2d7344f4c30a93a7eac3f0bee3804ce4b";
    const auto SCHEMA1_HASH_ECDB_MAP = "4c73213a48e882d88a453e9204d6f6067836588beb7351d7d3b24aabd7b914a4";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "9be4fbd40e62d7b5a8ed26922b331cd12f446a492e91a534ed713325d604250d";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Koo' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <BaseClass>Koo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None' >
                        <BaseClass>Foo</BaseClass>
                        <ECProperty propertyName='L3' typeName='long' />
                        <ECProperty propertyName='S3' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Boo' modifier='None' >
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='L4' typeName='long' />
                        <ECProperty propertyName='S4' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert a row for each class",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Koo (L1, S1) VALUES (1, 't1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Foo (L1, S1, L2, S2) VALUES (2, 't2', 3, 't3')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Goo (L1, S1, L2, S2, L3, S3) VALUES (4, 't4', 5, 't5', 6,'t6')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Boo (L1, S1, L2, S2, L3, S3, L4, S4) VALUES (5, 't5', 6, 't6', 7,'t7', 8,'t8')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "f1fbfc4221450f71a2a90692e7c64c92ddc563ba9eff985f175bddd79e3a6cf1";
    const auto SCHEMA2_HASH_ECDB_MAP = "955ad0e567105cc07df037a47fd81f4376defdddc225ef83f6d666cf3b51bc24";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "0803494fab1a844dceae1d44d99227ac41727b1aa05fd0896ae903c72f295122";
    Test(
        "Delete some properties",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Koo' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                        <ECProperty propertyName='D1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <BaseClass>Koo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='D2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None' >
                        <BaseClass>Foo</BaseClass>
                        <ECProperty propertyName='L3' typeName='long' />
                        <ECProperty propertyName='D3' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Boo' modifier='None' >
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='L4' typeName='long' />
                        <ECProperty propertyName='D4' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "see if ECSQL fail for a property which has been deleted",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Koo (L1, S1) VALUES (1, 't1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Foo (L1, S1, L2, S2) VALUES (2, 't2',3, 't3')"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Goo (L1, S1, L2, S2, L3, S3) VALUES (4, 't4', 5, 't5', 6,'t6')"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Boo (L1, S1, L2, S2, L3, S3, L4, S4) VALUES (5, 't5', 6, 't6', 7,'t7', 8,'t8')"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Ensure new property is null for existing rows",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ECInstanceId FROM ONLY TestSchema.Koo WHERE D1 IS NULL"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ECInstanceId FROM ONLY TestSchema.Foo WHERE D2 IS NULL"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ECInstanceId FROM ONLY TestSchema.Goo WHERE D2 IS NULL AND D3 IS NULL"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT ECInstanceId FROM ONLY TestSchema.Boo WHERE D2 IS NULL AND D3 IS NULL AND D4 IS NULL"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert new row with new value",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Koo (L1, S1, D1) VALUES (1, 't1', 'd1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Foo (L1, S1, D1, L2, D2) VALUES (2, 't2', 'd2',3, 'd3')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Goo (L1, S1, D1, L2, D2, L3, D3) VALUES (4, 't3', 'd4', 5, 'd5',6 ,'d6')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO TestSchema.Boo (L1, S1, D1, L2, D2, L3, D3, L4, D4) VALUES (5, 't4', 'd7', 6, 'd8',7 ,'d9', 8,'d10')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddDeleteVirtualColumns)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "6019f52ffe28049c087c423d8b084443f68e24bb9a49b0aab382c9e0acb4e729";
    const auto SCHEMA1_HASH_ECDB_MAP = "13b955ae789dfff78ff1960ab1743a130b8fe229c55bb1c26c264ab30e3c20f6";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias='ecdbmap' />
                    <ECEntityClass typeName='Foo' modifier='Abstract' >
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete and Add some properties",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "419b1e5280227d1e96e51c7c41f4cc3cf8dd20f8745d880fdb457285788d9bff";
            const auto SCHEMA_HASH_ECDB_MAP = "f13b5a76d30187c753890b60fe1752cc74ce8312e92ae883b127d0445700a9e7";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias='ecdbmap' />
                    <ECEntityClass typeName='Foo' modifier='Abstract' >
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='D1' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteOverriddenProperties)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "977ed7e8eb12c60df52729c509e26f6f4ff2a390e17f373a400c06b06e1ffbd0";
    const auto SCHEMA1_HASH_ECDB_MAP = "6fa37d7b2f78e0ce4a987535382ef9fda79dc792f7e5a1254066394328ae80e1";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "c11693c59fc4f4b172596da51727a1461cb6731a4c7586841dfeb296becedd03";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None' >
                        <BaseClass>Foo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Change Abstract to Sealed is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <ECProperty propertyName='L1' typeName='long' />
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None' >
                        <BaseClass>Foo</BaseClass>
                        <ECProperty propertyName='L2' typeName='long' />
                        <ECProperty propertyName='S2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            auto newBriefcase = m_hub->CreateBriefcase();

            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateCAProperties)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "b108c05f4bf633af9128112a359abd8bda883e1ba359ded02a8c1771bdf926f9";
    const auto SCHEMA1_HASH_ECDB_MAP = "9e81b5d344d5172ca9148b06caef2c1275ae36dc69cceabeeedd697a696bdb4e";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName = 'TestCA' appliesTo = 'PrimitiveProperty'>
                        <ECProperty propertyName = 'ColumnName' typeName = 'string' description = 'If not specified, the ECProperty name is used. It must follow EC Identifier specification.' />
                        <ECProperty propertyName = 'IsNullable' typeName = 'boolean' description = 'If false, values must not be unset for this property.' />
                    </ECCustomAttributeClass>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' >
                            <ECCustomAttributes>
                                <TestCA xmlns='TestSchema.01.00'>
                                    <IsNullable>false</IsNullable>
                                </TestCA>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "5cdae8a05050281bcdf2fdd907388ed00b50db2a7904d68f48b00a8623928cb4";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName = 'TestCA' appliesTo = 'PrimitiveProperty'>
                        <ECProperty propertyName = 'ColumnName' typeName = 'string' description = 'If not specified, the ECProperty name is used. It must follow EC Identifier specification.' />
                        <ECProperty propertyName = 'IsNullable' typeName = 'boolean' description = 'If false, values must not be unset for this property.' />
                        <ECProperty propertyName = 'IsUnique' typeName = 'boolean' description = 'Only allow unique values for this property.' />
                        <ECProperty propertyName = 'Collation' typeName = 'string' description = 'Specifies how string comparisons should work for this property. Possible values: Binary (default): bit to bit matching. NoCase: The same as binary, except that the 26 upper case characters of ASCII are folded to their lower case equivalents before comparing. Note that it only folds ASCII characters. RTrim: The same as binary, except that trailing space characters are ignored.' />
                    </ECCustomAttributeClass>
                    <ECEntityClass typeName='TestClass' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Modified Test Property' description='this is modified property' typeName='string' >
                            <ECCustomAttributes>
                                <TestCA xmlns='TestSchema.01.00'>
                                    <IsNullable>false</IsNullable>
                                    <IsUnique>true</IsUnique>
                                </TestCA>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify Schema, Class, property and CAClassProperties attributes upgraded successfully",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_TRUE(testSchema != nullptr);
            ASSERT_TRUE(testSchema->GetAlias() == "ts");
            ASSERT_TRUE(testSchema->GetDisplayLabel() == "Modified Test Schema");
            ASSERT_TRUE(testSchema->GetDescription() == "modified test schema");

            auto testClass = testSchema->GetClassCP("TestClass");
            ASSERT_TRUE(testClass != nullptr);
            ASSERT_TRUE(testClass->GetDisplayLabel() == "Modified Test Class");
            ASSERT_TRUE(testClass->GetDescription() == "modified test class");

            auto testProperty = testClass->GetPropertyP("TestProperty");
            ASSERT_TRUE(testProperty != nullptr);
            ASSERT_TRUE(testProperty->GetDisplayLabel() == "Modified Test Property");
            ASSERT_TRUE(testProperty->GetDescription() == "this is modified property");

            //Verify attributes via ECSql using MataSchema
            ECSqlStatement statement;
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description, Alias FROM meta.ECSchemaDef WHERE Name='TestSchema'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Schema", statement.GetValueText(0));
            ASSERT_STREQ("modified test schema", statement.GetValueText(1));
            ASSERT_STREQ("ts", statement.GetValueText(2));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECClassDef WHERE Name='TestClass'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Class", statement.GetValueText(0));
            ASSERT_STREQ("modified test class", statement.GetValueText(1));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECPropertyDef WHERE Name='TestProperty'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Property", statement.GetValueText(0));
            ASSERT_STREQ("this is modified property", statement.GetValueText(1));
            statement.Finalize();

            //Verify class and Property accessible
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT TestProperty FROM ts.TestClass"));
            ASSERT_EQ(BE_SQLITE_DONE, statement.Step());
            statement.Finalize();

            //verify CA changes
            testProperty = m_briefcase->Schemas().GetSchema("TestSchema")->GetClassCP("TestClass")->GetPropertyP("TestProperty");
            ASSERT_TRUE(testProperty != nullptr);
            auto propertyMapCA = testProperty->GetCustomAttribute("TestCA");
            ASSERT_TRUE(propertyMapCA != nullptr);
            ECValue val;
            ASSERT_EQ(ECObjectsStatus::Success, propertyMapCA->GetValue(val, "IsNullable"));
            ASSERT_FALSE(val.GetBoolean());

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewEntityClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "48f524bc0ff9862b036f277eddb9e089d2cd150795e16b39c83905b63a2468f5";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "bf8155d55306c3b2ea6e5791d30c4f70b57376f318d33d782478e531f6e59f26";
    const auto SCHEMA2_HASH_ECDB_MAP = "32608ea390282589dafbb36721fb70a9336a359434d056ab67dd245415c0f814";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "533fbcc8fc6a9a9efdb25aff7db7bdb91856955e6b8c236b3f5218b64361d533";
    Test(
        "Upgrade with some attributes and import schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' />
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify tables",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            //new class should be added with new namespace prefix
            ASSERT_TRUE(m_briefcase->TableExists("ts_TestClass"));

            //Verify Schema attributes upgraded successfully
            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_TRUE(testSchema != nullptr);

            //Verify Newly Added Entity Class exists
            auto entityClass = testSchema->GetClassCP("TestClass");
            ASSERT_TRUE(entityClass != nullptr);
            ASSERT_TRUE(entityClass->GetDisplayLabel() == "Test Class");
            ASSERT_TRUE(entityClass->GetDescription() == "This is test Class");

            //Verify attributes via ECSql using MataSchema
            ECSqlStatement statement;
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECClassDef WHERE Name='TestClass'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Test Class", statement.GetValueText(0));
            ASSERT_STREQ("This is test Class", statement.GetValueText(1));
            statement.Finalize();

            //Query newly added Entity Class
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT * FROM ts.TestClass"));
            ASSERT_EQ(DbResult::BE_SQLITE_DONE, statement.Step());
            statement.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewSubClassForBaseWithTPH)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "cf03646c72c2cffef0dcc00aacefb3dd2f048fd02ea3197bb48414b08babeb3a";
    const auto SCHEMA1_HASH_ECDB_MAP = "0545286d311abcbdeb26e11f658b2add89b5e12b3be78806aeb9b0a1544979d8";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "97780c55b8972e6b86c8bd514db8948c6369dca78b94d4f14da12eb4d6dd8e59";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "1ac4d33ea5b7b2d6a3108a19ccdf6f9fe746fd3c1b88f62bf1e3b711cf31c674";
    const auto SCHEMA2_HASH_ECDB_MAP = "d6b71706869c7a07d9fe63ffda73e42a35bab2426152021eea91277ee3fb3d40";
    Test(
        "Adding new Class to TPH is expected to succeed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None' >
                        <BaseClass>Parent</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "d5a273fd85339166ac564843a06fa7024e62c6018f1cbf4442fd7e7490b16302";
    const auto SCHEMA3_HASH_ECDB_MAP = "89637627a86a2af369a6e85be5bb6f828c041295391b5aac58038e03ede27632";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "b1cf0f4d87b6f8702dd08d08b90931141e441dc145a5e827c66110368acfe764";
    Test(
        "Adding new column to TPH is expected to succeed until strict mode is enforced",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None' >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='Sub1' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewClass_NewProperty_TPH_ShareColumns)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "fd6a18f3211e538152fa723175bc2814b4994b21b892b4c9e9f83764009e0db4";
    const auto SCHEMA1_HASH_ECDB_MAP = "1e2bf61e978994641f553af1df51767c7d3fb625c758fc5e41506d4c32a6bc3b";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "9afc1fa2bb0dc6be01dea2ad48253e05cc127bbbd5134a205ee35602735f2ad7";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None' >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='Sub1' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "c28e933a4bce30fbed9050b85aa6f616f2980e593f11fb89371d83a237d30b8d";
    const auto SCHEMA2_HASH_ECDB_MAP = "bf815e4ff9173a1640619d709c70014db6e235c6b5683776e73049474ee42743";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "48044d7a0f99acacd68e771434d1c52243f129131fcb6ea0f8d6d3442e3bab08";
    Test(
        "Adding new Class with new property to TPH+ShareColumns is expected to fail",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None' >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='Sub1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub2' modifier='None' >
                        <BaseClass>Sub1</BaseClass>
                        <ECProperty propertyName='Sub2' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, VerifyMappingOfPropertiesToOverflowOnJoinedTable)
    {
    auto assertSelectSql = [](ECDbCR ecdb, Utf8CP sql, int expectedColumnCount, int expectedRowCount, Utf8CP expectedColumnName)
        {
        Statement stmt;

        //Verify Column count
        ASSERT_EQ(DbResult::BE_SQLITE_OK, stmt.Prepare(ecdb, sql)) << " ECSQL: " << sql;
        ASSERT_EQ(expectedColumnCount, stmt.GetColumnCount()) << " ECSQL: " << sql;

        //Verify Row count
        int actualRowCount = 0;
        while (stmt.Step() == BE_SQLITE_ROW)
            actualRowCount++;

        ASSERT_EQ(expectedRowCount, actualRowCount) << " ECSQL: " << sql;

        //Verify that the columns generated are same as expected
        Utf8String actualColumnNames;
        for (int i = 0; i < stmt.GetColumnCount(); i++)
            actualColumnNames.append(stmt.GetColumnName(i));

        ASSERT_STREQ(expectedColumnName, actualColumnNames.c_str());
        stmt.Finalize();
        };

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "7dcdc4d4a7575c3ac09e0bef4b92b8a09eba6b6a520d1c4f8d71c306137cf95f";
    const auto SCHEMA1_HASH_ECDB_MAP = "f8bfd29165366bd4c1c8effe108400b02a223e89c359d380fa3d899143b57e90";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "73249e5c8fcbfb020a011b07a94b3a477390f12ecb63f2b6e491b7f8197366ae";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='ECDbMap' version='02.00' prefix='ecdbmap' />
                    <ECEntityClass typeName='C1'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>1</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='A' typeName='int'/>
                        <ECProperty propertyName='B' typeName='string'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='C2'>
                        <BaseClass>C1</BaseClass>
                        <ECProperty propertyName='C' typeName='int'/>
                        <ECProperty propertyName='D' typeName='int'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );


    Test(
        "Inserting Instances for C1 and C2",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.C2 (A,B,C,D) VALUES (1,'val1',2,33)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            assertSelectSql(*m_briefcase, "SELECT * FROM ts_C1", 4, 1, "IdECClassIdAB");
            assertSelectSql(*m_briefcase, "SELECT * FROM ts_C2", 3, 1, "C1IdECClassIdjs1");
            assertSelectSql(*m_briefcase, "SELECT * FROM ts_C2_Overflow", 3, 1, "C1IdECClassIdos1");

            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verifying the inserted values for classes C1 and C2",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT A,B,C,D FROM ts.C2"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_EQ(1, stmt.GetValueInt(0));
            ASSERT_STREQ("val1", stmt.GetValueText(1));
            ASSERT_EQ(2, stmt.GetValueInt(2));
            ASSERT_EQ(33, stmt.GetValueInt(3));
            stmt.Finalize();
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "3d1099acdee3ee310287bbd41f7da83f2a76379b03b5ff5816fd2a704733c7d6";
    const auto SCHEMA2_HASH_ECDB_MAP = "0fa95b092bd284fbf574afacc413263e566d879dd4fbbd6ec126e5949d44a379";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "c81d0d817930d4a5015881ac11a63b3c15595a5ea74490a85ff61a0ba25ef5c6";
    Test(
        "Adding New Entity Class",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='ECDbMap' version='02.00' prefix='ecdbmap' />
                    <ECEntityClass typeName='C1'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>1</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='A' typeName='int'/>
                        <ECProperty propertyName='B' typeName='string'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='C2'>
                        <BaseClass>C1</BaseClass>
                        <ECProperty propertyName='C' typeName='int'/>
                        <ECProperty propertyName='D' typeName='int'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='C3'>
                        <BaseClass>C1</BaseClass>
                        <ECProperty propertyName='E' typeName='double'/>
                        <ECProperty propertyName='F' typeName='int'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        ASSERT_ECDB_SCHEMA_HASH(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA);
                        ASSERT_ECDB_MAP_HASH   (*newBriefcase, SCHEMA1_HASH_ECDB_MAP);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            ASSERT_ECDB_SCHEMA_HASH  (*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            ASSERT_ECDB_MAP_HASH     (*newBriefcase, SCHEMA2_HASH_ECDB_MAP);
            ASSERT_SQLITE_SCHEMA_HASH(*newBriefcase, SCHEMA2_HASH_SQLITE_SCHEMA);

            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) {
                ASSERT_ECDB_SCHEMA_HASH(syncDb, SCHEMA2_HASH_ECDB_SCHEMA);
                ASSERT_ECDB_MAP_HASH   (syncDb, SCHEMA2_HASH_ECDB_MAP);
                });
            }
    );

    Test(
        "Verify that the class is added successfully",
        [&]()
            {
            m_schemaChannel->WithReadOnly(
                [&](ECDbR syncDb)
                    {
                    auto testSchema = syncDb.Schemas().GetSchema("TestSchema");
                    ASSERT_NE(testSchema, nullptr);
                    ASSERT_NE(testSchema->GetClassCP("C3"), nullptr);
                    }
            );
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "5e184f0eb5eac83e37864babf3265119721fdfec5a07d6a9388ab592a0f06808";
    const auto SCHEMA3_HASH_ECDB_MAP = "f1ad5502c3d7f0b2fe51bdfbdd4616301fa108ed054cc05daf851cc9bc2306aa";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "1f1cbc4d26ed14f4946aa009b6d03fc391a79e76b25935e62642af4bd3be1e9e";
    Test(
        "Adding Entity Classes C31 and C32",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='ECDbMap' version='02.00' prefix='ecdbmap' />
                    <ECEntityClass typeName='C1'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>1</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='A' typeName='int'/>
                        <ECProperty propertyName='B' typeName='string'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='C2'>
                        <BaseClass>C1</BaseClass>
                        <ECProperty propertyName='C' typeName='int'/>
                        <ECProperty propertyName='D' typeName='int'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='C3'>
                        <BaseClass>C1</BaseClass>
                        <ECProperty propertyName='E' typeName='double'/>
                        <ECProperty propertyName='F' typeName='int'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='C31'>
                        <BaseClass>C3</BaseClass>
                        <ECProperty propertyName='G' typeName='double'/>
                        <ECProperty propertyName='H' typeName='int'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='C32'>
                        <BaseClass>C3</BaseClass>
                        <ECProperty propertyName='I' typeName='string'/>
                        <ECProperty propertyName='J' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        //CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_EQ               (BE_SQLITE_OK, newBriefcase->SaveChanges());
                        ASSERT_ECDB_SCHEMA_HASH (*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA);
                        ASSERT_ECDB_MAP_HASH    (*newBriefcase, SCHEMA2_HASH_ECDB_MAP);
                        // ASSERT_SQLITE_SCHEMA_HASH(*newBriefcase, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        }
                )
            );
            ASSERT_EQ                (SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade, GetSyncDbUri()));
            ASSERT_EQ                (BE_SQLITE_OK, newBriefcase->SaveChanges());
            ASSERT_ECDB_SCHEMA_HASH  (*newBriefcase, SCHEMA3_HASH_ECDB_SCHEMA);
            ASSERT_ECDB_MAP_HASH     (*newBriefcase, SCHEMA3_HASH_ECDB_MAP);
            ASSERT_SQLITE_SCHEMA_HASH(*newBriefcase, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) {
                ASSERT_ECDB_SCHEMA_HASH  (syncDb, SCHEMA3_HASH_ECDB_SCHEMA);
                ASSERT_ECDB_MAP_HASH     (syncDb, SCHEMA3_HASH_ECDB_MAP);
                });
            }
    );

    Test(
        "verify the the values",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        ASSERT_EQ                (BE_SQLITE_OK, m_briefcase->SaveChanges());
                        ASSERT_ECDB_SCHEMA_HASH  (*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA);
                        ASSERT_ECDB_MAP_HASH     (*m_briefcase, SCHEMA3_HASH_ECDB_MAP);
                        ASSERT_SQLITE_SCHEMA_HASH(*m_briefcase, "bde533a4f80841946dc2205235cac929ece8455b2682da69a7794aa3a1ef71ff");
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            //Verify that the classes are added successfully
            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_NE(testSchema, nullptr);
            ASSERT_NE(testSchema->GetClassCP("C31"), nullptr);
            ASSERT_NE(testSchema->GetClassCP("C32"), nullptr);

            //Tables for C1,C2,C3 should exist.
            ASSERT_TRUE(m_briefcase->TableExists("ts_C1"));
            ASSERT_TRUE(m_briefcase->TableExists("ts_C2"));
            ASSERT_TRUE(m_briefcase->TableExists("ts_C3"));
            ASSERT_TRUE(m_briefcase->TableExists("ts_C3_Overflow"));

            //C31 and C32 should not exist.
            ASSERT_FALSE(m_briefcase->TableExists("ts_C31"));
            ASSERT_FALSE(m_briefcase->TableExists("ts_C32"));

            //Inserting Instances in Classes C31 and C32
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.C31 (E,F,G,H) VALUES (10.32,3,11.1,50)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.C32 (E,F,I,J) VALUES (23.45,6,'val4',44.60)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            //Verifying values
            assertSelectSql(*m_briefcase, "SELECT * FROM ts_C3", 3, 2, "C1IdECClassIdjs1");
            assertSelectSql(*m_briefcase, "SELECT * FROM ts_C3_Overflow", 5, 2, "C1IdECClassIdos1os2os3");

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT G,H FROM ts.C31"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_EQ(11.1, stmt.GetValueDouble(0));
            ASSERT_EQ(50, stmt.GetValueInt(1));
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT I,J FROM ts.C32"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_STREQ("val4", stmt.GetValueText(0));
            ASSERT_EQ(44.60, stmt.GetValueDouble(1));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            ASSERT_ECDB_SCHEMA_HASH  (*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA);
            ASSERT_ECDB_MAP_HASH     (*m_briefcase, SCHEMA3_HASH_ECDB_MAP);
            ASSERT_SQLITE_SCHEMA_HASH(*m_briefcase, "bde533a4f80841946dc2205235cac929ece8455b2682da69a7794aa3a1ef71ff");
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) {
                    ASSERT_ECDB_SCHEMA_HASH (syncDb, SCHEMA3_HASH_ECDB_SCHEMA);
                    ASSERT_ECDB_MAP_HASH    (syncDb, SCHEMA3_HASH_ECDB_MAP);
                });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewClassModifyAllExistingAttributes)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "482c8e3b064ef4866027ed52003f319d83d4374385fb9c82430a8360af5b5c59";
    const auto SCHEMA1_HASH_ECDB_MAP = "82a4f93a397725447cf558de379c6f5a4c044c2de789edf25e9f889fbaf52a43";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' >
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "cb1d2a420b7b40df0e48d5a2f70c009e7cdd82b1a64ed8e8f7ad1a6ce17a5545";
    const auto SCHEMA2_HASH_ECDB_MAP = "89c8df19fa639dbc42652c0a1e7ff24d6b494f89e91f89d25abca6326c049dc9";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "175954922d32d3addfe52c3c8197b4848879bcd07e9c48ff120bd59f22ed6157";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Modified Test Property' description='this is modified property' typeName='string' >
                        </ECProperty>
                    </ECEntityClass>
                    <ECEntityClass typeName='NewTestClass' displayLabel='New Test Class' description='This is New test Class' modifier='None' />
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify Schema, Class, property and CAClassProperties attributes upgraded successfully",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            //Verify Schema, Class, property and CAClassProperties attributes upgraded successfully
            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_NE(testSchema, nullptr);
            ASSERT_EQ(testSchema->GetAlias(),"ts");
            ASSERT_EQ(testSchema->GetDisplayLabel(), "Modified Test Schema");
            ASSERT_EQ(testSchema->GetDescription(), "modified test schema");

            auto testClass = testSchema->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);
            ASSERT_EQ(testClass->GetDisplayLabel(), "Modified Test Class");
            ASSERT_EQ(testClass->GetDescription(), "modified test class");

            auto testProperty = testClass->GetPropertyP("TestProperty");
            ASSERT_NE(testProperty, nullptr);
            ASSERT_EQ(testProperty->GetDisplayLabel(), "Modified Test Property");
            ASSERT_EQ(testProperty->GetDescription(), "this is modified property");

            //verify newly added Entity Class exists
            auto newTestClass = testSchema->GetClassCP("NewTestClass");
            ASSERT_NE(newTestClass, nullptr);
            ASSERT_EQ(newTestClass->GetDisplayLabel(), "New Test Class");
            ASSERT_EQ(newTestClass->GetDescription(), "This is New test Class");

            //Verify attributes via ECSql using MataSchema
            ECSqlStatement statement;
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description, Alias FROM meta.ECSchemaDef WHERE Name='TestSchema'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Schema", statement.GetValueText(0));
            ASSERT_STREQ("modified test schema", statement.GetValueText(1));
            ASSERT_STREQ("ts", statement.GetValueText(2));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECClassDef WHERE Name='TestClass'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Class", statement.GetValueText(0));
            ASSERT_STREQ("modified test class", statement.GetValueText(1));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description From meta.ECClassDef WHERE Name='NewTestClass'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("New Test Class", statement.GetValueText(0));
            ASSERT_STREQ("This is New test Class", statement.GetValueText(1));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECPropertyDef WHERE Name='TestProperty'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Property", statement.GetValueText(0));
            ASSERT_STREQ("this is modified property", statement.GetValueText(1));
            statement.Finalize();

            //Query existing and newly added Entity Classes
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT TestProperty FROM ts.TestClass"));
            ASSERT_EQ(DbResult::BE_SQLITE_DONE, statement.Step());
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT * FROM ts.NewTestClass"));
            ASSERT_EQ(DbResult::BE_SQLITE_DONE, statement.Step());
            statement.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewECDbMapCANotSupported)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "8a8d97dd38805188cf4dcafecb1a48e9045df0a4f941f4c8bbdfae18c8f04011";
    const auto SCHEMA1_HASH_ECDB_MAP = "d66e7330b944910eb2123301d081f2556e51dcd9c59c739082fe55b9c63ddd45";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "cada7f8e10fef1a4b8bfd574c110b6ecb84653e8e4a769a50ec281b56a4b3c00";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='3.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECProperty propertyName='S' typeName='string' />
                        <ECProperty propertyName='D' typeName='double' />
                        <ECProperty propertyName='L' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Add New ECDbMapCA on ECClass",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='4.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='S' typeName='string' />
                        <ECProperty propertyName='D' typeName='double' />
                        <ECProperty propertyName='L' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AppendNewCA)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "fc9ad3bb46442c4af71fc02112e46cfbcf96e4e65d06f3d911c2f1081075a73c";
    const auto SCHEMA1_HASH_ECDB_MAP = "cf1ab83f94b23c6488da13b61ebb1d463504a4304a9f05c90813ac8c4a8f8f1b";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "533fbcc8fc6a9a9efdb25aff7db7bdb91856955e6b8c236b3f5218b64361d533";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECCustomAttributeClass typeName = 'UserCA1' appliesTo = 'Any' />
                    <ECCustomAttributeClass typeName = 'UserCA2' appliesTo = 'Any' />
                    <ECCustomAttributeClass typeName = 'UserCA3' appliesTo = 'Any' />
                    <ECCustomAttributeClass typeName = 'UserCA4' appliesTo = 'Any' />
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='test class' modifier='None' >
                         <ECCustomAttributes>
                            <UserCA1 xmlns = 'TestSchema.01.00.00' />
                            <UserCA2 xmlns = 'TestSchema.01.00.00' />
                            <UserCA3 xmlns = 'TestSchema.01.00.00' />
                         </ECCustomAttributes>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "a8cc0df53bb1339d49f8c2609edeeb4ffcb0cf77eae648966ec01a1284ffd7d4";
    const auto SCHEMA2_HASH_ECDB_MAP = "80d2aae54ffc27813eb1bd1d660aa80e02c1bbdb8522af0c27e64040393bfc72";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "f5d18dd4acb5c7c8a7980d29bc65fdcb530ad0df51dfcfe94d001ce821b0b57e";
    Test(
        "Add new CustomAttribute",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'CoreCustomAttributes' version = '01.00' alias = 'CoreCA' />
                    <ECCustomAttributeClass typeName = 'UserCA1' appliesTo = 'Any' />
                    <ECCustomAttributeClass typeName = 'UserCA2' appliesTo = 'Any' />
                    <ECCustomAttributeClass typeName = 'UserCA3' appliesTo = 'Any' />
                    <ECCustomAttributeClass typeName = 'UserCA4' appliesTo = 'Any' />
                    <ECEntityClass typeName='TestClass' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                         <ECCustomAttributes>
                            <UserCA1 xmlns = 'TestSchema.01.00.00' />
                            <UserCA2 xmlns = 'TestSchema.01.00.00' />
                            <UserCA3 xmlns = 'TestSchema.01.00.00' />
                            <UserCA4 xmlns = 'TestSchema.01.00.00' />
                            <ClassHasCurrentTimeStampProperty xmlns='CoreCustomAttributes.01.00'>
                                <PropertyName>LastMod</PropertyName>
                            </ClassHasCurrentTimeStampProperty>
                         </ECCustomAttributes>
                        <ECProperty propertyName='LastMod' typeName='dateTime' readOnly='True'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify Schema, Class, property attributes upgraded successfully",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_NE(testSchema, nullptr);
            ASSERT_EQ(testSchema->GetAlias(),"ts");
            ASSERT_EQ(testSchema->GetDisplayLabel(), "Modified Test Schema");
            ASSERT_EQ(testSchema->GetDescription(), "modified test schema");

            auto testClass = testSchema->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);
            ASSERT_EQ(testClass->GetDisplayLabel(), "Modified Test Class");
            ASSERT_EQ(testClass->GetDescription(), "modified test class");

            //verify tables
            ASSERT_TRUE(m_briefcase->TableExists("ts_TestClass"));

            //Verify attributes via ECSql using MataSchema
            ECSqlStatement statement;
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description, Alias FROM meta.ECSchemaDef WHERE Name='TestSchema'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Schema", statement.GetValueText(0));
            ASSERT_STREQ("modified test schema", statement.GetValueText(1));
            ASSERT_STREQ("ts", statement.GetValueText(2));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECClassDef WHERE Name='TestClass'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Class", statement.GetValueText(0));
            ASSERT_STREQ("modified test class", statement.GetValueText(1));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT * FROM ts.TestClass"));
            ASSERT_EQ(DbResult::BE_SQLITE_DONE, statement.Step());
            statement.Finalize();

            //Verify newly added CA
            testClass = m_briefcase->Schemas().GetSchema("TestSchema")->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);
            auto bsca = testClass->GetCustomAttribute("CoreCustomAttributes", "ClassHasCurrentTimeStampProperty");
            ASSERT_NE(bsca, nullptr);

            ECValue val;
            ASSERT_EQ(ECObjectsStatus::Success, bsca->GetValue(val, "PropertyName"));
            ASSERT_STRCASEEQ("LastMod", val.GetUtf8CP());

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewCA)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "f2f99d37b9073c43aba89e57cd57edd79f620892eaf9816806b378407da7bad2";
    const auto SCHEMA1_HASH_ECDB_MAP = "32608ea390282589dafbb36721fb70a9336a359434d056ab67dd245415c0f814";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "533fbcc8fc6a9a9efdb25aff7db7bdb91856955e6b8c236b3f5218b64361d533";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "eb85ce269f0d9cc012db7b6e7df1c18a8398897db796459bfb8ea1ec15f88336";
    const auto SCHEMA2_HASH_ECDB_MAP = "5888e8d32c483df1f7527c9790561eb86e8130cfec63713bffefdb614aae67f4";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "f5d18dd4acb5c7c8a7980d29bc65fdcb530ad0df51dfcfe94d001ce821b0b57e";
    Test(
        "Add new CustomAttribute",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'CoreCustomAttributes' version = '01.00' alias = 'CoreCA' />
                    <ECEntityClass typeName='TestClass' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                        <ECCustomAttributes>
                            <ClassHasCurrentTimeStampProperty xmlns='CoreCustomAttributes.01.00'>
                                <PropertyName>LastMod</PropertyName>
                            </ClassHasCurrentTimeStampProperty>
                        </ECCustomAttributes>
                        <ECProperty propertyName='LastMod' typeName='dateTime' readOnly='True'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify Schema, Class, property attributes upgraded successfully",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_NE(testSchema, nullptr);
            ASSERT_EQ(testSchema->GetAlias(), "ts");
            ASSERT_EQ(testSchema->GetDisplayLabel(), "Modified Test Schema");
            ASSERT_EQ(testSchema->GetDescription(), "modified test schema");

            auto testClass = testSchema->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);
            ASSERT_EQ(testClass->GetDisplayLabel(), "Modified Test Class");
            ASSERT_EQ(testClass->GetDescription(), "modified test class");

            //verify tables
            ASSERT_TRUE(m_briefcase->TableExists("ts_TestClass"));

            //Verify attributes via ECSql using MataSchema
            ECSqlStatement statement;
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description, Alias FROM meta.ECSchemaDef WHERE Name='TestSchema'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Schema", statement.GetValueText(0));
            ASSERT_STREQ("modified test schema", statement.GetValueText(1));
            ASSERT_STREQ("ts", statement.GetValueText(2));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECClassDef WHERE Name='TestClass'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Class", statement.GetValueText(0));
            ASSERT_STREQ("modified test class", statement.GetValueText(1));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT * FROM ts.TestClass"));
            ASSERT_EQ(DbResult::BE_SQLITE_DONE, statement.Step());
            statement.Finalize();

            //Verify newly added CA
            testClass = m_briefcase->Schemas().GetSchema("TestSchema")->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);
            auto bsca = testClass->GetCustomAttribute("CoreCustomAttributes", "ClassHasCurrentTimeStampProperty");
            ASSERT_NE(bsca, nullptr);

            ECValue val;
            ASSERT_EQ(ECObjectsStatus::Success, bsca->GetValue(val, "PropertyName"));
            ASSERT_STRCASEEQ("LastMod", val.GetUtf8CP());

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewECProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "f658d8871c57de304786ad7a38b5340463fd7fa8e008edff9c63962bf5c55a77";
    const auto SCHEMA1_HASH_ECDB_MAP = "32608ea390282589dafbb36721fb70a9336a359434d056ab67dd245415c0f814";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "533fbcc8fc6a9a9efdb25aff7db7bdb91856955e6b8c236b3f5218b64361d533";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "ee0946063314af2790a376bc6104debedc11fcb0eea2648b39bac805542e9a1c";
    const auto SCHEMA2_HASH_ECDB_MAP = "82a4f93a397725447cf558de379c6f5a4c044c2de789edf25e9f889fbaf52a43";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "Upgrade with some attributes and import schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify newly added property exists",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_NE(testSchema, nullptr);

            auto testClass = testSchema->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);

            auto testProperty = testClass->GetPropertyP("TestProperty");
            ASSERT_NE(testProperty, nullptr);
            ASSERT_EQ(testProperty->GetDisplayLabel(), "Test Property");
            ASSERT_EQ(testProperty->GetDescription(), "this is property");

            ECSqlStatement statement;
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECPropertyDef WHERE Name='TestProperty'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Test Property", statement.GetValueText(0));
            ASSERT_STREQ("this is property", statement.GetValueText(1));
            statement.Finalize();

            //Query newly added Property
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT TestProperty FROM ts.TestClass"));
            ASSERT_EQ(DbResult::BE_SQLITE_DONE, statement.Step());
            statement.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteOverridePropertyOutOfOrderAndThenAddAnewPropertyCauseUniqueIndexToFail)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "e7289951c692a26c6a1955116cac7a7ce30486f371d3701ebcd16b71242736b3";
    const auto SCHEMA1_HASH_ECDB_MAP = "73eab5d68e91d13d229c85142f08bc4d1b87a995f05ec40ee70c9db3876e8358";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b03c0e8b59618d07b7a2c8f04bfa0b488ceae1cf4ef7e5eabc09c11f1e7e42f9";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name='ECDbMap' version='02.00' alias='ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00' />
                        </ECCustomAttributes>
                        <ECProperty propertyName='Prop1' typeName='string' />
                        <ECProperty propertyName='Prop2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub' modifier='None' >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='Prop1' typeName='string' />
                        <ECProperty propertyName='Prop2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("AddPropertyToBaseClass", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "41c0ce6c68454dc2c3f03c97f8d464608e4904b6a60c7aa468eb3272960906b8";
    Test(
        "Delete override property",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name='ECDbMap' version='02.00' alias='ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00' />
                        </ECCustomAttributes>
                       <ECProperty propertyName='Prop1' typeName='string' />
                       <ECProperty propertyName='Prop2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub' modifier='None' >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='Prop2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "697f83b13ea95e1de816a553bb849ac8ff619b96389a97aa709f57e9f0691441";
    const auto SCHEMA3_HASH_ECDB_MAP = "7446bd9b37672cc32bc2e47bf321e86535036348978bf9561c482372893f7795";
    Test(
        "add Override Property back",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name='ECDbMap' version='02.00' alias='ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00' />
                        </ECCustomAttributes>
                       <ECProperty propertyName='Prop1' typeName='string' />
                       <ECProperty propertyName='Prop2' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub' modifier='None' >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='Prop1' typeName='string' />
                        <ECProperty propertyName='Prop2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            //This cause unique index error in ec_Property(id, classId, ordinal) before fix
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddPropertyToBaseClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "a0ca69cadd1cb8eafe98293187746699ee27b52f4379cedae32f0933765a46c3";
    const auto SCHEMA1_HASH_ECDB_MAP = "edfbeec1cf01d1d8da8a43a740de68aad40cc26ef23f304cb0e286ee157548e5";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b03c0e8b59618d07b7a2c8f04bfa0b488ceae1cf4ef7e5eabc09c11f1e7e42f9";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name='ECDbMap' version='02.00' alias='ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00' />
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub' modifier='None' >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='Prop1' typeName='string' />
                        <ECProperty propertyName='Prop2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("AddPropertyToBaseClass", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    ECSqlStatement stmt;
    ECInstanceKey row1;
    Test(
        "Insert values to initial schema",
        [&]()
            {
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub(Prop1,Prop2) VALUES ('Instance1 Prop1', 'Instance1 Prop2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(row1));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "78c1bae7becca6bf4d60adbb62e75b2e778d8a8cd3d7d79471be018d1ab4a061";
    const auto SCHEMA2_HASH_ECDB_MAP = "b0cc01fa6a44ec8e1d12c58c2b9462a1283d4877b4056186082b0ac79ff14b5c";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "351e3a23da01181b90915602d96a7346fab461425708e7ddc36797c2e4340402";
    Test(
        "Upgrade with some attributes and import schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name='ECDbMap' version='02.00' alias='ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00' />
                        </ECCustomAttributes>
                        <ECProperty propertyName='BaseProp1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub' modifier='None' >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='Prop1' typeName='string' />
                        <ECProperty propertyName='Prop2' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    ECInstanceKey row2;
    Test(
        "Insert values to upgraded schema",
        [&]()
            {
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub(BaseProp1,Prop1,Prop2) VALUES ('Instance2 BaseProp1', 'Instance2 Prop1', 'Instance2 Prop2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step(row2));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );

    Test(
        "Verify select",
        [&]()
            {
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT BaseProp1, Prop1, Prop2 FROM ts.Sub WHERE ECInstanceId=?"));
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(1, row1.GetInstanceId()));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_TRUE(stmt.IsValueNull(0));
            ASSERT_STREQ("Instance1 Prop1", stmt.GetValueText(1));
            ASSERT_STREQ("Instance1 Prop2", stmt.GetValueText(2));
            stmt.ClearBindings();
            stmt.Reset();
            ASSERT_EQ(ECSqlStatus::Success, stmt.BindId(1, row2.GetInstanceId()));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_STREQ("Instance2 BaseProp1", stmt.GetValueText(0));
            ASSERT_STREQ("Instance2 Prop1", stmt.GetValueText(1));
            ASSERT_STREQ("Instance2 Prop2", stmt.GetValueText(2));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );

    Test(
        "verify that all three props map to different columns",
        [&]()
            {
            Statement statement;
            ASSERT_EQ(BE_SQLITE_OK, statement.Prepare(
                *m_briefcase,
                "select count(distinct pm.ColumnId) FROM ec_PropertyPath pp JOIN ec_PropertyMap pm "
                "ON pm.PropertyPathId = pp.Id JOIN ec_Property p ON p.Id = pp.RootPropertyId "
                "WHERE p.Name IN ('BaseProp1', 'Prop1', 'Prop2')"
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, statement.Step());
            ASSERT_EQ(3, statement.GetValueInt(0)) << "The three properties of ECClass Sub must map to 3 different columns";

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddPropertyToSubclassThenPropertyToBaseClass_TPH_SharedColumns)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "99be3eca8c7db46e07cf934acae443775c940dd22a7d4dc84e743de18b3d6e0c";
    const auto SCHEMA1_HASH_ECDB_MAP = "01a0a473911bb6c60d37cc69a2fc06d41bd59429f8deb60314fd5a166d939d26";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "351e3a23da01181b90915602d96a7346fab461425708e7ddc36797c2e4340402";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Base" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00.00" />
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("AddPropertyToSubclassThenPropertyToBaseClass_TPH_SharedColumns", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Prop1,Prop2) VALUES (10,'1-1', '1-2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub2(Code,PropA,PropB) VALUES (20,'1-A', 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "2490b9dd86d960217c571897b65d1490b2efc93741e514c2f5aa33e6c0a54b30";
    const auto SCHEMA2_HASH_ECDB_MAP = "a5344168ddb4db575c1c18f29ae777ffd66fb147accd4257be35cca76f2f15c3";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "36a8357bd9daa5ac0a3d65079cab9ee91366fa480bc724bfc46ef22b340022df";
    Test(
        "Add property to Sub1",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Base" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00.00" />
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                        <ECProperty propertyName="Prop3" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and validate values to upgraded schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Prop1,Prop2,Prop3) VALUES (11,'2-1', '2-2', 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            auto expected = JsonValue(R"json([{"Code":10,"Prop1":"1-1","Prop2":"1-2"},{"Code":11,"Prop1":"2-1","Prop2":"2-2","Prop3":2}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code, Prop1, Prop2, Prop3 FROM ts.Sub1"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"Code":20,"PropA":"1-A","PropB":1}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code, PropA, PropB FROM ts.Sub2"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "7f240c84ec90e9f38293e09e975586a915f77c8b8401ee91b180b84750e9d842";
    const auto SCHEMA3_HASH_ECDB_MAP = "d94bdbcace3c39f255192f674a1e0b804cb66fd6be1ebb4ca91ad25ec1908ed7";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "8a852b9eb779c1e89a873952c34887f103f7679b9b473cc06c90e12d214818ce";
    Test(
        "Add property to Base",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.2" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Base" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00.00" />
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                        <ECProperty propertyName="Prop3" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and validate values to final schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Name,Prop1,Prop2,Prop3) VALUES (12,'Object 12', '3-1', '3-2', 3)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub2(Code,Name,PropA,PropB) VALUES (21,'Object 21', '2-A', 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            auto expected = JsonValue(R"json([{"Code":10,"Prop1":"1-1","Prop2":"1-2"},{"Code":11,"Prop1":"2-1","Prop2":"2-2","Prop3":2},{"Code":12, "Name":"Object 12","Prop1":"3-1","Prop2":"3-2","Prop3":3}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code, Name, Prop1, Prop2, Prop3 FROM ts.Sub1"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"Code":20,"PropA":"1-A","PropB":1},{"Code":21,"Name":"Object 21","PropA":"2-A","PropB":2}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code, Name, PropA, PropB FROM ts.Sub2"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddPropertyToSubclassThenPropertyToBaseClass_TPH_JoinedTable_SharedCols)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "4db8e223774dfd62f4c1659f5a2bd79818cf09c5d248eeeebd27e884ed3c1bf7";
    const auto SCHEMA1_HASH_ECDB_MAP = "7d7cc795d852b7f497f0f3df236c2edbbf26fb6477d44bbf1bcd349f7080704d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ebe2cbd764b3e700395e4bccbac629b543fe5e1758da6db5e627ccbfd12f10be";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Geometric2dElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName="Origin" typeName="Point2d" />
                    </ECEntityClass>
                    <ECEntityClass typeName="PhysicalElement" modifier="Abstract" >
                        <BaseClass>Geometric2dElement</BaseClass>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="SubBase" modifier="Abstract" >
                        <BaseClass>PhysicalElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("AddPropertyToSubclassThenPropertyToBaseClass_TPH_JoinedTable_SharedCols", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Origin.X,Origin.Y,Name,Prop1,Prop2) VALUES (101,1,1,'Sub1 1','1', '2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub2(Code,Origin.X,Origin.Y,Name,PropA,PropB) VALUES (201,1,1,'Sub2 1','A', 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "7da1f1c635893eab84b4262544def21794c6857d72b9ebcb90c192e6f39f6714";
    const auto SCHEMA2_HASH_ECDB_MAP = "6ab05671deb54d6d30fe6ca0474dedd12034295c9f67ac06e454b8371e80c3b2";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "fa35be3b944aeb606d51e60ff02e9a2b4caad5051882535bce90b0be77b66319";
    Test(
        "Add property to Sub1",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Geometric2dElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName="Origin" typeName="Point2d" />
                    </ECEntityClass>
                    <ECEntityClass typeName="PhysicalElement" modifier="Abstract" >
                        <BaseClass>Geometric2dElement</BaseClass>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="SubBase" modifier="Abstract" >
                        <BaseClass>PhysicalElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                        <ECProperty propertyName="Prop3" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and validate values to upgraded schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Origin.X,Origin.Y,Name,Prop1,Prop2,Prop3) VALUES (102,2,2,'Sub1 2','1', '2', 3)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            auto expected = JsonValue(R"json([{"Code":101,"Origin": {"x":1.0,"y":1.0},"Name": "Sub1 1", "Prop1":"1","Prop2":"2"},{"Code":102,"Origin": {"x":2.0,"y":2.0},"Name": "Sub1 2", "Prop1":"1","Prop2":"2", "Prop3": 3}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name, Prop1, Prop2, Prop3 FROM ts.Sub1"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"Code":201,"Origin": {"x":1.0,"y":1.0},"Name": "Sub2 1", "PropA":"A","PropB":1}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name,PropA, PropB FROM ts.Sub2"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "8c46915baf4e019bf8126756ce91af831b706528afd600bd3de7b0ccdbc1622e";
    const auto SCHEMA3_HASH_ECDB_MAP = "1fa65d6e13f36e0b14cc595d08d13cdb8f1e75e96f6c6bf477a344411c7d1d3e";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "0535fb0fc5cd6b23e103f16be7eb1716127142cf81323d27af56be2d85d2211e";
    Test(
        "Add property to SubBase",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.2" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Geometric2dElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName="Origin" typeName="Point2d" />
                    </ECEntityClass>
                    <ECEntityClass typeName="PhysicalElement" modifier="Abstract" >
                        <BaseClass>Geometric2dElement</BaseClass>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="SubBase" modifier="Abstract" >
                        <BaseClass>PhysicalElement</BaseClass>
                        <ECProperty propertyName="Kind" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                        <ECProperty propertyName="Prop3" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and validate values to final schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Origin.X,Origin.Y,Name,Kind,Prop1,Prop2,Prop3) VALUES (103,3,3,'Sub1 3',3,'1', '2', 3)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub2(Code,Origin.X,Origin.Y,Name,Kind,PropA,PropB) VALUES (202,2,2,'Sub2 2',2,'A', 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            auto expected = JsonValue(
                R"json([{"Code":101,"Origin": {"x":1.0,"y":1.0},"Name": "Sub1 1", "Prop1":"1","Prop2":"2"},
                {"Code":102,"Origin": {"x":2.0,"y":2.0},"Name": "Sub1 2", "Prop1":"1","Prop2":"2", "Prop3": 3},
                {"Code":103,"Origin": {"x":3.0,"y":3.0},"Name": "Sub1 3", "Kind":3, "Prop1":"1","Prop2":"2", "Prop3": 3}])json"
            );
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name,Kind,Prop1,Prop2,Prop3 FROM ts.Sub1"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(
                R"json([{"Code":201,"Origin": {"x":1.0,"y":1.0},"Name": "Sub2 1", "PropA":"A","PropB":1},
                {"Code":202,"Origin": {"x":2.0,"y":2.0},"Name": "Sub2 2", "Kind":2, "PropA":"A","PropB":2}])json"
            );
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name,Kind,PropA,PropB FROM ts.Sub2"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddPropertyToSubclassThenPropertyToBaseClass_TPH_JoinedTable_SharedCols_AllAddedPropsToOverflow)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "df0df0956dc32d9c0be325ea76969728dfb1f0c7a51678e872012f046529145e";
    const auto SCHEMA1_HASH_ECDB_MAP = "972b210d0debf0168955060c25b696dd80e99e176a125b7e0a00621acdb76984";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "cdb949b55ac86f953832043bd5a5584b49e3f212e6c22012217319bb592a99c9";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Geometric2dElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>2</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName="Origin" typeName="Point2d" />
                    </ECEntityClass>
                    <ECEntityClass typeName="PhysicalElement" modifier="Abstract" >
                        <BaseClass>Geometric2dElement</BaseClass>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="SubBase" modifier="Abstract" >
                        <BaseClass>PhysicalElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(
                SchemaImportResult::OK,
                SetupECDb(
                    "AddPropertyToSubclassThenPropertyToBaseClass_TPH_JoinedTable_SharedCols_AllAddedPropsToOverflow",
                    schema,
                    SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade
                )
            );
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Origin.X,Origin.Y,Name,Prop1,Prop2) VALUES (101,1,1,'Sub1 1','1', '2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub2(Code,Origin.X,Origin.Y,Name,PropA,PropB) VALUES (201,1,1,'Sub2 1','A', 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "b59d9d791934049a7f0e839c7df4e2cde2162fd8f1f282b8e43e2cdd079c04ea";
    const auto SCHEMA2_HASH_ECDB_MAP = "f05ebacafe4c08f4b3763914157284f3a2917e8c32b519d6afcb993c9f424de0";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "1c2d8fbbf412b7e4623c14af0fb850f5a96711103f3364184500c0605ae9c7a1";
    Test(
        "Add property to Sub1",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Geometric2dElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>2</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName="Origin" typeName="Point2d" />
                    </ECEntityClass>
                    <ECEntityClass typeName="PhysicalElement" modifier="Abstract" >
                        <BaseClass>Geometric2dElement</BaseClass>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="SubBase" modifier="Abstract" >
                        <BaseClass>PhysicalElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                        <ECProperty propertyName="Prop3" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and validate values to upgraded schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Origin.X,Origin.Y,Name,Prop1,Prop2,Prop3) VALUES (102,2,2,'Sub1 2','1', '2', 3)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            auto expected = JsonValue(R"json([{"Code":101,"Origin": {"x":1.0,"y":1.0},"Name": "Sub1 1", "Prop1":"1","Prop2":"2"},{"Code":102,"Origin": {"x":2.0,"y":2.0},"Name": "Sub1 2", "Prop1":"1","Prop2":"2", "Prop3": 3}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name, Prop1, Prop2, Prop3 FROM ts.Sub1"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"Code":201,"Origin": {"x":1.0,"y":1.0},"Name": "Sub2 1", "PropA":"A","PropB":1}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name,PropA, PropB FROM ts.Sub2"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "2362402456d838c9cfb15dd278e651571a84bba0c15189b2e0894966e78fff04";
    const auto SCHEMA3_HASH_ECDB_MAP = "12969517d427966e0c143181f523a33314fbee6c8d11c3ab1170d6eb5cbef552";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "fa3932855399557ee728462fd837644af585c2c6b17284b679b69b9372a78ab1";
    Test(
        "Add property to SubBase",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.2" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Geometric2dElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>2</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName="Origin" typeName="Point2d" />
                    </ECEntityClass>
                    <ECEntityClass typeName="PhysicalElement" modifier="Abstract" >
                        <BaseClass>Geometric2dElement</BaseClass>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="SubBase" modifier="Abstract" >
                        <BaseClass>PhysicalElement</BaseClass>
                        <ECProperty propertyName="Kind" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                        <ECProperty propertyName="Prop3" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and validate values to final schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Origin.X,Origin.Y,Name,Kind,Prop1,Prop2,Prop3) VALUES (103,3,3,'Sub1 3',3,'1', '2', 3)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub2(Code,Origin.X,Origin.Y,Name,Kind,PropA,PropB) VALUES (202,2,2,'Sub2 2',2,'A', 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            auto expected = JsonValue(
                R"json([{"Code":101,"Origin": {"x":1.0,"y":1.0},"Name": "Sub1 1", "Prop1":"1","Prop2":"2"},
                {"Code":102,"Origin": {"x":2.0,"y":2.0},"Name": "Sub1 2", "Prop1":"1","Prop2":"2", "Prop3": 3},
                {"Code":103,"Origin": {"x":3.0,"y":3.0},"Name": "Sub1 3", "Kind":3, "Prop1":"1","Prop2":"2", "Prop3": 3}])json"
            );
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name,Kind,Prop1,Prop2,Prop3 FROM ts.Sub1"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(
                R"json([{"Code":201,"Origin": {"x":1.0,"y":1.0},"Name": "Sub2 1", "PropA":"A","PropB":1},
                {"Code":202,"Origin": {"x":2.0,"y":2.0},"Name": "Sub2 2", "Kind":2, "PropA":"A","PropB":2}])json"
            );
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name,Kind,PropA,PropB FROM ts.Sub2"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddPropertyToSubclassThenPropertyToBaseClass_TPH_JoinedTable_SharedCols_AddedBasePropToOverflow)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "2cc81e820cf5b5e866f641aeaee96cbedbc54e77c6d1a52de204e9b069207003";
    const auto SCHEMA1_HASH_ECDB_MAP = "07189aca401a6e2b70d563e7c10cb23cecc6783fe5b02185cd53952360b525da";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ebe2cbd764b3e700395e4bccbac629b543fe5e1758da6db5e627ccbfd12f10be";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Geometric2dElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName="Origin" typeName="Point2d" />
                    </ECEntityClass>
                    <ECEntityClass typeName="PhysicalElement" modifier="Abstract" >
                        <BaseClass>Geometric2dElement</BaseClass>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="SubBase" modifier="Abstract" >
                        <BaseClass>PhysicalElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("AddPropertyToSubclassThenPropertyToBaseClass_TPH_JoinedTable_SharedCols_AddedBasePropToOverflow", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Origin.X,Origin.Y,Name,Prop1,Prop2) VALUES (101,1,1,'Sub1 1','1', '2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub2(Code,Origin.X,Origin.Y,Name,PropA,PropB) VALUES (201,1,1,'Sub2 1','A', 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "bc135bcc4384862b3390356422497cc037a290741ef29d311e1d3f428ca87110";
    const auto SCHEMA2_HASH_ECDB_MAP = "97f7dba66cf9300e4851bfed1a4af5c3f2b3f34af2f255a5a49a27bc77cf9588";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "fa35be3b944aeb606d51e60ff02e9a2b4caad5051882535bce90b0be77b66319";
    Test(
        "Add property to Sub1",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Geometric2dElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName="Origin" typeName="Point2d" />
                    </ECEntityClass>
                    <ECEntityClass typeName="PhysicalElement" modifier="Abstract" >
                        <BaseClass>Geometric2dElement</BaseClass>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="SubBase" modifier="Abstract" >
                        <BaseClass>PhysicalElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                        <ECProperty propertyName="Prop3" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and validate values to upgraded schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Origin.X,Origin.Y,Name,Prop1,Prop2,Prop3) VALUES (102,2,2,'Sub1 2','1', '2', 3)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            auto expected = JsonValue(R"json([{"Code":101,"Origin": {"x":1.0,"y":1.0},"Name": "Sub1 1", "Prop1":"1","Prop2":"2"},{"Code":102,"Origin": {"x":2.0,"y":2.0},"Name": "Sub1 2", "Prop1":"1","Prop2":"2", "Prop3": 3}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name, Prop1, Prop2, Prop3 FROM ts.Sub1"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(R"json([{"Code":201,"Origin": {"x":1.0,"y":1.0},"Name": "Sub2 1", "PropA":"A","PropB":1}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name,PropA, PropB FROM ts.Sub2"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "d2001aabeb5413315fbccf51e27d2631e79bee7a4fb56aaa441b4095af993904";
    const auto SCHEMA3_HASH_ECDB_MAP = "41528e6148f887e82d1881ee11edd47428de14855940adeb00c03924f722df97";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "fccbddbf34fd8230f25884931499595acb18dfa9345b273d605c2141bfbbe9f2";
    Test(
        "Add property to SubBase",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.2" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Code" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns="ECDbMap.02.00.00"/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Geometric2dElement" modifier="Abstract" >
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName="Origin" typeName="Point2d" />
                    </ECEntityClass>
                    <ECEntityClass typeName="PhysicalElement" modifier="Abstract" >
                        <BaseClass>Geometric2dElement</BaseClass>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="SubBase" modifier="Abstract" >
                        <BaseClass>PhysicalElement</BaseClass>
                        <ECProperty propertyName="Kind" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub1" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="Prop1" typeName="string" />
                        <ECProperty propertyName="Prop2" typeName="string" />
                        <ECProperty propertyName="Prop3" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" modifier="None" >
                        <BaseClass>SubBase</BaseClass>
                        <ECProperty propertyName="PropA" typeName="string" />
                        <ECProperty propertyName="PropB" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());

            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and validate values to final schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub1(Code,Origin.X,Origin.Y,Name,Kind,Prop1,Prop2,Prop3) VALUES (103,3,3,'Sub1 3',3,'1', '2', 3)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub2(Code,Origin.X,Origin.Y,Name,Kind,PropA,PropB) VALUES (202,2,2,'Sub2 2',2,'A', 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            auto expected = JsonValue(
                R"json([{"Code":101,"Origin": {"x":1.0,"y":1.0},"Name": "Sub1 1", "Prop1":"1","Prop2":"2"},
                {"Code":102,"Origin": {"x":2.0,"y":2.0},"Name": "Sub1 2", "Prop1":"1","Prop2":"2", "Prop3": 3},
                {"Code":103,"Origin": {"x":3.0,"y":3.0},"Name": "Sub1 3", "Kind":3, "Prop1":"1","Prop2":"2", "Prop3": 3}])json"
            );
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name,Kind,Prop1,Prop2,Prop3 FROM ts.Sub1"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            expected = JsonValue(
                R"json([{"Code":201,"Origin": {"x":1.0,"y":1.0},"Name": "Sub2 1", "PropA":"A","PropB":1},
                {"Code":202,"Origin": {"x":2.0,"y":2.0},"Name": "Sub2 2", "Kind":2, "PropA":"A","PropB":2}])json"
            );
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT Code,Origin,Name,Kind,PropA,PropB FROM ts.Sub2"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Add_Delete_ECProperty_ShareColumns)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "f3ac3f3c779506fc8e0568bb94a0a348c4e12b482e3e554da176e0be644caee1";
    const auto SCHEMA1_HASH_ECDB_MAP = "7ccad25164023d18df6d27269b9d3d04a61c60e4ef4daed1fd9196b530c4f0a8";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "7e7c571fae587a105f76a300ffed5b4f1ac2a7297c51e2bd1142fccf161029ea";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                        <ECProperty propertyName='P2' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test("Check Parent table column count", [&]() { ASSERT_EQ(4, GetColumnCount("ts_Parent")); });

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "93138d9b82f580c3196bbbd7e01c6693561d53fa1c2b0c8a5ddd86bd4d55bf03";
    const auto SCHEMA2_HASH_ECDB_MAP = "e2885712613bbc0caf2b7710a20430c1199f88172002083602e8d0c9956ef968";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "616136b709172fd8b18c5d9213f3c87b5c3d05a852787260324b52e009c45ae4";
    Test(
        "Upgrade with some attributes and import schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                        <ECProperty propertyName='P3' typeName='int' />
                        <ECProperty propertyName='P4' typeName='int' />
                        <ECProperty propertyName='P5' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify attributes of upgraded successfully",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
                        ASSERT_EQ(6, GetColumnCount("ts_Parent"));

                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Parent(P1, P3, P4, P5) VALUES(1, 2, 3, 4)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewPropertyModifyAllExistingAttributes)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "482c8e3b064ef4866027ed52003f319d83d4374385fb9c82430a8360af5b5c59";
    const auto SCHEMA1_HASH_ECDB_MAP = "82a4f93a397725447cf558de379c6f5a4c044c2de789edf25e9f889fbaf52a43";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' >
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "0def004efc014ab44efc82f5b84e08388897086e38bbd42bf3405028ab5c323c";
    const auto SCHEMA2_HASH_ECDB_MAP = "27eb6ad10db6eb8321f1bb6f50f4e7e758ae528f00dea0094ba8244cddbabd0f";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "8b832600509809548c2f2b03e1b963075e7b44395edb842ca660ed4c1c9ec9c1";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Modified Test Property' description='this is modified property' typeName='string' >
                        </ECProperty>
                        <ECProperty propertyName='NewTestProperty' displayLabel='New Test Property' description='this is new property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify Schema, Class, property and CAClassProperties attributes upgraded successfully",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            //Verify Schema, Class, property and CAClassProperties attributes upgraded successfully
            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_NE(testSchema, nullptr);
            ASSERT_EQ(testSchema->GetAlias(), "ts");
            ASSERT_EQ(testSchema->GetDisplayLabel(), "Modified Test Schema");
            ASSERT_EQ(testSchema->GetDescription(), "modified test schema");

            auto testClass = testSchema->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);
            ASSERT_EQ(testClass->GetDisplayLabel(), "Modified Test Class");
            ASSERT_EQ(testClass->GetDescription(), "modified test class");

            auto testProperty = testClass->GetPropertyP("TestProperty");
            ASSERT_NE(testProperty, nullptr);
            ASSERT_EQ(testProperty->GetDisplayLabel(), "Modified Test Property");
            ASSERT_EQ(testProperty->GetDescription(), "this is modified property");

            //verify newly added Property exists
            auto newTestProperty = testClass->GetPropertyP("NewTestProperty");
            ASSERT_NE(newTestProperty, nullptr);
            ASSERT_EQ(newTestProperty->GetDisplayLabel(), "New Test Property");
            ASSERT_EQ(newTestProperty->GetDescription(), "this is new property");

            //Verify attributes via ECSql using MataSchema
            ECSqlStatement statement;
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description, Alias FROM meta.ECSchemaDef WHERE Name='TestSchema'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Schema", statement.GetValueText(0));
            ASSERT_STREQ("modified test schema", statement.GetValueText(1));
            ASSERT_STREQ("ts", statement.GetValueText(2));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECClassDef WHERE Name='TestClass'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Class", statement.GetValueText(0));
            ASSERT_STREQ("modified test class", statement.GetValueText(1));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECPropertyDef WHERE Name='TestProperty'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Property", statement.GetValueText(0));
            ASSERT_STREQ("this is modified property", statement.GetValueText(1));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECPropertyDef WHERE Name='NewTestProperty'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("New Test Property", statement.GetValueText(0));
            ASSERT_STREQ("this is new property", statement.GetValueText(1));
            statement.Finalize();

            //Query existing and newly added Entity Classes
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT TestProperty, NewTestProperty FROM ts.TestClass"));
            ASSERT_EQ(DbResult::BE_SQLITE_DONE, statement.Step());
            statement.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewCAOnProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "482c8e3b064ef4866027ed52003f319d83d4374385fb9c82430a8360af5b5c59";
    const auto SCHEMA1_HASH_ECDB_MAP = "82a4f93a397725447cf558de379c6f5a4c044c2de789edf25e9f889fbaf52a43";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "31f58e3f67f6e434de26af890cd60058af4d970ed51d621e06719f557bcf8f6c";
    const auto SCHEMA2_HASH_ECDB_MAP = "92d4761e5e147a0a15cc49571291ca1c7f21493b8d00f0a769afd38a2960d297";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName = 'TestCA' appliesTo = 'PrimitiveProperty'>
                        <ECProperty propertyName = 'IsUnique' typeName = 'boolean' description = 'Only allow unique values for this property.' />
                        <ECProperty propertyName = 'Collation' typeName = 'string' description = 'Specifies how string comparisons should work for this property. Possible values: Binary (default): bit to bit matching. NoCase: The same as binary, except that the 26 upper case characters of ASCII are folded to their lower case equivalents before comparing. Note that it only folds ASCII characters. RTrim: The same as binary, except that trailing space characters are ignored.' />
                    </ECCustomAttributeClass>
                    <ECEntityClass typeName='TestClass' displayLabel='Modified Test Class' description='modified test class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Modified Test Property' description='this is modified property' typeName='string' >
                            <ECCustomAttributes>
                                <TestCA xmlns='TestSchema.01.00'>
                                    <IsUnique>false</IsUnique>
                                </TestCA>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify Schema, Class and property attributes upgraded successfully",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            //Verify Schema, Class and property attributes upgraded successfully
            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_NE(testSchema, nullptr);
            ASSERT_EQ(testSchema->GetAlias(), "ts");
            ASSERT_EQ(testSchema->GetDisplayLabel(), "Modified Test Schema");
            ASSERT_EQ(testSchema->GetDescription(), "modified test schema");

            auto testClass = testSchema->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);
            ASSERT_EQ(testClass->GetDisplayLabel(), "Modified Test Class");
            ASSERT_EQ(testClass->GetDescription(), "modified test class");

            auto testProperty = testClass->GetPropertyP("TestProperty");
            ASSERT_NE(testProperty, nullptr);
            ASSERT_EQ(testProperty->GetDisplayLabel(), "Modified Test Property");
            ASSERT_EQ(testProperty->GetDescription(), "this is modified property");

            //Verify attributes via ECSql using MataSchema
            ECSqlStatement statement;
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description, Alias FROM meta.ECSchemaDef WHERE Name='TestSchema'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Schema", statement.GetValueText(0));
            ASSERT_STREQ("modified test schema", statement.GetValueText(1));
            ASSERT_STREQ("ts", statement.GetValueText(2));

            statement.Finalize();
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECClassDef WHERE Name='TestClass'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Class", statement.GetValueText(0));
            ASSERT_STREQ("modified test class", statement.GetValueText(1));

            statement.Finalize();
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECPropertyDef WHERE Name='TestProperty'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Modified Test Property", statement.GetValueText(0));
            ASSERT_STREQ("this is modified property", statement.GetValueText(1));

            //Query Property
            statement.Finalize();
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT TestProperty FROM ts.TestClass"));
            ASSERT_EQ(DbResult::BE_SQLITE_DONE, statement.Step());

            //verify newly added CA on Property
            testProperty = m_briefcase->Schemas().GetSchema("TestSchema")->GetClassCP("TestClass")->GetPropertyP("TestProperty");
            ASSERT_NE(testProperty, nullptr);
            auto testCA = testProperty->GetCustomAttribute("TestCA");
            ASSERT_NE(testCA, nullptr);
            ECValue val;
            ASSERT_EQ(ECObjectsStatus::Success, testCA->GetValue(val, "IsUnique"));
            ASSERT_FALSE(val.GetBoolean());
            statement.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateECDbMapCA_AddMaxSharedColumnsBeforeOverflow)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "527e4f7e7f42ada3feb168b808bc7f7b4e8bcd0126c0feccb142ecbdc7ce4637";
    const auto SCHEMA1_HASH_ECDB_MAP = "cb2d5561bdf63a6e12212081a48862d73338de2d4964f0cb80fb675880d6815d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "97780c55b8972e6b86c8bd514db8948c6369dca78b94d4f14da12eb4d6dd8e59";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub' modifier='None' >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='P2' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, MaxSharedColumnsBeforeOverflowForSubClasses_AddProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "55e6002482091413020ed9d445251d173cd17c645ee32baee4e83fc1c2af211a";
    const auto SCHEMA1_HASH_ECDB_MAP = "6314fb2092ff0a231a12a50bcde1d90d64a6c58263d53718b4e34c8d58fa7591";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "9afc1fa2bb0dc6be01dea2ad48253e05cc127bbbd5134a205ee35602735f2ad7";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='S1' typeName='double' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test("Check Parent table column count", [&]() { ASSERT_EQ(4, GetColumnCount("ts_Parent")); });

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "62ff287b5e854e2b607ecfc7f4049941ff5a75447bb3d9b80c9b1823e8228a52";
    const auto SCHEMA2_HASH_ECDB_MAP = "5ca4e3f05088b4d40e4f8ed4c756ceba99ade166dc3d4ddd66f69b9c48bdfa66";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "bcd3a8ade2f995a66dc59b7dbeb79a18a19d566e76029e3029e065a6c9b49934";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='S1' typeName='double' />
                        <ECProperty propertyName='S2' typeName='double' />
                        <ECProperty propertyName='S3' typeName='double' />
                        <ECProperty propertyName='S4' typeName='double' />
                        <ECProperty propertyName='S5' typeName='double' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check Parent table column count of edited schema",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        ASSERT_EQ(8, GetColumnCount("ts_Parent"));

                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, MaxSharedColumnsBeforeOverflowWithJoinedTable_AddProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "72d492c18ecdfb5c9d22e2fc9e1ebcae349972d7be78a7040d79afeaf67eea3e";
    const auto SCHEMA1_HASH_ECDB_MAP = "ad20c24f80db11abc958f5f88be6963f917a5aba3038cdef6a20cfa8427ec6e1";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "1ac9eb8ed7dde6b0057bc57f4d9d160800e495b9424c9fca2090540bef948116";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='S1' typeName='double' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            // CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            ASSERT_ECDB_SCHEMA_HASH  (*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            ASSERT_ECDB_MAP_HASH     (*m_briefcase, SCHEMA1_HASH_ECDB_MAP);
            ASSERT_SQLITE_SCHEMA_HASH(*m_briefcase, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) {
                //CheckHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
                    ASSERT_ECDB_SCHEMA_HASH  (syncDb, SCHEMA1_HASH_ECDB_SCHEMA);
                    ASSERT_ECDB_MAP_HASH     (syncDb, SCHEMA1_HASH_ECDB_MAP);
                });
            }
    );

    Test(
        "Check table column counts",
        [&]()
            {
            ASSERT_EQ(3, GetColumnCount("ts_Parent"));
            ASSERT_EQ(3, GetColumnCount("ts_Sub1"));
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "f4878d964a644b436dacb9fb48ce2e5965dd7aa5740386caf7006e9c2032ed18";
    const auto SCHEMA2_HASH_ECDB_MAP = "03b35120cfc7a025601e8383bb2d143b80c61a6126d9f2769fd13de69f430e34";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "f7c6cd08cd9cf6a6b39f6c048819b0ead2192e7fb67e4493025d20430742f5a1";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                   </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='S1' typeName='double' />
                        <ECProperty propertyName='S2' typeName='double' />
                        <ECProperty propertyName='S3' typeName='double' />
                        <ECProperty propertyName='S4' typeName='double' />
                        <ECProperty propertyName='S5' typeName='double' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        // CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_ECDB_SCHEMA_HASH  (*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA);
                        ASSERT_ECDB_MAP_HASH     (*newBriefcase, SCHEMA1_HASH_ECDB_MAP);
                        ASSERT_SQLITE_SCHEMA_HASH(*newBriefcase, "ae5a6aa1c3e672de4ac4dc406cee1187661c7b5807c02988012e72c140647985");
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            // CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            ASSERT_ECDB_SCHEMA_HASH  (*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            ASSERT_ECDB_MAP_HASH     (*newBriefcase, SCHEMA2_HASH_ECDB_MAP);
            ASSERT_SQLITE_SCHEMA_HASH(*newBriefcase, "84bbd4adf50d92be2f91e99b1908c5bfae8ece0ba5f9e4f8609552f033c44088");
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) {
                ASSERT_ECDB_SCHEMA_HASH  (*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA);
                ASSERT_ECDB_MAP_HASH     (*newBriefcase, SCHEMA2_HASH_ECDB_MAP);
                //CheckHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP);
                });
            }
    );

    Test(
        "Check table column counts of edited schema",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        ASSERT_EQ(3, GetColumnCount("ts_Parent"));
                        ASSERT_EQ(7, GetColumnCount("ts_Sub1"));

                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ImportMultipleSchemaVersions_AddNewProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "5c23555b96567e545629e02fccfcaf4ffdc181025242c5f53e8702da57356ea3";
    const auto SCHEMA1_HASH_ECDB_MAP = "32608ea390282589dafbb36721fb70a9336a359434d056ab67dd245415c0f814";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "533fbcc8fc6a9a9efdb25aff7db7bdb91856955e6b8c236b3f5218b64361d533";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.2.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Schema upgrade with lower minor version not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify newly added property must not exist at this point",
        [&]()
            {
            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_NE(testSchema, nullptr);

            auto testClass = testSchema->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);

            auto testProperty = testClass->GetPropertyP("TestProperty");
            ASSERT_EQ(testProperty, nullptr);
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "19e2850510ac54893901108839240aa72f40b7a72cd6bd48c8dd3f47c8ef2b7b";
    const auto SCHEMA2_HASH_ECDB_MAP = "82a4f93a397725447cf558de379c6f5a4c044c2de789edf25e9f889fbaf52a43";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import edited schema with higher minor version with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.3.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*m_briefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify newly added property must exist after third schema import",
        [&]()
            {
            auto testSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            ASSERT_NE(testSchema, nullptr);

            auto testClass = testSchema->GetClassCP("TestClass");
            ASSERT_NE(testClass, nullptr);

            auto testProperty = testClass->GetPropertyP("TestProperty");
            ASSERT_NE(testProperty, nullptr);
            ASSERT_EQ(testProperty->GetDisplayLabel(), "Test Property");
            ASSERT_EQ(testProperty->GetDescription(), "this is property");

            ReopenECDb();

            ECSqlStatement statement;
            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT DisplayLabel, Description FROM meta.ECPropertyDef WHERE Name='TestProperty'"));
            ASSERT_EQ(DbResult::BE_SQLITE_ROW, statement.Step());
            ASSERT_STREQ("Test Property", statement.GetValueText(0));
            ASSERT_STREQ("this is property", statement.GetValueText(1));
            statement.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, statement.Prepare(*m_briefcase, "SELECT TestProperty FROM ts.TestClass"));
            ASSERT_EQ(DbResult::BE_SQLITE_DONE, statement.Step());
            statement.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateMultipleSchemasInDb)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "060ca2515704ccdba19312f70eb84f9bc289420c2b00a9a35ab4c69ef02a333b";
    const auto SCHEMA1_HASH_ECDB_MAP = "77b1a9c17a99904316b810f09889cae0f49a88194e07ecc35b4853b1570bcfb6";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "049a71f7160af033d7b57e8c315d17d5bca0fed3781f81e60b9da71583ed10ba";
    Test(
        "import initial schema",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("updateStartupCompanyschema.ecdb", SchemaItem::CreateForFile("DSCacheSchema.01.00.00.ecschema.xml")));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    Test(
        "Schema upgrade with lower minor version not allowed",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem::CreateForFile("DSCacheSchema.01.00.03.ecschema.xml")));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

// ---------------------------------------------------------------------------------------
// @bsimethod
// +---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UnsettingSchemaAlias)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "196c3dba02927f22033ef960281758702f3f48a5e52fa7e1dde012472ec7ea5d";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );
    Test(
        "Schema alias can't be set to empty",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, InvalidValueForSchemaAlias)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "196c3dba02927f22033ef960281758702f3f48a5e52fa7e1dde012472ec7ea5d";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "615c7cbe8e5146d30d1ad2a078ef1d6d2b72cb835a9688a5f347b18a0dd8d149";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema1' alias='ts1' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Try Upgrading to already existing alias",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts1' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, MajorVersionChange_WithoutMajorVersionIncremented)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "af7be50d60a542eea7ee73b740d6577b990de976e0bed125a0ca57f89e14469c";
    const auto SCHEMA1_HASH_ECDB_MAP = "fd957857f78f1211c894cd907c4f68fcc9a3cd9cd1f5066ad33575ce56899e8c";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "5f9d0f627116d1b5c25df711b3ace0455e1122e9552b90ebab2f5b4800f37653";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='3.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <ECProperty propertyName='S' typeName='string' />
                        <ECProperty propertyName='D' typeName='double' />
                        <ECProperty propertyName='L' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Major Version change without Major Version incremented is expected to be not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='3.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Schema Update with ECSchema Major Version decremented is expected to be not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <ECProperty propertyName='S' typeName='string' />
                        <ECProperty propertyName='D' typeName='double' />
                        <ECProperty propertyName='L' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Delete_ECDbMapCANotSupported)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "32d7cd8f9671cdd1ab18f7a9d4da2fa1a6ec689f21df0ef2c386fb1874dca69d";
    const auto SCHEMA1_HASH_ECDB_MAP = "15f9bf3ac0037f5ce8c270d1014480dd46319bbe42aa9b3393ac95fdce07b745";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "66da69352d1835f2ce0c2d05ea1cb1baa8fcb9c7b4fd021ae29ba7c5fc73e683";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='S' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete ECDbMap CA",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECProperty propertyName='S' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull from shared channel and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Delete_ECEntityClass_OwnTable)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "c7f8a071c0a9638b4fd840e3ede4aef82c3b264c37389457ee2f5a853ae9594f";
    const auto SCHEMA1_HASH_ECDB_MAP = "8d7ec81880ecdd60c65416cd3a1dfa453d06b1bfc3e3671332e3d3cee596e9c2";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ba51a2faf251723c905bdebb6154d0ebfddfb90a7e3ac5d181eac666e3316e61";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <ECProperty propertyName='S' typeName='string' />
                        <ECProperty propertyName='D' typeName='double' />
                        <ECProperty propertyName='L' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECProperty propertyName='S' typeName='string' />
                        <ECProperty propertyName='D' typeName='double' />
                        <ECProperty propertyName='L' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(S,D,L) VALUES ('test1', 1.3, 334)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(S,D,L) VALUES ('test2', 23.3, 234)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(S,D,L) VALUES ('test3', 44.32, 3344)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(S,D,L) VALUES ('test4', 13.3, 2345)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_TRUE(m_briefcase->TableExists("ts_Foo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete class returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECProperty propertyName='S' typeName='string' />
                        <ECProperty propertyName='D' typeName='double' />
                        <ECProperty propertyName='L' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and select values from edited schema",
        [&]()
            {
            ASSERT_TRUE(m_briefcase->TableExists("ts_Foo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT S, D, L FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT S, D, L FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(S,D,L) VALUES ('test1', 1.3, 334)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(S,D,L) VALUES ('test2', 23.3, 234)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Delete_Add_ECEntityClass_TPH)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "3909058e8f808f06e094e0ccca25e3f373c501376d4e3764e5da9f2844b8a88f";
    const auto SCHEMA1_HASH_ECDB_MAP = "9ce71ce4e533c0e9b8bf57198bae832a502d2ef9fc85bf6632d3a4994a9ec8b4";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "16559b7b4323066a05e869346c07e4f52505db2adf89f6c2bcfab2701739ddf2";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));

            ASSERT_EQ(8, GetColumnCount("ts_Goo"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL) VALUES ('test1', 1.3, 334)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL) VALUES ('test2', 23.3, 234)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test3', 44.32, 3344)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test4', 13.3, 2345)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "71ae05d6c0cdb615eaa64224e6f81394dd4255388d30eda7a56b45b87ce350bb";
    const auto SCHEMA2_HASH_ECDB_MAP = "30633e146c8a31c57969fc262a33ab94dabb20268b622a426b8de4e8b6050b61";
    Test(
        "Delete Foo class should be successful",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Select values from edited schema",
        [&]()
            {
            //Following should not exist
            ASSERT_EQ(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));

            //Following should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            //Verify number of columns should not change as we don't delete columns
            ASSERT_EQ(8, GetColumnCount("ts_Goo"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete Goo class returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='3.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "da8d41dbd13cf32ee133d3cf4797ae2bdbe4d152aedca9dabe5780eb7dcf2a0c";
    const auto SCHEMA3_HASH_ECDB_MAP = "5c33ccba9264ad19e7b4dbd19561fc92a0da11416aa6baf8111eb6db5b5ecae3";
    Test(
        "Adding new derived class should be successful",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='5.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and select values from edited schema",
        [&]()
            {
            //should exist
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);

            //following should not exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_EQ(8, GetColumnCount("ts_Goo"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL) VALUES ('test1', 1.3, 334)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL) VALUES ('test2', 23.3, 234)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Delete_Add_ECEntityClass_TPH_ShareColumns)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "57557dd238919eee8d9449f2bfb9eb99375599970806377dc5287ecb38532f4f";
    const auto SCHEMA1_HASH_ECDB_MAP = "b0d641919115e7f8bc8b45ff315a1d848b2d58f3a0c8559c5db40b373f915b94";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "5dfcae2814c747473d2e3d92fae39746d12fe3e1f4d54dd1444462c670eee54d";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub' modifier='None'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            //following table should exist.
            ASSERT_TRUE(m_briefcase->TableExists("ts_Base"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Base"), nullptr);

            //Following table should not exist
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Sub"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Sub"));

            ASSERT_EQ(6, GetColumnCount("ts_Base"));
            ASSERT_EQ(5, GetColumnCount("ts_Base_Overflow"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub(FS,FD,FL,FI) VALUES ('test1', 1.3, 334, 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub(FS,FD,FL,FI) VALUES ('test2', 23.3, 234, 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Base(GS,GD,GL) VALUES ('test3', 44.32, 3344)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Base(GS,GD,GL) VALUES ('test4', 13.3, 2345)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "8cdc8bf9cc4f2a466434800dd6c9b1cbe5bd1589d846dba7d8bdc4906176b1b9";
    const auto SCHEMA2_HASH_ECDB_MAP = "07423d2427c5cb77993d4569c71b23473bb691790b9c2a086768a5cd5f4c9c3f";
    Test(
        "Delete derived class should be successful",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Select values from edited schema",
        [&]()
            {
            //Following should not exist
            ASSERT_EQ(m_briefcase->Schemas().GetClass("TestSchema", "Sub"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Sub"));

            //Following should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Base"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Base"), nullptr);

            ASSERT_EQ(6, GetColumnCount("ts_Base")) << "After deleting subclass Foo";

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL FROM ts.Sub"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Base"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "test that the index definitions in ec_Index are cleaned up when a table is deleted",
        [&]()
            {
            Statement stmt;
            ASSERT_EQ(BE_SQLITE_OK, stmt.Prepare(*m_briefcase, "SELECT count(*) FROM ec_Index i JOIN ec_Table t ON i.TableId=t.Id WHERE t.Name LIKE 'ts_Base' COLLATE NOCASE"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << stmt.GetSql();
            ASSERT_EQ(1, stmt.GetValueInt(0)) << stmt.GetSql();
            stmt.Finalize();
            }
    );

    Test(
        "Delete class containing ECDbMap CA returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='3.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                   <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "93c5cb374d14a205fc169693c4338a9f12d547b361f246e0f78f421a4bfbc182";
    Test(
        "Adding new derived entity class is expected to be supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='5.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub' modifier='None'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and select values from edited schema",
        [&]()
            {
            //Table should not exist
            ASSERT_FALSE(m_briefcase->TableExists("ts_Sub"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Sub"), nullptr);

            //Table should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Base"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Base"), nullptr);

            ASSERT_EQ(6, GetColumnCount("ts_Base")) << "After readding subclass";
            ASSERT_EQ(5, GetColumnCount("ts_Base_Overflow")) << "After readding subclass";

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL FROM ts.Sub"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Base"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub(FS,FD,FL,FI) VALUES ('test1', 1.3, 334, 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Sub(FS,FD,FL,FI) VALUES ('test2', 23.3, 234, 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Delete_Add_ECEntityClass_TPH_MaxSharedColumnsBeforeOverflow)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "021dc9da7025160233ea62ecfa7d5d2a9ac0bdb107e8559fffa7c57bc5f7ea31";
    const auto SCHEMA1_HASH_ECDB_MAP = "f6a49635c6b2b3010fc1b7a3d7d6915c4b68c460edbbdaeca0f14acdc5c05a22";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "34d33dc96c7bb654829707f150f5043f54bd8ce00223605e18beb6395df31ae0";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias='ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            //following table should exist.
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            //Following table should not exist
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));

            ASSERT_EQ(9, GetColumnCount("ts_Goo"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test1', 1.3, 334, 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test2', 23.3, 234, 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test3', 44.32, 3344)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test4', 13.3, 2345)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "1b6cbd21278fef2a253a49ea4b9145e110bc90d46b40d10a23f3433effb40bf5";
    const auto SCHEMA2_HASH_ECDB_MAP = "8563af10f463fac0e47a8d780f5a4e55690997975dbbaf6a2defcd84c2f2c216";
    Test(
        "Delete derived class should be successful",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Select values from edited schema",
        [&]()
            {
            //Following should not exist
            ASSERT_EQ(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));

            //Following should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_EQ(9, GetColumnCount("ts_Goo")) << "after deleting subclass Foo";

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete class containing ECDbMap CA returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='3.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias = 'ecdbmap' />
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "79cf917d8807d9a5c342ea6fd0ae1c94e62064c6df674282dd4e45e405e14c2f";
    const auto SCHEMA3_HASH_ECDB_MAP = "6cc020da2cd3f730a06ef8ec56b4a91a2c50e65b4a661f11df920516fcb5ebcf";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "c9c389e6ce5d19e02647b7683c2bd9abfa50f679b1d12fb6bb9bc091f31ac117";
    Test(
        "New derived entity class is expected to be supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='5.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias='ecdbmap' />
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                        <ECProperty propertyName='FI1' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and select values from edited schema",
        [&]()
            {
            //Table should not exist
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);

            //Table should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_EQ(9, GetColumnCount("ts_Goo")) << "after readding subclass Foo";
            ASSERT_EQ(3, GetColumnCount("ts_Goo_Overflow")) << "after readding subclass Foo";

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI,FI1) VALUES ('test1', 1.3, 334, 1, 11)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI,FI1) VALUES ('test2', 23.3, 234, 2, 22)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Delete_Add_ECEntityClass_JoinedTable)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "58aafc70e26ae806d7ceab0e49dc28cb6d48ed97e3e05764be1625bc6cc9efca";
    const auto SCHEMA1_HASH_ECDB_MAP = "289e3a715e899c80c1569006197d220267e85679750a7c68577b20820150f811";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "198ea1e5fc10e61385477677ac014e133c4bd431279fa95b96e0385d2ac231f9";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            //Following Table should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Parent"), nullptr);

            //Following should not exist
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));

            ASSERT_EQ(3, GetColumnCount("ts_Parent"));
            ASSERT_EQ(9, GetColumnCount("ts_Goo"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test1', 1.3, 334, 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test2', 23.3, 234, 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test3', 44.32, 3344)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test4', 13.3, 2345)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "f923386ce1c2dda26bc043bbba1483c681430caf5e71ca3b0e4d2e1f63d8bada";
    const auto SCHEMA2_HASH_ECDB_MAP = "d2e26e8ae313511517c4f4691211abb5dbecb9c13de62fc3b904a1dcc55f8335";
    Test(
        "Delete a class should be successful",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Select values from edited schema",
        [&]()
            {
            //Following should not exist
            ASSERT_EQ(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));

            //Following should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Parent"), nullptr);

            ASSERT_EQ(3, GetColumnCount("ts_Parent"));
            ASSERT_EQ(9, GetColumnCount("ts_Goo"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL, FI FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete Derived ECClass returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='3.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting Class with CA JoinedTablePerDirectSubClass returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='4.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "c1a1ecfe4c91e537489093103796329783af7cc0ea95147430f9ca4a078085b0";
    const auto SCHEMA3_HASH_ECDB_MAP = "4f4c286309e28a5a0be4cf9236ab7127018b9cdc637d3df3048654fa1885918b";
    Test(
        "Adding new derived Entity class is supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='7.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and select values from edited schema",
        [&]()
            {
            //Table should not exist
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);

            //following tables should exist.
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Parent"), nullptr);

            ASSERT_EQ(9, GetColumnCount("ts_Goo"));
            ASSERT_EQ(3, GetColumnCount("ts_Parent"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test1', 1.3, 334, 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test2', 23.3, 234, 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Delete_Add_ECEntityClass_JoinedTable_ShareColumns)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "e8b42fa51573d515a72ab4cdcaccea0038c970054df80e243d58d9a601d958e2";
    const auto SCHEMA1_HASH_ECDB_MAP = "5aa493bfb683b5b1780b0bd983327875b61a9e6ebcf8b470b045e67e831af07d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "a1964e3088b720502599eabd2d466af61bf3503609f608109e2eeb983664ec13";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            //Following Table should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Parent"), nullptr);

            //Following should not exist
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));

            //Verify number of columns
            ASSERT_EQ(6, GetColumnCount("ts_Goo"));
            ASSERT_EQ(5, GetColumnCount("ts_Goo_Overflow"));
            ASSERT_EQ(3, GetColumnCount("ts_Parent"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test1', 1.3, 334, 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test2', 23.3, 234, 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test3', 44.32, 3344)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test4', 13.3, 2345)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "dc859550a439731c3968a704475a2cdebd2b10c95f1a76dddd87965782226885";
    const auto SCHEMA2_HASH_ECDB_MAP = "9ec77f222f9a48c957da916413cfa3c4d2da94ff68d0886010f4cf4ada3fa35e";
    Test(
        "Delete a class should be successful",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Select values from edited schema",
        [&]()
            {
            //Following should not exist
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));
            ASSERT_EQ(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);

            //Following should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Parent"), nullptr);

            ASSERT_EQ(6, GetColumnCount("ts_Goo")) << "after deleting subclass Foo";
            ASSERT_EQ(3, GetColumnCount("ts_Parent")) << "after deleting subclass Foo";

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL, FI FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete Derived ECClass returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='3.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting Class with CA JoinedTablePerDirectSubClass,SharedColumnForSubClasses returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='4.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias = 'ecdbmap' />
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "d8ccc32b99144a763a596b91e3f36f538b6e873a6d304c0b6dbd7496f3010234";
    const auto SCHEMA3_HASH_ECDB_MAP = "f6e6221c598b147aa19bff6805da975ed820d6eaa0cd828af179b962fef62294";
    Test(
        "Adding new derived Entity class is supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='7.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and select values from edited schema",
        [&]()
            {
            //Table should not exist
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);

            //following tables should exist.
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Parent"), nullptr);

            ASSERT_EQ(3, GetColumnCount("ts_Parent")) << "after readding subclass Foo";
            ASSERT_EQ(6, GetColumnCount("ts_Goo")) << "after readding subclass Foo";
            ASSERT_EQ(5, GetColumnCount("ts_Goo_Overflow")) << "after readding subclass Foo";

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test1', 1.3, 334, 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test2', 23.3, 234, 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Delete_Add_ECEntityClass_JoinedTable_MaxSharedColumnsBeforeOverflow)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "39305274d27357663c37efdedfdfe7c0c6b4257f81a0f908bc8334d2e5ca3840";
    const auto SCHEMA1_HASH_ECDB_MAP = "973f90485192c813263887c3f41185624851ed454b242fb4bf99b47035824cb4";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "801a00457ec6cfec7aacc913420a79ca358bbc889c92026a5c2bfee9577ee3ae";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert values to initial schema",
        [&]()
            {
            //Following Table should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Parent"), nullptr);

            //Following should not exist
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));

            ASSERT_EQ(3, GetColumnCount("ts_Parent"));
            ASSERT_EQ(9, GetColumnCount("ts_Goo"));

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test1', 1.3, 334, 1)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI) VALUES ('test2', 23.3, 234, 2)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test3', 44.32, 3344)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Goo(GS,GD,GL) VALUES ('test4', 13.3, 2345)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "44a15f359e9044c31c98445beb9b218c9008e2bb831c2664ceb60f8bd5ed6a76";
    const auto SCHEMA2_HASH_ECDB_MAP = "a57358f40710ec64b80aa22daeb3d15d44364a49e44983975151e23d813ff3f0";
    Test(
        "Delete a class should be successful",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Select values from edited schema",
        [&]()
            {
            //Following should not exist
            ASSERT_EQ(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));

            //Following should exist
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Parent"), nullptr);

            ASSERT_EQ(3, GetColumnCount("ts_Parent")) << "after deleting subclass Foo";
            ASSERT_EQ(9, GetColumnCount("ts_Goo")) << "after deleting subclass Foo";

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL, FI FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete Derived ECClass returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='3.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting Class with CA JoinedTablePerDirectSubclass_MaxSharedColumnsBeforeOverflow returns arbitrary schema changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='4.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                </ECSchema>)xml"
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "845a37a8587286952bf4eef2d472986b8180165e1f5d73181ca723e70c6d28c0";
    const auto SCHEMA3_HASH_ECDB_MAP = "274411327dd432eca4b16e9767ef4f6023c30cdc49bb5b662511a16175211b2c";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "d0b491b295d1bb6fc6c642e4bf23bd0c64f246d331275609ce7949e38d53ba9b";
    Test(
        "Adding new derived Entity class is supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='7.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Parent' modifier='None'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' modifier='None'>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <BaseClass>Goo</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                        <ECProperty propertyName='FI1' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert and select values from edited schema",
        [&]()
            {
            //Table should not exist
            ASSERT_FALSE(m_briefcase->TableExists("ts_Foo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Foo"), nullptr);

            //following tables should exist.
            ASSERT_TRUE(m_briefcase->TableExists("ts_Goo"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Goo"), nullptr);

            ASSERT_TRUE(m_briefcase->TableExists("ts_Parent"));
            ASSERT_NE(m_briefcase->Schemas().GetClass("TestSchema", "Parent"), nullptr);

            ASSERT_EQ(3, GetColumnCount("ts_Parent")) << "after readding subclass Foo";
            ASSERT_EQ(9, GetColumnCount("ts_Goo")) << "after readding subclass Foo";
            ASSERT_EQ(3, GetColumnCount("ts_Goo_Overflow")) << "after readding subclass Foo";

            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT FS, FD, FL, FI, FI1 FROM ts.Foo"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT GS, GD, GL FROM ts.Goo"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI,FI1) VALUES ('test1', 1.3, 334, 1, 11)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Foo(FS,FD,FL,FI,FI1) VALUES ('test2', 23.3, 234, 2, 22)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteSubclassOfRelationshipConstraintConstraint)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "86117e6e8e28e0e0904f08c19f0756d2cc0afb8d72b0bdde8cce0b3ddf47fe53";
    const auto SCHEMA1_HASH_ECDB_MAP = "21f8aefb2bf54fae5fa2ca4b6dcd3fa797d9ee6e73d2620d8e903a880be726d7";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "5cbb6c7c42cd803fffbc52396ef40811891501f3bb320e8129d9752ee0c15835";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <BaseClass>A</BaseClass>
                        <ECProperty propertyName='propB' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='C' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)' polymorphic='True' roleLabel='A'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..*)' polymorphic='True' roleLabel='C'>
                            <Class class='C' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "6bca1ecb935995d41930d910bb3c380127d790595112273b4733449320e71cbe";
    const auto SCHEMA2_HASH_ECDB_MAP = "31edd3c8ceaf653793ac40c4dcd38d8e96949fadf32e04261ee10c973020d617";
    Test(
        "Deleting subclass of ECRel ConstraintClass",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='C' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)' polymorphic='True' roleLabel='A'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..*)' polymorphic='True' roleLabel='C'>
                            <Class class='C' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull to briefcase and verify hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteConcreteImplementationOfAbstractConstraintClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "7c452bfa34ca65496602fb71f0ce01e4609720330d62649385495ce9b634cc3e";
    const auto SCHEMA1_HASH_ECDB_MAP = "bddc8a25f686ebf94004ef46deed9ecd995a91f3edda50edf25c8b4891f6d5c7";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "08407100a9a57f13600d84034ef3bdb9f845f42a455ffb95dd427da2ec56f5a9";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <BaseClass>A</BaseClass>
                        <ECProperty propertyName='propB' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='C' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propC' typeName='int' />
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='Backward' />
                    </ECEntityClass>
                    <ECEntityClass typeName='D' modifier='None' >
                        <BaseClass>C</BaseClass>
                        <ECProperty propertyName='propD' typeName='int' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='C' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert, update, select",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.B(ECInstanceId, propA, propB) VALUES(1, 11, 22)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.D(ECInstanceId, propC, propD) VALUES(2, 33, 44)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "UPDATE ts.C SET A.Id=1 WHERE ECInstanceId=2"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //Verify Insertion
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.RelClass"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "47de9e1fd9dfac716b6af61653f81cf2324fd3a7284a25c372cda53f5a826e0e";
    const auto SCHEMA2_HASH_ECDB_MAP = "10206c9ccbcdce37776b7dfeffb01279ece8822aa6a5e92e25bddc2a0d9bf510";
    Test(
        "delete subclass of abstract rel constraint class",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='C' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propC' typeName='int' />
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='C' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify relationship Instance should be deleted along with deletion of constaint class",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.RelClass"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteECRelationships)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "adbddf46a6019a5167d065d8bb28c47d339718e66500b753f60b300508c54b26";
    const auto SCHEMA1_HASH_ECDB_MAP = "b515828bbdb9bca89e5aab10dd3a73a35fc1de3b00b6bdbc94cb779c2aa67dbc";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "9ebdb1081bab7f8982f5e71e27407e4111117f545432de62afc7a3c63da439ff";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Roo' modifier='None'>
                        <ECProperty propertyName='S3' typeName='string' />
                        <ECNavigationProperty propertyName='Foo' relationshipName='EndTableRelationship' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='EndTableRelationship' modifier='Sealed' strength='Embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='Foo' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Roo' />
                        </Target>
                    </ECRelationshipClass>
                    <ECRelationshipClass typeName='LinkTableRelationship' modifier='Sealed' strength='referencing' strengthDirection='forward' >
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class='Foo' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Roo' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting ECRelationship with ForeignKey Mapping",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Roo' modifier='None'>
                        <ECProperty propertyName='S3' typeName='string' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='LinkTableRelationship' modifier='Sealed' strength='referencing' strengthDirection='forward' >
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class='Foo' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Roo' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, "fe32bb03ad747c6f59b139592099310370504c52b0d27844046ae8db140cfb25");
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deletion of LinkTable mapped relationship",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' modifier='None'>
                        <ECProperty propertyName='S1' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Roo' modifier='None'>
                        <ECProperty propertyName='S3' typeName='string' />
                        <ECNavigationProperty propertyName='Foo' relationshipName='EndTableRelationship' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='EndTableRelationship' modifier='Sealed' strength='Embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='Foo' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Roo' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, "fe32bb03ad747c6f59b139592099310370504c52b0d27844046ae8db140cfb25");
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ScopedDisableFailOnAssertion disableFailOnAssertion;
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull to briefcase and verify hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteECStructClassUnsupported)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "40151b95cbaa57d553df6eab5afff14d535a646a335b9c07df7c29eec952e303";
    const auto SCHEMA1_HASH_ECDB_MAP = "187df5f660c246dbe2d3f2c8571b1cc1821a068bc1071d266a40bd9a570901c6";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting ECStructClass is expected to be not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateECDbMapCA_DbIndexChanges)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "637acde7ca044e96c5663602f2087d6e6e13a67791f93925b7380bd86871c41a";
    const auto SCHEMA1_HASH_ECDB_MAP = "0ef928042698d3b19898a6a6c320ff424221dc7962476743dd7fe898d1e6d605";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "5bc0f3a9ca33bfdee5ca7eab4994ccec5cf4a8b9f668077b6d8310ffe74438c9";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A'>
                        <ECProperty propertyName='PA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='Sealed'>
                        <ECCustomAttributes>
                            <DbIndexList xmlns='ECDbMap.02.00'>
                                <Indexes>
                                    <DbIndex>
                                        <Name>IDX_Partial_Index</Name>
                                        <IsUnique>False</IsUnique>
                                        <Properties>
                                            <string>AId.Id</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                        <ECProperty propertyName='PB' typeName='int' />
                        <ECNavigationProperty propertyName='AId' relationshipName='AHasB' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='AHasB' strength='Embedding'>
                        <Source cardinality='(0,1)' polymorphic='False'>
                            <Class class ='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='False'>
                            <Class class ='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values",
        [&]()
            {
            auto b = m_briefcase->Schemas().GetClass("TestSchema", "B");
            ASSERT_NE(b, nullptr);
            auto ca = b->GetCustomAttribute("DbIndexList");
            ASSERT_FALSE(ca.IsNull());

            ECValue indexes, indexName;
            ASSERT_EQ(ca->GetValue(indexes, "Indexes", 0), ECObjectsStatus::Success);
            ASSERT_EQ(indexes.GetStruct()->GetValue(indexName, "Name"), ECObjectsStatus::Success);
            ASSERT_STREQ(indexName.GetUtf8CP(), "IDX_Partial_Index");

            Statement stmt;
            ASSERT_EQ(BE_SQLITE_OK, stmt.Prepare(*m_briefcase, "SELECT NULL FROM ec_Index WHERE Name='IDX_Partial_Index'"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Modifying DbIndex::Name",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A'>
                        <ECProperty propertyName='PA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='Sealed'>
                        <ECCustomAttributes>
                            <DbIndexList xmlns='ECDbMap.02.00'>
                                <Indexes>
                                    <DbIndex>
                                        <Name>IDX_Partial</Name>
                                        <IsUnique>False</IsUnique>
                                        <Properties>
                                            <string>AId.Id</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                        <ECProperty propertyName='PB' typeName='int' />
                        <ECNavigationProperty propertyName='AId' relationshipName='AHasB' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='AHasB' strength='Embedding'>
                        <Source cardinality='(0,1)' polymorphic='False'>
                            <Class class ='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='False'>
                            <Class class ='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting DbIndex",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A'>
                        <ECProperty propertyName='PA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='PB' typeName='int' />
                        <ECNavigationProperty propertyName='AId' relationshipName='AHasB' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='AHasB' strength='Embedding'>
                        <Source cardinality='(0,1)' polymorphic='False'>
                            <Class class ='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='False'>
                            <Class class ='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsitest
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNavigationProperty)
    {
    Utf8CP schemaTemplate = R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    %s
                    <ECEntityClass typeName="A" modifier="None">
                        <ECProperty propertyName="Prop1" typeName="string" />
                    </ECEntityClass>
                   <ECEntityClass typeName="B" modifier="None">
                        <ECProperty propertyName="Prop2" typeName="string" />
                        %s
                    </ECEntityClass>
                    <ECRelationshipClass typeName="Rel" modifier="None">
                            <Source multiplicity="(0..1)" polymorphic="True" roleLabel="owns">
                              <Class class="A"/>
                            </Source>
                            <Target multiplicity="(0..*)" polymorphic="True" roleLabel="is owned by">
                              <Class class="B"/>
                            </Target>
                     </ECRelationshipClass>
                </ECSchema>)xml";

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "0dab442f8b0686220fd413d9d3209b64befe5109294450eca1109b6507da44a1";
    const auto SCHEMA1_HASH_ECDB_MAP = "aea9674f696e7f4022f0f51718377d04db7d2875428a6b7daaa16f14026d255d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "f9bff300a58a7bb07ba22f6a7377fdd578c7e538ec3625166a9ffa362c945759";
    Test(
        "import initial schema",
        [&]()
            {
            Utf8String schemaXml;
            schemaXml.Sprintf(schemaTemplate, "", "");

            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate_addnavprop", SchemaItem(schemaXml)));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "now add nav prop (logical FK)",
        [&]()
            {
            Utf8String schemaXml;
            schemaXml.Sprintf(schemaTemplate, "", R"xml(<ECNavigationProperty propertyName="A" relationshipName="Rel" direction="Backward"/>)xml");

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem(schemaXml)));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "now add nav prop (physical FK)",
        [&]()
            {
            Utf8String schemaXml;
            schemaXml.Sprintf(schemaTemplate, R"xml(<ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>)xml",
                        R"xml(<ECNavigationProperty propertyName="A" relationshipName="Rel" direction="Backward">
                            <ECCustomAttributes>
                                <ForeignKeyConstraint xmlns="ECDbMap.02.00"/>
                            </ECCustomAttributes>
                        </ECNavigationProperty>)xml");

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem(schemaXml)));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteNavigationProperty)
    {
    Utf8CP schemaTemplate = R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="A" modifier="None">
                        <ECProperty propertyName="Prop1" typeName="string" />
                    </ECEntityClass>
                   <ECEntityClass typeName="B" modifier="None">
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Prop2" typeName="string" />
                        %s
                    </ECEntityClass>
                    <ECRelationshipClass typeName="Rel" modifier="None">
                            <Source multiplicity="(0..1)" polymorphic="True" roleLabel="owns">
                              <Class class="A"/>
                            </Source>
                            <Target multiplicity="(0..*)" polymorphic="True" roleLabel="is owned by">
                              <Class class="B"/>
                            </Target>
                     </ECRelationshipClass>
                </ECSchema>)xml";

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "909b6f993e4a169a6b427779ba200111ffd63ddcc455ca12aee97d271666e3f3";
    const auto SCHEMA1_HASH_ECDB_MAP = "0e3ccd36edde4c9c57066dfd338fa46d824a212870067a9e9fe930d9c3c2f963";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "eeedaa46cd9adc8c22873dd50b9d81a83f7196e3a3f5ac45f11265dde8b38666";
    Test(
        "import initial schema",
        [&]()
            {
            Utf8String schemaXml;
            schemaXml.Sprintf(schemaTemplate,"1.0", R"xml(<ECNavigationProperty propertyName="A" relationshipName="Rel" direction="Backward"/>)xml");

            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate_deletenavprop", SchemaItem(schemaXml)));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "now delete nav prop (logical FK)",
        [&]()
            {
            Utf8String schemaXml;
            schemaXml.Sprintf(schemaTemplate,"2.0", "");

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem(schemaXml)));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "2cf412efd228ea6c27e70279071af94449a081a5232009e004072786400e06f2";
    const auto SCHEMA2_HASH_ECDB_MAP = "61c30bea6f021eab794ea2742e3b3b253b480eb4e1ea5f0dd8305f75de0a95d0";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "3cca6dc1285815073d703b4c7fa6345b29ee675848b9f71e870ee5548a0c818e";
    Test(
        "second initial schema",
        [&]()
            {
            Utf8String schemaXml;
            schemaXml.Sprintf(schemaTemplate,"1.0", R"xml(<ECNavigationProperty propertyName="A" relationshipName="Rel" direction="Backward">
                            <ECCustomAttributes>
                                <ForeignKeyConstraint xmlns="ECDbMap.02.00"/>
                            </ECCustomAttributes>
                        </ECNavigationProperty>)xml");

            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate_deletenavprop", SchemaItem(schemaXml)));
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "now delete nav prop (physical FK)",
        [&]()
            {
            Utf8String schemaXml;
            schemaXml.Sprintf(schemaTemplate,"2.0", "");

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem(schemaXml)));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsitest
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddForeignKeyConstraint)
    {
    Utf8CP schemaTemplate = R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                   %s
                    <ECEntityClass typeName="A" modifier="None">
                        <ECProperty propertyName="Prop1" typeName="string" />
                    </ECEntityClass>
                   <ECEntityClass typeName="B" modifier="None">
                        <ECProperty propertyName="Prop2" typeName="string" />
                        <ECNavigationProperty propertyName="A" relationshipName="Rel" direction="Backward">
                            <ECCustomAttributes>
                            %s
                            </ECCustomAttributes>
                        </ECNavigationProperty>
                    </ECEntityClass>
                    <ECRelationshipClass typeName="Rel" modifier="None">
                            <Source multiplicity="(0..1)" polymorphic="True" roleLabel="owns">
                              <Class class="A"/>
                            </Source>
                            <Target multiplicity="(0..*)" polymorphic="True" roleLabel="is owned by">
                              <Class class="B"/>
                            </Target>
                     </ECRelationshipClass>
                </ECSchema>)xml";

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "ec36c0c78773f4ced8573c2aab248dfb60d2a2c598c2d57762cfb131984c92de";
    const auto SCHEMA1_HASH_ECDB_MAP = "bd1a814c0c4278144b8352cbc3f19933233edf7bf29b44670d071ed421d9829a";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "848e8c7519769a050ef826c336c6b04fc6708db81fff2e839d24a8b92a101d2e";
    Test(
        "import initial schema",
        [&]()
            {
            Utf8String schemaXml;
            schemaXml.Sprintf(schemaTemplate, "", "");

            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate_addforeignkeyconstraint", SchemaItem(schemaXml)));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "now add FKConstraint CA",
        [&]()
            {
            Utf8String schemaXml;
            schemaXml.Sprintf(schemaTemplate, R"xml(<ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>)xml",
                        R"xml(<ForeignKeyConstraint xmlns="ECDbMap.02.00"/>)xml");

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem(schemaXml)));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsitest
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddLinkTableRelationshipMap)
    {
    Utf8CP schemaTemplate = R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                   %s
                    <ECEntityClass typeName="A" modifier="None">
                        <ECProperty propertyName="Prop1" typeName="string" />
                    </ECEntityClass>
                   <ECEntityClass typeName="B" modifier="None">
                        <ECProperty propertyName="Prop2" typeName="string" />
                    </ECEntityClass>
                    <ECRelationshipClass typeName="Rel" modifier="None">
                            <ECCustomAttributes>
                            %s
                            </ECCustomAttributes>
                            <Source multiplicity="%s" polymorphic="True" roleLabel="owns">
                              <Class class="A"/>
                            </Source>
                            <Target multiplicity="(0..*)" polymorphic="True" roleLabel="is owned by">
                              <Class class="B"/>
                            </Target>
                     </ECRelationshipClass>
                </ECSchema>)xml";

    for (Utf8CP parentMultiplicity : {"(0..1)", {"(0..*)"}})
        {
        Test(
            "import initial schema",
            [&]()
                {
                Utf8String schemaXml;
                schemaXml.Sprintf(schemaTemplate, "", "", parentMultiplicity);

                ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate_addlinktablerelationshipmap", SchemaItem(schemaXml)));
                }
        );

        Test(
            "now add LinkTableRelationshipMap CA",
            [&]()
                {
                Utf8String schemaXml;
                schemaXml.Sprintf(schemaTemplate, R"xml(<ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>)xml",
                            R"xml(<LinkTableRelationshipMap xmlns="ECDbMap.02.00"/>)xml", parentMultiplicity);

                ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(SchemaItem(schemaXml)));
                ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
                }
        );
        }

    Test(
        "Check hashes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "580b67535f003c71a4cdba4302cf4677bf3973bfabdf5f531c98cf1cae821681";
            const auto SCHEMA_HASH_ECDB_MAP = "aea9674f696e7f4022f0f51718377d04db7d2875428a6b7daaa16f14026d255d";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "f9bff300a58a7bb07ba22f6a7377fdd578c7e538ec3625166a9ffa362c945759";
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Add_Class_NavigationProperty_RelationshipClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "90be13f04338cd797f527b8065d8918a20ba3e92c69b1c3799b103f598886edf";
    const auto SCHEMA1_HASH_ECDB_MAP = "6c849212bff95279f5eea47734e4bf4a77b04a33cc95e5de20c60602c16f0a7b";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "23e0479f1f76f94556724337c8d1c63baff8dc3021a35dc6efcbab352a654724";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A'>
                        <ECProperty propertyName='PA' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "9be976e84a9c5a1144fa560e7bd3396046a4bc84676b543d29e09eab031c8771";
    const auto SCHEMA2_HASH_ECDB_MAP = "602831279820e1dfbdd1e6eb95cce981fa2169349654627227291a18b2d4e76b";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "39056b8e377dfefa9ea7a77e5c92e04f1b716f4aae339dd6f63b504ad2eebcbd";
    Test(
        "delete subclass of abstract rel constraint class",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A'>
                        <ECProperty propertyName='PA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B'>
                        <ECProperty propertyName='PB' typeName='int' />
                        <ECNavigationProperty propertyName='AId' relationshipName='AHasB' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='AHasB' strength='Embedding' modifier='Sealed'>
                        <Source cardinality='(0,1)' polymorphic='False'>
                            <Class class ='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='False'>
                            <Class class ='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check hashes and classes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            auto entityClass = m_briefcase->Schemas().GetClass("TestSchema", "B");
            ASSERT_NE(entityClass, nullptr);

            auto relClass = m_briefcase->Schemas().GetClass("TestSchema", "AHasB");
            ASSERT_NE(relClass, nullptr);

            auto navProp = entityClass->GetPropertyP("AId")->GetAsNavigationProperty();
            ASSERT_NE(navProp, nullptr);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ValidateModifingAddingDeletingBaseClassNotSupported)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "e2fecb1a3d7bce648175544841eb3b451f837d93f027da52072cfb672af1c481";
    const auto SCHEMA1_HASH_ECDB_MAP = "d9a7f336de6566ba93c66675215ba7b9763a9094fb5d098f26a8db2621b73f4d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "4bacc358a2275ef555ef887a19f0a37388b75f7ea374e2f2ac28412382b13dc5";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass0' modifier='None' />
                    <ECEntityClass typeName='TestClass' modifier='None' />
                    <ECEntityClass typeName='Sub' modifier='None' >
                        <BaseClass>TestClass</BaseClass>
                    </ECEntityClass >
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting Base Class not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass0' modifier='None' />
                    <ECEntityClass typeName='TestClass' modifier='None' />
                    <ECEntityClass typeName='Sub' modifier='None' >
                    </ECEntityClass >
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Modifying Base Class not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass0' modifier='None' />
                    <ECEntityClass typeName='TestClass' modifier='None' />
                    <ECEntityClass typeName='Sub' modifier='None' >
                        <BaseClass>TestClass0</BaseClass>
                    </ECEntityClass >
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Adding new Base Class not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass0' modifier='None' />
                    <ECEntityClass typeName='TestClass' modifier='None' />
                    <ECEntityClass typeName='Sub' modifier='None' >
                        <BaseClass>TestClass</BaseClass>
                        <BaseClass>TestClass0</BaseClass>
                    </ECEntityClass >
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteExistingECEnumeration)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "415672227fed9420ade6f54300493f474ae7a70b55d6f156855be481a05310d4";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='False'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("DeleteExistingECEnumeration", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Deletion of ECEnumeration is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyECEnumeratorsOfPreEC32Enum)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "a5c631b4aa11ef9fceb8156d7e6604f2a4d4e3854e63bce6e7fb9feac47a43ea";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'log' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ModifyECEnumeratorsOfPreEC32Enum", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "f6bed0bf12bf5cbaac3a3b6190db79d13c682db1a790d6c285a83806d8e8993d";
    Test(
        "Deleting enumerator display label",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' />
                        <ECEnumerator value = '1' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Deleting enumerator",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "ab15e6e97d83c967a0a8711fac21d24285ccceac2142c44a93cf700ab63568a6";
    Test(
        "Changing enumerator names when the old schema originates from pre EC3.2 is allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='TxtFile' value = '0' displayLabel = 'txt' />
                        <ECEnumerator name='LogFile' value = '1' displayLabel = 'log' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Importing a pre EC3.2 schema as the old schemas's enumerator names were already changed away from the default name",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'log' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyECEnumeratorsOfEC32Enum)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "1cd5238890a8623c88e106ee8e71da12dd3736f82b160a8a71c89976933fb964";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='Txt' value = '0' displayLabel = 'txt' description='TXT Files'/>
                        <ECEnumerator name='Log' value = '1' displayLabel = 'log' description='LOG Files'/>
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ModifyECEnumeratorsOfEC32Enum", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Deleting enumerator display label",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "ffc55b8d8984be36a33b3dd136f3f5c7e350d2e792eef5db96e1451af3b86ce6";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='Txt' value = '0' description='TXT Files'/>
                        <ECEnumerator name='Log' value = '1' description='LOG Files'/>
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "34bf286700533110c6fbe540dc75f7edd90fdc6588319953d3598797299d9c00";
    Test(
        "Deleting enumerator description",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='Txt' value = '0' displayLabel = 'txt'/>
                        <ECEnumerator name='Log' value = '1' displayLabel = 'log'/>
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying enumerator name is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='Txt' value = '0' displayLabel = 'txt' description='TXT Files'/>
                        <ECEnumerator name='Log2' value = '1' displayLabel = 'log' description='LOG Files'/>
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Deleting enumerator",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='Log' value = '1' displayLabel = 'log' description='LOG Files' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "96885fd5a45ae32f69c4c83abb6e22799a2b982dd930ac1085fbfea4f0528c5e";
    Test(
        "Adding enumerator",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='Txt' value = '0' displayLabel = 'txt' />
                        <ECEnumerator name='Log' value = '1' displayLabel = 'log' />
                        <ECEnumerator name='Csv' value = '2' displayLabel = 'csv' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Adding enumerator with EC3.2 schema should fail because existing enumerator names will not match",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'log' />
                        <ECEnumerator value = '2' displayLabel = 'csv' />
                        <ECEnumerator value = '3' displayLabel = 'cpp' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyECEnumeratorNames)
    {
    Test(
        "import initial pre EC3.2 schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "a5c631b4aa11ef9fceb8156d7e6604f2a4d4e3854e63bce6e7fb9feac47a43ea";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'log' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ModifyECEnumeratorNames", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "ab15e6e97d83c967a0a8711fac21d24285ccceac2142c44a93cf700ab63568a6";
    Test(
        "Changing enumerator names when the old schema originates from pre EC3.2 is allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='TxtFile' value = '0' displayLabel = 'txt' />
                        <ECEnumerator name='LogFile' value = '1' displayLabel = 'log' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Changing the names again after it was upgraded to EC3.2 is not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='TxtFile1' value = '0' displayLabel = 'txt' />
                        <ECEnumerator name='LogFile' value = '1' displayLabel = 'log' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "ab15e6e97d83c967a0a8711fac21d24285ccceac2142c44a93cf700ab63568a6";
    Test(
        "import initial EC3.2 schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='TxtFile' value = '0' displayLabel = 'txt' />
                        <ECEnumerator name='LogFile' value = '1' displayLabel = 'log' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ModifyECEnumeratorNames", schema));
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Changing the names in an EC3.2 schema is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEnumeration typeName='MyEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator name='TxtFile1' value = '0' displayLabel = 'txt' />
                        <ECEnumerator name='LogFile' value = '1' displayLabel = 'log' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyExistingECEnumeration)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "cbbd84bab835742e70bcf82ce2d8a2bcd45e29fca7eb7af20f7b49a7c94bad27";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='False'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Upgrade with some attributes and import schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "415672227fed9420ade6f54300493f474ae7a70b55d6f156855be481a05310d4";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='False'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyIsEntityClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "f658d8871c57de304786ad7a38b5340463fd7fa8e008edff9c63962bf5c55a77";
    const auto SCHEMA1_HASH_ECDB_MAP = "32608ea390282589dafbb36721fb70a9336a359434d056ab67dd245415c0f814";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "533fbcc8fc6a9a9efdb25aff7db7bdb91856955e6b8c236b3f5218b64361d533";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing ECClass::IsEntityClass is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='TestClass' modifier='None' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyIsStructClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "d6779da832df90fdc5e695f6e46838de46f17697c17bce379f1505a47d6be552";
    const auto SCHEMA1_HASH_ECDB_MAP = "187df5f660c246dbe2d3f2c8571b1cc1821a068bc1071d266a40bd9a570901c6";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='TestClass' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing ECClass::IsStructClass is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyIsCustomAttributeClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "bfec501acb9a41992346585c6074a99487e1b3d9ef019b6a0e109e949261f008";
    const auto SCHEMA1_HASH_ECDB_MAP = "187df5f660c246dbe2d3f2c8571b1cc1821a068bc1071d266a40bd9a570901c6";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName='TestClass' appliesTo='EntityClass, RelationshipClass' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing ECClass::IsCustomAttributeClass is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts_modified' displayLabel='Modified Test Schema' description='modified test schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyIsRelationshipClass)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "93694e336458d096352d016deb3a03644582dc2500aaaf5f5589a9b2fbea97e5";
    const auto SCHEMA1_HASH_ECDB_MAP = "b4fab7be1e0ee832dc6ae275f5d2ae6680c5be3bb03ec17dde46604fc365352f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "fe060b45ef83e14c1eff11cbdd2ab8b864f5430a4d9ae2c39ee9581fcbf28a09";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing ECClass::IsRelationshipClass is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' />
                    <ECCustomAttributeClass typeName='RelClass' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Multiplicity_EndTableNonPersistedSideCardianlityCannotBeChanged)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "2004371e0ba722b2c2c13d9623b2e10e5215e87fca2ca82724cef2b208bbe809";
    const auto SCHEMA1_HASH_ECDB_MAP = "349f65fea84d6e2fc1bbedc11ecab63ca7c7601814057e9560d5ef270f677e21";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "45aaf35a5dd662b06d031fe8479e6056900e5c5ac2224fd134065826001185ff";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)' roleLabel='A has B' polymorphic='False'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..*)' roleLabel='B has A' polymorphic='False'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "end table non persisted side cardianlity cannot be changed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..2)' roleLabel='A has B' polymorphic='False'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..*)' roleLabel='B has A' polymorphic='False'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Multiplicity_ChangetoLowerLimitNotSupported)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "2004371e0ba722b2c2c13d9623b2e10e5215e87fca2ca82724cef2b208bbe809";
    const auto SCHEMA1_HASH_ECDB_MAP = "349f65fea84d6e2fc1bbedc11ecab63ca7c7601814057e9560d5ef270f677e21";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "45aaf35a5dd662b06d031fe8479e6056900e5c5ac2224fd134065826001185ff";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)' roleLabel='A has B' polymorphic='False'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..*)' roleLabel='B has A' polymorphic='False'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing lower limit of multiplicity is not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)' roleLabel='A has B' polymorphic='False'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(1..*)' roleLabel='B has A' polymorphic='False'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DisablePolymorphicNotSupported)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "e71ed59586de84fbe469ab0237e75af6d7b53ef34155273fe88b1d0724b15793";
    const auto SCHEMA1_HASH_ECDB_MAP = "fc15fb753581557451bfe91421335e870fae16c26068d4beac61e067f0d1df7a";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "6a5bca1806845949796efc27355d7924410e5901dedf37646330864282d0e5ae";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                    </ECEntityClass>
                    <ECRelationshipClass typeName='R' modifier='Sealed' strength='embedding' >
                        <Source multiplicity='(0..1)' roleLabel='A has B' polymorphic='true'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)' roleLabel='B has A' polymorphic='true'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing Polymorphic from true to false is not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                    </ECEntityClass>
                    <ECRelationshipClass typeName='R' modifier='Sealed' strength='embedding' >
                        <Source multiplicity='(0..1)'  roleLabel='A has B' polymorphic='false'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)'  roleLabel='B has A' polymorphic='false'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Polymorphic_LinkTable)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "477ea7eb5d56ab4fc002645becdcb93b101552b9fdb9097223300962fd46b2e9";
    const auto SCHEMA1_HASH_ECDB_MAP = "7f5d5cc7101c0ba9ed5d92dc5734183d29286ee5e91fa3cb5352811ee06e46eb";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "2f053fb1d579b73b2a0102c4675720dc0fc3c82b81af3205bc82a59d1d44426b";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)'  roleLabel='A has B' polymorphic='False'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)'  roleLabel='B has A' polymorphic='False'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "check initial schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.A"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.B"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.RelClass"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            const auto relClass = m_briefcase->Schemas().GetClass("TestSchema", "RelClass")->GetRelationshipClassCP();
            ASSERT_NE(relClass, nullptr);
            ASSERT_FALSE(relClass->GetSource().GetIsPolymorphic());
            ASSERT_FALSE(relClass->GetTarget().GetIsPolymorphic());

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "The class map for the link table ECRelationshipClass 'TestSchema:RelClass' maps to more than one table on the source constraint: ts_A,ts_A1",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)'  roleLabel='A has B' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)'  roleLabel='B has A' polymorphic='True'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                    <ECEntityClass typeName='A1' modifier='None' >
                        <BaseClass>A</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='B1' modifier='None' >
                        <BaseClass>B</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "464fee8b4044eac594c0efe9e3275c85a1cf0d98f974be33ac09f0d85e504a91";
    const auto SCHEMA2_HASH_ECDB_MAP = "899c4de94118f8916e752bc2fa886986b4945aad3568cb01395d6bb8b30514bf";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "a94644aaaf6be97183584203f0230acf5dbb3888c3aadc69b6ae50d5105375ab";
    Test(
        "initialize second initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Abstract' strength='embedding' strengthDirection='forward' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <Source multiplicity='(0..1)'  roleLabel='A has B' polymorphic='False'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)'  roleLabel='B has A' polymorphic='False'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaItemTph", schema));
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "check second schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.A"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.B"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.RelClass"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            const auto relClass = m_briefcase->Schemas().GetClass("TestSchema", "RelClass")->GetRelationshipClassCP();
            ASSERT_NE(relClass, nullptr);
            ASSERT_FALSE(relClass->GetSource().GetIsPolymorphic());
            ASSERT_FALSE(relClass->GetTarget().GetIsPolymorphic());

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "e5f079d4943fa0d57c4ff0af03d05c5d25fe1759d67e25a3463763d977a095e2";
    const auto SCHEMA3_HASH_ECDB_MAP = "0bbdb9be079f3f4c3b1e6849a31b25735c8fdf8e1fa62ca688d880f09f9e843f";
    Test(
        "changing RelationshipConstraint::IsPolymorphic is allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <Source multiplicity='(0..1)'  roleLabel='A has B' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)' roleLabel='B has A' polymorphic='True'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                    <ECEntityClass typeName='A1' modifier='None' >
                        <BaseClass>A</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='B1' modifier='None' >
                        <BaseClass>B</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "check updated schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.A"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.B"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.RelClass"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.A1"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.B1"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            const auto relClass = m_briefcase->Schemas().GetClass("TestSchema", "RelClass")->GetRelationshipClassCP();
            ASSERT_NE(relClass, nullptr);
            ASSERT_TRUE(relClass->GetSource().GetIsPolymorphic());
            ASSERT_TRUE(relClass->GetTarget().GetIsPolymorphic());

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Polymorphic_EndTable)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "ab2e55e7a6eb54d99a91fd744c3e9f95701e8ceb30d236d42763913e17b49231";
    const auto SCHEMA1_HASH_ECDB_MAP = "349f65fea84d6e2fc1bbedc11ecab63ca7c7601814057e9560d5ef270f677e21";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "45aaf35a5dd662b06d031fe8479e6056900e5c5ac2224fd134065826001185ff";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)' roleLabel='A has B' polymorphic='False'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)' roleLabel='B has A' polymorphic='False'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "check initial schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.A"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.B"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.RelClass"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            const auto relClass = m_briefcase->Schemas().GetClass("TestSchema", "RelClass")->GetRelationshipClassCP();
            ASSERT_NE(relClass, nullptr);
            ASSERT_FALSE(relClass->GetSource().GetIsPolymorphic());
            ASSERT_FALSE(relClass->GetTarget().GetIsPolymorphic());

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Failed to map ECRelationshipClass 'TestSchema:RelClass'. The referenced end maps to more than one table",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECEntityClass typeName='A' modifier='None' >
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)' roleLabel='A has B' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)' roleLabel='B has A' polymorphic='True'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                    <ECEntityClass typeName='A1' modifier='None' >
                        <BaseClass>A</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='B1' modifier='None' >
                        <BaseClass>B</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            /*
                Use class Change polymorphic=true and add derived classes
                Add dervied class A->A1 and B->B2 FK Relationship
            */
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "b6fb1496f130dab0aa2d5912cf7b4fe6c09a4cbe5addf273d3b7e80863305746";
    const auto SCHEMA2_HASH_ECDB_MAP = "fbae021e02376864dd33b2602b562aade7faf5d7928f6b82d9f65feb723102a5";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "8dba5e6123728118b507020259e2b56b4cb51cc9c79e6103383d4751561592a8";
    Test(
        "initialize second initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)' roleLabel='A has B' polymorphic='False'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)' roleLabel='B has A' polymorphic='False'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            /*
                Same has TPH
                Use class Change polymorphic=true and add derived classes
                Add dervied class A->A1 and B->B2 FK Relationship
            */
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaItemTPH", schema));
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "check second schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.A"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.B"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.RelClass"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            const auto relClass = m_briefcase->Schemas().GetClass("TestSchema", "RelClass")->GetRelationshipClassCP();
            ASSERT_NE(relClass, nullptr);
            ASSERT_FALSE(relClass->GetSource().GetIsPolymorphic());
            ASSERT_FALSE(relClass->GetTarget().GetIsPolymorphic());

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "d93ece995f70216b8273161fe7c6347d86223762cb1c8cdb04fda179cb26775e";
    const auto SCHEMA3_HASH_ECDB_MAP = "2f413bd9f3fc52c3aedd74f5acc846a81c16cbec01374c867d8c21455a162bfb";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "1937df873cb078445eb6e5452b2dfe55c558f7bc3a1a12ddb8201a004399f14d";
    Test(
        "changing RelationshipConstraint::IsPolymorphic is allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00.00' alias = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECNavigationProperty propertyName='A' relationshipName='RelClass' direction='backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source multiplicity='(0..1)' roleLabel='A has B' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target multiplicity='(0..N)' roleLabel='B has A' polymorphic='True'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                    <ECEntityClass typeName='A1' modifier='None' >
                        <BaseClass>A</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='B1' modifier='None' >
                        <BaseClass>B</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "check updated schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.A"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.B"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.RelClass"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.A1"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT * FROM ts.B1"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            const auto relClass = m_briefcase->Schemas().GetClass("TestSchema", "RelClass")->GetRelationshipClassCP();
            ASSERT_NE(relClass, nullptr);
            ASSERT_TRUE(relClass->GetSource().GetIsPolymorphic());
            ASSERT_TRUE(relClass->GetTarget().GetIsPolymorphic());

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyRelationship)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "93694e336458d096352d016deb3a03644582dc2500aaaf5f5589a9b2fbea97e5";
    const auto SCHEMA1_HASH_ECDB_MAP = "b4fab7be1e0ee832dc6ae275f5d2ae6680c5be3bb03ec17dde46604fc365352f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "fe060b45ef83e14c1eff11cbdd2ab8b864f5430a4d9ae2c39ee9581fcbf28a09";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing Relationship Cardinality not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' />
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing Relationship Cardinality not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing Constraint Class not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' />
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='B' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing Target Constraint Class not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' />
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing NonPolymorphic Source not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='False'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing NonPolymorphic Target not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='False'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing relationship Strength not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='referencing' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing relationship Strength Direction not allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='backward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyRelationshipConstrainsRoleLabel)
    {
    const auto SCHEMA1_HASH_ECDB_MAP = "576443ffbbd0fcc2d8112de5bea143aa20606bda1ac2ae882b92361aac89d1ae";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ce3378023ce0804fa8fb01266337ff1f0fe8b0e8d5c1ad6933ba82272b776334";
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "0c0bbe5eb0aee5e0cc66288c5ccd9a711721ccae66d31ef505807ceeb6866939";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <BaseClass>A</BaseClass>
                        <ECProperty propertyName='propB' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='C' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' roleLabel='A has C' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' roleLabel='C belongs to A' polymorphic='True'>
                            <Class class='C' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Modifying Source constraint class RoleLabel is expected to be successful",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "35497a5b2e9f78e2759cfe86ed90e2fe8a09acdfbf96c044b2a5c90ad2463798";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <BaseClass>A</BaseClass>
                        <ECProperty propertyName='propB' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='C' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' roleLabel='A has C Modified' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' roleLabel='C belongs to A' polymorphic='True'>
                            <Class class='C' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Modifying Target Constraint class Role Label is expected to be successful",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "70dc6416f986535e5c805851c22cd71f624bbc46fb7511a593b06ab89963f63d";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <BaseClass>A</BaseClass>
                        <ECProperty propertyName='propB' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='C' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' roleLabel='A has C Modified' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' roleLabel='C belongs to A Modified' polymorphic='True'>
                            <Class class='C' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Modifying both source and target class RoleLabels simultaneously is expected to be successful",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "ea5bfa2d5384c9113a34c2b4ede5d811e11cb94fe52703f6fa9b1fe4538867a2";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='propA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <BaseClass>A</BaseClass>
                        <ECProperty propertyName='propB' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='C' modifier='None' >
                        <ECNavigationProperty propertyName='Parent' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' roleLabel='A has B and C' polymorphic='True'>
                            <Class class='A' />
                        </Source>
                        <Target cardinality='(0,N)' roleLabel='B and C belong to A' polymorphic='True'>
                            <Class class='C' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyECProperties)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "ad872091eb4ad3e35c5fc603088a523c39b434a5d24f85f5532bd9d8d26bbcca";
    const auto SCHEMA1_HASH_ECDB_MAP = "8ff0ba50c343fa14ed0beab677dc51a4be0cd097000cc151ebbc33a8caf342ae";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "e58a7343e3a4cfbec3f395c81b27a7b494710f6cca507012310f6fddb1045ecf";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='PrimitiveProperty' typeName='string' readOnly='false' />
                        <ECArrayProperty propertyName='PrimitiveArrayProperty' minOccurs='0' maxOccurs='5' typeName='string' />
                        <ECStructProperty propertyName='structProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECStructArrayProperty propertyName='StructArrayProp' typeName='ChangeInfoStruct' minOccurs='0' maxOccurs='5' readOnly='false' />
                        <ECProperty propertyName='ExtendedProperty' typeName='string' extendedTypeName='URL' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "SchemaItem with modified ECProperty type",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='PrimitiveProperty' typeName='int' readOnly='false' />
                        <ECArrayProperty propertyName='PrimitiveArrayProperty' minOccurs='0' maxOccurs='5' typeName='string' />
                        <ECStructProperty propertyName='structProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECStructArrayProperty propertyName='StructArrayProp' typeName='ChangeInfoStruct' minOccurs='0' maxOccurs='5' readOnly='false' />
                        <ECProperty propertyName='ExtendedProperty' typeName='string' extendedTypeName='URL' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "SchemaItem with modified ECStructProperty type",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='PrimitiveProperty' typeName='string' readOnly='false' />
                        <ECArrayProperty propertyName='PrimitiveArrayProperty' minOccurs='0' maxOccurs='5' typeName='string' />
                        <ECStructArrayProperty propertyName='structProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECStructArrayProperty propertyName='StructArrayProp' typeName='ChangeInfoStruct' minOccurs='0' maxOccurs='5' readOnly='false' />
                        <ECProperty propertyName='ExtendedProperty' typeName='string' extendedTypeName='URL' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "SchemaItem with modified ECStructArrayProperty type",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='PrimitiveProperty' typeName='string' readOnly='false' />
                        <ECArrayProperty propertyName='PrimitiveArrayProperty' minOccurs='0' maxOccurs='5' typeName='string' />
                        <ECStructProperty propertyName='structProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECStructProperty propertyName='StructArrayProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECProperty propertyName='ExtendedProperty' typeName='string' extendedTypeName='URL' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "SchemaItem with modified IsPrimitiveArray Type",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='PrimitiveProperty' typeName='string' readOnly='false' />
                        <ECProperty propertyName='PrimitiveArrayProperty' typeName='string' minOccurs='0' maxOccurs='5' />
                        <ECStructProperty propertyName='structProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECStructArrayProperty propertyName='StructArrayProp' typeName='ChangeInfoStruct' minOccurs='0' maxOccurs='5' readOnly='false' />
                        <ECProperty propertyName='ExtendedProperty' typeName='string' extendedTypeName='URL' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "SchemaItem with modified IsPrimitive type",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECArrayProperty propertyName='PrimitiveProperty' typeName='string' readOnly='false' />
                        <ECArrayProperty propertyName='PrimitiveArrayProperty' minOccurs='0' maxOccurs='5' typeName='string' />
                        <ECStructProperty propertyName='structProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECStructArrayProperty propertyName='StructArrayProp' typeName='ChangeInfoStruct' minOccurs='0' maxOccurs='5' readOnly='false' />
                        <ECProperty propertyName='ExtendedProperty' typeName='string' extendedTypeName='URL' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "SchemaItem with Modified ECPropertyArray MinOccurs",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='PrimitiveProperty' typeName='string' readOnly='false' />
                        <ECArrayProperty propertyName='PrimitiveArrayProperty' minOccurs='1' maxOccurs='5' typeName='string' />
                        <ECStructProperty propertyName='structProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECStructArrayProperty propertyName='StructArrayProp' typeName='ChangeInfoStruct' minOccurs='0' maxOccurs='5' readOnly='false' />
                        <ECProperty propertyName='ExtendedProperty' typeName='string' extendedTypeName='URL' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "SchemaItem with Modified ECArrayProperty MaxOccurs",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='PrimitiveProperty' typeName='string' readOnly='false' />
                        <ECArrayProperty propertyName='PrimitiveArrayProperty' minOccurs='0' maxOccurs='10' typeName='string' />
                        <ECStructProperty propertyName='structProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECStructArrayProperty propertyName='StructArrayProp' typeName='ChangeInfoStruct' minOccurs='0' maxOccurs='10' readOnly='false' />
                        <ECProperty propertyName='ExtendedProperty' typeName='string' extendedTypeName='URL' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "e16c4929e0809d5b814f56949a36ab99dee5e6535c158ee869f08264c9c10869";
    const auto SCHEMA2_HASH_ECDB_MAP = "8ff0ba50c343fa14ed0beab677dc51a4be0cd097000cc151ebbc33a8caf342ae";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "e58a7343e3a4cfbec3f395c81b27a7b494710f6cca507012310f6fddb1045ecf";
    Test(
        "SchemaItem with Modifed Extended Type is allowed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECStructClass typeName='ChangeInfoStruct' modifier='None'>
                        <ECProperty propertyName='ChangeStatus' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='PrimitiveProperty' typeName='string' readOnly='false' />
                        <ECArrayProperty propertyName='PrimitiveArrayProperty' minOccurs='0' maxOccurs='5' typeName='string' />
                        <ECStructProperty propertyName='structProp' typeName='ChangeInfoStruct' readOnly='false' />
                        <ECStructArrayProperty propertyName='StructArrayProp' typeName='ChangeInfoStruct' minOccurs='0' maxOccurs='5' readOnly='false' />
                        <ECProperty propertyName='ExtendedProperty' typeName='string' extendedTypeName='email' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull to main briefcase and verify hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ExtendedTypeName)
    {
    auto assertExtendedType = [] (ECDbCR ecdb, Utf8CP propName, Utf8CP expectedExtendedTypeName)
        {
        ECClassCP fooClass = ecdb.Schemas().GetClass("TestSchema", "Foo");
        ASSERT_NE(fooClass, nullptr);
        ECPropertyCP prop = fooClass->GetPropertyP(propName);
        ASSERT_NE(prop, nullptr);
        if (expectedExtendedTypeName == nullptr)
            ASSERT_FALSE(prop->HasExtendedType()) << propName;
        else
            {
            if (prop->GetIsPrimitive())
                ASSERT_STREQ(expectedExtendedTypeName, prop->GetAsPrimitiveProperty()->GetExtendedTypeName().c_str()) << propName;
            else if (prop->GetIsPrimitiveArray())
                ASSERT_STREQ(expectedExtendedTypeName, prop->GetAsPrimitiveArrayProperty()->GetExtendedTypeName().c_str()) << propName;
            else
                FAIL() << propName << " Expected extended type name: " << expectedExtendedTypeName;
            }
        };

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "c588ef4c662462f6743ed41025458b5d81ee45979ccf7e1cbd232f0f153d8c7f";
    const auto SCHEMA1_HASH_ECDB_MAP = "9aebf4920f15addf9acc9d19472764c1dd565e631b2fd17ce7e818d795a80ce3";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b55ce698e0c9b47e0225ecd34bbc35d7ed84dd0db83d0f7e014afdfac0c97ee6";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="noext" typeName="string" />
                        <ECProperty propertyName="ext" typeName="string" extendedTypeName="url" />
                        <ECArrayProperty propertyName="noext_array" typeName="string"/>
                        <ECArrayProperty propertyName="ext_array" typeName="string" extendedTypeName="email"/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ModifyExtendedTypeName", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "assert initial schema values",
        [&]()
            {
            assertExtendedType(*m_briefcase, "noext", nullptr);
            assertExtendedType(*m_briefcase, "ext", "url");
            assertExtendedType(*m_briefcase, "noext_array", nullptr);
            assertExtendedType(*m_briefcase, "ext_array", "email");
            }
    );

    Test(
        "add extended type name",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "cd8bfccdce4dd558cc3fd8117387745202713f8c5ba2224105851f4291222d8b";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="noext" typeName="string" extendedTypeName="json" />
                        <ECProperty propertyName="ext" typeName="string" extendedTypeName="url" />
                        <ECArrayProperty propertyName="noext_array" typeName="string" extendedTypeName="xml"/>
                        <ECArrayProperty propertyName="ext_array" typeName="string" extendedTypeName="email"/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "assert modified schema values",
        [&]()
            {
            assertExtendedType(*m_briefcase, "noext", "json");
            assertExtendedType(*m_briefcase, "ext", "url");
            assertExtendedType(*m_briefcase, "noext_array", "xml");
            assertExtendedType(*m_briefcase, "ext_array", "email");
            }
    );

    Test(
        "modify extended type name",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "099f5392ec61d3a56c0983b8bf32c9ae6d4606aa41a943018fac0ddcee7309bb";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="noext" typeName="string" extendedTypeName="json" />
                        <ECProperty propertyName="ext" typeName="string" extendedTypeName="http" />
                        <ECArrayProperty propertyName="noext_array" typeName="string" extendedTypeName="xml"/>
                        <ECArrayProperty propertyName="ext_array" typeName="string" extendedTypeName="mail"/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "assert modified schema values",
        [&]()
            {
            assertExtendedType(*m_briefcase, "noext", "json");
            assertExtendedType(*m_briefcase, "ext", "http");
            assertExtendedType(*m_briefcase, "noext_array", "xml");
            assertExtendedType(*m_briefcase, "ext_array", "mail");
            }
    );

    Test(
        "remove extended type name",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "0e7a6abd44d0b41dd2a6c98fbf5d3ef96ade18d895e46bd1e645fa9740b21a68";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="noext" typeName="string" />
                        <ECProperty propertyName="ext" typeName="string" />
                        <ECArrayProperty propertyName="noext_array" typeName="string"/>
                        <ECArrayProperty propertyName="ext_array" typeName="string"/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "assert modified schema values",
        [&]()
            {
            assertExtendedType(*m_briefcase, "noext", nullptr);
            assertExtendedType(*m_briefcase, "ext", nullptr);
            assertExtendedType(*m_briefcase, "noext_array", nullptr);
            assertExtendedType(*m_briefcase, "ext_array", nullptr);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyNavigationProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "9a0bf3270d9b6f806b2a6fba584284ea5adbb5b3aad662cc09b0cb61371fc4f9";
    const auto SCHEMA1_HASH_ECDB_MAP = "c529a0b4938348861ad4f2b358f6c161e89492dcfcc7d9d6f35f3b9a9ae1a714";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "f60e87c0db266a4c4ee20dfa2574c81688374d1e4955cc4c0bb0ee9e3ecfa1ca";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A'>
                        <ECProperty propertyName='PA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='A1'>
                        <ECProperty propertyName='PA1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B'>
                        <ECProperty propertyName='PB' typeName='int' />
                        <ECNavigationProperty propertyName='A' relationshipName='AHasB' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='AHasB' modifier='Sealed' strength='Embedding'>
                        <Source cardinality='(0,1)' polymorphic='False'>
                            <Class class ='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='False'>
                            <Class class ='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing relationship Class Name for a Navigation property is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='A'>
                        <ECProperty propertyName='PA' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='A1'>
                        <ECProperty propertyName='PA1' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B'>
                        <ECProperty propertyName='PB' typeName='int' />
                        <ECNavigationProperty propertyName='A' relationshipName='A1HasB' direction='Backward' />
                        <ECNavigationProperty propertyName='NewA' relationshipName='AHasB' direction='Backward' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='AHasB' modifier='Sealed' strength='embedding'>
                        <Source cardinality='(0,1)' polymorphic='False'>
                            <Class class ='A' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='False'>
                            <Class class ='B' />
                        </Target>
                    </ECRelationshipClass>
                    <ECRelationshipClass typeName='A1HasB' modifier='Sealed' strength='embedding'>
                        <Source cardinality='(0,1)' polymorphic='False'>
                            <Class class ='A1' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='False'>
                            <Class class ='B' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyPropToReadOnly)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "7a60e51fa0776e9dc5fec38e86228c8268fe3ae8e0eca99ee89c8261cd2742b0";
    const auto SCHEMA1_HASH_ECDB_MAP = "0e6b7964080a41d9b43654199977ff3c922ab896bfc020837e54f7f9ba15599d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "da13c21f7d24e47ac7c9ee7e796493f2ff0d11bd58901ea8c3cf0ad5fdbd4e84";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='ReadWriteProp' typeName='string' readOnly='false' />
                        <ECProperty propertyName='P1' typeName='string' readOnly='true' />
                        <ECProperty propertyName='P2' typeName='string' readOnly='false' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify insert and update of initial schema",
        [&]()
            {
            /*-------------------After 1st Schema Import--------------------------
            ReadWriteProp -> ReadWrite
            P1            -> ReadOnly
            P2            -> ReadWrite
            */
            ECSqlStatement stmt;
            //Insert should be successfull
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.TestClass(ReadWriteProp, P1, P2) VALUES('RW1', 'P1_Val1', 'P2_Val1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //readonly property can't be updated
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "UPDATE ts.TestClass Set ReadWriteProp='RW1new', P1='P1_Val1new'"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            //skipping readonly Property, Update should be successful.
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "UPDATE ts.TestClass Set ReadWriteProp='RW1new', P2='P2_Val1new' WHERE P2='P2_Val1'"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "b9e300a3416e1b43b20ae66d7518b385f86280d37847dbfef34b545e0b46ace2";
    Test(
        "Modifying readonly Flag is expected to succeed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='ReadWriteProp' typeName='string' readOnly='false' />
                        <ECProperty propertyName='P1' typeName='string' readOnly='false' />
                        <ECProperty propertyName='P2' typeName='string' readOnly='true' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify insert, update, select and delete of edited schema",
        [&]()
            {
            /*-------------------After 2nd Schema Import--------------------------
            ReadWriteProp -> ReadWrite
            P1            -> ReadWrite
            P2            -> ReadOnly
            */
            ECSqlStatement stmt;
            //Verify Insert
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.TestClass(ReadWriteProp, P1, P2) VALUES('RW2', 'P1_Val2', 'P2_Val2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //Verify Update
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "UPDATE ts.TestClass SET ReadWriteProp='RW2new', P2='P2_Val2new'"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "UPDATE ts.TestClass SET ReadWriteProp='RW2new', P1='P1_Val2new' WHERE P1='P1_Val2'"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //Verify Select
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT P2 FROM ts.TestClass WHERE ReadWriteProp='RW1new'"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_STREQ("P2_Val1new", stmt.GetValueText(0));
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT P1 FROM ts.TestClass WHERE ReadWriteProp='RW2new'"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_STREQ("P1_Val2new", stmt.GetValueText(0));
            stmt.Finalize();

            //Verify Delete
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "DELETE FROM ts.TestClass"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT COUNT(*) FROM ts.TestClass"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_EQ(0, stmt.GetValueInt(0));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "7a60e51fa0776e9dc5fec38e86228c8268fe3ae8e0eca99ee89c8261cd2742b0";
    Test(
        "Modifying readonly Flag is expected to succeed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='ReadWriteProp' typeName='string' readOnly='false' />
                        <ECProperty propertyName='P1' typeName='string' readOnly='true' />
                        <ECProperty propertyName='P2' typeName='string' readOnly='false' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify insert, update, select and delete of edited schema",
        [&]()
            {
            /*-------------------After 3rd Schema Import--------------------------
            ReadWriteProp -> ReadWrite
            P1            -> ReadOnly
            P2            -> ReadWrite
            */
            ECSqlStatement stmt;
            //Insert should be successfull
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.TestClass(ReadWriteProp, P1, P2) VALUES('RW1', 'P1_Val3', 'P2_Val3')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //verify update
            //Update Prepare should fail for ReadOnlyProp
            ASSERT_EQ(ECSqlStatus::InvalidECSql, stmt.Prepare(*m_briefcase, "UPDATE ts.TestClass Set ReadWriteProp='RW3new', P1='P1_Val3new'"));
            ASSERT_EQ(BE_SQLITE_ERROR, stmt.Step());
            stmt.Finalize();

            //skipping readonly Property Update should be successful.
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "UPDATE ts.TestClass Set ReadWriteProp='RW3new', P2='P2_Val3new' WHERE P1 = 'P1_Val3'"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //Verify Delete
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "DELETE FROM ts.TestClass"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT COUNT(*) FROM ts.TestClass"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_EQ(0, stmt.GetValueInt(0));
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyPropToReadOnlyOnClientBriefcase)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "7a60e51fa0776e9dc5fec38e86228c8268fe3ae8e0eca99ee89c8261cd2742b0";
    const auto SCHEMA1_HASH_ECDB_MAP = "0e6b7964080a41d9b43654199977ff3c922ab896bfc020837e54f7f9ba15599d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "da13c21f7d24e47ac7c9ee7e796493f2ff0d11bd58901ea8c3cf0ad5fdbd4e84";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='ReadWriteProp' typeName='string' readOnly='false' />
                        <ECProperty propertyName='P1' typeName='string' readOnly='true' />
                        <ECProperty propertyName='P2' typeName='string' readOnly='false' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check and reset briefcase id",
        [&]()
            {
            ASSERT_EQ(m_briefcase->GetBriefcaseId().GetValue(), 11);
            m_briefcase->ResetBriefcaseId(BeBriefcaseId(123));
            ASSERT_EQ(m_briefcase->GetBriefcaseId().GetValue(), 123);
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            }
    );

    Test(
        "Modifying readonly Flag is expected to succeed",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "b9e300a3416e1b43b20ae66d7518b385f86280d37847dbfef34b545e0b46ace2";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='ReadWriteProp' typeName='string' readOnly='false' />
                        <ECProperty propertyName='P1' typeName='string' readOnly='false' />
                        <ECProperty propertyName='P2' typeName='string' readOnly='true' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyCustomAttributePropertyValues)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "001f82eb2ecb6aaaef7d245e5a7137d4a64b0d1e6ade63fa02c3624ff7197bcb";
    const auto SCHEMA1_HASH_ECDB_MAP = "3c3a41f6c682e5316c1e93250f0b7ae3a3fc924d5bbe2e1e638565c53d5d47f9";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "77af11ada178c9b759bec7717d606ddd7d1ccfae9168df93c3918729958ef815";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName = 'TestCA' appliesTo = 'PrimitiveProperty'>
                        <ECProperty propertyName = 'BinaryProp' typeName = 'Binary' />
                        <ECProperty propertyName = 'BooleanProp' typeName = 'boolean' />
                        <ECProperty propertyName = 'DateTimeProp' typeName = 'DateTime' />
                        <ECProperty propertyName = 'DoubleProp' typeName = 'Double' />
                        <ECProperty propertyName = 'IntegerProp' typeName = 'int' />
                        <ECProperty propertyName = 'LongProp' typeName = 'long' />
                        <ECProperty propertyName = 'Point2DProp' typeName = 'Point2D' />
                        <ECProperty propertyName = 'Point3DProp' typeName = 'Point3D' />
                        <ECProperty propertyName = 'StringProp' typeName = 'string' />
                    </ECCustomAttributeClass>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' >
                        <ECCustomAttributes>
                            <TestCA xmlns='TestSchema.01.00'>
                                <BinaryProp>10100101</BinaryProp>
                                <BooleanProp>true</BooleanProp>
                                <DateTimeProp>20160509</DateTimeProp>
                                <DoubleProp>1.0001</DoubleProp>
                                <IntegerProp>10</IntegerProp>
                                <LongProp>1000000</LongProp>
                                <Point2DProp>3.0,4.5</Point2DProp>
                                <Point3DProp>30.5,40.5,50.5</Point3DProp>
                                <StringProp>'This is String Property'</StringProp>
                            </TestCA>
                        </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "ee0b347dc640f1e2d106f19d96dac393a67e618634d36eebac0be5896398b8a3";
    Test(
        "Modifying CA instance properties values is supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' displayLabel='Test Schema' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName = 'TestCA' appliesTo = 'PrimitiveProperty'>
                        <ECProperty propertyName = 'BinaryProp' typeName = 'Binary' />
                        <ECProperty propertyName = 'BooleanProp' typeName = 'boolean' />
                        <ECProperty propertyName = 'DateTimeProp' typeName = 'DateTime' />
                        <ECProperty propertyName = 'DoubleProp' typeName = 'Double' />
                        <ECProperty propertyName = 'IntegerProp' typeName = 'int' />
                        <ECProperty propertyName = 'LongProp' typeName = 'long' />
                        <ECProperty propertyName = 'Point2DProp' typeName = 'Point2D' />
                        <ECProperty propertyName = 'Point3DProp' typeName = 'Point3D' />
                        <ECProperty propertyName = 'StringProp' typeName = 'string' />
                    </ECCustomAttributeClass>
                    <ECEntityClass typeName='TestClass' displayLabel='Test Class' description='This is test Class' modifier='None' >
                        <ECProperty propertyName='TestProperty' displayLabel='Test Property' description='this is property' typeName='string' >
                        <ECCustomAttributes>
                            <TestCA xmlns='TestSchema.01.00'>
                                <BinaryProp>10100011</BinaryProp>
                                <BooleanProp>false</BooleanProp>
                                <DateTimeProp>20160510</DateTimeProp>
                                <DoubleProp>2.0001</DoubleProp>
                                <IntegerProp>20</IntegerProp>
                                <LongProp>2000000</LongProp>
                                <Point2DProp>4.0,5.5</Point2DProp>
                                <Point3DProp>35.5,45.5,55.5</Point3DProp>
                                <StringProp>'This is Modified String Property'</StringProp>
                            </TestCA>
                        </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "check values and hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            Statement stmt;
            ASSERT_EQ(BE_SQLITE_OK, stmt.Prepare(*m_briefcase, "Select ec_CustomAttribute.[Instance] from ec_Property  INNER JOIN ec_CustomAttribute ON ec_CustomAttribute.[ContainerId] = ec_Property.[Id] Where ec_Property.[Name] = 'TestProperty'"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            const auto expected = "<TestCA xmlns=\"TestSchema.01.00\">\n    <BinaryProp>10100011</BinaryProp>\n    <BooleanProp>False</BooleanProp>\n    <DateTimeProp>20160510</DateTimeProp>\n    <DoubleProp>2.0001000000000002</DoubleProp>\n    <IntegerProp>20</IntegerProp>\n    <LongProp>2000000</LongProp>\n    <Point2DProp>4,5.5</Point2DProp>\n    <Point3DProp>35.5,45.5,55.5</Point3DProp>\n    <StringProp>'This is Modified String Property'</StringProp>\n</TestCA>\n";
            ASSERT_STREQ(expected, stmt.GetValueText(0));
            stmt.Finalize();
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteECCustomAttributeClass_Complex)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "03354c0af69d5a58e365f855e9e2322fbf467593d432c472058ce86e0b53a279";
    const auto SCHEMA1_HASH_ECDB_MAP = "5f054bc1e83be4b5e3f906e6cc6ba6b2c80ec66425ce5793ec8edf7be24a212d";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='T' nameSpacePrefix='T' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName = 'C01' appliesTo = 'Schema'>                      <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C02' appliesTo = 'EntityClass'>                 <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C03' appliesTo = 'CustomAttributeClass'>        <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C04' appliesTo = 'StructClass'>                 <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C05' appliesTo = 'RelationshipClass'>           <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C06' appliesTo = 'AnyClass'>                    <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C07' appliesTo = 'StructProperty'>              <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C08' appliesTo = 'ArrayProperty'>               <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C09' appliesTo = 'StructArrayProperty'>         <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C10' appliesTo = 'NavigationProperty'>          <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C11' appliesTo = 'AnyProperty'>                 <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C12' appliesTo = 'SourceRelationshipConstraint'><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C13' appliesTo = 'TargetRelationshipConstraint'><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C14' appliesTo = 'AnyRelationshipConstraint'>   <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C15' appliesTo = 'Any'>                         <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate_customAttributes", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    std::map<Utf8String, ECClassId> caClasses;
    for (ECClassCP ecClass : m_briefcase->Schemas().GetSchema("T")->GetClasses())
        if (ecClass->IsCustomAttributeClass())
            caClasses[ecClass->GetName()] = ecClass->GetId();

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "cbfea557c8cd19d815d30a1338fc882aba28df116c39cd16841adeb8139b3333";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='T' nameSpacePrefix='T' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributes><C01 xmlns='T.01.00'><S>test1_c01</S></C01></ECCustomAttributes>
                    <ECCustomAttributeClass typeName = 'C01' appliesTo = 'Schema'>                      <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c01</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C02' appliesTo = 'EntityClass'>                 <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c02</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C03' appliesTo = 'CustomAttributeClass'>                                                                                            <ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C04' appliesTo = 'StructClass'>                 <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c04</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C05' appliesTo = 'RelationshipClass'>           <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c05</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C06' appliesTo = 'AnyClass'>                    <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c06</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C07' appliesTo = 'StructProperty'>              <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c07</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C08' appliesTo = 'ArrayProperty'>               <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c08</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C09' appliesTo = 'StructArrayProperty'>         <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c09</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C10' appliesTo = 'NavigationProperty'>          <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c10</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C11' appliesTo = 'AnyProperty'>                 <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c11</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C12' appliesTo = 'SourceRelationshipConstraint'><ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c12</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C13' appliesTo = 'TargetRelationshipConstraint'><ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c13</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C14' appliesTo = 'AnyRelationshipConstraint'>   <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c14</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                    <ECCustomAttributeClass typeName = 'C15' appliesTo = 'Any'>                         <ECCustomAttributes><C03 xmlns='T.01.00'><S>test1_c15</S></C03></ECCustomAttributes><ECProperty propertyName = 'S' typeName = 'string' /></ECCustomAttributeClass>
                </ECSchema>)xml"
            );
            ReopenECDb();
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of edited schema",
        [&]()
            {
            auto stmt = m_briefcase->GetCachedStatement("SELECT NULL FROM ec_Class WHERE Id = ?");
            for (auto const& kp : caClasses)
                {
                stmt->ClearBindings();
                stmt->Reset();
                stmt->BindId(1, kp.second);
                ASSERT_EQ(BE_SQLITE_ROW, stmt->Step());
                }
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "2c095289850bc5969847a3cb5d7c19a003f429bcbe5ec0444ad5cacc02f98b6b";
    const auto SCHEMA3_HASH_ECDB_MAP = "6ca78cda694d59bb3a5c40be3c65f701f2a4c9d2ac5f540f7ab2ba1f0642f85a";
    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "ae7ad4e97e3565034c76b4e797368c6c9951037e95edce4c73b0799d8d2ea256";
    Test(
        "import second edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='T1' nameSpacePrefix='T1' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='T' version='01.00.00' prefix='T' />
                    <ECCustomAttributes><C01 xmlns='T.01.00'><S>test1_t1</S></C01></ECCustomAttributes>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECCustomAttributes>
                            <C02 xmlns = 'T.01.00'><S>entity_Class</S></C02>
                            <C06 xmlns = 'T.01.00'><S>any_class</S></C06>
                            <C15 xmlns = 'T.01.00'><S>any</S></C15>
                        </ECCustomAttributes>
                        <ECProperty propertyName='prop' typeName='boolean' >
                        <ECCustomAttributes>
                            <Localizable xmlns='CoreCustomAttributes.01.00'/>
                            <C11 xmlns = 'T.01.00'><S>AnyProperty</S></C11>
                            <C11 xmlns = 'T.01.00'><S>AnyProperty</S></C11>
                        </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of second edited schema",
        [&]()
            {
            int customAttributeInstances = 0;
            auto stmt = m_briefcase->GetCachedStatement("SELECT  NULL FROM ec_CustomAttribute WHERE ClassId = ?");
            for (auto const& kp : caClasses)
                {
                stmt->ClearBindings();
                stmt->Reset();
                stmt->BindId(1, kp.second);
                while (stmt->Step() == BE_SQLITE_ROW)
                    customAttributeInstances++;
                }
            ASSERT_EQ(20, customAttributeInstances);
            }
    );

    const auto SCHEMA4_HASH_ECDB_SCHEMA = "e76699170bf977e0cc3bf0468cc06d86fb48b17c00de68df2d087729843ffefd";
    const auto SCHEMA4_HASH_ECDB_MAP = "43aa68fd7a5b92a4e8588a665c68d0e4ce0f9f52d1ec0866317ca761ac2794d5";
    Test(
        "import final edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='T' nameSpacePrefix='T' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA4_HASH_ECDB_SCHEMA, SCHEMA4_HASH_ECDB_MAP, SCHEMA3_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA4_HASH_ECDB_SCHEMA, SCHEMA4_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of final edited schema",
        [&]()
            {
            auto stmt = m_briefcase->GetCachedStatement("SELECT  NULL FROM ec_Class WHERE Id = ?");
            for (auto const& kp : caClasses)
                {
                stmt->ClearBindings();
                stmt->Reset();
                stmt->BindId(1, kp.second);
                ASSERT_EQ(BE_SQLITE_DONE, stmt->Step());
                }

            stmt = m_briefcase->GetCachedStatement("SELECT  NULL FROM ec_ClassMap WHERE ClassId = ?");
            for (auto const& kp : caClasses)
                {
                stmt->ClearBindings();
                stmt->Reset();
                stmt->BindId(1, kp.second);
                ASSERT_EQ(BE_SQLITE_DONE, stmt->Step());
                }

            int customAttributeInstances = 0;
            stmt = m_briefcase->GetCachedStatement("SELECT  NULL FROM ec_CustomAttribute WHERE ClassId = ?");
            for (auto const& kp : caClasses)
                {
                stmt->ClearBindings();
                stmt->Reset();
                stmt->BindId(1, kp.second);
                while (stmt->Step() == BE_SQLITE_ROW)
                    customAttributeInstances++;
                }
            ASSERT_EQ(0, customAttributeInstances);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteECCustomAttributeClass_Simple)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "205ce8d1b9e54de1ff55b5ea1e936f057a3eb703320ec8ab4230db48199bb32d";
    const auto SCHEMA1_HASH_ECDB_MAP = "187df5f660c246dbe2d3f2c8571b1cc1821a068bc1071d266a40bd9a570901c6";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName = 'TestCA' appliesTo = 'PrimitiveProperty,EntityClass' />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "ae6495862b3292e69082cfcbf16e30c7f29c6b7899f0d7c9cbf909ba8afce766";
    const auto SCHEMA2_HASH_ECDB_MAP = "9c7834d13177336f0fa57105b9c1175b912b2e12e62ca2224482c0ffd9dfd337";
    Test(
        "Deleting a ECCustomAttributeClass",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteCustomAttribute)
    {
    const auto SCHEMA1_HASH_ECDB_MAP = "b3451bc7e45fc9c1ca0c9bc35ecee6619f91a59562ed82397701d00bdc1092c1";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "b045a712145d7714963d05ccbe62f7f0297865d4b87166a77d778cb5062c85eb";
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "816835b7f5e6a9e0369ccb6c4df1a5d590441664069db87b9a1997cf5fbad95a";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts_modified' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'CoreCustomAttributes' version = '01.00' alias = 'CoreCA' />
                    <ECCustomAttributes>
                        <DynamicSchema xmlns = 'CoreCustomAttributes.01.00' />
                    </ECCustomAttributes>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECCustomAttributes>
                            <ClassHasCurrentTimeStampProperty xmlns='CoreCustomAttributes.01.00'>
                                <PropertyName>LastMod</PropertyName>
                            </ClassHasCurrentTimeStampProperty>
                        </ECCustomAttributes>
                        <ECProperty propertyName='LastMod' typeName='dateTime' readOnly='True'/>
                        <ECProperty propertyName='prop' typeName='boolean' >
                        <ECCustomAttributes>
                            <Localizable xmlns='CoreCustomAttributes.01.00'/>
                        </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("deleteca", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Delete CA from Schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "e397125bb7faf341b2744b7671289761cbaacfead31cf6cc6bb2fca34143f96a";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts_modified' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'CoreCustomAttributes' version = '01.00' alias = 'CoreCA' />
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECCustomAttributes>
                            <ClassHasCurrentTimeStampProperty xmlns='CoreCustomAttributes.01.00'>
                                <PropertyName>LastMod</PropertyName>
                            </ClassHasCurrentTimeStampProperty>
                        </ECCustomAttributes>
                        <ECProperty propertyName='LastMod' typeName='dateTime' readOnly='True'/>
                        <ECProperty propertyName='prop' typeName='boolean' >
                        <ECCustomAttributes>
                            <Localizable xmlns='CoreCustomAttributes.01.00'/>
                        </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    Test(
        "check if custom attribute exists",
        [&]()
            {
            IECInstancePtr schemaCA = m_briefcase->Schemas().GetSchema("TestSchema")->GetCustomAttribute("DynamicSchema");
            ASSERT_EQ(schemaCA, nullptr);
            }
    );

    Test(
        "Delete CA from Schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "6beadb180f423b0433bb8d5b410992590fbbf5300606188367a59268f79dbcc9";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts_modified' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name = 'CoreCustomAttributes' version = '01.00' alias = 'CoreCA' />
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='LastMod' typeName='dateTime' />
                        <ECProperty propertyName='prop' typeName='boolean' >
                            <ECCustomAttributes>
                                <Localizable xmlns='CoreCustomAttributes.01.00'/>
                            </ECCustomAttributes>
                       </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    Test(
        "check if custom attributes exists",
        [&]()
            {
            IECInstancePtr classCA = m_briefcase->Schemas().GetSchema("TestSchema")->GetClassCP("TestClass")->GetCustomAttribute("CoreCustomAttributes", "ClassHasCurrentTimeStampProperty");
            ASSERT_EQ(classCA, nullptr);
            }
    );

    Test(
        "Delete CA from property",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "d63fb83ffed6cb20e5b7dd4ca5d6f0a92bddb04f6a3aa04d022fce12753e197d";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts_modified' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='LastMod' typeName='dateTime' />
                        <ECProperty propertyName='prop' typeName='boolean' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "check if any custom attribute exists",
        [&]()
            {
            int caCount = 0;
            for (IECInstancePtr ca : m_briefcase->Schemas().GetSchema("TestSchema")->GetClassCP("TestClass")->GetPropertyP("prop")->GetCustomAttributes(true))
                {
                caCount++;
                }

            ASSERT_EQ(0, caCount);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ChangesToExisitingTable)
    {
    auto employee1 = "Monifa Eli";
    auto employee2 = "Elfriede Lysistrate";
    auto employee3 = "Mildgy Kirstin";
    auto employee4 = "Maudie Iunia";

    Test("Setup empty ECDb", [&]() { ASSERT_EQ(SchemaImportResult::OK, SetupECDb("existingTableUpdate")); });

    Test(
        "Create existing table and insert rows",
        [&]()
            {
            m_briefcase->ExecuteSql("CREATE TABLE test_Employee(Id INTEGER PRIMARY KEY, Name TEXT);");
            m_briefcase->ExecuteSql(SqlPrintfString("INSERT INTO test_Employee (Id, Name) VALUES (101, '%s');",employee1));
            m_briefcase->ExecuteSql(SqlPrintfString("INSERT INTO test_Employee (Id, Name) VALUES (201, '%s');",employee2));
            m_briefcase->ExecuteSql(SqlPrintfString("INSERT INTO test_Employee (Id, Name) VALUES (301, '%s');",employee3));
            m_briefcase->ExecuteSql(SqlPrintfString("INSERT INTO test_Employee (Id, Name) VALUES (401, '%s');",employee4));
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "c6a2113aefb38fe0242ba3d0df31e5d836694bd2330086442396f7fe0b75ff1f";
    const auto SCHEMA1_HASH_ECDB_MAP = "f6a0dd072e1de66c6464263267d943b834b29dabcf65968991ce8057f532c500";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "dfff539d4fd7990e0704c0d0c4c4aead812af2f494369b94722fe18e33c4107d";
    Test(
        "Map ECSchema to exisitng table",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name='ECDbMap' version='02.00' alias='ecdbmap'/>
                    <ECEntityClass typeName='Employee' modifier='Sealed' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>ExistingTable</MapStrategy>
                                <TableName>test_Employee</TableName>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='Name' typeName='string' >
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Modify and add new existing table and relate it to another one",
        [&]()
            {
            m_briefcase->ExecuteSql("CREATE TABLE test_Title(Id INTEGER PRIMARY KEY, Name TEXT);");
            m_briefcase->ExecuteSql("INSERT INTO test_Title (Id, Name) VALUES (1, 'Senior Software Engineer');");
            m_briefcase->ExecuteSql("INSERT INTO test_Title (Id, Name) VALUES (2, 'Software Quality Analyst');");
            m_briefcase->ExecuteSql("INSERT INTO test_Title (Id, Name) VALUES (3, 'Advisory Software Engineer');");
            m_briefcase->ExecuteSql("INSERT INTO test_Title (Id, Name) VALUES (4, 'Distinguished Architect');");
            m_briefcase->ExecuteSql("ALTER TABLE test_Employee ADD COLUMN TitleId INTEGER REFERENCES test_Title(Id);");
            m_briefcase->ExecuteSql("UPDATE test_Employee SET TitleId = 1 WHERE Id = 101");
            m_briefcase->ExecuteSql("UPDATE test_Employee SET TitleId = 2 WHERE Id = 201");
            m_briefcase->ExecuteSql("UPDATE test_Employee SET TitleId = 3 WHERE Id = 301");
            m_briefcase->ExecuteSql("UPDATE test_Employee SET TitleId = 4 WHERE Id = 401");
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "87fd70107adba07c902832c15ae8a50f899c460a33247f5cc5132fdad509a65d";
    const auto SCHEMA2_HASH_ECDB_MAP = "5da9d82274583ba50f96d4723881d6d33614ce2b633359506b6c925a4ab98a5a";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "482dffcb077dc246d87f4ceea6eb23c1fbdf3625e79ce209bb7bfa5ff33fb945";
    Test(
        "Map ECSchema to exisitng table",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name='ECDbMap' version='02.00' alias='ecdbmap'/>
                    <ECEntityClass typeName='Employee' modifier='Sealed' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>ExistingTable</MapStrategy>
                                <TableName>test_Employee</TableName>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='Name' typeName='string' >
                        </ECProperty>
                        <ECNavigationProperty propertyName='TitleId' relationshipName='EmployeeHasTitle' direction='forward'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='Title' modifier='Sealed' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>ExistingTable</MapStrategy>
                                <TableName>test_Title</TableName>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='Name' typeName='string' >
                        </ECProperty>
                    </ECEntityClass>
                    <ECRelationshipClass typeName='EmployeeHasTitle' strength='referencing' strengthDirection='Backward' modifier='Sealed'>
                        <Source multiplicity='(0..*)' polymorphic='false' roleLabel='Employee'>
                            <Class class='Employee'/>
                        </Source>
                        <Target multiplicity='(0..1)' polymorphic='false' roleLabel='Title'>
                            <Class class='Title'/>
                        </Target>
                    </ECRelationshipClass>'
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "check if custom attributes exists",
        [&]()
            {
            ECSqlStatement stmt;
            stmt.Prepare(*m_briefcase, "SELECT E.Name EmployeeName, T.Name EmployeeTitle FROM ts.Employee E JOIN ts.Title T USING ts.EmployeeHasTitle ORDER BY E.ECInstanceId");

            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_STREQ(employee1, stmt.GetValueText(0));
            ASSERT_STREQ("Senior Software Engineer", stmt.GetValueText(1));

            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_STREQ(employee2, stmt.GetValueText(0));
            ASSERT_STREQ("Software Quality Analyst", stmt.GetValueText(1));

            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_STREQ(employee3, stmt.GetValueText(0));
            ASSERT_STREQ("Advisory Software Engineer", stmt.GetValueText(1));

            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step());
            ASSERT_STREQ(employee4, stmt.GetValueText(0));
            ASSERT_STREQ("Distinguished Architect", stmt.GetValueText(1));

            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteCAInstanceWithoutProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "a1437c54956f2014a9678da9c1d5ad65aeea17870d5ee4d14f46f91bb17e74d8";
    const auto SCHEMA1_HASH_ECDB_MAP = "671d76cb7b99813e58c768167a1177a28b6157027e35018ddfc6d683535cd837";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "3773503282c19580ff282c9fa26270dd0b6b318efe89dc56209a54b9c5f955df";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName = 'TestCA' appliesTo = 'PrimitiveProperty,EntityClass'>
                    </ECCustomAttributeClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECCustomAttributes>
                            <TestCA xmlns='TestSchema.01.00'>
                            </TestCA>
                        </ECCustomAttributes>
                        <ECProperty propertyName='prop' typeName='boolean' >
                        <ECCustomAttributes>
                            <TestCA xmlns='TestSchema.01.00'>
                            </TestCA>
                        </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("deletecainstancewithoutproperty", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "01f57eddc63e8a858f433a23aab57e387970aa135a8805b6b9dce2fb3f636e7f";
    Test(
        "Deleting a ECCustomAttributeClass",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECCustomAttributeClass typeName = 'TestCA' appliesTo = 'PrimitiveProperty,EntityClass'>
                    </ECCustomAttributeClass>
                    <ECEntityClass typeName='TestClass' modifier='None' >
                        <ECProperty propertyName='prop' typeName='boolean' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });

            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto ecSchema = m_briefcase->Schemas().GetSchema("TestSchema");
            auto testClass = ecSchema->GetClassCP("TestClass");
            auto ecProperty = testClass->GetPropertyP("prop");

            auto systemSchemaCA = ecSchema->GetCustomAttribute("SystemSchema");
            ASSERT_EQ(systemSchemaCA, nullptr);

            auto classCA = testClass->GetCustomAttribute("TestCA");
            ASSERT_EQ(classCA, nullptr);

            auto propertyCA = ecProperty->GetCustomAttribute("TestCA");
            ASSERT_EQ(propertyCA, nullptr);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddKoQAndUpdatePropertiesWithKoQ)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "7c3e55542f487d33c55d99adf4bf02dee3e63036024a40964d145f1877689122";
    const auto SCHEMA1_HASH_ECDB_MAP = "f2d5d71b823dd3298c0719e900404bf7bba8f0507e77e1d1ea74bc46ffb0deba";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "121610485f6708d108a30eec1bf8954c9d22dad7c46f64a46b68b4800670237e";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' />
                        <ECProperty propertyName='Homepage' typeName='string' />
                        <ECArrayProperty propertyName='AlternativeLengths' typeName='double' minOccurs='0' maxOccurs='unbounded' />
                        <ECArrayProperty propertyName='Favorites' typeName='string'  minOccurs='0' maxOccurs='unbounded' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("AddKoQAndUpdatePropertiesWithKoQ", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "bb8172839b677ede876645754fce67bd5a4121891fc94aed8063f08b169f0b02";
    Test(
        "Add KoQ And Update Properties With KoQ",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <KindOfQuantity typeName='MyKindOfQuantity' description='My KindOfQuantity'
                                    displayLabel='My KindOfQuantity' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN;M' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double'  kindOfQuantity='MyKindOfQuantity' />
                        <ECProperty propertyName='Homepage' typeName='string' extendedTypeName='URL' />
                        <ECArrayProperty propertyName='AlternativeLengths' typeName='double' minOccurs='0' maxOccurs='unbounded' kindOfQuantity = 'MyKindOfQuantity'/>
                        <ECArrayProperty propertyName='Favorites' typeName='string' extendedTypeName='URL' minOccurs='0' maxOccurs='unbounded' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto myKindOfQuantity = m_briefcase->Schemas().GetKindOfQuantity("TestSchema", "MyKindOfQuantity");
            ASSERT_NE(myKindOfQuantity, nullptr);
            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);

            auto foo_length = foo->GetPropertyP("Length")->GetAsPrimitiveProperty();
            ASSERT_NE(foo_length, nullptr);
            ASSERT_EQ(foo_length->GetKindOfQuantity(), myKindOfQuantity);

            auto foo_homepage = foo->GetPropertyP("Homepage")->GetAsPrimitiveProperty();
            ASSERT_NE(foo_homepage, nullptr);
            ASSERT_STREQ("URL", foo_homepage->GetExtendedTypeName().c_str());

            auto foo_alternativeLengths = foo->GetPropertyP("AlternativeLengths")->GetAsPrimitiveArrayProperty();
            ASSERT_NE(foo_alternativeLengths, nullptr);
            ASSERT_EQ(foo_alternativeLengths->GetKindOfQuantity(), myKindOfQuantity);

            auto foo_favorites = foo->GetPropertyP("Favorites")->GetAsPrimitiveArrayProperty();
            ASSERT_NE(foo_favorites, nullptr);
            ASSERT_STREQ("URL", foo_favorites->GetExtendedTypeName().c_str());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyPropertyType_PrimitiveToNonStrictEnum)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "673403d04fd08653bce50675c29d3715fc5eceb680c4b71accc4a3c12090a248";
    const auto SCHEMA1_HASH_ECDB_MAP = "c4c4f512f7ebe4eae2bae12c6c05c003fcf1b58e57f1722f3aff5d1274d8e863";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "e7510aa3d1cd96d6f7333d9f04ed7487185f14b393af616be1e7cbb2ffbc8c10";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "b47a36f7fdd4b1c278c14f38a76c394bce8653086208a1c3f678382ff8fcb894";
    Test(
        "changing primitive to NonString Enum is supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='False'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='NonStrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto nonStrictEnum = m_briefcase->Schemas().GetEnumeration("TestSchema", "NonStrictEnum");
            ASSERT_TRUE(nonStrictEnum != nullptr);

            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_TRUE(foo != nullptr);

            auto foo_type = foo->GetPropertyP("Type")->GetAsPrimitiveProperty();
            ASSERT_TRUE(foo_type != nullptr);
            ASSERT_TRUE(foo_type->GetEnumeration() == nonStrictEnum);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyPropertyType_PrimitiveToStrictEnum)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "673403d04fd08653bce50675c29d3715fc5eceb680c4b71accc4a3c12090a248";
    const auto SCHEMA1_HASH_ECDB_MAP = "c4c4f512f7ebe4eae2bae12c6c05c003fcf1b58e57f1722f3aff5d1274d8e863";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "e7510aa3d1cd96d6f7333d9f04ed7487185f14b393af616be1e7cbb2ffbc8c10";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing primitive to Strict Enum is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='StrictEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='StrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ReplaceKindOfQuantityWithSamePersistenceUnit)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "05b7136885fe091623ca388485b7cdfdd722d1bfab619cac2f02900834101cba";
    const auto SCHEMA1_HASH_ECDB_MAP = "5659388559d478844183f01f75b22a5832f850d1769a9ec5f13326079d7cbe2f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "092a472c7dc8e3e92377272c796d841e0c2f3a855eeb875f4df80f54637569bf";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double'  kindOfQuantity='KindOfQuantity1' />
                        <ECProperty propertyName='Homepage' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ReplaceKindOfQuantityWithSamePersistenceUnit", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "54f3f9cedd983b6a5452672c36d4e9546c31cac1426478efb649f6480be1a83f";
    Test(
        "Changing the KindOfQuantity of an ECProperty to another KindOfQuantity with same persistence unit",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN' />
                    <KindOfQuantity typeName='KindOfQuantity2' description='KindOfQuantity2'
                                    displayLabel='KindOfQuantity2' persistenceUnit='CM' relativeError='.2'
                                    presentationUnits='FT;IN' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' kindOfQuantity='KindOfQuantity2' />
                        <ECProperty propertyName='Homepage' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            auto KindOfQuantity2 = m_briefcase->Schemas().GetKindOfQuantity("TestSchema", "KindOfQuantity2");
            ASSERT_NE(KindOfQuantity2, nullptr);
            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);

            auto foo_length = foo->GetPropertyP("Length")->GetAsPrimitiveProperty();
            ASSERT_NE(foo_length, nullptr);
            ASSERT_EQ(foo_length->GetKindOfQuantity(), KindOfQuantity2);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ReplaceKindOfQuantityWithDifferentPersistenceUnit)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "62cf1c5cda1721e38167e06505d4527077a0517faa7035baf3b6ef578491ac8f";
    const auto SCHEMA1_HASH_ECDB_MAP = "64731feb471a02cf819d681c8296594419dc8196361ad87a53ba52facc017bb9";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "3ededf56f0dde0c1ee7a4396b6b2dc1b7828a62914d8b1f87b1ee65e53d8c800";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' kindOfQuantity='KindOfQuantity1' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ReplaceKindOfQuantityWithDifferentPersistenceUnit", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing the KindOfQuantity of an ECProperty to another KindOfQuantity with a different persistence unit.",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <KindOfQuantity typeName='KindOfQuantity2' description='KindOfQuantity2'
                                    displayLabel='KindOfQuantity2' persistenceUnit='u:M' relativeError='.2'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' kindOfQuantity='KindOfQuantity2' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing the KindOfQuantity of an ECProperty to another KindOfQuantity with a different persistence unit is allowed by using the AllowUnitChange custom attribute on the property. However, AllowUnitChange CA must have non-empty From and To properties.",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <ECSchemaReference name="SchemaUpgradeCustomAttributes" version="01.00.00" alias="SchemaUpgradeCA" />
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <KindOfQuantity typeName='KindOfQuantity2' description='KindOfQuantity2'
                                    displayLabel='KindOfQuantity2' persistenceUnit='u:M' relativeError='.2'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' kindOfQuantity='KindOfQuantity2' >
                            <ECCustomAttributes>
                                <AllowUnitChange xmlns="SchemaUpgradeCustomAttributes.01.00.00">
                                    <From>u:CM</From>
                                </AllowUnitChange>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing the KindOfQuantity of an ECProperty to another KindOfQuantity with a different persistence unit is allowed by using the AllowUnitChange custom attribute on the property. However, AllowUnitChange CA must have non-empty From and To properties.",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <ECSchemaReference name="SchemaUpgradeCustomAttributes" version="01.00.00" alias="SchemaUpgradeCA" />
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <KindOfQuantity typeName='KindOfQuantity2' description='KindOfQuantity2'
                                    displayLabel='KindOfQuantity2' persistenceUnit='u:M' relativeError='.2'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' kindOfQuantity='KindOfQuantity2' >
                            <ECCustomAttributes>
                                <AllowUnitChange xmlns="SchemaUpgradeCustomAttributes.01.00.00">
                                    <From>u:CM</From>
                                    <To></To>
                                </AllowUnitChange>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing the KindOfQuantity of an ECProperty to another KindOfQuantity with a different persistence unit is allowed by using the AllowUnitChange custom attribute on the property. However, AllowUnitChange CA must have non-empty From and To properties.",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <ECSchemaReference name="SchemaUpgradeCustomAttributes" version="01.00.00" alias="SchemaUpgradeCA" />
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <KindOfQuantity typeName='KindOfQuantity2' description='KindOfQuantity2'
                                    displayLabel='KindOfQuantity2' persistenceUnit='u:M' relativeError='.2'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' kindOfQuantity='KindOfQuantity2' >
                            <ECCustomAttributes>
                                <AllowUnitChange xmlns="SchemaUpgradeCustomAttributes.01.00.00">
                                </AllowUnitChange>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "7335670e88a93b1ff1cc1312c8b07ecb018b4d16888d869072539b1112101f44";
    const auto SCHEMA2_HASH_ECDB_MAP = "0f4879b8f4926961a823daa9c50418a8a7b145f6510182eb563042bf27708ccd";
    Test(
        "Changing the KindOfQuantity of an ECProperty to another KindOfQuantity with a different persistence unit is allowed by using the AllowUnitChange custom attribute on the property.",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <ECSchemaReference name="SchemaUpgradeCustomAttributes" version="01.00.00" alias="SchemaUpgradeCA" />
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <KindOfQuantity typeName='KindOfQuantity2' description='KindOfQuantity2'
                                    displayLabel='KindOfQuantity2' persistenceUnit='u:M' relativeError='.2'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' kindOfQuantity='KindOfQuantity2' >
                            <ECCustomAttributes>
                                <AllowUnitChange xmlns="SchemaUpgradeCustomAttributes.01.00.00">
                                    <From>u:CM</From>
                                    <To>u:M</To>
                                </AllowUnitChange>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteKindOfQuantityFromECSchema)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "4ed085173d29f9ef8b0467c15437bb32fb63dd96d386be754b3417cc02f0b159";
    const auto SCHEMA1_HASH_ECDB_MAP = "5659388559d478844183f01f75b22a5832f850d1769a9ec5f13326079d7cbe2f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "092a472c7dc8e3e92377272c796d841e0c2f3a855eeb875f4df80f54637569bf";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;CM' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double'  kindOfQuantity='MyKindOfQuantity' />
                        <ECProperty propertyName='Homepage' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting KindOfQuantity from an ECSchema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' />
                        <ECProperty propertyName='Homepage' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyECArrayProperty_KOQToKOQ)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "269ab53beb3ede2fbee40ef61928dab01fc6979b4639e232513e1a51fbbd6439";
    const auto SCHEMA1_HASH_ECDB_MAP = "f88b7eba7f064f04e0f4a014c5392235343e46aa2c3e6a219840f240a1a2cf2d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "1041d62154badc784bf9445ac7d1777ee7c9d591c17e76e694d2ac9426372c38";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN' />
                    <KindOfQuantity typeName='KindOfQuantity2' description='KindOfQuantity2'
                                    displayLabel='KindOfQuantity2' persistenceUnit='CM' relativeError='.2'
                                    presentationUnits='FT;IN' />
                    <KindOfQuantity typeName='KindOfQuantity3' persistenceUnit='M' relativeError='.1'
                                    presentationUnits='FT;IN' />
                    <ECEntityClass typeName='Foo' >
                        <ECArrayProperty propertyName='Length' typeName='double' minOccurs='0' maxOccurs='unbounded' kindOfQuantity = 'KindOfQuantity1'/>
                        <ECArrayProperty propertyName='Width' typeName='double' minOccurs='0' maxOccurs='unbounded' kindOfQuantity = 'KindOfQuantity2'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "ddd4ff30feeeab606d686231bb9267fc91e67c17bf36a6d95ae50535a82fd128";
    Test(
        "Changing of KindOfQuantity of an ECArrayProperty to another KindOfQuantity with same persistence unit",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN' />
                    <KindOfQuantity typeName='KindOfQuantity2' description='KindOfQuantity2'
                                    displayLabel='KindOfQuantity2' persistenceUnit='CM' relativeError='.2'
                                    presentationUnits='FT;IN' />
                    <KindOfQuantity typeName='KindOfQuantity3' persistenceUnit='M' relativeError='.1'
                                    presentationUnits='FT;IN' />
                    <ECEntityClass typeName='Foo' >
                        <ECArrayProperty propertyName='Length' typeName='double' minOccurs='0' maxOccurs='unbounded' kindOfQuantity = 'KindOfQuantity2'/>
                        <ECArrayProperty propertyName='Width' typeName='double' minOccurs='0' maxOccurs='unbounded' kindOfQuantity = 'KindOfQuantity1'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto KindOfQuantity1 = m_briefcase->Schemas().GetKindOfQuantity("TestSchema", "KindOfQuantity1");
            ASSERT_NE(KindOfQuantity1, nullptr);
            auto KindOfQuantity2 = m_briefcase->Schemas().GetKindOfQuantity("TestSchema", "KindOfQuantity2");
            ASSERT_NE(KindOfQuantity2, nullptr);
            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);

            auto foo_length = foo->GetPropertyP("Length");
            ASSERT_NE(foo_length, nullptr);
            auto foo_width = foo->GetPropertyP("Width");
            ASSERT_NE(foo_width, nullptr);

            ASSERT_EQ(foo_length->GetKindOfQuantity(), KindOfQuantity2);
            ASSERT_EQ(foo_width->GetKindOfQuantity(), KindOfQuantity1);
            }
    );

    Test(
        "Changing of KindOfQuantity of an ECArrayProperty to another KindOfQuantity with different persistence unit",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <KindOfQuantity typeName='KindOfQuantity1' description='KindOfQuantity1'
                                    displayLabel='KindOfQuantity1' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN' />
                    <KindOfQuantity typeName='KindOfQuantity2' description='KindOfQuantity2'
                                    displayLabel='KindOfQuantity2' persistenceUnit='CM' relativeError='.2'
                                    presentationUnits='FT;IN' />
                    <KindOfQuantity typeName='KindOfQuantity3' persistenceUnit='M' relativeError='.1'
                                    presentationUnits='FT;IN' />
                    <ECEntityClass typeName='Foo' >
                        <ECArrayProperty propertyName='Length' typeName='double' minOccurs='0' maxOccurs='unbounded' kindOfQuantity = 'KindOfQuantity2'/>
                        <ECArrayProperty propertyName='Width' typeName='double' minOccurs='0' maxOccurs='unbounded' kindOfQuantity = 'KindOfQuantity3'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, RemoveKindOfQuantityFromECArrayProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "99c072d184d3723418e9ad7b603ad4bda3c06fe50f2e6fd3405dfa9d503f41f3";
    const auto SCHEMA1_HASH_ECDB_MAP = "584ace5177fd0550ec8555f921b95f4adfb6a0c984e0615ed50358146725f3fa";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "3b86f6ab88c4041d828b67ca9989db90aa570a8561b99a2d6f7c564c072454aa";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN' />
                    <ECEntityClass typeName='Foo' >
                        <ECArrayProperty propertyName='Length' typeName='double' minOccurs='0' maxOccurs='unbounded' kindOfQuantity = 'MyKindOfQuantity'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verifying KOQ assigned to the property",
        [&]()
            {
            auto koq = m_briefcase->Schemas().GetKindOfQuantity("TestSchema", "MyKindOfQuantity");
            ASSERT_NE(koq, nullptr);

            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);

            ASSERT_EQ(koq, foo->GetPropertyP("Length")->GetKindOfQuantity());
            }
    );

    Test(
        "Removing KindOfQuantity from an ECArrayProperty is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN' />
                    <ECEntityClass typeName='Foo' >
                        <ECArrayProperty propertyName='Length' typeName='double' minOccurs='0' maxOccurs='unbounded'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, RemoveKindOfQuantityFromECProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "2d9ea90b3ce142c657f88507902146d47a0e1aeaf9df185e39140f90642e5c01";
    const auto SCHEMA1_HASH_ECDB_MAP = "64731feb471a02cf819d681c8296594419dc8196361ad87a53ba52facc017bb9";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "3ededf56f0dde0c1ee7a4396b6b2dc1b7828a62914d8b1f87b1ee65e53d8c800";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' kindOfQuantity='MyKindOfQuantity'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verifying KOQ assigned to the property",
        [&]()
            {
            auto koq = m_briefcase->Schemas().GetKindOfQuantity("TestSchema", "MyKindOfQuantity");
            ASSERT_NE(koq, nullptr);

            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);

            ASSERT_EQ(koq, foo->GetPropertyP("Length")->GetKindOfQuantity());
            }
    );

    Test(
        "Removing KindOfQuantity from an ECProperty is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='CM' relativeError='.5'
                                    presentationUnits='FT;IN' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, RemoveKindOfQuantityFromECPropertyUsingCA)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "abe4d45d8308bca3b8d6825cbcd63970c0d24ed26a0a4c072bbaffcbc3b678c3";
    const auto SCHEMA1_HASH_ECDB_MAP = "64731feb471a02cf819d681c8296594419dc8196361ad87a53ba52facc017bb9";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "3ededf56f0dde0c1ee7a4396b6b2dc1b7828a62914d8b1f87b1ee65e53d8c800";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' kindOfQuantity='MyKindOfQuantity' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ReplaceKindOfQuantityWithDifferentPersistenceUnit", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verifying KOQ assigned to the property",
        [&]()
            {
            auto koq = m_briefcase->Schemas().GetKindOfQuantity("TestSchema", "MyKindOfQuantity");
            ASSERT_NE(koq, nullptr);

            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);

            ASSERT_EQ(koq, foo->GetPropertyP("Length")->GetKindOfQuantity());
            }
    );

    Test(
        "Removing KindOfQuantity from an ECProperty is not supported with malformed AllowUnitChange CA",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' >
                            <ECCustomAttributes>
                                <AllowUnitChange xmlns="SchemaUpgradeCustomAttributes.01.00.00">
                                    <From>u:CM</From>
                                </AllowUnitChange>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Removing KindOfQuantity from an ECProperty is not supported with malformed AllowUnitChange CA",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' >
                            <ECCustomAttributes>
                                <AllowUnitChange xmlns="SchemaUpgradeCustomAttributes.01.00.00">
                                </AllowUnitChange>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Removing KindOfQuantity from an ECProperty is not supported with malformed AllowUnitChange CA",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' >
                            <ECCustomAttributes>
                                <AllowUnitChange xmlns="SchemaUpgradeCustomAttributes.01.00.00">
                                    <From>u:M</From>
                                    <To></To>
                                </AllowUnitChange>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "a8e47a16bc83df289944fec9cb9ae648a030d0f10ed4a35d80bc332683726dd9";
    const auto SCHEMA2_HASH_ECDB_MAP = "0f4879b8f4926961a823daa9c50418a8a7b145f6510182eb563042bf27708ccd";
    Test(
        "Removing KindOfQuantity from an ECProperty is supported by using custom attribute on property",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName='MyKindOfQuantity' description='MyKindOfQuantity'
                                    displayLabel='MyKindOfQuantity' persistenceUnit='u:CM' relativeError='.5'
                                    presentationUnits='f:AmerFI[u:FT][u:IN]' />
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Length' typeName='double' >
                            <ECCustomAttributes>
                                <AllowUnitChange xmlns="SchemaUpgradeCustomAttributes.01.00.00">
                                    <From>u:CM</From>
                                    <To></To>
                                </AllowUnitChange>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull, Verifying KOQ is removed from the property and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto fooClass = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(fooClass, nullptr);
            auto lengthProp = fooClass->GetPropertyP("Length");
            ASSERT_NE(lengthProp, nullptr);

            ASSERT_EQ(nullptr, lengthProp->GetKindOfQuantity());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, KoQDeleteWithDoNotFailFlag)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "a31eb400ef3940ade2cd37b085073054b7523be6b4052390bc733c62dda14ab4";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName="KoQ1" displayLabel="KoQ1" relativeError=".5" persistenceUnit="u:CM" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_KindOfQuantity", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Illegal KoQ modification should not fail when DoNotFail flag is on",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::DoNotFailForDeletionsOrModifications));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check if KindOfQuantity still exists",
        [&]()
            {
            auto schema = m_briefcase->Schemas().GetSchema("TestSchema");
            auto koq = schema->GetKindOfQuantityCP("KoQ1");
            ASSERT_NE(koq, nullptr) << "KindOfQuantity 'KoQ1' should still exist";
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, KoQModificationWithDoNotFailFlag)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "a31eb400ef3940ade2cd37b085073054b7523be6b4052390bc733c62dda14ab4";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName="KoQ1" persistenceUnit="u:CM" relativeError=".5" displayLabel="KoQ1" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_KindOfQuantity", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Illegal KoQ modification should not fail when DoNotFail flag is on",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "8420b2d0c008ce2e25c57abdc1b2b52aaaa0cb657c495316b2dd8a8b3b589325";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName="KoQ1" persistenceUnit="u:CM" relativeError=".5" displayLabel="New KoQ1 label" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::DoNotFailForDeletionsOrModifications));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check if KindOfQuantity still exists",
        [&]()
            {
            auto schema = m_briefcase->Schemas().GetSchema("TestSchema");
            auto koq = schema->GetKindOfQuantityCP("KoQ1");
            ASSERT_TRUE(koq != nullptr) << "KoQ1";
            EXPECT_STRCASEEQ("New KoQ1 label", koq->GetDisplayLabel().c_str()) << "Display label should be modified";
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, IllegalKoQModificationWithDoNotFailFlag)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "5f99a893290932cb3537193f6afe585b37f49cf4dc9b8bede66f5f0cc6e9ee9f";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName="KoQ1" description="KoQ1" relativeError=".5" persistenceUnit="u:CM" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_KindOfQuantity", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Illegal KoQ modification should not fail when DoNotFail flag is on",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <ECSchemaReference name="Formats" version="01.00.00" alias="f" />
                    <KindOfQuantity typeName="KoQ1" description="KoQ1" relativeError=".5" persistenceUnit="u:M" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::DoNotFailForDeletionsOrModifications));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check if KindOfQuantity still exists",
        [&]()
            {
            auto schema = m_briefcase->Schemas().GetSchema("TestSchema");
            auto koq = schema->GetKindOfQuantityCP("KoQ1");
            ASSERT_TRUE(koq != nullptr) << "KoQ1";
            EXPECT_STRCASEEQ("CM", koq->GetPersistenceUnit()->GetName().c_str()) << "PersistenceUnit should no be modified";
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, KindOfQuantity)
    {
    auto assertKoq = [] (ECSchemaCR schema, Utf8CP name, Utf8CP displayLabel, Utf8CP description, Utf8CP persUnit, Utf8CP presFormats, double relError)
        {
        KindOfQuantityCP koq = schema.GetKindOfQuantityCP(name);
        ASSERT_TRUE(koq != nullptr) << name;
        EXPECT_STRCASEEQ(name, koq->GetName().c_str()) << name;
        if (Utf8String::IsNullOrEmpty(displayLabel))
            EXPECT_FALSE(koq->GetIsDisplayLabelDefined()) << name;
        else
            EXPECT_STRCASEEQ(displayLabel, koq->GetDisplayLabel().c_str()) << name;

        if (Utf8String::IsNullOrEmpty(description))
            description = "";

        EXPECT_STRCASEEQ(description, koq->GetDescription().c_str()) << name;

        EXPECT_DOUBLE_EQ(relError, koq->GetRelativeError()) << name;
        EXPECT_STRCASEEQ(persUnit, koq->GetPersistenceUnit()->GetQualifiedName(koq->GetSchema()).c_str()) << name;
        Utf8String actualPresentationFormats;
        bool isFirstFormat = true;
        for (ECN::NamedFormatCR format : koq->GetPresentationFormats())
            {
            if (!isFirstFormat)
                actualPresentationFormats.append(";");

            actualPresentationFormats.append(format.GetQualifiedFormatString(koq->GetSchema()));
            isFirstFormat = false;
            }

        EXPECT_STRCASEEQ(presFormats, actualPresentationFormats.c_str()) << name;
        };

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "7c512d5897d77560dae8e27615916f4a2c2534f9a985a8bb0e123dcfc9dfc4d5";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                        <KindOfQuantity typeName="K1" description="My KOQ 1" displayLabel="KOQ 1" persistenceUnit="CM" relativeError="1" />
                        <KindOfQuantity typeName="K2" description="My KOQ 2" displayLabel="KOQ 2" persistenceUnit="M" presentationUnits="FT;IN" relativeError="2" />
                        <KindOfQuantity typeName="K3" description="My KOQ 3" displayLabel="KOQ 3" persistenceUnit="KG" presentationUnits="G" relativeError="3" />
                        <KindOfQuantity typeName="K4" description="My KOQ 4" displayLabel="KOQ 4" persistenceUnit="G" presentationUnits="MG" relativeError="4" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_KindOfQuantity", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "check initial schema values",
        [&]()
            {
            auto schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            assertKoq(*schema, "K1", "KOQ 1", "My KOQ 1", "u:CM", "", 1);
            assertKoq(*schema, "K2", "KOQ 2", "My KOQ 2", "u:M", "f:DefaultReal[u:FT];f:DefaultReal[u:IN]", 2);
            assertKoq(*schema, "K3", "KOQ 3", "My KOQ 3", "u:KG", "f:DefaultReal[u:G]", 3);
            assertKoq(*schema, "K4", "KOQ 4", "My KOQ 4", "u:G", "f:DefaultReal[u:MG]", 4);
            }
    );

    Test(
        "Deleting a KOQ is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <KindOfQuantity typeName="K1" description="My KOQ 1" displayLabel="KOQ 1" persistenceUnit="CM" relativeError="1" />
                    <KindOfQuantity typeName="K2" description="My KOQ 2" displayLabel="KOQ 2" persistenceUnit="M" presentationUnits="FT;IN" relativeError="2" />
                    <KindOfQuantity typeName="K4" description="My KOQ 4" displayLabel="KOQ 4" persistenceUnit="G" presentationUnits="MG" relativeError="4" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying the persistence unit is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <KindOfQuantity typeName="K1" description="My KOQ 1" displayLabel="KOQ 1" persistenceUnit="CM" relativeError="1" />
                    <KindOfQuantity typeName="K2" description="My KOQ 2" displayLabel="KOQ 2" persistenceUnit="CM" presentationUnits="FT;IN"  relativeError="3"/>
                    <KindOfQuantity typeName="K3" description="My KOQ 3" displayLabel="KOQ 3" persistenceUnit="KG" presentationUnits="G" relativeError="3" />
                    <KindOfQuantity typeName="K4" description="My KOQ 4" displayLabel="KOQ 4" persistenceUnit="G" presentationUnits="MG" relativeError="4" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Removing the relative error is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <KindOfQuantity typeName="K1" description="My KOQ 1" displayLabel="KOQ 1" persistenceUnit="CM" relativeError="1" />
                    <KindOfQuantity typeName="K2" description="My KOQ 2" displayLabel="KOQ 2" persistenceUnit="M" presentationUnits="FT;IN"/>
                    <KindOfQuantity typeName="K3" description="My KOQ 3" displayLabel="KOQ 3" persistenceUnit="KG" presentationUnits="G" relativeError="3" />
                    <KindOfQuantity typeName="K4" description="My KOQ 4" displayLabel="KOQ 4" persistenceUnit="G" presentationUnits="MG" relativeError="4" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "cb8c7902333a00b01b1f90e0c8205824355e540452bd27628761fb2504f09123";
    Test(
        "Adding a KOQ is supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <KindOfQuantity typeName="K1" description="My KOQ 1" displayLabel="KOQ 1" persistenceUnit="CM" relativeError="1" />
                    <KindOfQuantity typeName="K2" description="My KOQ 2" displayLabel="KOQ 2" persistenceUnit="M" presentationUnits="FT;IN" relativeError="2" />
                    <KindOfQuantity typeName="K3" description="My KOQ 3" displayLabel="KOQ 3" persistenceUnit="KG" presentationUnits="G" relativeError="3" />
                    <KindOfQuantity typeName="K4" description="My KOQ 4" displayLabel="KOQ 4" persistenceUnit="G" presentationUnits="MG" relativeError="4" />
                    <KindOfQuantity typeName="K5" description="My KOQ 5" displayLabel="KOQ 5" persistenceUnit="M" presentationUnits="M(Meters4u);IN(Inches4u);FT(fi8);FT(feet4u)" relativeError="5" />
                    <KindOfQuantity typeName="K6" description="My KOQ 6" displayLabel="KOQ 6" persistenceUnit="M" presentationUnits="M(Meters4u);IN(Inches4u);FT(fi8);FT(feet4u)" relativeError="6" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "check edited schema values",
        [&]()
            {
            auto schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            assertKoq(*schema, "K1", "KOQ 1", "My KOQ 1", "u:CM", "", 1);
            assertKoq(*schema, "K2", "KOQ 2", "My KOQ 2", "u:M", "f:DefaultReal[u:FT];f:DefaultReal[u:IN]", 2);
            assertKoq(*schema, "K3", "KOQ 3", "My KOQ 3", "u:KG", "f:DefaultReal[u:G]", 3);
            assertKoq(*schema, "K4", "KOQ 4", "My KOQ 4", "u:G", "f:DefaultReal[u:MG]", 4);
            assertKoq(*schema, "K5", "KOQ 5", "My KOQ 5", "u:M", "f:DefaultRealUNS(4)[u:M|m];f:DefaultRealUNS(4)[u:IN|&quot;];f:AmerFI;f:DefaultRealUNS(4)[u:FT|']", 5);
            assertKoq(*schema, "K6", "KOQ 6", "My KOQ 6", "u:M", "f:DefaultRealUNS(4)[u:M|m];f:DefaultRealUNS(4)[u:IN|&quot;];f:AmerFI;f:DefaultRealUNS(4)[u:FT|']", 6);
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "271ef4872091520d16c0d8928700dd81c83786bcb3962e63597e9efe16846ae6";
    Test(
        "Modifying a KOQ is supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.2" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <KindOfQuantity typeName="K1" displayLabel="KOQ 1" persistenceUnit="CM" presentationUnits="IN;FT" relativeError="1" />
                    <KindOfQuantity typeName="K2" description="My KOQ 2" persistenceUnit="M" presentationUnits="IN;FT" relativeError="2" />
                    <KindOfQuantity typeName="K3" description="My Nice KOQ 3" displayLabel="KOQ 3" persistenceUnit="KG" presentationUnits="G" relativeError="3" />
                    <KindOfQuantity typeName="K4" description="My KOQ 4" displayLabel="Nice KOQ 4" persistenceUnit="G" presentationUnits="KG;MG" relativeError="40" />
                    <KindOfQuantity typeName="K5" description="My KOQ 5" displayLabel="KOQ 5" persistenceUnit="M" presentationUnits="M(Meters4u);FT(fi8);FT(feet4u)" relativeError="5" />
                    <KindOfQuantity typeName="K6" description="My KOQ 6" displayLabel="KOQ 6" persistenceUnit="M" relativeError="6" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "check final schema values",
        [&]()
            {
            auto schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            assertKoq(*schema, "K1", "KOQ 1", nullptr, "u:CM", "f:DefaultReal[u:IN];f:DefaultReal[u:FT]", 1);
            //changing the order of pres units is supported
            assertKoq(*schema, "K2", nullptr, "My KOQ 2", "u:M", "f:DefaultReal[u:IN];f:DefaultReal[u:FT]", 2);
            assertKoq(*schema, "K3", "KOQ 3", "My Nice KOQ 3", "u:KG", "f:DefaultReal[u:G]", 3);
            //changing the order of pres units and adding a pres unit is supported
            assertKoq(*schema, "K4", "Nice KOQ 4", "My KOQ 4", "u:G", "f:DefaultReal[u:KG];f:DefaultReal[u:MG]", 40);
            assertKoq(*schema, "K5", "KOQ 5", "My KOQ 5", "u:M", "f:DefaultRealUNS(4)[u:M|m];f:AmerFI;f:DefaultRealUNS(4)[u:FT|']", 5);
            assertKoq(*schema, "K6", "KOQ 6", "My KOQ 6", "u:M", "", 6);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyPropertyType_PrimitiveToPrimitive)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "673403d04fd08653bce50675c29d3715fc5eceb680c4b71accc4a3c12090a248";
    const auto SCHEMA1_HASH_ECDB_MAP = "c4c4f512f7ebe4eae2bae12c6c05c003fcf1b58e57f1722f3aff5d1274d8e863";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "e7510aa3d1cd96d6f7333d9f04ed7487185f14b393af616be1e7cbb2ffbc8c10";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "changing primitive to another primitive",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyPropertyType_EnumToPrimitive)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "2fbc9acfd7bfd86e0ce6d7f71adf61a02384d6647a8e8d84cd98eff2c5e13a74";
    const auto SCHEMA1_HASH_ECDB_MAP = "c4c4f512f7ebe4eae2bae12c6c05c003fcf1b58e57f1722f3aff5d1274d8e863";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "e7510aa3d1cd96d6f7333d9f04ed7487185f14b393af616be1e7cbb2ffbc8c10";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='StrictEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='StrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "a5977d316a00e199cc827b1b2759a8fa6efb5a66f97999e7102ae254e85bb939";
    Test(
        "Changing Enum to primitive",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='StrictEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            auto strictEnum = m_briefcase->Schemas().GetEnumeration("TestSchema", "StrictEnum");
            ASSERT_NE(strictEnum, nullptr);
            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);

            auto foo_type = foo->GetPropertyP("Type")->GetAsPrimitiveProperty();
            ASSERT_NE(foo_type, nullptr);
            ASSERT_EQ(foo_type->GetEnumeration(), nullptr);
            ASSERT_EQ(foo_type->GetType(), PrimitiveType::PRIMITIVETYPE_Integer);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyPropertyType_EnumToEnum)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "9c28c66effaf094d4633ffc89eb62a4038c838993a888d7dff855ab2a71a6f8e";
    const auto SCHEMA1_HASH_ECDB_MAP = "9b921ce3ee8793491224ba570b16f0bc3f2213c998394196d99cde40f7711796";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "52c7fc1b63f5be3a0315cb55cf08e1a9d414242a8d2c7438ec7d8a80fe3d2753";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='StrictEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEnumeration typeName='UnStrictEnum' backingTypeName='int' isStrict='False'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='StrictEnum' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' >
                        <ECProperty propertyName='Type' typeName='UnStrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "46a657a7179fbe28c86db0cca6f059f1f9b31c3116ba41d507cf95b0e240d14a";
    Test(
        "changing Enum to Enum",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='StrictEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEnumeration typeName='UnStrictEnum' backingTypeName='int' isStrict='False'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='UnStrictEnum' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Goo' >
                        <ECProperty propertyName='Type' typeName='StrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            auto strictEnum = m_briefcase->Schemas().GetEnumeration("TestSchema", "StrictEnum");
            ASSERT_NE(strictEnum, nullptr);
            auto unstrictEnum = m_briefcase->Schemas().GetEnumeration("TestSchema", "UnStrictEnum");
            ASSERT_NE(unstrictEnum, nullptr);

            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);
            auto goo = m_briefcase->Schemas().GetClass("TestSchema", "Goo");
            ASSERT_NE(goo, nullptr);

            auto foo_type = foo->GetPropertyP("Type")->GetAsPrimitiveProperty();
            ASSERT_NE(foo_type, nullptr);
            ASSERT_EQ(foo_type->GetEnumeration(), unstrictEnum);

            auto goo_type = goo->GetPropertyP("Type")->GetAsPrimitiveProperty();
            ASSERT_NE(goo_type, nullptr);
            ASSERT_EQ(goo_type->GetEnumeration(), strictEnum);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyPropertyTypeString_EnumToPrimitive)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "099a0de32dda8560f943bd152e00ba7e370ab5334552889287db243ef70be506";
    const auto SCHEMA1_HASH_ECDB_MAP = "131bdba7931dfdfa214c56942c4af9d734a81e1b523d9574ce159ac6001ae14d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "852df9e13096afc389d705b9ac7dcc52e98cf3e3857b33d9cec3606787f1cdeb";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='StrictEnum' backingTypeName='string' isStrict='True'>
                        <ECEnumerator value = 'val1' displayLabel = 'txt' />
                        <ECEnumerator value = 'val2' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='StrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "152f4525069a5f907dd06710b19bbf67ff2865e03f977c8af52d91c83f0432e5";
    Test(
        "Changing String Enum to String",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='StrictEnum' backingTypeName='string' isStrict='True'>
                        <ECEnumerator value = 'val1' displayLabel = 'txt' />
                        <ECEnumerator value = 'val2' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            auto strictEnum = m_briefcase->Schemas().GetEnumeration("TestSchema", "StrictEnum");
            ASSERT_NE(strictEnum, nullptr);
            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);

            auto foo_type = foo->GetPropertyP("Type")->GetAsPrimitiveProperty();
            ASSERT_NE(foo_type, nullptr);
            ASSERT_EQ(foo_type->GetEnumeration(), nullptr);
            ASSERT_EQ(foo_type->GetType(), PrimitiveType::PRIMITIVETYPE_String);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyPropertyTypeString_PrimitiveToUnStrictEnum)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "716723025aac38ef21fd31d55785e2200e5f466cd5613dff7b7a0bbc4ec8843a";
    const auto SCHEMA1_HASH_ECDB_MAP = "131bdba7931dfdfa214c56942c4af9d734a81e1b523d9574ce159ac6001ae14d";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "852df9e13096afc389d705b9ac7dcc52e98cf3e3857b33d9cec3606787f1cdeb";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='string' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "b46535b03ded5f309d0d3a55df730871178ad22b8c6476024a562b836d2728b5";
    Test(
        "changing String to Unstrict Enum",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='string' isStrict='False'>
                        <ECEnumerator value = 'val1' displayLabel = 'txt' />
                        <ECEnumerator value = 'val2' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='NonStrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            auto nonStrictEnum = m_briefcase->Schemas().GetEnumeration("TestSchema", "NonStrictEnum");
            ASSERT_NE(nonStrictEnum, nullptr);
            auto foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_NE(foo, nullptr);

            auto foo_type = foo->GetPropertyP("Type")->GetAsPrimitiveProperty();
            ASSERT_NE(foo_type, nullptr);
            ASSERT_EQ(foo_type->GetEnumeration(), nonStrictEnum);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyEnumType_IntToString)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "2fbc9acfd7bfd86e0ce6d7f71adf61a02384d6647a8e8d84cd98eff2c5e13a74";
    const auto SCHEMA1_HASH_ECDB_MAP = "c4c4f512f7ebe4eae2bae12c6c05c003fcf1b58e57f1722f3aff5d1274d8e863";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "e7510aa3d1cd96d6f7333d9f04ed7487185f14b393af616be1e7cbb2ffbc8c10";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='StrictEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='StrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Changing Enum Type is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='string' isStrict='True'>
                        <ECEnumerator value = 'val1' displayLabel = 'txt' />
                        <ECEnumerator value = 'val2' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='StrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, RemoveExistingEnum)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "2fbc9acfd7bfd86e0ce6d7f71adf61a02384d6647a8e8d84cd98eff2c5e13a74";
    const auto SCHEMA1_HASH_ECDB_MAP = "c4c4f512f7ebe4eae2bae12c6c05c003fcf1b58e57f1722f3aff5d1274d8e863";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "e7510aa3d1cd96d6f7333d9f04ed7487185f14b393af616be1e7cbb2ffbc8c10";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='StrictEnum' backingTypeName='int' isStrict='True'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='StrictEnum' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting Enum",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='Foo' >
                        <ECProperty propertyName='Type' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            ECEnumerationCP strictEnum = m_briefcase->Schemas().GetEnumeration("TestSchema", "StrictEnum");
            ASSERT_TRUE(strictEnum != nullptr);
            ECClassCP foo = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_TRUE(foo != nullptr);

            PrimitiveECPropertyCP foo_type = foo->GetPropertyP("Type")->GetAsPrimitiveProperty();

            ASSERT_TRUE(foo_type != nullptr);
            ASSERT_TRUE(foo_type->GetEnumeration() == strictEnum);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewRelationship)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "458ed30f99a2a5d74443cb8c9825f90581f825571ef4bbb44a3c3464a0c942a1";
    const auto SCHEMA1_HASH_ECDB_MAP = "608569ef682f7bc0b3aa7c97c00fa631c3e268d32205d11273a0acf190344c46";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "a8ce44f73dc6a565ca2183641c95b2fee3da99a77b71017e57b7bc1caca1fed4";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECProperty propertyName='AProp' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECProperty propertyName='BProp' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "77d6cb4a8a19dac3bc63d7df8b6d0c17cb1d71e65c9545ae732893874738e2fc";
    const auto SCHEMA2_HASH_ECDB_MAP = "881afd325637f8ed0172eb15f3ecb87ac4ab8e19e926083c01c36d40d2a1e621";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "caf1bd588ab6660d46272cd8808293e3cb1b398cad07e151cc560494c39bd0ff";
    Test(
        "Add new endtable relationship",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECProperty propertyName='AProp' typeName='int' />
                        <ECNavigationProperty propertyName='B' relationshipName='RelClass' direction='Backward'/>
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECProperty propertyName='BProp' typeName='int' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='embedding' strengthDirection='forward' >
                        <Source cardinality='(0,1)' polymorphic='True'>
                            <Class class='B' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify Adding new EndTable relationship",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(3, GetColumnCount("ts_A"));
            ASSERT_EQ(2, GetColumnCount("ts_B"));
            }
    );

    Test(
        "import second initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECProperty propertyName='AProp' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECProperty propertyName='BProp' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA3_HASH_ECDB_SCHEMA = "c02722b6126b1a193a3a52a50ee27b902828300608daf943ada80b71e211aa42";
    const auto SCHEMA3_HASH_ECDB_MAP = "68e28cd7d51d17eb7dcf334bc04db30836392dec8f924c66e2de60b23b5844e3";
//    const auto SCHEMA3_HASH_SQLITE_SCHEMA = "ed6b6f57add8e79ff99b93ee2d73b5d07c270c04141a5fc68ea6fbb102ad094f";
    Test(
        "Add new LinkTable relationship",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='2.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEntityClass typeName='A' modifier='None' >
                        <ECProperty propertyName='AProp' typeName='int' />
                    </ECEntityClass>
                    <ECEntityClass typeName='B' modifier='None' >
                        <ECProperty propertyName='BProp' typeName='int' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='RelClass' modifier='Sealed' strength='referencing' strengthDirection='forward' >
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class='B' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='A' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, "ed6b6f57add8e79ff99b93ee2d73b5d07c270c04141a5fc68ea6fbb102ad094f", false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify Adding new linkTable relationship for different briefcaseIds",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA3_HASH_ECDB_SCHEMA, SCHEMA3_HASH_ECDB_MAP, "253e9493a4c8f283867e0c2c675a35613553cdc452acafee8ca5090c9f5a16d0", false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        ASSERT_TRUE(m_briefcase->TableExists("ts_RelClass"));
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewDerivedEndTableRelationship)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "dc727e2c21cc983ccb2696b7bc9fb5ca455a913b90b65a99eb99ae48bb4ac368";
    const auto SCHEMA1_HASH_ECDB_MAP = "e503be0750b95cf6659623899b613d139bc465a544331c07def79258b17fee7e";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "1abf71b58c837ebebda036e0ba7bd650ecd2f981e12833ba4f87062d4afd008e";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                <ECSchemaReference name='ECDbMap' version='02.00' prefix='ecdbmap' />
                    <ECEntityClass typeName='Model' >
                        <ECProperty propertyName='Name' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='Code' typeName='string' />
                        <ECNavigationProperty propertyName='Model' relationshipName='ModelHasElements' direction='Backward' />
                    </ECEntityClass>
                    <ECEntityClass typeName='GeometricElement' modifier='None'>
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='GeometricElement' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Geometric3dElement' modifier='None'>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName='Geometry3d' typeName='string' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='ModelHasElements' modifier='Abstract' strength='embedding'>
                        <Source cardinality='(1,1)' polymorphic='True'>
                            <Class class='Model' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Element' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "002d588fd6f92dbfd0200f58b20db3bd484153d1d75499e95da92520b28d7ff1";
    const auto SCHEMA2_HASH_ECDB_MAP = "5a44268cef931438c6e6ff2fc17b6fc3ee0d82999e58465f914ee4146e7c7a33";
    Test(
        "Add new Derived EndTable relationship",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                  <ECSchemaReference name='ECDbMap' version='02.00' prefix='ecdbmap' />
                    <ECEntityClass typeName='Model' >
                        <ECProperty propertyName='Name' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='Code' typeName='string' />
                        <ECNavigationProperty propertyName='Model' relationshipName='ModelHasElements' direction='Backward' />
                    </ECEntityClass>
                    <ECEntityClass typeName='GeometricElement' modifier='None'>
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName='GeometricElement' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Geometric3dElement' modifier='None'>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName='Geometry3d' typeName='string' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='ModelHasElements' modifier='Abstract' strength='embedding'>
                        <Source cardinality='(1,1)' polymorphic='True'>
                        <Class class='Model' />
                            </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Element' />
                        </Target>
                    </ECRelationshipClass>
                    <ECRelationshipClass typeName='ModelHasGeometricElements' strength='embedding' modifier='Sealed'>
                    <BaseClass>ModelHasElements</BaseClass>
                        <Source cardinality='(1,1)' polymorphic='True'>
                            <Class class='Model' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='GeometricElement' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull, verify Adding new derived endtable relationship for different briefcaseIds and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            auto modelHasGeometricElementsRelClassId = m_briefcase->Schemas().GetClassId("TestSchema", "ModelHasGeometricElements");
            ASSERT_TRUE(modelHasGeometricElementsRelClassId.IsValid());

            //Insert Test Data
            //Model
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Model(ECInstanceId, Name) VALUES(101, 'Model1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Model(ECInstanceId, Name) VALUES(102, 'Model2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //GeometricElement
            Utf8String ecsql;
            ecsql.Sprintf("INSERT INTO ts.GeometricElement(ECInstanceId, Code, Model.Id, Model.RelECClassId, GeometricElement) VALUES(201, 'Code1', 101, %s, 'GeometricElement1')",
                        modelHasGeometricElementsRelClassId.ToString().c_str());
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, ecsql.c_str()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            ecsql.Sprintf("INSERT INTO ts.GeometricElement(ECInstanceId, Code, Model.Id, Model.RelECClassId, GeometricElement) VALUES(202, 'Code2', 101, %s, 'GeometricElement2')",
                        modelHasGeometricElementsRelClassId.ToString().c_str());
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, ecsql.c_str()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //Geometric3dElement
            ecsql.Sprintf("INSERT INTO ts.Geometric3dElement(ECInstanceId, Code, Model.Id, Model.RelECClassId, GeometricElement, Geometry3d) VALUES(301, 'Code3', 102, %s, 'GeometricElement3', 'Geometry3d3')",
                        modelHasGeometricElementsRelClassId.ToString().c_str());
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, ecsql.c_str()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            ecsql.Sprintf("INSERT INTO ts.Geometric3dElement(ECInstanceId, Code, Model.Id, Model.RelECClassId, GeometricElement, Geometry3d) VALUES(302, 'Code4', 102, %s, 'GeometricElement4', 'Geometry3d4')",
                        modelHasGeometricElementsRelClassId.ToString().c_str());
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, ecsql.c_str()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //Select statements
            //Verify insertions
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT count(*) FROM ts.ModelHasElements"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << stmt.GetECSql();
            ASSERT_EQ(4, stmt.GetValueInt(0)) << stmt.GetECSql();
            stmt.Finalize();

            //FROM ONLY abstract class is expected to return 0 rows
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT count(*) FROM ONLY ts.ModelHasElements"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << stmt.GetECSql();
            ASSERT_EQ(0, stmt.GetValueInt(0)) << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT count(*) FROM ts.ModelHasGeometricElements"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << stmt.GetECSql();
            ASSERT_EQ(4, stmt.GetValueInt(0)) << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddNewDerivedLinkTableRelationship)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "3f22d51546a8e2ebadab2c8f35c1c3347e02849427141afabb06af8ec76e5856";
    const auto SCHEMA1_HASH_ECDB_MAP = "0e0d6edff319e1b45f02d55d36614779c4de456f7c138f4c7453365ac351852e";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "2ce665b051189115b16f758c6134cc0752529ddcae6ccb2a5404269b682ec691";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='ECDbMap' version='02.00' prefix='ecdbmap' />
                    <ECEntityClass typeName='Model' >
                        <ECProperty propertyName='Name' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='Code' typeName='string' />
                        <ECNavigationProperty propertyName='Model' relationshipName='ModelHasElements' direction='Backward' />
                    </ECEntityClass>
                    <ECEntityClass typeName='InformationElement' modifier='Abstract'>
                        <BaseClass>Element</BaseClass>
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='LinkElement' modifier='Abstract'>
                        <BaseClass>InformationElement</BaseClass>
                        <ECCustomAttributes>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>8</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='UrlLink' modifier='Sealed'>
                        <BaseClass>LinkElement</BaseClass>
                        <ECProperty propertyName='Url' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='EmbeddedLink' modifier='Sealed'>
                        <BaseClass>LinkElement</BaseClass>
                        <ECProperty propertyName='Name' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='GeometricElement' modifier='Abstract'>
                        <ECCustomAttributes>
                                <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Geometric3dElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>16</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName='Geometry' typeName='Bentley.Geometry.Common.IGeometry' />
                    </ECEntityClass>
                    <ECEntityClass typeName='VolumeElement'>
                        <BaseClass>Geometric3dElement</BaseClass>
                        <ECProperty propertyName='Name' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Annotation3dElement'>
                        <BaseClass>Geometric3dElement</BaseClass>
                        <ECProperty propertyName='Font' typeName='string' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='ModelHasElements' modifier='Sealed' strength='embedding'>
                        <Source cardinality='(1,1)' polymorphic='True'>
                            <Class class='Model' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Element' />
                        </Target>
                    </ECRelationshipClass>
                    <ECRelationshipClass typeName='ElementDrivesElement' strength='referencing' modifier='Abstract'>
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class='Element' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Element' />
                        </Target>
                    </ECRelationshipClass>
                    <ECRelationshipClass typeName='InformationElementDrivesInformationElement' strength='referencing' modifier='Sealed'>
                        <BaseClass>ElementDrivesElement</BaseClass>
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class='InformationElement' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='InformationElement' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "944daf7985f75e071ce42df6a163755228e291f15e0b6834349cbfab92e08a44";
    const auto SCHEMA2_HASH_ECDB_MAP = "582f85e9cf9edbcd395a8318a3066cdfeeaae58e1bd7f6ae4faf04a43e132484";
    Test(
        "Add new Derived LinkTable relationship",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name='ECDbMap' version='02.00' prefix='ecdbmap' />
                    <ECEntityClass typeName='Model' >
                        <ECProperty propertyName='Name' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Element' modifier='Abstract' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName='Code' typeName='string' />
                        <ECNavigationProperty propertyName='Model' relationshipName='ModelHasElements' direction='Backward' />
                    </ECEntityClass>
                    <ECEntityClass typeName='InformationElement' modifier='Abstract'>
                        <BaseClass>Element</BaseClass>
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='LinkElement' modifier='Abstract'>
                        <BaseClass>InformationElement</BaseClass>
                        <ECCustomAttributes>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>8</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='UrlLink' modifier='Sealed'>
                        <BaseClass>LinkElement</BaseClass>
                        <ECProperty propertyName='Url' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='EmbeddedLink' modifier='Sealed'>
                        <BaseClass>LinkElement</BaseClass>
                        <ECProperty propertyName='Name' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='GeometricElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <JoinedTablePerDirectSubclass xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <BaseClass>Element</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Geometric3dElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>16</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <BaseClass>GeometricElement</BaseClass>
                        <ECProperty propertyName='Geometry' typeName='Bentley.Geometry.Common.IGeometry' />
                    </ECEntityClass>
                    <ECEntityClass typeName='VolumeElement'>
                        <BaseClass>Geometric3dElement</BaseClass>
                        <ECProperty propertyName='Name' typeName='string' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Annotation3dElement'>
                        <BaseClass>Geometric3dElement</BaseClass>
                        <ECProperty propertyName='Font' typeName='string' />
                    </ECEntityClass>
                    <ECRelationshipClass typeName='ModelHasElements' modifier='Sealed' strength='embedding'>
                        <Source cardinality='(1,1)' polymorphic='True'>
                            <Class class='Model' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Element' />
                        </Target>
                    </ECRelationshipClass>
                    <ECRelationshipClass typeName='ElementDrivesElement' strength='referencing' modifier='Abstract'>
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class='Element' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Element' />
                        </Target>
                    </ECRelationshipClass>
                    <ECRelationshipClass typeName='InformationElementDrivesInformationElement' strength='referencing' modifier='Sealed'>
                        <BaseClass>ElementDrivesElement</BaseClass>
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class='InformationElement' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='InformationElement' />
                        </Target>
                    </ECRelationshipClass>
                    <ECRelationshipClass typeName='UrlLinkDrivesAnnotation3dElement' strength='referencing' modifier='Sealed'>
                        <BaseClass>ElementDrivesElement</BaseClass>
                        <Source cardinality='(0,N)' polymorphic='True'>
                            <Class class='UrlLink' />
                        </Source>
                        <Target cardinality='(0,N)' polymorphic='True'>
                            <Class class='Annotation3dElement' />
                        </Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, "dbc8e226f6f66fd5e99c22fe45ad02fa8eb00709710164220fb12f818161a9c8", false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, "dbc8e226f6f66fd5e99c22fe45ad02fa8eb00709710164220fb12f818161a9c8", false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull, Verify updated schemas and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );

            //Insert Test Data
            //Model
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Model(ECInstanceId, Name) VALUES(101, 'Model1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Model(ECInstanceId, Name) VALUES(102, 'Model2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //VolumeElement
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.VolumeElement(ECInstanceId, Code, Model.Id, Name) VALUES(201, 'Code1', 101, 'Volume1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.VolumeElement(ECInstanceId, Code, Model.Id, Name) VALUES(202, 'Code2', 102, 'Volume2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.VolumeElement(ECInstanceId, Code, Model.Id, Name) VALUES(203, 'Code3', 102, 'Volume3')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //AnnotationElement
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Annotation3dElement(ECInstanceId, Code, Model.Id, Font) VALUES(301, 'Code4', 101, 'Font1')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Annotation3dElement(ECInstanceId, Code, Model.Id, Font) VALUES(302, 'Code5', 102, 'Font2')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.Annotation3dElement(ECInstanceId, Code, Model.Id, Font) VALUES(303, 'Code6', 102, 'Font3')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //LinkUrl
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.UrlLink(ECInstanceId, Code, Model.Id, Url) VALUES(401, 'Code7', 101, 'http://www.staufen.de')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.UrlLink(ECInstanceId, Code, Model.Id, Url) VALUES(402, 'Code8', 101, 'http://www.staufen.de')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //EmbeddedLink
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.EmbeddedLink(ECInstanceId,Code, Model.Id, Name) VALUES(501, 'Code9', 102,'bliblablub')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.EmbeddedLink(ECInstanceId,Code, Model.Id, Name) VALUES(502, 'Code10', 102,'bliblablub')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            auto urlLInkId = m_briefcase->Schemas().GetSchema("TestSchema")->GetClassCP("UrlLink")->GetId();
            auto embeddedLinkId = m_briefcase->Schemas().GetSchema("TestSchema")->GetClassCP("EmbeddedLink")->GetId();
            auto annotation3dElementId = m_briefcase->Schemas().GetSchema("TestSchema")->GetClassCP("Annotation3dElement")->GetId();

            //InformationElementDrivesInformationElement
            Utf8String ecsql;
            ecsql.Sprintf("INSERT INTO ts.InformationElementDrivesInformationElement(SourceECInstanceId, SourceECClassId, TargetECInstanceId, TargetECClassId) VALUES(401 , %llu , 501 , %llu )", urlLInkId.GetValue(), embeddedLinkId.GetValue());
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, ecsql.c_str()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ecsql.Sprintf("INSERT INTO ts.InformationElementDrivesInformationElement(SourceECInstanceId, SourceECClassId, TargetECInstanceId, TargetECClassId) VALUES(401 , %llu , 502 , %llu )", urlLInkId.GetValue(), embeddedLinkId.GetValue());
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, ecsql.c_str()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //UrlLinkDrivesAnnotation3dElement
            ecsql.Sprintf("INSERT INTO ts.UrlLinkDrivesAnnotation3dElement(SourceECInstanceId, SourceECClassId, TargetECInstanceId, TargetECClassId) VALUES(402 , %llu , 301 , %llu )", urlLInkId.GetValue(), annotation3dElementId.GetValue());
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, ecsql.c_str()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ecsql.Sprintf("INSERT INTO ts.UrlLinkDrivesAnnotation3dElement(SourceECInstanceId, SourceECClassId, TargetECInstanceId, TargetECClassId) VALUES(402 , %llu , 302 , %llu )", urlLInkId.GetValue(), annotation3dElementId.GetValue());
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, ecsql.c_str()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            ecsql.Sprintf("INSERT INTO ts.UrlLinkDrivesAnnotation3dElement(SourceECInstanceId, SourceECClassId, TargetECInstanceId, TargetECClassId) VALUES(402 , %llu , 303 , %llu )", urlLInkId.GetValue(), annotation3dElementId.GetValue());
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, ecsql.c_str()));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            //Verify Insertions
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT count(*) FROM ts.ElementDrivesElement"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << stmt.GetECSql();
            ASSERT_EQ(5, stmt.GetValueInt(0)) << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT count(*) FROM ONLY ts.ElementDrivesElement"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << stmt.GetECSql();
            ASSERT_EQ(0, stmt.GetValueInt(0)) << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT count(*) FROM ts.InformationElementDrivesInformationElement"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << stmt.GetECSql();
            ASSERT_EQ(2, stmt.GetValueInt(0)) << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT count(*) FROM ts.UrlLinkDrivesAnnotation3dElement"));
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << stmt.GetECSql();
            ASSERT_EQ(3, stmt.GetValueInt(0)) << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddMaxSharedColumnsBeforeOverflow)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "02fe2c346b7a807cbb0117caf5291b9712d0bf5e805378dac6ad5c5a3dc3bcb0";
    const auto SCHEMA1_HASH_ECDB_MAP = "e2e290765aab188a54d8e20e50a3c86228f51cb0d997d01d4a2e9ad644f681cd";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "7382e4a4175cc619fe9b9342105140eebec8bd7261109e71e8ce0650c335a069";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        <ShareColumns xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate_addmaxsharedcolumnsbeforeoverflow", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Adding MaxSharedColumnsBeforeOverflow",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DeleteMaxSharedColumnsBeforeOverflow)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "9275b00d82f90201f8a0640fa4a158cb720e917b33840830d79157ad2ca9c8ac";
    const auto SCHEMA1_HASH_ECDB_MAP = "033af14df12f78762bd41e98de23ff92b10847046dc3e57029ccb2d0aa36e280";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "7382e4a4175cc619fe9b9342105140eebec8bd7261109e71e8ce0650c335a069";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate_deletemaxsharedcolumnsbeforeoverflow", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Deleting MaxSharedColumnsBeforeOverflow",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECEntityClass typeName='Base' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'/>
                        </ECCustomAttributes>
                        <ECProperty propertyName='GS' typeName='string' />
                        <ECProperty propertyName='GD' typeName='double' />
                        <ECProperty propertyName='GL' typeName='long' />
                    </ECEntityClass>
                    <ECEntityClass typeName='Sub1' modifier='None'>
                        <BaseClass>Base</BaseClass>
                        <ECProperty propertyName='FS' typeName='string' />
                        <ECProperty propertyName='FD' typeName='double' />
                        <ECProperty propertyName='FL' typeName='long' />
                        <ECProperty propertyName='FI' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->AbandonChanges());
            CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddEnumAndEnumProperty)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "265b20a58b21291292b3042c66949eebc7ba96ea9e702a275e6391a29e54db4f";
            const auto SCHEMA_HASH_ECDB_MAP = "e377918ed948b322302bce119e12d5743ec050b4cf05a4d342610a392bb20ca5";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "b9441b9a819f951681d5d0ddf736bfbed218f9cc5a522264b2c5f3abb5a8fbbd";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="Name" typeName="string"/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("AddEnumAndEnumProperty", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "f9ba8ad7fa731ceec8f97967caa357b5904e06ab73c69acc7b8e862ed7ca4301";
            const auto SCHEMA_HASH_ECDB_MAP = "656af8d059ec7de2b174ee0e9a151526d9c1cd33ea5f3d8003bef08c09348c6b";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "423d2d5fa08b3dc3192e8f3eb9ce6308f43ab16d6dd759a7a530ba23a5ad2fd5";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECEnumeration typeName="MyEnum" backingTypeName="int" isStrict="False">
                        <ECEnumerator value="0" displayLabel="On" />
                        <ECEnumerator value="1" displayLabel="Off" />
                    </ECEnumeration>
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="Name" typeName="string"/>
                        <ECProperty propertyName="Status" typeName="MyEnum"/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check enumerators",
        [&]()
            {
            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());
            ECClassCP fooClass = m_briefcase->Schemas().GetClass("TestSchema", "Foo");
            ASSERT_TRUE(fooClass != nullptr);
            ECPropertyCP enumProp = fooClass->GetPropertyP("Status");
            ASSERT_TRUE(enumProp != nullptr && enumProp->GetIsPrimitive());
            ECEnumerationCP actualEnum = enumProp->GetAsPrimitiveProperty()->GetEnumeration();
            ASSERT_TRUE(actualEnum != nullptr);
            ASSERT_STREQ("MyEnum", actualEnum->GetName().c_str());
            ASSERT_EQ(actualEnum, m_briefcase->Schemas().GetEnumeration("TestSchema", "MyEnum"));
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddingECEnumerationIntegerType)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "2c70cb8f4c31c5b78b660c6e4bcf8c95c0b52d303bcb1cd5c3dc3f4d9ec189e7";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='False' displayLabel='Test1Display' description='Test1Desc'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "766d13e1e8494446aa9c79341812f8b45343c89418ed8508ee78306fa5982e83";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='False' displayLabel='Test2Display' description='Test2Desc'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                        <ECEnumerator value = '2' displayLabel = 'exe' />
                        <ECEnumerator value = '3' displayLabel = 'dll' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check enumerators",
        [&]()
            {
            auto updatedEnum = m_briefcase->Schemas().GetEnumeration("TestSchema", "NonStrictEnum");
            ASSERT_TRUE(updatedEnum != nullptr);
            ASSERT_STREQ("Test2Display", updatedEnum->GetDisplayLabel().c_str());
            ASSERT_STREQ("Test2Desc", updatedEnum->GetDescription().c_str());
            ASSERT_EQ(false, updatedEnum->GetIsStrict());
            ASSERT_EQ(PRIMITIVETYPE_Integer, updatedEnum->GetType());

            auto assertEnumerator = [&](int32_t value, Utf8CP displayLabel)
                {
                ECEnumeratorCP newEnum = updatedEnum->FindEnumerator(value);
                ASSERT_TRUE(newEnum != nullptr);
                ASSERT_STREQ(displayLabel, newEnum->GetDisplayLabel().c_str());
                };

            assertEnumerator(0, "txt");
            assertEnumerator(1, "bat");
            assertEnumerator(2, "exe");
            assertEnumerator(3, "dll");
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AddingECEnumerationStringType)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "547468a9bd8ffe054a4be4bd15b8c995c880b541fb77c24024dcc9b26ee57d45";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='string' isStrict='False' displayLabel='Test1Display' description='Test1Desc'>
                        <ECEnumerator value = 't0' displayLabel = 'txt' />
                        <ECEnumerator value = 't1' displayLabel = 'bat' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "3c9b8e301359d4c02a921fa0bcc8479ac455c616277e430a7d7e2a21c9ea8a31";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='string' isStrict='False' displayLabel='Test2Display' description='Test2Desc'>
                        <ECEnumerator value = 't0' displayLabel = 'txt' />
                        <ECEnumerator value = 't1' displayLabel = 'bat' />
                        <ECEnumerator value = 't2' displayLabel = 'exe' />
                        <ECEnumerator value = 't3' displayLabel = 'dll' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check enumerators",
        [&]()
            {
            auto updatedEnum = m_briefcase->Schemas().GetEnumeration("TestSchema", "NonStrictEnum");
            ASSERT_TRUE(updatedEnum != nullptr);
            ASSERT_STREQ("Test2Display", updatedEnum->GetDisplayLabel().c_str());
            ASSERT_STREQ("Test2Desc", updatedEnum->GetDescription().c_str());
            ASSERT_EQ(false, updatedEnum->GetIsStrict());
            ASSERT_EQ(PRIMITIVETYPE_String, updatedEnum->GetType());

            auto assertEnumerator = [&](Utf8CP value, Utf8CP displayLabel)
                {
                ECEnumeratorCP newEnum = updatedEnum->FindEnumerator(value);
                ASSERT_TRUE(newEnum != nullptr);
                ASSERT_STREQ(displayLabel, newEnum->GetDisplayLabel().c_str());
                };

            assertEnumerator("t0", "txt");
            assertEnumerator("t1", "bat");
            assertEnumerator("t2", "exe");
            assertEnumerator("t3", "dll");
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateECEnumerationFromStrictToNonStrictAndUpdateEnumerators)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "b34189bc326584914f8d9aaf398519e635673545115d3a535c420cbff75bec4b";
    Test(
        "import initial schema",
        [&]()
            {

            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='True' displayLabel='Test1Display' description='Test1Desc'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying enumerator values is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='False' displayLabel='Test2Display' description='Test2Desc'>
                        <ECEnumerator value = '10' displayLabel = 'txt1' />
                        <ECEnumerator value = '11' displayLabel = 'bat1' />
                        <ECEnumerator value = '12' displayLabel = 'exe1' />
                        <ECEnumerator value = '13' displayLabel = 'dll1' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateECEnumerationFromUnStrictToStrict)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "2c70cb8f4c31c5b78b660c6e4bcf8c95c0b52d303bcb1cd5c3dc3f4d9ec189e7";
    Test(
        "import initial schema",
        [&]()
            {

            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='False' displayLabel='Test1Display' description='Test1Desc'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Cannot change IsStrict from false to true",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='True' displayLabel='Test1Display' description='Test1Desc'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ChangeECEnumeratorValue)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "772b43e4b4abd354409de2305ea61e8f9145044b8c3350be42d3b44197fb731e";
    Test(
        "import initial schema",
        [&]()
            {

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEnumeration typeName="IntEnum" backingTypeName="int" >
                        <ECEnumerator name="On" value="0" />
                        <ECEnumerator name="Off" value="1" />
                    </ECEnumeration>
                    <ECEnumeration typeName="StringEnum" backingTypeName="string" >
                        <ECEnumerator name="On" value="On" />
                        <ECEnumerator name="Off" value="Off" />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ChangeECEnumeratorValue", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "First change of enumerator values",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEnumeration typeName="IntEnum" backingTypeName="int" >
                        <ECEnumerator name="On" value="0" />
                        <ECEnumerator name="Off" value="2" />
                    </ECEnumeration>
                    <ECEnumeration typeName="StringEnum" backingTypeName="string" >
                        <ECEnumerator name="On" value="On" />
                        <ECEnumerator name="Off" value="Off" />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Second change of enumerator values",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEnumeration typeName="IntEnum" backingTypeName="int" >
                        <ECEnumerator name="On" value="0" />
                        <ECEnumerator name="Off" value="1" />
                    </ECEnumeration>
                    <ECEnumeration typeName="StringEnum" backingTypeName="string" >
                        <ECEnumerator name="On" value="Turn On" />
                        <ECEnumerator name="Off" value="Off" />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, ModifyEnumeratorNameInPre32ECSchema)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "52865b5f8ac7ba418068be2e36402f012eb7a11ad40d108d1df12809732442b1";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECEnumeration typeName="IntEnum" backingTypeName="int" >
                        <ECEnumerator value="0" />
                        <ECEnumerator value="1" />
                    </ECEnumeration>
                    <ECEnumeration typeName="StringEnum" backingTypeName="string" >
                        <ECEnumerator value="On" />
                        <ECEnumerator value="Off" />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ModifyEnumeratorNameInPre32ECSchema", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "33581d7a45f2bca32a89dfcf8c71a49033a0c90f0d0e10385ee3bf4cdb23929c";
    Test(
        "When coming from 3.1 schema, an enumerator name change is valid",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEnumeration typeName="IntEnum" backingTypeName="int" >
                        <ECEnumerator name="On" value="0" />
                        <ECEnumerator name="Off" value="1" />
                    </ECEnumeration>
                    <ECEnumeration typeName="StringEnum" backingTypeName="string" >
                        <ECEnumerator name="An" value="On" />
                        <ECEnumerator name="Aus" value="Off" />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Once the name was changed after the 3.1 conversion, it cannot be changed anymore",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEnumeration typeName="IntEnum" backingTypeName="int" >
                        <ECEnumerator name="TurnOn" value="0" />
                        <ECEnumerator name="TurnOff" value="1" />
                    </ECEnumeration>
                    <ECEnumeration typeName="StringEnum" backingTypeName="string" >
                        <ECEnumerator name="On" value="On" />
                        <ECEnumerator name="Off" value="Off" />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "9ed0e7e9a5520a1b3d7b1256f9585c86eb1fe0ba41dec0296d833776470f406e";
    Test(
        "start with EC3.2 enum which should never allow to rename an enumerator",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEnumeration typeName="IntEnum" backingTypeName="int" >
                        <ECEnumerator name="IntEnum0" value="0" />
                        <ECEnumerator name="IntEnum1" value="1" />
                    </ECEnumeration>
                    <ECEnumeration typeName="StringEnum" backingTypeName="string" >
                        <ECEnumerator name="On" value="On" />
                        <ECEnumerator name="Off" value="Off" />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("ModifyEnumeratorNameInPre32ECSchema", schema));
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Even if the enumerator name is the default EC3.2 conversion name, the change is not valid",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEnumeration typeName="IntEnum" backingTypeName="int" >
                        <ECEnumerator name="On" value="0" />
                        <ECEnumerator name="Off" value="1" />
                    </ECEnumeration>
                    <ECEnumeration typeName="StringEnum" backingTypeName="string" >
                        <ECEnumerator name="On" value="On" />
                        <ECEnumerator name="Off" value="Off" />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Once the name was changed away from the EC3.2 conversion default name, it cannot be changed anymore",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECEnumeration typeName="IntEnum" backingTypeName="int" >
                        <ECEnumerator name="TurnOn" value="0" />
                        <ECEnumerator name="TurnOff" value="1" />
                    </ECEnumeration>
                    <ECEnumeration typeName="StringEnum" backingTypeName="string" >
                        <ECEnumerator name="On" value="On" />
                        <ECEnumerator name="Off" value="Off" />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateECEnumerationAddDeleteEnumerators)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "b34189bc326584914f8d9aaf398519e635673545115d3a535c420cbff75bec4b";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='True' displayLabel='Test1Display' description='Test1Desc'>
                        <ECEnumerator value = '0' displayLabel = 'txt' />
                        <ECEnumerator value = '1' displayLabel = 'bat' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Cannot change Strict Enum (Only Adding new properties allowed)",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECEnumeration typeName='NonStrictEnum' backingTypeName='int' isStrict='True' displayLabel='Test2Display' description='Test2Desc'>
                        <ECEnumerator value = '10' displayLabel = 'txt1' />
                        <ECEnumerator value = '11' displayLabel = 'bat1' />
                        <ECEnumerator value = '12' displayLabel = 'exe1' />
                        <ECEnumerator value = '13' displayLabel = 'dll1' />
                    </ECEnumeration>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, PropertyCategoryAddUpdateDelete)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "c45c3c0f7214348837c5767840c56ce6150976bc03c184de9e58147bf0fe9536";
            const auto SCHEMA_HASH_ECDB_MAP = "514167887c868d4f20c05038b2d21989a511a4ecdffdce0f2b14b4b7da5acb05";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "9ba4d9ec2205473e823ffd7fb10ba60f98f1e0e2224c38549b82c1918c08c9f9";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <PropertyCategory typeName="C3" description="C3" displayLabel="C3" priority="3" />
                    <PropertyCategory typeName="C5" description="C5" displayLabel="C5" priority="5" />
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="P1" typeName="double" category="C1" />
                        <ECProperty propertyName="P2" typeName="double" category="C2" />
                        <ECProperty propertyName="P3" typeName="double" category="C3" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("getpropertycategories", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Assert properties in the initial schema",
        [&]()
            {
            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            PropertyCategoryCP c1 = m_briefcase->Schemas().GetPropertyCategory("Schema1", "C1");
            ASSERT_TRUE(c1 != nullptr);
            ASSERT_STREQ("C1", c1->GetName().c_str());
            ASSERT_EQ(1, (int) c1->GetPriority());

            PropertyCategoryCP c2 = m_briefcase->Schemas().GetPropertyCategory("Schema1", "C2");
            ASSERT_TRUE(c1 != nullptr);
            ASSERT_STREQ("C2", c2->GetName().c_str());
            ASSERT_EQ(2, (int) c2->GetPriority());

            PropertyCategoryCP c3 = m_briefcase->Schemas().GetPropertyCategory("Schema1", "C3");
            ASSERT_TRUE(c1 != nullptr);
            ASSERT_STREQ("C3", c3->GetName().c_str());
            ASSERT_EQ(3, (int) c3->GetPriority());

            PropertyCategoryCP c5 = m_briefcase->Schemas().GetPropertyCategory("Schema1", "C5");
            ASSERT_TRUE(c5 != nullptr);
            ASSERT_STREQ("C5", c5->GetName().c_str());
            ASSERT_EQ(5, (int) c5->GetPriority());

            ECSchemaCP schema1 = m_briefcase->Schemas().GetSchema("Schema1", false);
            ASSERT_TRUE(schema1 != nullptr);

            ECClassCP fooClass = m_briefcase->Schemas().GetClass("Schema1", "Foo");
            ASSERT_TRUE(fooClass != nullptr);
            ASSERT_EQ(4, schema1->GetPropertyCategoryCount());

            ECPropertyCP p1 = fooClass->GetPropertyP("P1");
            ASSERT_TRUE(p1 != nullptr);
            ASSERT_TRUE(p1->GetCategory() != nullptr);
            ASSERT_STREQ("C1", p1->GetCategory()->GetName().c_str());

            ECPropertyCP p2 = fooClass->GetPropertyP("P2");
            ASSERT_TRUE(p2 != nullptr);
            ASSERT_TRUE(p2->GetCategory() != nullptr);
            ASSERT_STREQ("C2", p2->GetCategory()->GetName().c_str());

            ECPropertyCP p3 = fooClass->GetPropertyP("P3");
            ASSERT_TRUE(p3 != nullptr);
            ASSERT_TRUE(p3->GetCategory() != nullptr);
            ASSERT_STREQ("C3", p3->GetCategory()->GetName().c_str());
            }
    );

    const auto SCHEMA1_HASH_ECDB_MAP = "680aeba74606e5052fa275fc3401baa3a1e84f19128eb854f37d68554a4d64d6";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "745bdc17145801a827c5404d318d1cd8903b73f2bf163d46c24aee86f173f7c7";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "0a4fb1822f4492fd9954a3d68283f59fc30b76698bf5be26ba5c1a8478f5e367";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="2.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <PropertyCategory typeName="C3" description="C3" displayLabel="C3" priority="3" />
                    <PropertyCategory typeName="C4" description="C4" displayLabel="C4" priority="4" />
                    <PropertyCategory typeName="C5" description="C5" displayLabel="C5" priority="5" />
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="P1" typeName="double" category="C4" />
                        <ECProperty propertyName="P2" typeName="double" />
                        <ECProperty propertyName="P3" typeName="double" category="C3" />
                        <ECProperty propertyName="P4" typeName="double" category="C1" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Assert properties in the edited schema",
        [&]()
            {
            ASSERT_EQ(BE_SQLITE_OK, ReopenECDb());

            PropertyCategoryCP c1 = m_briefcase->Schemas().GetPropertyCategory("Schema1", "C1");
            ASSERT_TRUE(c1 != nullptr);
            ASSERT_STREQ("C1", c1->GetName().c_str());
            ASSERT_EQ(1, (int) c1->GetPriority());

            PropertyCategoryCP c2 = m_briefcase->Schemas().GetPropertyCategory("Schema1", "C2");
            ASSERT_TRUE(c1 != nullptr);
            ASSERT_STREQ("C2", c2->GetName().c_str());
            ASSERT_EQ(2, (int) c2->GetPriority());

            PropertyCategoryCP c3 = m_briefcase->Schemas().GetPropertyCategory("Schema1", "C3");
            ASSERT_TRUE(c1 != nullptr);
            ASSERT_STREQ("C3", c3->GetName().c_str());
            ASSERT_EQ(3, (int) c3->GetPriority());

            PropertyCategoryCP c4 = m_briefcase->Schemas().GetPropertyCategory("Schema1", "C4");
            ASSERT_TRUE(c4 != nullptr);
            ASSERT_STREQ("C4", c4->GetName().c_str());
            ASSERT_EQ(4, (int) c4->GetPriority());

            PropertyCategoryCP c5 = m_briefcase->Schemas().GetPropertyCategory("Schema1", "C5");
            ASSERT_TRUE(c5 != nullptr);
            ASSERT_STREQ("C5", c5->GetName().c_str());
            ASSERT_EQ(5, (int) c5->GetPriority());

            ECSchemaCP schema1 = m_briefcase->Schemas().GetSchema("Schema1", false);
            ASSERT_TRUE(schema1 != nullptr);

            ECClassCP fooClass = m_briefcase->Schemas().GetClass("Schema1", "Foo");
            ASSERT_TRUE(fooClass != nullptr);
            ASSERT_EQ(5, schema1->GetPropertyCategoryCount());

            ECPropertyCP p1 = fooClass->GetPropertyP("P1");
            ASSERT_TRUE(p1 != nullptr);
            ASSERT_TRUE(p1->GetCategory() != nullptr);
            ASSERT_STREQ("C4", p1->GetCategory()->GetName().c_str());

            ECPropertyCP p2 = fooClass->GetPropertyP("P2");
            ASSERT_TRUE(p2 != nullptr);
            ASSERT_TRUE(p2->GetCategory() == nullptr);

            ECPropertyCP p3 = fooClass->GetPropertyP("P3");
            ASSERT_TRUE(p3 != nullptr);
            ASSERT_TRUE(p3->GetCategory() != nullptr);
            ASSERT_STREQ("C3", p3->GetCategory()->GetName().c_str());;

            ECPropertyCP p4 = fooClass->GetPropertyP("P4");
            ASSERT_TRUE(p4 != nullptr);
            ASSERT_TRUE(p4->GetCategory() != nullptr);
            ASSERT_STREQ("C1", p4->GetCategory()->GetName().c_str());
            }
    );

    Test(
        "Delete a Category",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "2f339962b84b8e2eae98a4572b85d1104f5fdfb22ad3aea05c6c775fb7645f41";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="3.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <PropertyCategory typeName="C3" description="C3" displayLabel="C3" priority="3" />
                    <PropertyCategory typeName="C4" description="C4" displayLabel="C4" priority="4" />
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="P1" typeName="double" category="C4" />
                        <ECProperty propertyName="P2" typeName="double" />
                        <ECProperty propertyName="P3" typeName="double" category="C3" />
                        <ECProperty propertyName="P4" typeName="double" category="C1" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, PropertyCategoryDelete)
    {
    const auto SCHEMA1_HASH_ECDB_MAP = "680aeba74606e5052fa275fc3401baa3a1e84f19128eb854f37d68554a4d64d6";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "745bdc17145801a827c5404d318d1cd8903b73f2bf163d46c24aee86f173f7c7";
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "0bf11fb1ab30ee77f896a0460071a736e04fae1abbe4d1639d8179f27213799a";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <PropertyCategory typeName="C3" description="C3" displayLabel="C3" priority="3" />
                    <PropertyCategory typeName="C4" description="C4" displayLabel="C4" priority="4" />
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="P1" typeName="double" category="C1" />
                        <ECProperty propertyName="P2" typeName="double" category="C2" />
                        <ECProperty propertyName="P3" typeName="double" category="C3" />
                        <ECProperty propertyName="P4" typeName="double" category="C4" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("getpropertycategories", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "PropertyCategory deletion should work if there are no dangling references",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "ea07aca8062e1563c12f43cbd662c6e74d936dff282bbb5dbd5a6ee707bc250f";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="2.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <PropertyCategory typeName="C3" description="C3" displayLabel="C3" priority="3" />
                    <PropertyCategory typeName="C5" description="C5" displayLabel="C5" priority="5" />
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="P1" typeName="double" category="C1" />
                        <ECProperty propertyName="P2" typeName="double" category="C2"/>
                        <ECProperty propertyName="P3" typeName="double" category="C3" />
                        <ECProperty propertyName="P4" typeName="double" category="C5" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, LegalPropertyCategoryDeleteWithDoNotFailFlag)
    {
    const auto SCHEMA1_HASH_ECDB_MAP = "680aeba74606e5052fa275fc3401baa3a1e84f19128eb854f37d68554a4d64d6";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "745bdc17145801a827c5404d318d1cd8903b73f2bf163d46c24aee86f173f7c7";
    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "0bf11fb1ab30ee77f896a0460071a736e04fae1abbe4d1639d8179f27213799a";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <PropertyCategory typeName="C3" description="C3" displayLabel="C3" priority="3" />
                    <PropertyCategory typeName="C4" description="C4" displayLabel="C4" priority="4" />
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="P1" typeName="double" category="C1" />
                        <ECProperty propertyName="P2" typeName="double" category="C2" />
                        <ECProperty propertyName="P3" typeName="double" category="C3" />
                        <ECProperty propertyName="P4" typeName="double" category="C4" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("getpropertycategories", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "PropertyCategory deletion should work if there are no dangling references",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "ea07aca8062e1563c12f43cbd662c6e74d936dff282bbb5dbd5a6ee707bc250f";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="2.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <PropertyCategory typeName="C3" description="C3" displayLabel="C3" priority="3" />
                    <PropertyCategory typeName="C5" description="C5" displayLabel="C5" priority="5" />
                    <ECEntityClass typeName="Foo" >
                        <ECProperty propertyName="P1" typeName="double" category="C1" />
                        <ECProperty propertyName="P2" typeName="double" category="C2"/>
                        <ECProperty propertyName="P3" typeName="double" category="C3" />
                        <ECProperty propertyName="P4" typeName="double" category="C5" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::DoNotFailForDeletionsOrModifications));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            PropertyCategoryCP cat = schema->GetPropertyCategoryCP("C4");
            ASSERT_TRUE(cat == nullptr) << "C4";
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, IllegalPropertyCategoryDeleteWithDoNotFailFlag)
    {
    Test(
        "initial schema1 setup should succeed",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "4697b8cef1943d01cf8f188b4a74a8542f61fa2a346fd0f9fc41120735e10412";
            const auto SCHEMA_HASH_ECDB_MAP = "cc05ef847358155e0fb798592b7674399d51317c2d023cd237ff3abcc26a43a3";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "dd425fde9290efc7080acb828fb87a371d83f2c073c9f246a301294d4253b5a2";

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <ECEntityClass typeName="Foo">
                        <ECProperty propertyName="P1" typeName="double" category="C2" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("getpropertycategories", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );


    const auto SCHEMA1_HASH_ECDB_MAP = "1b1ae0f5665cd383b79513c33a1ae6f0dab45115c58f7dc2d047015f91f80444";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ae9a7a553d09613c7f8cf5711dca7a996af71202254deca5cdddde9df2c229ce";
    Test(
        "importing second schema should succeed",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "54f7e30f2a27972d4aebc9425545cf720d05536da5565201a4f9a71d9a4bcf86";

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema2" alias="s2" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="Schema1" version="1.0" alias="s1" />
                    <ECEntityClass typeName="Foo">
                        <ECProperty propertyName="P2" typeName="double" category="s1:C2" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Illegal Property Category should be ignored when DoNotFailForDeletionsOrModifications flag is set",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "aeafa2da8beda0edc3403bf237f8b08dba5016c0f4848f6a1e538b035b4b76b6";

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="2.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <ECEntityClass typeName="Foo">
                        <ECProperty propertyName="P1" typeName="double" category="C1" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::DoNotFailForDeletionsOrModifications));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check property",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            PropertyCategoryCP cat = schema->GetPropertyCategoryCP("C2");
            ASSERT_TRUE(cat != nullptr) << "C2";
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, PropertyCategoryDeleteReferencedFails)
    {
    Test(
        "initial schema setup should succeed",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "4697b8cef1943d01cf8f188b4a74a8542f61fa2a346fd0f9fc41120735e10412";
            const auto SCHEMA_HASH_ECDB_MAP = "cc05ef847358155e0fb798592b7674399d51317c2d023cd237ff3abcc26a43a3";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "dd425fde9290efc7080acb828fb87a371d83f2c073c9f246a301294d4253b5a2";

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <ECEntityClass typeName="Foo">
                        <ECProperty propertyName="P1" typeName="double" category="C2" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("getpropertycategories", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "54f7e30f2a27972d4aebc9425545cf720d05536da5565201a4f9a71d9a4bcf86";
    const auto SCHEMA1_HASH_ECDB_MAP = "1b1ae0f5665cd383b79513c33a1ae6f0dab45115c58f7dc2d047015f91f80444";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ae9a7a553d09613c7f8cf5711dca7a996af71202254deca5cdddde9df2c229ce";
    Test(
        "importing second schema should succeed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema2" alias="s2" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="Schema1" version="1.0" alias="s1" />
                    <ECEntityClass typeName="Foo">
                        <ECProperty propertyName="P2" typeName="double" category="s1:C2" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "deleting category while a property still references it should be an error",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <ECEntityClass typeName="Foo">
                        <ECProperty propertyName="P1" typeName="double" category="C1" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "deleting category and removing referencing properties should succeed",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "26920616ab580d49d92dac00ed4e17be79b013eb2baab8dc0f13c4c38edb8ace";

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema2" alias="s2" version="1.1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="Schema1" version="1.0" alias="s1" />
                    <ECEntityClass typeName="Foo">
                        <ECProperty propertyName="P2" typeName="double" category="s1:C1" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, PropertyCategoryOverwriteDeleteReferencedFails)
    {
    // Same as previous but Import final schemas in different order and overwrite the previous version by
    // using the same version
    Test(
        "initial schema setup should succeed",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "4697b8cef1943d01cf8f188b4a74a8542f61fa2a346fd0f9fc41120735e10412";
            const auto SCHEMA_HASH_ECDB_MAP = "cc05ef847358155e0fb798592b7674399d51317c2d023cd237ff3abcc26a43a3";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "dd425fde9290efc7080acb828fb87a371d83f2c073c9f246a301294d4253b5a2";

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <PropertyCategory typeName="C2" description="C2" displayLabel="C2" priority="2" />
                    <ECEntityClass typeName="Foo">
                        <ECProperty propertyName="P1" typeName="double" category="C2" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("getpropertycategories", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "b04d8d36bdd856e54f39355a093e73bca97f1d5dba387f79329c84d840630c62";
    const auto SCHEMA1_HASH_ECDB_MAP = "cc05ef847358155e0fb798592b7674399d51317c2d023cd237ff3abcc26a43a3";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "dd425fde9290efc7080acb828fb87a371d83f2c073c9f246a301294d4253b5a2";
    Test(
        "importing second schema should succeed",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <PropertyCategory typeName="C1" description="C1" displayLabel="C1" priority="1" />
                    <ECEntityClass typeName="Foo">
                        <ECProperty propertyName="P1" typeName="double" category="C1" />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    auto schemas = std::vector<SchemaItem>{
        SchemaItem(
            R"xml(<?xml version="1.0" encoding="utf-8" ?>
            <ECSchema schemaName="Schema2" alias="s2" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                <ECSchemaReference name="Schema1" version="1.0" alias="s1" />
                <ECEntityClass typeName="Foo">
                    <ECProperty propertyName="P2" typeName="double" category="s1:C2" />
                </ECEntityClass>
            </ECSchema>)xml"
        ),
        SchemaItem(
            R"xml(<?xml version="1.0" encoding="utf-8" ?>
            <ECSchema schemaName="Schema2" alias="s2" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                <ECSchemaReference name="Schema1" version="1.0" alias="s1" />
                <ECEntityClass typeName="Foo">
                    <ECProperty propertyName="P2" typeName="double" category="s1:C1" />
                </ECEntityClass>
            </ECSchema>)xml"
        )
    };

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "5c75a9a15cdf58409b1c31e5f6522d48dd52366cdef7433854829bb0f7150c15";
    const auto SCHEMA2_HASH_ECDB_MAP = "1b1ae0f5665cd383b79513c33a1ae6f0dab45115c58f7dc2d047015f91f80444";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "ae9a7a553d09613c7f8cf5711dca7a996af71202254deca5cdddde9df2c229ce";

    Test(
        "referencing an invalid property category should not fail import and category should be ignored",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*schemas.begin()));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "deleting category and removing referencing properties should succeed",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchemas(*m_briefcase, schemas, SchemaManager::SchemaImportOptions::None, m_schemaChannel->GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, PropertyCategory)
    {
    auto assertCategory = [](ECSchemaCR schema, Utf8CP name, Utf8CP displayLabel, Utf8CP description, uint32_t priority)
        {
        PropertyCategoryCP cat = schema.GetPropertyCategoryCP(name);
        ASSERT_TRUE(cat != nullptr) << name;
        EXPECT_STREQ(name, cat->GetName().c_str()) << name;
        EXPECT_EQ(priority, cat->GetPriority()) << name;
        if (Utf8String::IsNullOrEmpty(displayLabel))
            EXPECT_FALSE(cat->GetIsDisplayLabelDefined()) << name;
        else
            EXPECT_STREQ(displayLabel, cat->GetDisplayLabel().c_str()) << name;

        if (Utf8String::IsNullOrEmpty(description))
            description = "";

        EXPECT_STREQ(description, cat->GetDescription().c_str()) << name;
        };

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "6bd56dc507cb2ba339b2a8713929e70523f83f0c2923a02f0811593b3bf8f15c";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                        <PropertyCategory typeName="C1" description="My Category 1" displayLabel="Category 1" priority="1" />
                        <PropertyCategory typeName="C2" description="My Category 2" displayLabel="Category 2" priority="2" />
                        <PropertyCategory typeName="C3" description="My Category 3" displayLabel="Category 3" priority="3" />
                        <PropertyCategory typeName="C4" description="My Category 4" displayLabel="Category 4" priority="4" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_PropertyCategory", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema categories",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_NE(nullptr, schema);

            assertCategory(*schema, "C1", "Category 1", "My Category 1", 1);
            assertCategory(*schema, "C2", "Category 2", "My Category 2", 2);
            assertCategory(*schema, "C3", "Category 3", "My Category 3", 3);
            assertCategory(*schema, "C4", "Category 4", "My Category 4", 4);
            }
    );

    Test(
        "Deleting a category is supported",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "4dd9fefd9904dcfae6daaabc9bafc5a35577c15a7cf51bc6a58bc4899947c03b";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <PropertyCategory typeName="C1" description="My Category 1" displayLabel="Category 1" priority="1" />
                    <PropertyCategory typeName="C2" description="My Category 2" displayLabel="Category 2" priority="2" />
                    <PropertyCategory typeName="C4" description="My Category 4" displayLabel="Category 4" priority="4" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Adding a category is supported",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "81b79056177d032b15429d8870bf65babf3a6b14ec9e081f9c86ed5976ea4102";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <PropertyCategory typeName="C1" description="My Category 1" displayLabel="Category 1" priority="1" />
                    <PropertyCategory typeName="C2" description="My Category 2" displayLabel="Category 2" priority="2" />
                    <PropertyCategory typeName="C3" description="My Category 3" displayLabel="Category 3" priority="3" />
                    <PropertyCategory typeName="C4" description="My Category 4" displayLabel="Category 4" priority="4" />
                    <PropertyCategory typeName="C5" description="My Category 5" displayLabel="Category 5" priority="5" />
                    <PropertyCategory typeName="C6" description="My Category 6" displayLabel="Category 6" priority="6" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema categories after deleting and adding",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_NE(nullptr, schema);

            assertCategory(*schema, "C1", "Category 1", "My Category 1", 1);
            assertCategory(*schema, "C2", "Category 2", "My Category 2", 2);
            assertCategory(*schema, "C3", "Category 3", "My Category 3", 3);
            assertCategory(*schema, "C4", "Category 4", "My Category 4", 4);
            assertCategory(*schema, "C5", "Category 5", "My Category 5", 5);
            assertCategory(*schema, "C6", "Category 6", "My Category 6", 6);
            }
    );

    Test(
        "Modifying a category is supported",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "b0d12529f36a9a57412eba5d05db96ca8bb152aef11adfa73433d7d1cb0333e6";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <PropertyCategory typeName="C1" displayLabel="Category 1" priority="1" />
                    <PropertyCategory typeName="C2" description="My Category 2" priority="2" />
                    <PropertyCategory typeName="C3" description="My nice Category 3" displayLabel="Category 3" priority="3" />
                    <PropertyCategory typeName="C4" description="My Category 4" displayLabel="Nice Category 4" priority="4" />
                    <PropertyCategory typeName="C5" description="My Category 5" displayLabel="Category 5" priority="50" />
                    <PropertyCategory typeName="C6" description="My Category 6" displayLabel="Category 6" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema categories after modifying",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_NE(nullptr, schema);

            assertCategory(*schema, "C1", "Category 1", nullptr, 1);
            assertCategory(*schema, "C2", nullptr, "My Category 2", 2);
            assertCategory(*schema, "C3", "Category 3", "My nice Category 3", 3);
            assertCategory(*schema, "C4", "Nice Category 4", "My Category 4", 4);
            assertCategory(*schema, "C5", "Category 5", "My Category 5", 50);
            //deleting the priority from the schema amounts to setting it to 0
            assertCategory(*schema, "C6", "Category 6", "My Category 6", 0);
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UnitSystems)
    {
    auto assertUnitSystem = [] (ECSchemaCR schema, Utf8CP name, Utf8CP displayLabel, Utf8CP description)
        {
        UnitSystemCP system = schema.GetUnitSystemCP(name);
        ASSERT_TRUE(system != nullptr) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(name, system->GetName().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(displayLabel, system->GetDisplayLabel().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(description, system->GetDescription().c_str()) << schema.GetFullSchemaName() << ":" << name;
        };

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "6d3aadb0464230000d9ba16f46ea51064257e12e7fa5ac5378d159066d72eb5c";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <UnitSystem typeName="UNUSEDU" displayLabel="Unused" description="Unused" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_unitsystems", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema values",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            assertUnitSystem(*schema, "METRIC", "Metric", "Metric Units of measure");
            assertUnitSystem(*schema, "IMPERIAL", "Imperial", "Units of measure from the British Empire");
            assertUnitSystem(*schema, "UNUSEDU", "Unused", "Unused");
            }
    );

    Test(
        "Deleting a unit system is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Renaming a UnitSystem is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.2" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <UnitSystem typeName="UNUSEDUS" displayLabel="Unused" description="Unused" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Adding a unit system, modifying display label and description of unit system, removing display label and description of unit system",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "e683b3ba3e15e0d340badaba3d9e0d787575f19fc4103947b7af23038d83d125";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.3" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="ImperialSystem" description="Units of measure from the British Empire." />
                    <UnitSystem typeName="UNUSEDU" displayLabel="Unused" description="Unused" />
                    <UnitSystem typeName="MyLocalOne" displayLabel="My Local one"  />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema values after modifications",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            assertUnitSystem(*schema, "METRIC", "METRIC", "");
            assertUnitSystem(*schema, "IMPERIAL", "ImperialSystem", "Units of measure from the British Empire.");
            assertUnitSystem(*schema, "UNUSEDU", "Unused", "Unused");
            assertUnitSystem(*schema, "MyLocalOne", "My Local one", "");
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Phenomena)
    {
    auto assertPhenomenon = [] (ECSchemaCR schema, Utf8CP name, Utf8CP displayLabel, Utf8CP description, Utf8CP definition)
        {
        PhenomenonCP phen = schema.GetPhenomenonCP(name);
        ASSERT_TRUE(phen != nullptr) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(name, phen->GetName().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(definition, phen->GetDefinition().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(displayLabel, phen->GetDisplayLabel().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(description, phen->GetDescription().c_str()) << schema.GetFullSchemaName() << ":" << name;
        };

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "ccaf6d9238bf9dc822867ba374bebdb8fa62b9fcf58b556cdd5c3afda0ed5604";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_phenomena", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema phenomenon",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            assertPhenomenon(*schema, "AREA", "Area", "", "LENGTH*LENGTH");
            assertPhenomenon(*schema, "UNUSEDP", "Unused", "", "LENGTH*LENGTH");
            }
    );

    Test(
        "Deleting a phenomenon is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Renaming a Phenomenon is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.2" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDPHEN" displayLabel="Unused" definition="LENGTH*LENGTH" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying Phenomenon.Definition is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.3" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Adding a phenomenon, modifying display label and description of phenomenon",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "277108218ae9caa645b900c85fd9c0806343ace92cc4da016cb6f18b0ea03255";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.4" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <Phenomenon typeName="AREA" displayLabel="Areal" description="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="VOLUME" displayLabel="Volume" definition="LENGTH*LENGTH*LENGTH" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema phenomenon after modifications",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            assertPhenomenon(*schema, "AREA", "Areal", "Area", "LENGTH*LENGTH");
            assertPhenomenon(*schema, "UNUSEDP", "Unused", "", "LENGTH*LENGTH");
            assertPhenomenon(*schema, "VOLUME", "Volume", "", "LENGTH*LENGTH*LENGTH");
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Units)
    {
    auto assertUnit = [](ECSchemaCR schema, Utf8CP name, Utf8CP displayLabel, Utf8CP description, Utf8CP definition, double numerator, double denominator, double offset, Utf8CP phenomenon, Utf8CP unitSystem)
        {
        ECUnitCP unit = schema.GetUnitCP(name);
        ASSERT_TRUE(unit != nullptr) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(name, unit->GetName().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(definition, unit->GetDefinition().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(displayLabel, unit->GetDisplayLabel().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(description, unit->GetDescription().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_DOUBLE_EQ(numerator, unit->GetNumerator()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_DOUBLE_EQ(denominator, unit->GetDenominator()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_DOUBLE_EQ(offset, unit->GetOffset()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(phenomenon, unit->GetPhenomenon()->GetFullName().c_str()) << schema.GetFullSchemaName() << ":" << name;
        ASSERT_STREQ(unitSystem, unit->GetUnitSystem()->GetFullName().c_str()) << schema.GetFullSchemaName() << ":" << name;
        };

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "3780bc9b30cc32f1633478be3098e3a37df04075f41f86edf4b3e7cd6bec0d39";
    Test(
        "Import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareM" displayLabel="Square Meter" definition="M*M" numerator="1.0" phenomenon="AREA" unitSystem="METRIC" />
                    <Unit typeName="SquareFt" displayLabel="Square Feet" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_units", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema units",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            assertUnit(*schema, "SquareM", "Square Meter", "", "M*M", 1.0, 1.0, 0.0, "Schema1:AREA", "Schema1:METRIC");
            assertUnit(*schema, "SquareFt", "Square Feet", "", "Ft*Ft", 10.0, 1.0, 0.4, "Schema1:AREA", "Schema1:IMPERIAL");
            }
    );

    Test(
        "Deleting a unit is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareFt" displayLabel="Square Feet" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Renaming a Unit is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.2" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareMeter" displayLabel="Square Meter" definition="M*M" numerator="1.0" phenomenon="AREA" unitSystem="METRIC" />
                    <Unit typeName="SquareFt" displayLabel="Square Feet" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying Unit.Definition is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.3" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareM" displayLabel="Square Meter" definition="M*M*" numerator="1.0" phenomenon="AREA" unitSystem="METRIC" />
                    <Unit typeName="SquareFt" displayLabel="Square Feet" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying Unit.Numerator is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.4" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareM" displayLabel="Square Meter" definition="M*M" numerator="1.5" phenomenon="AREA" unitSystem="METRIC" />
                    <Unit typeName="SquareFt" displayLabel="Square Feet" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying Unit.Denominator is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.5" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareM" displayLabel="Square Meter" definition="M*M" numerator="1.0" denominator="2.0" phenomenon="AREA" unitSystem="METRIC" />
                    <Unit typeName="SquareFt" displayLabel="Square Feet" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying Unit.Offset is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.6" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareM" displayLabel="Square Meter" definition="M*M" numerator="1.0" offset="1.0" phenomenon="AREA" unitSystem="METRIC" />
                    <Unit typeName="SquareFt" displayLabel="Square Feet" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying Unit.UnitSystem is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.7" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareM" displayLabel="Square Meter" definition="M*M" numerator="1.0" phenomenon="AREA" unitSystem="IMPERIAL" />
                    <Unit typeName="SquareFt" displayLabel="Square Feet" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Modifying Unit.Phenomenon is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.8" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" displayLabel="Metric" description="Metric Units of measure" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="Imperial" description="Units of measure from the British Empire" />
                    <Phenomenon typeName="AREA" displayLabel="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareM" displayLabel="Square Meter" definition="M*M" numerator="1.0" phenomenon="UNUSEDP" unitSystem="METRIC" />
                    <Unit typeName="SquareFt" displayLabel="Square Feet" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Adding a unit, modifying display label and description of unit, removing display label of unit",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "1f84f073fb5628db9f18be0152af5a91b44350b61519965b024e6e9caf9daf53";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema1" alias="s1" version="1.0.9" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="METRIC" />
                    <UnitSystem typeName="IMPERIAL" displayLabel="ImperialSystem" description="Units of measure from the British Empire." />
                    <Phenomenon typeName="AREA" displayLabel="Areal" description="Area" definition="LENGTH*LENGTH" />
                    <Phenomenon typeName="UNUSEDP" displayLabel="Unused" definition="LENGTH*LENGTH" />
                    <Unit typeName="SquareM" displayLabel="Square Metre" description="Square Metre" definition="M*M" numerator="1.0" phenomenon="AREA" unitSystem="METRIC" />
                    <Unit typeName="SquareFt" definition="Ft*Ft" numerator="10.0" offset="0.4" phenomenon="AREA" unitSystem="IMPERIAL" />
                    <Unit typeName="MyUnit" displayLabel="My Unit" description="my nice unit" definition="M*M" numerator="1.0" phenomenon="AREA" unitSystem="METRIC" />
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema units after modifications",
        [&]()
            {
            ECSchemaCP schema = m_briefcase->Schemas().GetSchema("Schema1");
            ASSERT_TRUE(schema != nullptr);

            assertUnit(*schema, "SquareM", "Square Metre", "Square Metre", "M*M", 1.0, 1.0, 0.0, "Schema1:AREA", "Schema1:METRIC");
            assertUnit(*schema, "SquareFt", "SquareFt", "", "Ft*Ft", 10.0, 1.0, 0.4, "Schema1:AREA", "Schema1:IMPERIAL");
            assertUnit(*schema, "MyUnit", "My Unit", "my nice unit", "M*M", 1.0, 1.0, 0.0, "Schema1:AREA", "Schema1:METRIC");
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AllowedChangingUnitConversionProperties)
    {
    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "7c971f1b51995e5c3ebc26d3d6b05f1f34189cc9c77c7a3492cc1696e7a0ff9f";
            auto schema = SchemaItem(
                R"schema(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="01.00.07" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="TestUnitSystem"/>
                    <Phenomenon typeName="LENGTH" definition="LENGTH"/>
                    <Unit typeName="TestUnit1" phenomenon="LENGTH" unitSystem="TestUnitSystem" definition="TestUnit1" description="Test unit 1." displayLabel="TestLabel1"/>
                </ECSchema>)schema"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_unitsystems", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Changing from undefined to default values is allowed",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "d580a1e84b62ad088235a2ac5bb02da98a0f01ece96add8d81b391917c87ed33";
            auto schema = SchemaItem(
                R"schema(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="TestSchema" alias="ts" version="01.00.07" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <UnitSystem typeName="TestUnitSystem"/>
                    <Phenomenon typeName="LENGTH" definition="LENGTH"/>
                    <Unit typeName="TestUnit1" phenomenon="LENGTH" unitSystem="TestUnitSystem" definition="TestUnit1" description="Test unit 1." displayLabel="TestLabel1" numerator="1.0" denominator="1.0" offset="0.0"/>
                </ECSchema>)schema"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, NotAllowedChangingUnitConversionProperties)
    {
    // Numerator, denominator and offset propertise are undefined
    SchemaItem schemaWithoutUnitProperties(R"schema(<?xml version="1.0" encoding="UTF-8"?>
        <ECSchema schemaName="TestSchema" alias="ts" version="01.00.07" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
            <UnitSystem typeName="TestUnitSystem"/>
            <Phenomenon typeName="LENGTH" definition="LENGTH"/>
            <Unit typeName="TestUnit1" phenomenon="LENGTH" unitSystem="TestUnitSystem" definition="TestUnit1" description="Test unit 1." displayLabel="TestLabel1"/>
        </ECSchema>)schema");
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "7c971f1b51995e5c3ebc26d3d6b05f1f34189cc9c77c7a3492cc1696e7a0ff9f";

    // Numerator, denominator and offset propertise are not default values
    SchemaItem schemaWithUnitProperties(R"schema(<?xml version="1.0" encoding="UTF-8"?>
        <ECSchema schemaName="TestSchema" alias="ts" version="01.00.07" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
            <UnitSystem typeName="TestUnitSystem"/>
            <Phenomenon typeName="LENGTH" definition="LENGTH"/>
            <Unit typeName="TestUnit1" phenomenon="LENGTH" unitSystem="TestUnitSystem" definition="TestUnit1" description="Test unit 1." displayLabel="TestLabel1" numerator="3.0" denominator="2.0" offset="2.0"/>
        </ECSchema>)schema");
    const auto SCHEMA2_HASH_ECDB_SCHEMA = "7d63bc23dc3764364c0b0a0e17df9ebc7ee921375e6b802fed561e119cbcbc5a";


    Test(
        "Import initial schemas without unit properties",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("testDB", schemaWithoutUnitProperties));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Deleting a unit system is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml()xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schemaWithUnitProperties)) << "ECSchema Upgrade failed. Changing properties of Unit 'TestSchema:TestUnit1' is not supported except for DisplayLabel and Description.";
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Import initial schemas with unit properties",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("testDB1", schemaWithUnitProperties));
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Deleting a unit system is not supported",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schemaWithoutUnitProperties)) << "ECSchema Upgrade failed. Changing properties of Unit 'TestSchema:TestUnit1' is not supported except for DisplayLabel and Description.";
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, AllowedChangingConstantConversionProperties)
    {
    // Denominator property is undefined
    SchemaItem schemaWithoutConstantProperties(
        R"schema(<?xml version="1.0" encoding="UTF-8"?>
        <ECSchema xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2" version="01.02.03" schemaName="TestSchema" alias="t">
            <Constant typeName="TestConstant" displayLabel="Test Constant" description="testing a constant" definition="TestConstant" phenomenon="TestPhenomenon" numerator="1.0"/>
            <Phenomenon typeName="TestPhenomenon" definition="TestPhenomenon" />
            <UnitSystem typeName="TestUnitSystem" />
        </ECSchema>)schema"
    );
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "679b0da3c4f6709e829c8f97b1e7dcf0a1d7b2f67732e53b1e80df0160536bad";

    // Denominator property is set to default
    SchemaItem schemaWithConstantProperties(
        R"schema(<?xml version="1.0" encoding="UTF-8"?>
        <ECSchema xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2" version="01.02.03" schemaName="TestSchema" alias="t">
            <Constant typeName="TestConstant" displayLabel="Test Constant" description="testing a constant" definition="TestConstant" phenomenon="TestPhenomenon" numerator="1.0" denominator="1.0"/>
            <Phenomenon typeName="TestPhenomenon" definition="TestPhenomenon" />
            <UnitSystem typeName="TestUnitSystem" />
        </ECSchema>)schema"
    );
    const auto SCHEMA2_HASH_ECDB_SCHEMA = "25059b91331afdf2125ad07a307e7e72f0e63c351c05180d7966b4b969af0f03";

    Test(
        "import schema without constant property",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("testDB", schemaWithoutConstantProperties));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "import schema with constant property",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schemaWithConstantProperties));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, NotAllowedChangingConstantConversionProperties)
    {
    // Denominator property is undefined
    SchemaItem schemaWithoutConstantProperty(
        R"schema(<?xml version="1.0" encoding="UTF-8"?>
        <ECSchema schemaName="TestSchema" alias="ts" version="01.00.07" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
            <UnitSystem typeName="TestUnitSystem"/>
            <Phenomenon typeName="LENGTH" definition="LENGTH"/>
            <Constant typeName="TestConstant" phenomenon="LENGTH" definition="TestConstant" displayLabel="TestLabel1" numerator="1.0"/>
        </ECSchema>)schema"
    );
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "c33e8ca5dc27ca03ea7583fced2289aaa95e6637ab924559435f675fb08a4f12";

    // Denominator and numerator properties are not default value
    SchemaItem schemaWithConstantProperty(
        R"schema(<?xml version="1.0" encoding="UTF-8"?>
        <ECSchema schemaName="TestSchema" alias="ts" version="01.00.07" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
            <UnitSystem typeName="TestUnitSystem"/>
            <Phenomenon typeName="LENGTH" definition="LENGTH"/>
            <Constant typeName="TestConstant" phenomenon="LENGTH" definition="TestConstant" displayLabel="TestLabel1" numerator="3.0" denominator="2.0"/>
        </ECSchema>)schema"
    );
    const auto SCHEMA2_HASH_ECDB_SCHEMA = "f63bff95aad63665233b21d41d5ed7170e37c38f869fbbf8cda78d6632e34787";

    Test(
        "import schema without constant property",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("testDB", schemaWithoutConstantProperty));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "fail to import schema with constant property",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schemaWithConstantProperty));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "import schema with constant property",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("testDB1", schemaWithConstantProperty));
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "fail to import schema without constant property",
        [&]()
            {
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schemaWithoutConstantProperty));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, Formats)
    {
    auto assertFormat = [](ECDbCR ecdb, Utf8CP name, Utf8CP displayLabel, Utf8CP description, JsonValue const& numericSpec, JsonValue const& compSpec)
        {
        ECFormatCP format = ecdb.Schemas().GetFormat("Schema", name);
        ASSERT_TRUE(format != nullptr) << "Schema." << name;

        Utf8String assertMessage(format->GetSchema().GetFullSchemaName());
        assertMessage.append(".").append(format->GetName());

        ASSERT_STREQ(name, format->GetName().c_str()) << assertMessage;
        if (Utf8String::IsNullOrEmpty(displayLabel))
            ASSERT_FALSE(format->GetIsDisplayLabelDefined()) << assertMessage;
        else
            ASSERT_STREQ(displayLabel, format->GetInvariantDisplayLabel().c_str()) << assertMessage;

        if (Utf8String::IsNullOrEmpty(description))
            ASSERT_FALSE(format->GetIsDescriptionDefined()) << assertMessage;
        else
            ASSERT_STREQ(description, format->GetInvariantDescription().c_str()) << assertMessage;

        if (numericSpec.m_value.isNull())
            ASSERT_FALSE(format->HasNumeric()) << assertMessage;
        else
            {
            ASSERT_TRUE(format->HasNumeric()) << assertMessage;
            Json::Value jval;
            ASSERT_TRUE(format->GetNumericSpec()->ToJson(jval, false)) << assertMessage;
            ASSERT_EQ(numericSpec, JsonValue(jval)) << assertMessage;
            }

        if (compSpec.m_value.isNull())
            ASSERT_FALSE(format->HasComposite()) << assertMessage;
        else
            {
            Json::Value jval;
            ASSERT_TRUE(format->GetCompositeSpec()->ToJson(jval)) << assertMessage;
            ASSERT_TRUE(format->HasComposite()) << assertMessage;
            ASSERT_EQ(compSpec, JsonValue(jval)) << assertMessage;
            }
        };

    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "c1ba33ebaaf6c5a4f42fc49efcc3dec582597cf6210fb2bdb7041856f51683de";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <Format typeName="MyFormat" displayLabel="My Format" roundFactor="0.3" type="Fractional" showSignOption="OnlyNegative" formatTraits="TrailZeroes|KeepSingleZero"
                            precision="4" decimalSeparator="." thousandSeparator="," uomSeparator=" ">
                    </Format>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_formats", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check initial schema format",
        [&]()
            {
            auto numericSpec = JsonValue(
                R"json({
                    "roundFactor":0.3,
                    "type": "Fractional",
                    "showSignOption": "OnlyNegative",
                    "formatTraits": ["trailZeroes", "keepSingleZero"],
                    "precision": 4,
                    "decimalSeparator": ".",
                    "thousandSeparator": ",",
                    "uomSeparator": " "
                })json"
            );
            assertFormat(*m_briefcase, "MyFormat", "My Format", "", numericSpec, JsonValue());
            }
    );

    Test(
        "Modify DisplayLabel, Description, NumericSpec",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "7821e469378ed6dee3396f5899459e9071422c4982868662712253aaddd349a3";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema" alias="ts" version="1.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <Format typeName="MyFormat" displayLabel="My nice Format" description="Real nice format" roundFactor="1.3" type="Scientific" scientificType="ZeroNormalized" showSignOption="SignAlways" formatTraits="KeepSingleZero"
                            precision="5" decimalSeparator="," thousandSeparator="." uomSeparator="#">
                    </Format>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check modified schema format",
        [&]()
            {
            auto numericSpec = JsonValue(
                R"json({
                    "roundFactor":1.3,
                    "type": "Scientific",
                    "scientificType":"ZeroNormalized",
                    "showSignOption": "SignAlways",
                    "formatTraits": ["keepSingleZero"],
                    "precision": 5, "decimalSeparator": ",",
                    "thousandSeparator": ".",
                    "uomSeparator": "#"
                })json"
            );
            assertFormat(*m_briefcase, "MyFormat", "My nice Format", "Real nice format", numericSpec, JsonValue());
            }
    );


    const auto SCHEMA1_HASH_ECDB_SCHEMA = "f0a697922495183d20cd2d6b1ce02ba014203c1fe4336863d2a268838e36d67c";
    Test(
        "remove optional attributes from num spec",
        [&]()
            {

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema" alias="ts" version="1.0.2" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <Format typeName="MyFormat" roundFactor="1.3" type="Scientific" scientificType="ZeroNormalized" showSignOption="SignAlways"
                            precision="5">
                    </Format>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check schema format with removed optional attributes",
        [&]()
            {
            auto numericSpec = JsonValue(R"json({"roundFactor":1.3, "type": "Scientific", "scientificType":"ZeroNormalized", "showSignOption": "SignAlways", "precision": 5})json");
            assertFormat(*m_briefcase, "MyFormat", "", "", numericSpec, JsonValue());
            }
    );

    Test(
        "Adding composite is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema" alias="ts" version="1.0.3" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <Format typeName="MyFormat" roundFactor="1.3" type="Scientific" scientificType="ZeroNormalized" showSignOption="SignAlways"
                            precision="5">
                        <Composite>
                            <Unit label="mm">u:MM</Unit>
                        </Composite>
                    </Format>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "start with format that already has a composite",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "c31df30e1eca247565aff4f808fc47a0fd40344ee90ba97c4b751c35df19b611";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema" alias="ts" version="2.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <Unit typeName="MyMeter" displayLabel="My Metre" definition="u:M" numerator="1.0" phenomenon="u:LENGTH" unitSystem="u:METRIC" />
                    <Format typeName="MyFormat" displayLabel="My Format" roundFactor="0.3" type="Fractional" showSignOption="OnlyNegative" formatTraits="TrailZeroes|KeepSingleZero"
                            precision="4" decimalSeparator="." thousandSeparator="," uomSeparator=" ">
                        <Composite>
                            <Unit label="m">MyMeter</Unit>
                            <Unit label="mm">u:MM</Unit>
                        </Composite>
                    </Format>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupgrade_formats", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check new schema format",
        [&]()
            {
            assertFormat(*m_briefcase, "MyFormat", "My Format", "",
                 JsonValue(R"json({"roundFactor":0.3, "type": "Fractional", "showSignOption": "OnlyNegative", "formatTraits": ["trailZeroes", "keepSingleZero"], "precision": 4, "decimalSeparator": ".", "thousandSeparator": ",", "uomSeparator": " "})json"),
                 JsonValue(R"json({"includeZero":true, "units": [{"name":"MyMeter", "label":"m"}, {"name":"MM", "label":"mm"}]})json"));
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "330e71056bbac2f1e382454baf95796d1f93e771cf1cf15fb3387b98b5943c6b";
    Test(
        "Modify CompSpec except for units",
        [&]()
            {

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema" alias="ts" version="2.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <Unit typeName="MyMeter" displayLabel="My Metre" definition="u:M" numerator="1.0" phenomenon="u:LENGTH" unitSystem="u:METRIC" />
                    <Format typeName="MyFormat" displayLabel="My Format" roundFactor="0.3" type="Fractional" showSignOption="OnlyNegative" formatTraits="TrailZeroes|KeepSingleZero"
                            precision="4" decimalSeparator="." thousandSeparator="," uomSeparator=" ">
                        <Composite spacer="=" includeZero="False">
                            <Unit label="meterle">MyMeter</Unit>
                            <Unit label="millimeterle">u:MM</Unit>
                        </Composite>
                    </Format>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Check modified schema format",
        [&]()
            {
            assertFormat(*m_briefcase, "MyFormat", "My Format", "",
                 JsonValue(R"json({"roundFactor":0.3, "type": "Fractional", "showSignOption": "OnlyNegative", "formatTraits": ["trailZeroes", "keepSingleZero"], "precision": 4, "decimalSeparator": ".", "thousandSeparator": ",", "uomSeparator": " "})json"),
                 JsonValue(R"json({"spacer":"=", "includeZero":false, "units": [{"name":"MyMeter", "label":"meterle"}, {"name":"MM", "label":"millimeterle"}]})json"));
            }
    );

    Test(
        "Modifying Composite Unit is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema" alias="ts" version="2.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <Unit typeName="MyMeter" displayLabel="My Metre" definition="u:M" numerator="1.0" phenomenon="u:LENGTH" unitSystem="u:METRIC" />
                    <Format typeName="MyFormat" displayLabel="My Format" roundFactor="0.3" type="Fractional" showSignOption="OnlyNegative" formatTraits="TrailZeroes|KeepSingleZero"
                            precision="4" decimalSeparator="." thousandSeparator="," uomSeparator=" ">
                        <Composite spacer="=" includeZero="False">
                            <Unit label="meterle">u:M</Unit>
                            <Unit label="millimeterle">u:MM</Unit>
                        </Composite>
                    </Format>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Deleting a Composite Unit is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema" alias="ts" version="2.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <Unit typeName="MyMeter" displayLabel="My Metre" definition="u:M" numerator="1.0" phenomenon="u:LENGTH" unitSystem="u:METRIC" />
                    <Format typeName="MyFormat" displayLabel="My Format" roundFactor="0.3" type="Fractional" showSignOption="OnlyNegative" formatTraits="TrailZeroes|KeepSingleZero"
                            precision="4" decimalSeparator="." thousandSeparator="," uomSeparator=" ">
                        <Composite spacer="=" includeZero="False">
                            <Unit label="meterle">MyMeter</Unit>
                        </Composite>
                    </Format>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );

    Test(
        "Adding a Composite Unit is not supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="Schema" alias="ts" version="2.0.1" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="Units" version="01.00.00" alias="u" />
                    <Unit typeName="MyMeter" displayLabel="My Metre" definition="u:M" numerator="1.0" phenomenon="u:LENGTH" unitSystem="u:METRIC" />
                    <Format typeName="MyFormat" displayLabel="My Format" roundFactor="0.3" type="Fractional" showSignOption="OnlyNegative" formatTraits="TrailZeroes|KeepSingleZero"
                            precision="4" decimalSeparator="." thousandSeparator="," uomSeparator=" ">
                        <Composite spacer="=" includeZero="False">
                            <Unit label="meterle">MyMeter</Unit>
                            <Unit label="millimeterle">u:MM</Unit>
                            <Unit label="kilometerle">u:KM</Unit>
                        </Composite>
                    </Format>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, MultiSessionSchemaImport_TPC)
    {
    Test(
        "Import initial schema with L1",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "11471d4438add3071f6407442bf1f7101a09abbbdd4c01d65f48661ea96cc538";
            const auto SCHEMA_HASH_ECDB_MAP = "a3a4f4bd3e7c375e583bb9d5dde2d4ee593dab571dd1ab2bae88d5c531753137";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "2821726bf97bd871e7e7ca78101175541782ba81be1b692eee2a68547f403a48";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema1' alias='ts1' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA'/>
                    <ECEntityClass typeName='TestClassA' >
                        <ECProperty propertyName='L1' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("multisession_si", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts1.TestClassA (ECInstanceId, L1) VALUES(1, 101)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            }
    );

    Test(
        "import schema with L2",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "7743a2728733771e9c5c24229e5a584c5421b54b8b618c71c97c140ba1496c19";
            const auto SCHEMA_HASH_ECDB_MAP = "e27a81dde2bb68b528d15f9955238ba42ee0ebb407693b6ee296fb38aca7f55f";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "ac93dde76353c71cd46529e0dc9fb3c0db7adb9fd487261692c8b4c7efae03cd";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName='TestSchema2' alias='ts2' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA'/>
                    <ECSchemaReference name='TestSchema1' version='01.00.00' alias='ts1'/>
                    <ECEntityClass typeName='TestClassB' >
                        <BaseClass>ts1:TestClassA</BaseClass>
                        <ECProperty propertyName='L2' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Second insert schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts2.TestClassB (ECInstanceId, L1, L2) VALUES(2, 102, 202)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "cf04062a9bf74ccd5f5e3daea8bb0db6a820dd2a02a51d71d909fa38e6252e0e";
    const auto SCHEMA1_HASH_ECDB_MAP = "58a0204bc83ebddc5fbb9e3d119e07413090cae17ebe26fb633f12c20f22d958";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "1ff0f991ff1ef6ba274718b360b3d53311bb194ea555eb064a67d16c4e6a694e";
    Test(
        "import schema with L3",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName='TestSchema3' alias='ts3' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA'/>
                    <ECSchemaReference name='TestSchema2' version='01.00.00' alias='ts2'/>
                    <ECEntityClass typeName='TestClassC' >
                        <BaseClass>ts2:TestClassB</BaseClass>
                        <ECProperty propertyName='L3' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Third insert schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts3.TestClassC (ECInstanceId, L1, L2, L3) VALUES(3, 103, 203, 303)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            }
    );

    const ECClassCP classTestClassA = m_briefcase->Schemas().GetClass("TestSchema1", "TestClassA");
    const ECClassCP classTestClassB = m_briefcase->Schemas().GetClass("TestSchema2", "TestClassB");
    const ECClassCP classTestClassC = m_briefcase->Schemas().GetClass("TestSchema3", "TestClassC");

    ASSERT_NE(nullptr, classTestClassA);
    ASSERT_NE(nullptr, classTestClassB);
    ASSERT_NE(nullptr, classTestClassC);
    Test(
        "L1",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts1.TestClassA WHERE ECInstanceId=1 AND ECClassId=%s AND L1=101",
                        classTestClassA->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts1.TestClassA WHERE ECInstanceId=2 AND ECClassId=%s AND L1=102",
                        classTestClassB->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts1.TestClassA WHERE ECInstanceId=3 AND ECClassId=%s AND L1=103",
                        classTestClassC->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();
            }
    );

    Test(
        "L2",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("SELECT 1 FROM ts2.TestClassB WHERE ECInstanceId=1")));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step()) << "Not Expecting Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts2.TestClassB WHERE ECInstanceId=2 AND ECClassId=%s AND L1=102 AND L2=202",
                        classTestClassB->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts2.TestClassB WHERE ECInstanceId=3 AND ECClassId=%s AND L1=103 AND L2=203",
                        classTestClassC->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();
            }
    );

   Test(
        "L3",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("SELECT 1 FROM ts3.TestClassC WHERE ECInstanceId=1")));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step()) << "Not Expecting Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("SELECT 1 FROM ts3.TestClassC WHERE ECInstanceId=2 ")));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step()) << "Not Expecting Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts3.TestClassC WHERE ECInstanceId=3 AND ECClassId=%s AND L1=103 AND L2=203 AND L3=303",
                        classTestClassC->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();
            }
    );

    Test(
        "Final hash check",
        [&]()
            {
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

// -------------------------------------------------------------------------------------- -
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, MultiSessionSchemaImport_TPH_Joined_OnDerivedClass)
    {
    Test(
        "Import initial schema with L1",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "11471d4438add3071f6407442bf1f7101a09abbbdd4c01d65f48661ea96cc538";
            const auto SCHEMA_HASH_ECDB_MAP = "a3a4f4bd3e7c375e583bb9d5dde2d4ee593dab571dd1ab2bae88d5c531753137";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "2821726bf97bd871e7e7ca78101175541782ba81be1b692eee2a68547f403a48";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema1' alias='ts1' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA'/>
                    <ECEntityClass typeName='TestClassA' >
                        <ECProperty propertyName='L1' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("multisession_si", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts1.TestClassA (ECInstanceId, L1) VALUES(1, 101)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            }
    );

    Test(
        "import schema with L2",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "0e72376b34d8116a76a63dccc11def3103ccd9944c5ad4283f8ab3a820d701ff";
            const auto SCHEMA_HASH_ECDB_MAP = "c11d8ab770b965c462d934f1f9177fe749fd87824d4a8738fd3eeacb753bd099";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "fd751d28824929a1249194c4d4018c7a5333b5f08b70f771af607225d972eb79";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName='TestSchema2' alias='ts2' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA'/>
                    <ECSchemaReference name='TestSchema1' version='01.00.00' alias='ts1'/>
                    <ECEntityClass typeName='TestClassB' >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                         <JoinedTablePerDirectSubclass xmlns = "ECDbMap.02.00" />
                        </ECCustomAttributes>
                        <BaseClass>ts1:TestClassA</BaseClass>
                        <ECProperty propertyName='L2' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Second insert schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts2.TestClassB (ECInstanceId, L1, L2) VALUES(2, 102, 202)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "899a1b01dd12478aa304ab2a763754903ed0d7fed7118b7f099caec2ea69b7cc";
    const auto SCHEMA1_HASH_ECDB_MAP = "1d21c19eb85166662cd57b4219628730a413c81737e54beb07f1272800fe9923";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "19eef9c97b8be9f7a82a64658c99fc156331906dfd285100146f46f04304454a";
    Test(
        "import schema with L3",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName='TestSchema3' alias='ts3' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA'/>
                    <ECSchemaReference name='TestSchema2' version='01.00.00' alias='ts2'/>
                    <ECEntityClass typeName='TestClassC' >
                        <BaseClass>ts2:TestClassB</BaseClass>
                        <ECProperty propertyName='L3' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Third insert schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts3.TestClassC (ECInstanceId, L1, L2, L3) VALUES(3, 103, 203, 303)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            }
    );

    const ECClassCP classTestClassA = m_briefcase->Schemas().GetClass("TestSchema1", "TestClassA");
    const ECClassCP classTestClassB = m_briefcase->Schemas().GetClass("TestSchema2", "TestClassB");
    const ECClassCP classTestClassC = m_briefcase->Schemas().GetClass("TestSchema3", "TestClassC");

    ASSERT_NE(nullptr, classTestClassA);
    ASSERT_NE(nullptr, classTestClassB);
    ASSERT_NE(nullptr, classTestClassC);
    Test(
        "L1",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts1.TestClassA WHERE ECInstanceId=1 AND ECClassId=%s AND L1=101",
                        classTestClassA->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts1.TestClassA WHERE ECInstanceId=2 AND ECClassId=%s AND L1=102",
                        classTestClassB->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts1.TestClassA WHERE ECInstanceId=3 AND ECClassId=%s AND L1=103",
                        classTestClassC->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();
            }
    );

    Test(
        "L2",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("SELECT 1 FROM ts2.TestClassB WHERE ECInstanceId=1")));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step()) << "Not Expecting Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts2.TestClassB WHERE ECInstanceId=2 AND ECClassId=%s AND L1=102 AND L2=202",
                        classTestClassB->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts2.TestClassB WHERE ECInstanceId=3 AND ECClassId=%s AND L1=103 AND L2=203",
                        classTestClassC->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();
            }
    );

   Test(
        "L3",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("SELECT 1 FROM ts3.TestClassC WHERE ECInstanceId=1")));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step()) << "Not Expecting Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("SELECT 1 FROM ts3.TestClassC WHERE ECInstanceId=2 ")));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step()) << "Not Expecting Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts3.TestClassC WHERE ECInstanceId=3 AND ECClassId=%s AND L1=103 AND L2=203 AND L3=303",
                        classTestClassC->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();
            }
    );

    Test(
        "Final hash check",
        [&]()
            {
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, MultiSessionSchemaImport_TPH_OnDerivedClass)
    {
    Test(
        "Import initial schema with L1",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "11471d4438add3071f6407442bf1f7101a09abbbdd4c01d65f48661ea96cc538";
            const auto SCHEMA_HASH_ECDB_MAP = "a3a4f4bd3e7c375e583bb9d5dde2d4ee593dab571dd1ab2bae88d5c531753137";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "2821726bf97bd871e7e7ca78101175541782ba81be1b692eee2a68547f403a48";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema1' alias='ts1' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA'/>
                    <ECEntityClass typeName='TestClassA' >
                        <ECProperty propertyName='L1' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("multisession_si", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Insert schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts1.TestClassA (ECInstanceId, L1) VALUES(1, 101)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            }
    );

    Test(
        "import schema with L2",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "e978f82f18a5e05f88d89cd8246585a917605699f9885f287dd50229bdd9f622";
            const auto SCHEMA_HASH_ECDB_MAP = "5d7fb10acf8c16c084b42898ce97a1cc2c0e443b514770f9e887d4a7f93f250d";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "fd751d28824929a1249194c4d4018c7a5333b5f08b70f771af607225d972eb79";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName='TestSchema2' alias='ts2' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA'/>
                    <ECSchemaReference name='TestSchema1' version='01.00.00' alias='ts1'/>
                    <ECEntityClass typeName='TestClassB' >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <BaseClass>ts1:TestClassA</BaseClass>
                        <ECProperty propertyName='L2' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Second insert schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts2.TestClassB (ECInstanceId, L1, L2) VALUES(2, 102, 202)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "d9c1dd492913ab5e653859b3f36145bfa9caa28bc585e71b6e85b97d9b2f6106";
    const auto SCHEMA1_HASH_ECDB_MAP = "a74b32d6668ddad9fc906692d307983567b2e5d915120a9bdcb632cd387ef6c4";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "3a9a899ac76e337b3e442da538e53889dfbc5988e682014083fb76759e691e54";
    Test(
        "import schema with L3",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName='TestSchema3' alias='ts3' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.1'>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap" />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA'/>
                    <ECSchemaReference name='TestSchema2' version='01.00.00' alias='ts2'/>
                    <ECEntityClass typeName='TestClassC' >
                        <BaseClass>ts2:TestClassB</BaseClass>
                        <ECProperty propertyName='L3' typeName='double'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Third insert schema values",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts3.TestClassC (ECInstanceId, L1, L2, L3) VALUES(3, 103, 203, 303)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();
            }
    );

    const ECClassCP classTestClassA = m_briefcase->Schemas().GetClass("TestSchema1", "TestClassA");
    const ECClassCP classTestClassB = m_briefcase->Schemas().GetClass("TestSchema2", "TestClassB");
    const ECClassCP classTestClassC = m_briefcase->Schemas().GetClass("TestSchema3", "TestClassC");

    ASSERT_NE(nullptr, classTestClassA);
    ASSERT_NE(nullptr, classTestClassB);
    ASSERT_NE(nullptr, classTestClassC);
    Test(
        "L1",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts1.TestClassA WHERE ECInstanceId=1 AND ECClassId=%s AND L1=101",
                        classTestClassA->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts1.TestClassA WHERE ECInstanceId=2 AND ECClassId=%s AND L1=102",
                        classTestClassB->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts1.TestClassA WHERE ECInstanceId=3 AND ECClassId=%s AND L1=103",
                        classTestClassC->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();
            }
    );

    Test(
        "L2",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("SELECT 1 FROM ts2.TestClassB WHERE ECInstanceId=1")));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step()) << "Not Expecting Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts2.TestClassB WHERE ECInstanceId=2 AND ECClassId=%s AND L1=102 AND L2=202",
                        classTestClassB->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts2.TestClassB WHERE ECInstanceId=3 AND ECClassId=%s AND L1=103 AND L2=203",
                        classTestClassC->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();
            }
    );

   Test(
        "L3",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("SELECT 1 FROM ts3.TestClassC WHERE ECInstanceId=1")));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step()) << "Not Expecting Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, SqlPrintfString("SELECT 1 FROM ts3.TestClassC WHERE ECInstanceId=2 ")));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step()) << "Not Expecting Row : " << stmt.GetECSql();
            stmt.Finalize();

            ASSERT_EQ(
                ECSqlStatus::Success,
                stmt.Prepare(
                    *m_briefcase,
                    SqlPrintfString(
                        "SELECT 1 FROM ts3.TestClassC WHERE ECInstanceId=3 AND ECClassId=%s AND L1=103 AND L2=203 AND L3=303",
                        classTestClassC->GetId().ToString(BeInt64Id::UseHex::Yes).c_str()
                    )
                )
            );
            ASSERT_EQ(BE_SQLITE_ROW, stmt.Step()) << "Expect Row : " << stmt.GetECSql();
            stmt.Finalize();
            }
    );

    Test(
        "Final hash check",
        [&]()
            {
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateClass_AddStructProperty)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "a85cb4bc03c77acd742934a5674b147d5f659c25ed2937277ccfc8d380aa8673";
    const auto SCHEMA1_HASH_ECDB_MAP = "1dcc46de132feabc89cbac91d89945a19f8249d7f668123924495bfe9f516aaf";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "09b41632226f8839c9dab4977eb80dfd23a1c8233fdf2d0a1141aab82bc15c29";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECStructClass typeName='ST' modifier='None'>
                        <ECProperty propertyName='S1' typeName='int' readOnly='false' />
                        <ECProperty propertyName='S2' typeName='int' readOnly='false' />
                        <ECProperty propertyName='S3' typeName='int' readOnly='false' />
                        <ECProperty propertyName='S4' typeName='int' readOnly='false' />
                        <ECProperty propertyName='S5' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>False</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                        <ECProperty propertyName='P2' typeName='int' />
                        <ECProperty propertyName='P3' typeName='int' />
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "ed1b4d34eb356bb87f7d2de04f87cf233e4ed5f243d236ecd6bd50b73cf7e508";
    const auto SCHEMA2_HASH_ECDB_MAP = "61a3da504bf6f368e19037873cd4a9dfb3d4ae96b8e7355b0c1700357a757c2c";
    const auto SCHEMA2_HASH_SQLITE_SCHEMA = "f5abc5c441b181da4304718eb784db74252a5505044fab31818d5913b31cc4ab";
    Test(
        "Adding StructProperty is supported",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' nameSpacePrefix='ts' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.0'>
                    <ECSchemaReference name = 'ECDbMap' version='02.00' prefix = 'ecdbmap' />
                    <ECStructClass typeName='ST' modifier='None'>
                        <ECProperty propertyName='S1' typeName='int' readOnly='false' />
                        <ECProperty propertyName='S2' typeName='int' readOnly='false' />
                        <ECProperty propertyName='S3' typeName='int' readOnly='false' />
                        <ECProperty propertyName='S4' typeName='int' readOnly='false' />
                        <ECProperty propertyName='S5' typeName='int' readOnly='false' />
                    </ECStructClass>
                    <ECEntityClass typeName='Foo' modifier='None' >
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00'>
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>False</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                        <ECProperty propertyName='P1' typeName='int' />
                        <ECProperty propertyName='P2' typeName='int' />
                        <ECProperty propertyName='P3' typeName='int' />
                        <ECStructProperty propertyName='S' typeName='ST'/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );

            auto newBriefcase = m_hub->CreateBriefcase();
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *newBriefcase,
                    [&]()
                        {
                        CheckHashes(*newBriefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*newBriefcase));
                        ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(*newBriefcase, schema, SchemaManager::SchemaImportOptions::None, GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, newBriefcase->SaveChanges());
            CheckHashes(*newBriefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA2_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Pull and check hashes",
        [&]()
            {
            ASSERT_EQ(
                SchemaSync::Status::OK,
                m_schemaChannel->Pull(
                    *m_briefcase,
                    [&]()
                        {
                        CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, "0c91898b2420372f2c02b21896dd9c928f78fb17d723dabad0606a5dd0a93641", false, __LINE__);
                        ASSERT_TRUE(ForeignkeyCheck(*m_briefcase));
                        ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
                        }
                )
            );
            ASSERT_EQ(SUCCESS, m_briefcase->Schemas().CreateClassViewsInDb());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, DisallowMajorSchemaUpgrade)
    {
    //Note: for each test schema we test it with the minor version being incremented and the major version being incremented
    auto assertImport = [this](Utf8CP schemaTemplate, Utf8CP newSchemaVersion, SchemaManager::SchemaImportOptions options, std::tuple<Utf8CP, Utf8CP, Utf8CP> hashes)
        {
        auto initialSchema = SchemaItem(
            R"xml(<?xml version="1.0" encoding="utf-8" ?>
            <ECSchema schemaName="TestSchema" alias="ts" version="1.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                <ECEntityClass typeName="Parent" >
                    <ECCustomAttributes>
                        <ClassMap xmlns="ECDbMap.02.00">
                            <MapStrategy>TablePerHierarchy</MapStrategy>
                        </ClassMap>
                        <ShareColumns xmlns="ECDbMap.02.00"/>
                    </ECCustomAttributes>
                    <ECProperty propertyName="Name" typeName="string" />
                    <ECProperty propertyName="Code" typeName="int"/>
                    <ECProperty propertyName="Val" typeName="int" />
                </ECEntityClass>
                <ECEntityClass typeName="Sub" >
                    <BaseClass>Parent</BaseClass>
                    <ECProperty propertyName="SubProp" typeName="string" />
                </ECEntityClass>
            </ECSchema>)xml"
        );
        SetupECDb("schemaupgrade_DisallowMajorSchemaUpgrade", initialSchema);
        Utf8String schemaXml;
        schemaXml.Sprintf(schemaTemplate, newSchemaVersion);
        SchemaImportResult actualStat = ImportSchema(SchemaItem(schemaXml), options);
        if (actualStat == SchemaImportResult::OK)
            {
            const auto [schemaHash, mapHash, dbSchemaHash] = hashes;
            CheckHashes(*m_briefcase, schemaHash, mapHash, dbSchemaHash);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, std::get<0>(hashes), std::get<1>(hashes)); });
            }
        return actualStat;
        };

    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "616136b709172fd8b18c5d9213f3c87b5c3d05a852787260324b52e009c45ae4";
    Test(
        "Deleting a property",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml";

            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {"", "", ""})
            ) << "Deleting a property on a shared column (must fail because it requires the major schema version to be incremented)";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Deleting a property on a shared column (must fail because it requires the major schema version to be incremented)";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "195373de08013c06a291d65f20a8cd9560999643512760fcaf4ff514ddb2226c";
            const auto SCHEMA_HASH_ECDB_MAP = "4a10ee8f68f18a559ced9d42a70f626e1902808d616625e8aca5a604ebff9b87";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "Deleting a property on a shared column";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                // assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade)
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Deleting a property on a shared column";
            }
    );

    Test(
        "Deleting a class",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml";

            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {"", "", ""})
            ) << "Deleting a class (must fail because it requires the major schema version to be incremented)";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Deleting a class (must fail because it requires the major schema version to be incremented)";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "22176ec40a646fbc63f5ae7eee793dba7d58d920d8e5734a5734ad1611be6cb4";
            const auto SCHEMA_HASH_ECDB_MAP = "ac70532d749a8c144d51cf686e6a61c46775b9e05ea451760fd229f7a107f0f9";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "Deleting a class";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Deleting a class";
            }
    );

    Test(
        "adding IsNullable constraint on existing property",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" >
                            <ECCustomAttributes>
                                <PropertyMap xmlns="ECDbMap.02.00">
                                    <IsNullable>False</IsNullable>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml";

            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {"", "", ""})
            ) << "IsNullable on existing property is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "IsNullable on existing property is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {"", "", ""})
            ) << "IsNullable on existing property is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "IsNullable on existing property is never supported because adding ECDbMap CA is not allowed";
            }
    );

    Test(
        "adding IsNullable constraint on new property",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                        <ECProperty propertyName="NewProp" typeName="string" >
                            <ECCustomAttributes>
                                <PropertyMap xmlns="ECDbMap.02.00">
                                    <IsNullable>False</IsNullable>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "4561b3ffb11d88309497651e299d6f420786093397d93a98dc6ba4ddec9d86f5";
            const auto SCHEMA_HASH_ECDB_MAP = "84a3a5e11259bae6a8800d8215f48b1e611d5bb77c3bac620da73b23f9e06a92";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "2e503df7e76cb940852191fcae5feb0c7aa11bfddd09d3f22056260426db5c5d";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "IsNullable on new property in existing class is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "IsNullable on new property in existing class is never supported because adding ECDbMap CA is not allowed";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "5c24344e34e3d76c781f9a2ad0240fb0dc3fee393ae4189878821088900d53da";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "IsNullable on new property in existing class is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "IsNullable on new property in existing class is never supported because adding ECDbMap CA is not allowed";
            }
    );

    Test(
        "adding IsNullable constraint on property on new subclass",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp2" typeName="string" >
                            <ECCustomAttributes>
                                <PropertyMap xmlns="ECDbMap.02.00">
                                    <IsNullable>False</IsNullable>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "671394c182e8482addb19dd5e66665c8152dee2b808aea2ab7cfc261bdc0ebf4";
            const auto SCHEMA_HASH_ECDB_MAP = "69bd23036dcf0d21216e0e4a663ad5d77092817016f552c278d6fbf3d14c59bf";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "IsNullable on property on new subclass";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "IsNullable on property on new subclass";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "e453968f8137956a148f8ed02c76bf3b8cb8699dbb709f38e08a1c4411a11ee0";
            const auto SCHEMA2_HASH_ECDB_MAP = "69bd23036dcf0d21216e0e4a663ad5d77092817016f552c278d6fbf3d14c59bf";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "IsNullable on property on new subclass works because ECDb ignores it because the class is not the root of the table.";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "IsNullable on property on new subclass works because ECDb ignores it because the class is not the root of the table.";
            }
    );

    Test(
        "adding IsNullable constraint on property on new subclass in new schema",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema2" alias="ts2" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="TestSchema" version="01.00" alias="ts"/>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Sub2" >
                        <BaseClass>ts:Parent</BaseClass>
                        <ECProperty propertyName="SubProp2" typeName="string" >
                            <ECCustomAttributes>
                                <PropertyMap xmlns="ECDbMap.02.00">
                                    <IsNullable>False</IsNullable>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "0b4bd446afb14a88532e8d737a06e7073a69a0a7658136ccd655d846a092a2d0";
            const auto SCHEMA_HASH_ECDB_MAP = "69bd23036dcf0d21216e0e4a663ad5d77092817016f552c278d6fbf3d14c59bf";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.0", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "IsNullable on property on new subclass in new schema";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "IsNullable on property on new subclass in new schema";
            }
    );

    Test(
        "adding IsUnique constraint on existing property",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" >
                            <ECCustomAttributes>
                                <PropertyMap xmlns="ECDbMap.02.00">
                                    <IsUnique>True</IsUnique>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml";

            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {"", "", ""})
            ) << "IsUnique on existing property is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "IsUnique on existing property is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {"", "", ""})
            ) << "IsUnique on existing property is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "IsUnique on existing property is never supported because adding ECDbMap CA is not allowed";
            }
    );

    Test(
        "adding IsUnique constraint on new property",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                        <ECProperty propertyName="NewProp" typeName="string" >
                            <ECCustomAttributes>
                                <PropertyMap xmlns="ECDbMap.02.00">
                                    <IsUnique>True</IsUnique>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "26d2a2bb445fcff8d12c37d1a2fbfbce86ec4b14379c0eed1d8afc1ec3013eb0";
            const auto SCHEMA_HASH_ECDB_MAP = "84a3a5e11259bae6a8800d8215f48b1e611d5bb77c3bac620da73b23f9e06a92";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "2e503df7e76cb940852191fcae5feb0c7aa11bfddd09d3f22056260426db5c5d";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "IsUnique on new property in existing class is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "IsUnique on new property in existing class is never supported because adding ECDbMap CA is not allowed";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "a451997ff9d0bee0747ce329514b1794cbf0ec8b707d0d395e48b597fd77624e";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "IsUnique on new property in existing class is never supported because adding ECDbMap CA is not allowed";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "IsUnique on new property in existing class is never supported because adding ECDbMap CA is not allowed";
            }
    );

    Test(
        "adding IsUnique constraint on shared column",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp2" typeName="string" >
                            <ECCustomAttributes>
                                <PropertyMap xmlns="ECDbMap.02.00">
                                    <IsUnique>True</IsUnique>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "d74853b31042003e6571265a18e6050200703b792fa2d34128f698c06470597b";
            const auto SCHEMA_HASH_ECDB_MAP = "69bd23036dcf0d21216e0e4a663ad5d77092817016f552c278d6fbf3d14c59bf";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "Adding unique index on shared column is ignored";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "Adding unique index on shared column is ignored";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "180d8d41f2af2fde7a5102e622a82524eb39bc2ae9d374043544c145ee923b56";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "Adding unique index on shared column is ignored";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Adding unique index on shared column is ignored";
            }
    );

    Test(
        "adding IsUnique constraint on shared column with ScopedDisableFailOnAssertion",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema2" alias="ts2" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="TestSchema" version="01.00" alias="ts"/>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Sub2" >
                        <BaseClass>ts:Parent</BaseClass>
                        <ECProperty propertyName="SubProp2" typeName="string" >
                            <ECCustomAttributes>
                                <PropertyMap xmlns="ECDbMap.02.00">
                                    <IsUnique>True</IsUnique>
                                </PropertyMap>
                            </ECCustomAttributes>
                        </ECProperty>
                    </ECEntityClass>
                </ECSchema>)xml";

            ScopedDisableFailOnAssertion disableFailOnAssertion;
            const auto SCHEMA_HASH_ECDB_SCHEMA = "243bf6ec9eb753ae841f8f5bdd79be4a3f108cd11e96fc9b0b3ea048139b3739";
            const auto SCHEMA_HASH_ECDB_MAP = "69bd23036dcf0d21216e0e4a663ad5d77092817016f552c278d6fbf3d14c59bf";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.0", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "Adding unique index on shared column is ignored";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA})
            ) << "Adding unique index on shared column is ignored";
            }
    );

    Test(
        "adding unique index on existing property",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                            <DbIndexList xmlns="ECDbMap.02.00">
                                <Indexes>
                                    <DbIndex>
                                        <Name>uix_Parent_Code</Name>
                                        <IsUnique>True</IsUnique>
                                        <Properties>
                                            <string>Code</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                           </DbIndexList>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "eea4d406b801b29d20ee53f7bf931d4fb4d2620ef47611aed3ff713c2f943afe";
            const auto SCHEMA_HASH_ECDB_MAP = "358afdf1d6bcfd8af6bc408fa9a1c11eb29907169db6d58e0ab7231d3dbb8e7a";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "6dd9dcc7cf66b8bef870ce37f21e666964fd9cc93e16945aba81e5d684bf4b67";

            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on existing property must fail because adding a ECDbMap CA on existing class is not allowed.";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on existing property must fail because adding a ECDbMap CA on existing class is not allowed.";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "6b3f5b182b9b64f546090083ce65cf0706451481717f073a69ec4d66d7be7bcc";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on existing property must fail because adding a ECDbMap CA on existing class is not allowed.";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Unique index on existing property must fail because adding a ECDbMap CA on existing class is not allowed.";
            }
    );

    Test(
        "adding unique index on new property",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                            <DbIndexList xmlns="ECDbMap.02.00">
                                <Indexes>
                                    <DbIndex>
                                        <Name>uix_Parent_NewProp</Name>
                                        <IsUnique>True</IsUnique>
                                        <Properties>
                                            <string>NewProp</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                        <ECProperty propertyName="NewProp" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "6c0a59a3349d67cd61bed05f1b61c14ec042504154db7a2c1c45a914cfe5469b";
            const auto SCHEMA_HASH_ECDB_MAP = "bdaba10f700ff097382ecc4edb11711b1f59dc5c0dbe3a7e0598ec1b4564dc0b";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "3d2258a5a3872f482a7fd354eec23fac9e2f16333121d98d1ce834220a006079";

            EXPECT_EQ(
                SchemaImportResult::OK ,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on new property in existing class must fail because adding a ECDbMap CA on existing class is not allowed.";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on new property in existing class must fail because adding a ECDbMap CA on existing class is not allowed.";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "67fa399deab85627083b1b2457199c24d10de901e639211e1010af6c55bb1f16";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on new property in existing class must fail because adding a ECDbMap CA on existing class is not allowed.";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Unique index on new property in existing class must fail because adding a ECDbMap CA on existing class is not allowed.";
            }
    );

    Test(
        "adding unique index on new property on new subclass",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" >
                        <ECCustomAttributes>
                            <DbIndexList xmlns="ECDbMap.02.00">
                                <Indexes>
                                    <DbIndex>
                                        <Name>uix_Sub2_SubProp2</Name>
                                        <IsUnique>True</IsUnique>
                                        <Properties>
                                            <string>SubProp2</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp2" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "b98cdb52891c555f9946c3f272c0e730c92375e4cf72e881ff19e806223974ba";
            const auto SCHEMA_HASH_ECDB_MAP = "0c6d064f5f21f92356151b3e9c52bd6cb2a2e8027987aa2687305dd780bda604";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "6fda81ae8767e9b33a939e0560f5fbf05b519464a8044306c82ae67e15f5d7c1";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on new property on new subclass";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on new property on new subclass";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "680a3543a9081ad74d66031a907005d9db3a8463b0aa6540e2e818959dd5d2ed";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on new property on new subclass";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Unique index on new property on new subclass";
            }
    );

    Test(
        "adding unique index on new property on new subclass in new schema",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema2" alias="ts2" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="TestSchema" version="01.00" alias="ts"/>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Sub2" >
                        <ECCustomAttributes>
                            <DbIndexList xmlns="ECDbMap.02.00">
                                <Indexes>
                                    <DbIndex>
                                        <Name>uix_Sub2_SubProp2</Name>
                                        <IsUnique>True</IsUnique>
                                        <Properties>
                                            <string>SubProp2</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                        <BaseClass>ts:Parent</BaseClass>
                        <ECProperty propertyName="SubProp2" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "fcb6e0baccd101db520b904fc6eebaf4337799b0f50e3daf84ccc83182e7d624";
            const auto SCHEMA_HASH_ECDB_MAP = "0c6d064f5f21f92356151b3e9c52bd6cb2a2e8027987aa2687305dd780bda604";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "6fda81ae8767e9b33a939e0560f5fbf05b519464a8044306c82ae67e15f5d7c1";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.0", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on new property on new subclass in new schema";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on new property on new subclass in new schema";
            }
    );

    Test(
        "adding unique index on inherited property on new subclass",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub2" >
                        <ECCustomAttributes>
                            <DbIndexList xmlns="ECDbMap.02.00">
                                <Indexes>
                                    <DbIndex>
                                        <Name>uix_Sub2_Code</Name>
                                        <IsUnique>True</IsUnique>
                                        <Properties>
                                            <string>Code</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp2" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "972605d73b066e9afc243af438953a7241890c884c27d77b3463a27065b77b5a";
            const auto SCHEMA_HASH_ECDB_MAP = "466ab4ba3fc8d57fa8098e2e9545f5cfe28eca890cf13e7b48eed38414d02adc";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "7ba09e84f3a0aa7ac4ad0ff40a9408bbecc03b5ca432c1eb20ceeccc2b4ccaf1";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on inherited property on new subclass";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on inherited property on new subclass";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "bee85fca95ae89cc0c1c4bfb054b6d207ff99899dcfd0d24de93783dea9ac4c4";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on inherited property on new subclass";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Unique index on inherited property on new subclass";
            }
    );

    Test(
        "adding unique index on inherited property on new subclass in new schema",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema2" alias="ts2" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="TestSchema" version="01.00" alias="ts"/>
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Sub2" >
                        <ECCustomAttributes>
                            <DbIndexList xmlns="ECDbMap.02.00">
                                <Indexes>
                                    <DbIndex>
                                        <Name>uix_Sub2_Code</Name>
                                        <IsUnique>True</IsUnique>
                                        <Properties>
                                            <string>Code</string>
                                        </Properties>
                                    </DbIndex>
                                </Indexes>
                            </DbIndexList>
                        </ECCustomAttributes>
                        <BaseClass>ts:Parent</BaseClass>
                        <ECProperty propertyName="SubProp2" typeName="int" />
                    </ECEntityClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "1a477603d314cee614e536c0e2f81e3bc06bbe7e75c7caed36edb1ddff22dcba";
            const auto SCHEMA_HASH_ECDB_MAP = "466ab4ba3fc8d57fa8098e2e9545f5cfe28eca890cf13e7b48eed38414d02adc";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "7ba09e84f3a0aa7ac4ad0ff40a9408bbecc03b5ca432c1eb20ceeccc2b4ccaf1";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.0", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on inherited property on new subclass in new schema";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Unique index on inherited property on new subclass in new schema";
            }
    );

    Test(
        "adding physical FK on new class",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Child" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECNavigationProperty propertyName="Parent" relationshipName="ParentHasChildren" direction="backward">
                            <ECCustomAttributes>
                                <ForeignKeyConstraint xmlns="ECDbMap.02.00"/>
                            </ECCustomAttributes>
                        </ECNavigationProperty>
                    </ECEntityClass>
                    <ECRelationshipClass typeName="ParentHasChildren" modifier="Sealed" strength="embedding" strengthDirection="forward" >
                        <Source multiplicity="(0..1)" polymorphic="True" roleLabel="has">
                            <Class class="Parent" />
                        </Source>
                        <Target multiplicity="(0..1)" polymorphic="True"  roleLabel="is contained by">
                            <Class class="Child" />
                        </Target>
                     </ECRelationshipClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "ff049625a6ede950f13be6fd3d922cc15ed6f5f70e6daa215db23d45c4fa3c8f";
            const auto SCHEMA_HASH_ECDB_MAP = "d07a65b5a384d2b2e18c71c1a14d41f601e26aa7ed4d70729ad64fc15fb9ee7e";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "10d5a90079a310b3413384e50ea3cfea8c5232a73b91fa57740ca350fdc64f80";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Physical FK on new class";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Physical FK on new class";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "8d6772f7e3796a13a5724ec87179033777226f06977ef87be1f0401a012ef479";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Physical FK on new class";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Physical FK on new class";
            }
    );

    Test(
        "adding physical FK on new nav prop in existing class",
        [&]()
            {
            auto newSchema = R"xml(<?xml version="1.0" encoding="utf-8" ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="%s" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                    <ECSchemaReference name="ECDbMap" version="02.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="Parent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns="ECDbMap.02.00"/>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                        <ECProperty propertyName="Code" typeName="int"/>
                        <ECProperty propertyName="Val" typeName="int" />
                        <ECNavigationProperty propertyName="Sibling" relationshipName="GrandparentHasParent" direction="backward">
                            <ECCustomAttributes>
                                <ForeignKeyConstraint xmlns="ECDbMap.02.00"/>
                            </ECCustomAttributes>
                        </ECNavigationProperty>
                    </ECEntityClass>
                    <ECEntityClass typeName="Sub" >
                        <BaseClass>Parent</BaseClass>
                        <ECProperty propertyName="SubProp" typeName="string" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Grandparent" >
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECProperty propertyName="Name" typeName="string" />
                    </ECEntityClass>
                    <ECRelationshipClass typeName="GrandparentHasParent" modifier="Sealed" strength="embedding" strengthDirection="forward" >
                        <Source multiplicity="(0..1)" polymorphic="True" roleLabel="has">
                            <Class class="Grandparent" />
                        </Source>
                        <Target multiplicity="(0..1)" polymorphic="True"  roleLabel="is contained by">
                            <Class class="Parent" />
                        </Target>
                     </ECRelationshipClass>
                </ECSchema>)xml";

            const auto SCHEMA_HASH_ECDB_SCHEMA = "c94610934f7a8db3a2db4fbe376163df97ba19b48d68240ecc64fb1033b64b3c";
            const auto SCHEMA_HASH_ECDB_MAP = "6f5ff0efbc2a19c023da791462a32b527d48dabb01a5b628fbe8d6532a46f1b3";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "fe61924d982bc1a50bfff5af0fec230c8995c0d277293e95fef8f89ffe5f83ce";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::None, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Physical FK on new nav prop in existing class";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "1.1", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Physical FK on new nav prop in existing class";

            const auto SCHEMA2_HASH_ECDB_SCHEMA = "fad2eb642d7302ab88515d8afd12eda77b6a023e2b71153d5c1bc30abe765053";
            EXPECT_EQ(
                SchemaImportResult::OK,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::None, {SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA})
            ) << "Physical FK on new nav prop in existing class";
            EXPECT_EQ(
                SchemaImportResult::ERROR,
                assertImport(newSchema, "2.0", SchemaManager::SchemaImportOptions::DisallowMajorSchemaUpgrade, {"", "", ""})
            ) << "Physical FK on new nav prop in existing class";
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateReferencesFromDifferentContext)
    {
    Test("Setup empty ECDb", [&]() { ASSERT_EQ(SchemaImportResult::OK, SetupECDb("failingImport")); });

    Test(
        "first schema set",
        [&]()
            {
            ECSchemaReadContextPtr ctx = ECSchemaReadContext::CreateContext();
            ctx->AddSchemaLocater(m_briefcase->GetSchemaLocater());
            ECSchemaPtr myRef, mySchema;
            // newer references 1.0.1
            ECSchema::ReadFromXmlString(myRef, R"xml(<?xml version="1.0" encoding="utf-8"?>
            <ECSchema schemaName="MyRef" alias="myref" version="01.00.01" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                <ECEntityClass typeName="MyRefClass"  modifier="none">
                    <ECProperty propertyName="MyRefProperty" typeName="int" />
                </ECEntityClass>
            </ECSchema>)xml", *ctx);

            // reference older version (1.0.0)
            ECSchema::ReadFromXmlString(mySchema, R"xml(<?xml version="1.0" encoding="utf-8"?>
            <ECSchema schemaName="MySchema" alias="ts" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                <ECSchemaReference name="MyRef" version="01.00.00" alias="myref" />
                <ECEntityClass typeName="MyClass"  modifier="none">
                    <BaseClass>myref:MyRefClass</BaseClass>
                    <ECProperty propertyName="MyProperty" typeName="int" />
                </ECEntityClass>
            </ECSchema>)xml", *ctx);

            const auto SCHEMA_HASH_ECDB_SCHEMA = "cc65bd9568f94ed2e0b246272e0ade4e1347aefd1cf4ea2f5448e2a95b7279ce";
            const auto SCHEMA_HASH_ECDB_MAP = "50e8780fda26200b3f97e18a48265eaf1e01c3850f783599dac578eefeacf1b9";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "cd4463b1058dc63446a6aab613ec85ed6364d441fb98e2526ffab5914a84d726";
            ASSERT_EQ(SchemaImportResult::OK, m_briefcase->Schemas().ImportSchemas(ctx->GetCache().GetSchemas(), SchemaManager::SchemaImportOptions::None, nullptr, m_schemaChannel->GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "second without locator",
        [&]()
            {
            ECSchemaReadContextPtr ctx = ECSchemaReadContext::CreateContext();

            // no locator
            // ctx->AddSchemaLocater(m_briefcase->GetSchemaLocater());
            ECSchemaPtr myRef, mySchema;
            // newer references 1.0.1
            ECSchema::ReadFromXmlString(myRef, R"xml(<?xml version="1.0" encoding="utf-8"?>
            <ECSchema schemaName="MyRef" alias="myref" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                <ECEntityClass typeName="MyRefClass"  modifier="none">
                    <ECProperty propertyName="MyRefProperty" typeName="int" />
                </ECEntityClass>
            </ECSchema>)xml", *ctx);

            // reference older version (1.0.0)
            ECSchema::ReadFromXmlString(mySchema, R"xml(<?xml version="1.0" encoding="utf-8"?>
            <ECSchema schemaName="MySchema" alias="ts" version="01.00.00" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.1">
                <ECSchemaReference name="MyRef" version="01.00.00" alias="myref" />
                <ECEntityClass typeName="MyClass"  modifier="none">
                    <BaseClass>myref:MyRefClass</BaseClass>
                    <ECProperty propertyName="MyProperty" typeName="int" />
                    <ECProperty propertyName="MyProperty1" typeName="int" />
                </ECEntityClass>
            </ECSchema>)xml", *ctx);

            const auto SCHEMA_HASH_ECDB_SCHEMA = "3efbfdedc865b69a0f69deecc5d96edb811a98a2ff98773703d0eaf4cd4bc4da";
            const auto SCHEMA_HASH_ECDB_MAP = "16cf0552a8bdaec4c6d759dd89b4c40de262969f4d0b905248f81a1ef7aa87b4";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "ff0d88d2b854d847016398b4a1740f41963695c4403f5af75c679a6aba3b8060";
            ASSERT_EQ(SchemaImportResult::OK, m_briefcase->Schemas().ImportSchemas(ctx->GetCache().GetSchemas(), SchemaManager::SchemaImportOptions::None, nullptr, m_schemaChannel->GetSyncDbUri())) << "This should fail";
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateRelationshipConstraintClassGeneralize)
    {
    const auto SCHEMA1_HASH_ECDB_MAP = "b2fad42e3ef33786344ad4c6907c85d86ce8a054eccdb4377e15970e7d6150bf";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "5c2cb7332bd42ab1b5531bbd12a493c967aa83058a21f6b9ff8af82a28a89ecf";
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "ac62e787980a0f6e665dd93d732e8893ecdd46243140fec4670defc0f5d28863";

            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="LinearReferencing" alias="lr" version="02.00.02" description="Base schema for Linear Referencing." xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="CoreCustomAttributes" version="01.00.03" alias="CoreCA"/>
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="ILinearlyLocated" modifier="Abstract" description="">
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                                <AppliesToEntityClass>GeometricElement3d</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName="ILinearLocationElement" description="" modifier="Abstract">
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                                <AppliesToEntityClass>GeometricElement3d</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName="ILinearLocationLocatesElement" strength="referencing" modifier="None" description="">
                        <Source multiplicity="(0..*)" polymorphic="true" roleLabel="linearly-locates">
                            <Class class="ILinearLocationElement"/>
                        </Source>
                        <Target multiplicity="(0..1)" polymorphic="true" roleLabel="linearly-located by">
                            <Class class="GeometricElement3d"/>
                        </Target>
                    </ECRelationshipClass>
                    <ECEntityClass typeName="LinearLocationElement" description="" modifier="Abstract">
                        <BaseClass>GeometricElement3d</BaseClass>
                        <BaseClass>ILinearLocationElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Element" modifier="Abstract" description="">
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement3d" modifier="Abstract" displayLabel="">
                        <BaseClass>Element</BaseClass>
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("schemaupdate", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of initial schema",
        [&]()
            {
            auto aILinearLocationElement = m_briefcase->Schemas().GetClass("LinearReferencing", "ILinearLocationElement");
            auto aILinearlyLocated = m_briefcase->Schemas().GetClass("LinearReferencing", "ILinearlyLocated");
            auto aILinearLocationLocatesElement = m_briefcase->Schemas().GetClass("LinearReferencing", "ILinearLocationLocatesElement")->GetRelationshipClassCP();
            ECValue r;
            aILinearLocationElement->GetCustomAttributeLocal("IsMixin")->GetValue(r, "AppliesToEntityClass");
            ASSERT_STREQ("GeometricElement3d", r.GetUtf8CP());

            aILinearlyLocated->GetCustomAttributeLocal("IsMixin")->GetValue(r, "AppliesToEntityClass");
            ASSERT_STREQ("GeometricElement3d", r.GetUtf8CP());

            auto aConstraintClass = aILinearLocationLocatesElement->GetTarget().GetConstraintClasses().front();
            ASSERT_STREQ("GeometricElement3d", aConstraintClass->GetName().c_str());
            }
    );

    Test(
        "Import schema with smaller read version",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "d1dc6c3d20d2de827bad7418bb80343f3f1a073a1e0ba1ca482c18c90d583c1e";
            auto schema = SchemaItem(
                R"xml(<?xml version="1.0" encoding="UTF-8"?>
                <ECSchema schemaName="LinearReferencing" alias="lr" version="02.00.02" description="Base schema for Linear Referencing." xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="CoreCustomAttributes" version="01.00.03" alias="CoreCA"/>
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName="ILinearlyLocated" modifier="Abstract" description="">
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName="ILinearLocationElement" description="" modifier="Abstract">
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes>
                            <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                                <AppliesToEntityClass>Element</AppliesToEntityClass>
                            </IsMixin>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName="ILinearLocationLocatesElement" strength="referencing" modifier="None" description="">
                        <Source multiplicity="(0..*)" polymorphic="true" roleLabel="linearly-locates">
                            <Class class="ILinearLocationElement"/>
                        </Source>
                        <Target multiplicity="(0..1)" polymorphic="true" roleLabel="linearly-located by">
                            <Class class="Element"/>
                        </Target>
                    </ECRelationshipClass>
                    <ECEntityClass typeName="LinearLocationElement" description="" modifier="Abstract">
                        <BaseClass>GeometricElement3d</BaseClass>
                        <BaseClass>ILinearLocationElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName="Element" modifier="Abstract" description="">
                        <ECCustomAttributes>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName="GeometricElement3d" modifier="Abstract" displayLabel="">
                        <BaseClass>Element</BaseClass>
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Check values of modified schema",
        [&]()
            {
            auto aILinearLocationElement = m_briefcase->Schemas().GetClass("LinearReferencing", "ILinearLocationElement");
            auto aILinearlyLocated = m_briefcase->Schemas().GetClass("LinearReferencing", "ILinearlyLocated");
            auto aILinearLocationLocatesElement = m_briefcase->Schemas().GetClass("LinearReferencing", "ILinearLocationLocatesElement")->GetRelationshipClassCP();
            ECValue r;
            aILinearLocationElement->GetCustomAttributeLocal("IsMixin")->GetValue(r, "AppliesToEntityClass");
            ASSERT_STREQ("Element", r.GetUtf8CP());

            aILinearlyLocated->GetCustomAttributeLocal("IsMixin")->GetValue(r, "AppliesToEntityClass");
            ASSERT_STREQ("Element", r.GetUtf8CP());

            auto aConstraintClass = aILinearLocationLocatesElement->GetTarget().GetConstraintClasses().front();
            ASSERT_STREQ("Element", aConstraintClass->GetName().c_str());
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateClass_AddPropertyDeeplyNestedStruct)
    {
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "e51908b526d962bd2ebc85005e1639273ff6b7e3a6149faac13d3d4fd909c031";
            const auto SCHEMA_HASH_ECDB_MAP = "dbb55e277e5d656ea1e6547b5fd996374f1732d80d5e8ac81b03679d7a89ce92";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "479b48bde854f27df13fa92eda4ebbc7affece5d08af6d536761fd68e985c937";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8' ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="01.00.00" displayLabel="Nested Struct Test Schema" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECStructClass typeName="ColorType">
                        <ECProperty propertyName="blue" typeName="string" displayLabel="Blue"/>
                        <ECProperty propertyName="green" typeName="string" displayLabel="Green"/>
                        <ECProperty propertyName="red" typeName="string" displayLabel="Red"/>
                    </ECStructClass>
                    <ECStructClass typeName="ColorNestedType" displayLabel="PSet_Draughting.ColorNested">
                        <ECStructProperty propertyName="color" typeName="ColorType"/>
                    </ECStructClass>
                    <ECStructClass typeName="NestedColorNestedType" >
                        <ECStructProperty propertyName="nestedColor" typeName="ColorNestedType" />
                    </ECStructClass>
                    <ECEntityClass typeName="TestClass">
                        <ECStructProperty propertyName="ColorNested" typeName="NestedColorNestedType"/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("addPropertyToDeeplyNestedStruct", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify inserted instances",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.TestClass (ColorNested.nestedColor.color.red, ColorNested.nestedColor.color.green, ColorNested.nestedColor.color.blue) VALUES ('red', 'green', 'blue')"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            auto expected = JsonValue(R"json([{"ColorNested":{"nestedColor":{"color":{"blue":"blue","green":"green","red":"red"}}}}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT colornested FROM ts.testclass"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt));
            stmt.Finalize();
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "c880f7669a6441ca0f075dfc7a50ab0cc9fa75cd43e65dabd17473160990e55e";
    const auto SCHEMA1_HASH_ECDB_MAP = "1676154019631a5edb66edfc3562351d5fe82bc47b66cefbea1498c26d79cf24";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "bde3d19daf523466084dca405ce2aae51b89a6ce327125a89b1d1b4b2ca67738";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8' ?>
                <ECSchema schemaName="TestSchema" alias="ts" version="01.00.01" displayLabel="Nested Struct Test Schema" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECStructClass typeName="ColorType">
                        <ECProperty propertyName="blue" typeName="string" displayLabel="Blue"/>
                        <ECProperty propertyName="green" typeName="string" displayLabel="Green"/>
                        <ECProperty propertyName="red" typeName="string" displayLabel="Red"/>
                        <ECProperty propertyName="new" typeName="int" />
                    </ECStructClass>
                    <ECStructClass typeName="ColorNestedType" displayLabel="PSet_Draughting.ColorNested">
                        <ECStructProperty propertyName="color" typeName="ColorType"/>
                    </ECStructClass>
                    <ECStructClass typeName="NestedColorNestedType" >
                        <ECStructProperty propertyName="nestedColor" typeName="ColorNestedType" />
                    </ECStructClass>
                    <ECEntityClass typeName="TestClass">
                        <ECProperty propertyName="prop1" typeName="double" />
                        <ECStructProperty propertyName="ColorNested" typeName="NestedColorNestedType"/>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify we can insert and select",
        [&]()
            {
            ECSqlStatement stmt;
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "INSERT INTO ts.TestClass (prop1, ColorNested.nestedColor.color.red, ColorNested.nestedColor.color.green, ColorNested.nestedColor.color.blue, ColorNested.nestedColor.color.new) VALUES (42.42, 'red2', 'green2', 'blue2', 42)"));
            ASSERT_EQ(BE_SQLITE_DONE, stmt.Step());
            stmt.Finalize();

            auto expected = JsonValue(R"json([{"ColorNested":{"nestedColor":{"color":{"blue":"blue","green":"green","red":"red"}}}},{"prop1":42.42,"ColorNested":{"nestedColor":{"color":{"blue":"blue2","green":"green2","red":"red2","new":42}}}}])json");
            ASSERT_EQ(ECSqlStatus::Success, stmt.Prepare(*m_briefcase, "SELECT prop1, colornested FROM ts.testclass"));
            ASSERT_EQ(expected, GetHelper().ExecutePreparedECSql(stmt)) << "Verify inserted instances";
            stmt.Finalize();
            }
    );

    Test(
        "Final hash check",
        [&]()
            {
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateRelationshipConstraintWithMixin)
    {
    const auto SCHEMA1_HASH_ECDB_MAP = "7fd0b7ef5b3520e219471363ea5c59afdd4ddd13958f1bbb580eaa54cd3f43f6";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ff29f114c33fe47a161cbe7aee80437b8e8c3bd943ab5a38c4ae34af07100a69";
    Test(
        "import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "50dba9f402e569f78dfa736c4e19edd1c4633e37771f6d75d050c35745dbda05";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>Element1</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'ILinearElementSource'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UpdateRelationshipConstraintWithMixin", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import edited schema with some changes",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "71b9d0239bb83761d4ae0d27b2ad5305620f4d7cddbc58e18b436f190f58f701";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>Element1</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'Element1'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpgradeRelationshipConstraintWithBrokenMixin)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "50dba9f402e569f78dfa736c4e19edd1c4633e37771f6d75d050c35745dbda05";
    const auto SCHEMA1_HASH_ECDB_MAP = "7fd0b7ef5b3520e219471363ea5c59afdd4ddd13958f1bbb580eaa54cd3f43f6";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ff29f114c33fe47a161cbe7aee80437b8e8c3bd943ab5a38c4ae34af07100a69";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>Element1</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'ILinearElementSource'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UpgradeRelationshipConstraintWithBrokenMixin", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import not allowed edited schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>Element1</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'Element2'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateMixinRelationshipConstraintNoPolymorphs)
    {
    const auto SCHEMA1_HASH_ECDB_SCHEMA = "50dba9f402e569f78dfa736c4e19edd1c4633e37771f6d75d050c35745dbda05";
    const auto SCHEMA1_HASH_ECDB_MAP = "7fd0b7ef5b3520e219471363ea5c59afdd4ddd13958f1bbb580eaa54cd3f43f6";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ff29f114c33fe47a161cbe7aee80437b8e8c3bd943ab5a38c4ae34af07100a69";
    Test(
        "import initial schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>Element1</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'ILinearElementSource'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UpdateMixinRelationshipConstraintNoPolymorphs", schema));
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import not allowed edited schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>Element1</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'false' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'false' roleLabel = 'is attributed by'><Class class = 'Element1'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateMixinRelationshipConstraintAcrossFiles)
    {
    Test(
        "Import initial BaseSchema schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "e6283be671f3c6456896cfd457f8a4d6eedc1c7c0bea21f8f2826a1009fa7eaf";
            const auto SCHEMA_HASH_ECDB_MAP = "8b979abbb9dd61bc9e5784a847e76d09ada26d9eaab8f9729cd5cce95317140a";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "2df78b6e0177d9f4c85d510e067e13ea7adc08caaf7e653d015b717679f55356";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='BaseSchema' alias='base' description='Holds base classes' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>Element1</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UpdateMixinRelationshipConstraintAcrossFiles", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );


    const auto SCHEMA1_HASH_ECDB_MAP = "736277e733963d032c0ddeaec92f005a59a257836f2024cfa05462b36ab3046f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "88b6554b08bdf2eb97a7cd5dd97ca0da3727df37c1689e4649063d63835f2fdb";
    Test(
        "import TestSchema schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "b636b29d184c72bfb26b7c20ae4d1cc4762d72b5887a5623600993339a51b030";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema' version='01.00.00' alias='base' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>base:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'ILinearElementSource'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import edited TestSchema schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "4c70c9542bf703ac67c24ed8f7222711cdb1824789b29365783fc766da61807b";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema' version='01.00.00' alias='base' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>base:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'base:Element1'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, FailedMixinRelationshipConstraintAcrossFiles)
    {
    Test(
        "Import initial BaseSchema schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "8cc82573fd2e067fbd2c87ecbc6c34f0e4cfcb151739e7819223f831340c7ae1";
            const auto SCHEMA_HASH_ECDB_MAP = "8b979abbb9dd61bc9e5784a847e76d09ada26d9eaab8f9729cd5cce95317140a";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "2df78b6e0177d9f4c85d510e067e13ea7adc08caaf7e653d015b717679f55356";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='BaseSchema' alias='base' description='Holds base classes' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("FailedMixinRelationshipConstraintAcrossFiles", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "f09be58693f7d68cdd9912230c27aa9565d2eecfaf439f8ef53e8328840eb596";
    const auto SCHEMA1_HASH_ECDB_MAP = "736277e733963d032c0ddeaec92f005a59a257836f2024cfa05462b36ab3046f";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "88b6554b08bdf2eb97a7cd5dd97ca0da3727df37c1689e4649063d63835f2fdb";
    Test(
        "import TestSchema schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema' version='01.00.00' alias='base' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>base:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'ILinearElementSource'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import not allowed edited TestSchema schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema' version='01.00.00' alias='base' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECEntityClass typeName = 'ILinearElementSource'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00' modifier='Abstract'>
                            <AppliesToEntityClass>base:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'base:Element1'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, UpdateMixinRelationshipConstraintAcrossMultiFiles)
    {
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "0342b920a1b694aa41064dba9c68044e717faeeb3b785123bfe46546d74b80e1";
    Test(
        "Import initial BaseSchema schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "3aa1a57b93d31a79cf55f3afa779fb11751825858c66b21d927fa98a8dfed21d";
            const auto SCHEMA_HASH_ECDB_MAP = "d115cdd34a808986a3d360510fee3be9edb0db7221a6543513d6e3c3564d8aea";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='BaseSchema' alias='base1' description='Holds base classes' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("UpdateMixinRelationshipConstraintAcrossMultiFiles", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import BaseSchema2 schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "5e558436ad82987ae29b13f591772ffac51c79bafde17acb966348a422657cec";
            const auto SCHEMA_HASH_ECDB_MAP = "2a73a5d77fd887a494c931f5fa366b43764755a5342825f4a6df8bcea2cd7f80";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='BaseSchema2' alias='base2' description='Holds more base classes' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema' version='01.00.00' alias='base1' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>base1:Element1</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_MAP = "42d46d24970bcdfd196edc29de8c9a5c1f7874d43c0960673512306c8db3d782";
    Test(
        "import TestSchema schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "eefca43484628966f68ee30899895c8c864bf0d400af488c8920d8d42a6ab35f";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema2' version='01.00.00' alias='base2' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base2:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base2:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'base2:Element2'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import edited TestSchema schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "fdb79f95329f1828ccafa86f1bd11739497308838b84707e41921104383f23d6";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema' version='01.00.00' alias='base1' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base1:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base1:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'base1:Element1'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, FailMixinRelationshipConstraintAcrossMultiFiles)
    {
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "0342b920a1b694aa41064dba9c68044e717faeeb3b785123bfe46546d74b80e1";
    Test(
        "Import initial BaseSchema schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "3aa1a57b93d31a79cf55f3afa779fb11751825858c66b21d927fa98a8dfed21d";
            const auto SCHEMA_HASH_ECDB_MAP = "d115cdd34a808986a3d360510fee3be9edb0db7221a6543513d6e3c3564d8aea";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='BaseSchema' alias='base1' description='Holds base classes' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("FailMixinRelationshipConstraintMultiFileVersioning", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import BaseSchema2 schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "5e558436ad82987ae29b13f591772ffac51c79bafde17acb966348a422657cec";
            const auto SCHEMA_HASH_ECDB_MAP = "2a73a5d77fd887a494c931f5fa366b43764755a5342825f4a6df8bcea2cd7f80";
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='BaseSchema2' alias='base2' description='Holds more base classes' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema' version='01.00.00' alias='base1' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>base1:Element1</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "eefca43484628966f68ee30899895c8c864bf0d400af488c8920d8d42a6ab35f";
    const auto SCHEMA2_HASH_ECDB_MAP = "42d46d24970bcdfd196edc29de8c9a5c1f7874d43c0960673512306c8db3d782";
    Test(
        "import TestSchema schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema2' version='01.00.00' alias='base2' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base2:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base2:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'base2:Element2'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import not allowed edited TestSchema schema",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base1:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base1:Element1</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'base1:Element1'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, FailMixinRelationshipConstraintMultiFileVersioning)
    {
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "0342b920a1b694aa41064dba9c68044e717faeeb3b785123bfe46546d74b80e1";
    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "7ae06651c57adc149df8765158a9e135711d4c004f055840df71762b81a79b9f";
            const auto SCHEMA_HASH_ECDB_MAP = "2a73a5d77fd887a494c931f5fa366b43764755a5342825f4a6df8bcea2cd7f80";

            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='BaseSchema' alias='base1' description='Holds base classes' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                        <ECCustomAttributes>
                            <ClassMap xmlns='ECDbMap.02.00.00'>
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                            <ShareColumns xmlns='ECDbMap.02.00.00'>
                                <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                            </ShareColumns>
                        </ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element1' modifier='Abstract'>
                        <BaseClass>BaseElement</BaseClass>
                    </ECEntityClass>
                    <ECEntityClass typeName='Element2' modifier='Abstract'>
                        <BaseClass>Element1</BaseClass>
                    </ECEntityClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("FailMixinRelationshipConstraintMultiFileVersioning", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    const auto SCHEMA2_HASH_ECDB_SCHEMA = "c92d66e490be72769d7f9be1cfe10c4b82a41b6c5bd7942eef904429ccd81cdb";
    const auto SCHEMA2_HASH_ECDB_MAP = "42d46d24970bcdfd196edc29de8c9a5c1f7874d43c0960673512306c8db3d782";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<?xml version='1.0' encoding='utf-8'?>
                <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.0' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                    <ECSchemaReference name='BaseSchema' version='01.00.00' alias='base1' />
                    <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                    <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base1:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                    </ECEntityClass>
                    <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                        <BaseClass>ILinearlyLocated</BaseClass>
                        <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                            <AppliesToEntityClass>base1:Element2</AppliesToEntityClass>
                        </IsMixin></ECCustomAttributes>
                        <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                    </ECEntityClass>
                    <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                        <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                        <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'base1:Element2'/></Target>
                    </ECRelationshipClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );

    Test(
        "import not allowed schemas",
        [&]()
            {
            auto schemas = std::vector<SchemaItem>{
                SchemaItem(
                    R"xml(<?xml version='1.0' encoding='utf-8'?>
                    <ECSchema schemaName='BaseSchema' alias='base1' description='Holds base classes' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                        <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                        <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                        <ECEntityClass typeName='BaseElement' modifier='Abstract'>
                            <ECCustomAttributes>
                                <ClassMap xmlns='ECDbMap.02.00.00'>
                                    <MapStrategy>TablePerHierarchy</MapStrategy>
                                </ClassMap>
                                <ShareColumns xmlns='ECDbMap.02.00.00'>
                                    <MaxSharedColumnsBeforeOverflow>32</MaxSharedColumnsBeforeOverflow>
                                    <ApplyToSubclassesOnly>True</ApplyToSubclassesOnly>
                                </ShareColumns>
                            </ECCustomAttributes>
                        </ECEntityClass>
                        <ECEntityClass typeName='Element1' modifier='Abstract'>
                            <BaseClass>BaseElement</BaseClass>
                        </ECEntityClass>
                    </ECSchema>)xml"
                ),
                SchemaItem(
                    R"xml(<?xml version='1.0' encoding='utf-8'?>
                    <ECSchema schemaName='TestSchema' alias='ts' description='This is Test Schema' version='1.0.1' xmlns='http://www.bentley.com/schemas/Bentley.ECXML.3.2'>
                        <ECSchemaReference name='BaseSchema' version='01.00.01' alias='base1' />
                        <ECSchemaReference name='CoreCustomAttributes' version='01.00.00' alias='CoreCA' />
                        <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap"/>
                        <ECEntityClass typeName='ILinearlyLocated' modifier='Abstract'>
                            <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                                <AppliesToEntityClass>base1:Element1</AppliesToEntityClass>
                            </IsMixin></ECCustomAttributes>
                        </ECEntityClass>
                        <ECEntityClass typeName='ILinearlyLocatedAttribution' modifier='Abstract'>
                            <BaseClass>ILinearlyLocated</BaseClass>
                            <ECCustomAttributes> <IsMixin xmlns='CoreCustomAttributes.01.00.00'>
                                <AppliesToEntityClass>base1:Element1</AppliesToEntityClass>
                            </IsMixin></ECCustomAttributes>
                            <ECNavigationProperty propertyName = 'AttributedElement' relationshipName = 'ILinearlyLocatedAttributesElement' direction = 'Forward' displayLabel = 'Attributed Element'/>
                        </ECEntityClass>
                        <ECRelationshipClass typeName = 'ILinearlyLocatedAttributesElement' strength = 'referencing' modifier='None'>
                            <Source multiplicity = '(0..*)' polymorphic = 'true' roleLabel = 'attributes'><Class class = 'ILinearlyLocatedAttribution'/></Source>
                            <Target multiplicity = '(0..1)' polymorphic = 'true' roleLabel = 'is attributed by'><Class class = 'base1:Element1'/></Target>
                        </ECRelationshipClass>
                    </ECSchema>)xml"
                )
            };
            ASSERT_EQ(SchemaImportResult::ERROR, ImportSchemas(*m_briefcase, schemas, SchemaManager::SchemaImportOptions::None, m_schemaChannel->GetSyncDbUri()));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->AbandonChanges());
            CheckHashes(*m_briefcase, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA2_HASH_ECDB_SCHEMA, SCHEMA2_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, OverflowedStructClass_NestedStruct)
    {
    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "65db43b14a2585e983b2401fee9fa856ca73c9f06b6ef87b20301925c38b46c4";
            const auto SCHEMA_HASH_ECDB_MAP = "69c97fac1f94d513495caf65e1722fc0fcbd4f414b17910fe446117bfbcccb10";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "e567d8390f0b253a968210f626c58f7be75b1f306d6e3def12f575cb576256a2";
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="S" typeName="S" />
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECStructProperty propertyName="T" typeName="T" />
                        <ECStructArrayProperty propertyName="T_ARRAY" typeName="T" minOccurs="0" maxOccurs="unbounded"/>
                    </ECStructClass>
                    <ECStructClass typeName="T" modifier="None">
                        <ECProperty propertyName="I" typeName="int"/>
                        <ECProperty propertyName="P2D" typeName="point2d"/>
                        <ECArrayProperty propertyName="P2D_ARRAY" typeName="point2d" minOccurs="0" maxOccurs="unbounded"/>
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("struct_prop", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify before schema map for struct property this will change after v2 import",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
            Json::Value expected = R"(
                [
                    "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Element:ECInstanceId:ts_Element:Id",
                    "TestSchema:Element:S.T.I:ts_Element:ps1",
                    "TestSchema:Element:S.T.P2D.X:ts_Element:ps2",
                    "TestSchema:Element:S.T.P2D.Y:ts_Element:ps3",
                    "TestSchema:Element:S.T.P2D_ARRAY:ts_Element:ps4",
                    "TestSchema:Element:S.T_ARRAY:ts_Element:ps5"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );
    auto inst1 = R"({
        "className": "ts.Element",
        "data": {
            "S": {
                "T": {
                    "I": 7242,
                    "P2D" : {"x": 3793.0, "y": 5133.0},
                    "P2D_ARRAY": [
                        {"x": 1183.0, "y": 1243.0},
                        {"x": 1805.0, "y": 9804.0},
                        {"x": 7940.0, "y": 1088.0}
                        ]
                },
                "T_ARRAY": [{
                    "I": 7765,
                    "P2D" : {"x": 8360.0, "y": 8429.0},
                    "P2D_ARRAY": [
                        {"x": 4662.0, "y": 9892.0},
                        {"x": 5177.0, "y": 5730.0},
                        {"x": 1030.0, "y": 5774.0}
                        ]
                    }
                ]
            }
        }
    })"_json;

    auto key1 = InsertInstance(*m_briefcase, inst1);
    Test(
        "verify instance was written correctly",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "S");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "c703d2256f4f9143b2696b1c4714f672064b863a6a122467f75f8c2b67643069";
    const auto SCHEMA1_HASH_ECDB_MAP = "ff333615117c5dd2bc1a1aae1e93013942cc59f18297a15d93ef310caf13db93";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "dbdde34ca352550fe87ae4c0a8bc7150d45089a4093b2fff5fd3439c3fc1a884";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="S" typeName="S" />
                        <ECProperty propertyName="L" typeName="int"/>
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECStructProperty propertyName="T" typeName="T" />
                        <ECStructArrayProperty propertyName="T_ARRAY" typeName="T" minOccurs="0" maxOccurs="unbounded"/>
                    </ECStructClass>
                    <ECStructClass typeName="T" modifier="None">
                        <ECProperty propertyName="I" typeName="int"/>
                        <ECProperty propertyName="P2D" typeName="point2d"/>
                        <ECProperty propertyName="P3D" typeName="point3d"/>
                        <ECArrayProperty propertyName="P2D_ARRAY" typeName="point2d" minOccurs="0" maxOccurs="unbounded"/>
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify property map after schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
            Json::Value expected = R"(
                [
                    "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Element:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Element:ECInstanceId:ts_Element:Id",
                    "TestSchema:Element:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Element:L:ts_Element:ps6",
                    "TestSchema:Element:S.T.I:ts_Element_Overflow:os4",
                    "TestSchema:Element:S.T.P2D.X:ts_Element_Overflow:os5",
                    "TestSchema:Element:S.T.P2D.Y:ts_Element_Overflow:os6",
                    "TestSchema:Element:S.T.P2D_ARRAY:ts_Element_Overflow:os7",
                    "TestSchema:Element:S.T.P3D.X:ts_Element_Overflow:os1",
                    "TestSchema:Element:S.T.P3D.Y:ts_Element_Overflow:os2",
                    "TestSchema:Element:S.T.P3D.Z:ts_Element_Overflow:os3",
                    "TestSchema:Element:S.T_ARRAY:ts_Element_Overflow:os8"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    auto inst2 = R"({
        "className": "ts.Element",
        "data": {
            "L": 1910,
            "S": {
                "T": {
                    "I": 4853,
                    "P2D" : {"x": 6484.0, "y": 2779.0},
                    "P3D" : {"x": 1131.0, "y": 1540.0, "z": 4873.0},
                    "P2D_ARRAY": [
                        {"x": 7712.0, "y": 1171.0},
                        {"x": 5858.0, "y": 6044.0},
                        {"x": 5606.0, "y": 2163.0}
                        ]
                },
                "T_ARRAY": [{
                    "I": 2839,
                    "P2D" : {"x": 7595.0, "y": 8429.0},
                    "P3D" : {"x": 8397.0, "y": 3303.0, "z": 1096.0},
                    "P2D_ARRAY": [
                        {"x": 4662.0, "y": 2686.0},
                        {"x": 1996.0, "y": 6779.0},
                        {"x": 8576.0, "y": 9819.0}
                        ]
                    }
                ]
            }
        }
    })"_json;
    auto key2 = InsertInstance(*m_briefcase, inst2);

    Test(
        "verify instance was transformed correctly after schema import",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "S");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "verify instance inserted after schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key2, "L,S");
            ASSERT_STREQ(inst2["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "Make sure the column where property used to reside is set to null",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4, ps5 FROM ts_element where id = ?");
            vs->BindId(1, key1.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE(vs->IsColumnNull(0)) << "Expect ps1 to be null";
            ASSERT_TRUE(vs->IsColumnNull(1)) << "Expect ps2 to be null";
            ASSERT_TRUE(vs->IsColumnNull(2)) << "Expect ps3 to be null";
            ASSERT_TRUE(vs->IsColumnNull(3)) << "Expect ps4 to be null";
            ASSERT_TRUE(vs->IsColumnNull(4)) << "Expect ps5 to be null";
            }
    );

    Test(
        "Final hash check",
        [&]()
            {
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, OverflowedStructClass_Simple)
    {
    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "bbb6bcb18fcdc074f74decefadd33f48f5cc899cfdf3f4ae95553e881e7cc085";
            const auto SCHEMA_HASH_ECDB_MAP = "efb2203a0db50751d6ee39ffb4097b664af42dcad0c296f6307024338459228c";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "372b9817ba28a59811387f40c58bb6b6e2d25f854aee946216c37495c99fb16c";
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="structProp" typeName="S" />
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECProperty propertyName="P1" typeName="int" />
                        <ECProperty propertyName="P2" typeName="int" />
                        <ECProperty propertyName="P3" typeName="int" />
                        <ECProperty propertyName="P4" typeName="int" />
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("struct_prop", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "Verify before schema map for struct property this will change after v2 importe",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
            Json::Value expected = R"(
                [
                    "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Element:ECInstanceId:ts_Element:Id",
                    "TestSchema:Element:structProp.P1:ts_Element:ps1",
                    "TestSchema:Element:structProp.P2:ts_Element:ps2",
                    "TestSchema:Element:structProp.P3:ts_Element:ps3",
                    "TestSchema:Element:structProp.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    auto inst1 = R"({
        "className": "ts.Element",
        "data": {
            "structProp": {
                "P1": 2210,
                "P2": 6703,
                "P3": 8481,
                "P4": 5339
            }
        }
    })"_json;

    auto key1 = InsertInstance(*m_briefcase, inst1);
    Test(
        "verify instance was written correctlye",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "structProp");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "021d8b1b7b0fa9bd214e2c7b2845f377966aad39fbc58cc6dd8ed2de8234ba52";
    const auto SCHEMA1_HASH_ECDB_MAP = "dda7c3a60923cb4f4f40e4251df34d47a716f65e88cef94a2be0511b39d4e527";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "84bda55de37b3c29de3a3bc49fffb942f5b4a688b58e5eaa947b90bd7fa65325";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                    <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="structProp" typeName="S" />
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECProperty propertyName="P1" typeName="int" />
                        <ECProperty propertyName="P2" typeName="int" />
                        <ECProperty propertyName="P3" typeName="int" />
                        <ECProperty propertyName="P4" typeName="int" />
                        <ECProperty propertyName="P5" typeName="int" />
                        <ECProperty propertyName="P6" typeName="int" />
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify property map after schema upgrade",
        [&]()
        {
        Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
        Json::Value expected = R"(
            [
                "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                "TestSchema:Element:ECClassId:ts_Element_Overflow:ECClassId",
                "TestSchema:Element:ECInstanceId:ts_Element:Id",
                "TestSchema:Element:ECInstanceId:ts_Element_Overflow:Id",
                "TestSchema:Element:structProp.P1:ts_Element_Overflow:os3",
                "TestSchema:Element:structProp.P2:ts_Element_Overflow:os4",
                "TestSchema:Element:structProp.P3:ts_Element_Overflow:os5",
                "TestSchema:Element:structProp.P4:ts_Element_Overflow:os6",
                "TestSchema:Element:structProp.P5:ts_Element_Overflow:os1",
                "TestSchema:Element:structProp.P6:ts_Element_Overflow:os2"
            ]
        )"_json;
        ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
        }
    );

    auto inst2 = R"({
        "className": "ts.Element",
        "data": {
            "structProp": {
                "P1": 3472,
                "P2": 4663,
                "P3": 8695,
                "P4": 9963,
                "P5": 5040,
                "P6": 2494
            }
        }
    })"_json;
    auto key2 = InsertInstance(*m_briefcase, inst2);

    Test(
        "verify instance was transformed correctly after schema import",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "structProp");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "verify instance inserted after schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key2, "structProp");
            ASSERT_STREQ(inst2["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "Make sure the column where property used to reside is set to null",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4 FROM ts_element where id = ?");
            vs->BindId(1, key1.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE(vs->IsColumnNull(0)) << "Expect ps1 to be null";
            ASSERT_TRUE(vs->IsColumnNull(1)) << "Expect ps2 to be null";
            ASSERT_TRUE(vs->IsColumnNull(2)) << "Expect ps3 to be null";
            ASSERT_TRUE(vs->IsColumnNull(3)) << "Expect ps4 to be null";
            }
    );

    Test(
        "Final hash check",
        [&]()
            {
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, OverflowedStructClass_OverflowTableDoesNotExist_CheckDataMoveCorrectly)
    {
    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "c5200fb69896736a0aaaf2e4932f694b7368ff9a525c0b51a848913e760727f5";
            const auto SCHEMA_HASH_ECDB_MAP = "0c2517eea45e5719f75e11bfc33cb9508f9ea880493c703b48dc7e37dc7e5279";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "e567d8390f0b253a968210f626c58f7be75b1f306d6e3def12f575cb576256a2";
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                    <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="structProp" typeName="S" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom2d">
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName="G1" typeName="int" />
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECProperty propertyName="P1" typeName="int" />
                        <ECProperty propertyName="P2" typeName="int" />
                        <ECProperty propertyName="P3" typeName="int" />
                        <ECProperty propertyName="P4" typeName="int" />
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("struct_prop", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify element mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
            Json::Value expected = R"(
                [
                    "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Element:ECInstanceId:ts_Element:Id",
                    "TestSchema:Element:structProp.P1:ts_Element:ps1",
                    "TestSchema:Element:structProp.P2:ts_Element:ps2",
                    "TestSchema:Element:structProp.P3:ts_Element:ps3",
                    "TestSchema:Element:structProp.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );
    Test(
        "verify geom2d mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom2d");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom2d:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom2d:G1:ts_Element:ps5",
                    "TestSchema:Geom2d:structProp.P1:ts_Element:ps1",
                    "TestSchema:Geom2d:structProp.P2:ts_Element:ps2",
                    "TestSchema:Geom2d:structProp.P3:ts_Element:ps3",
                    "TestSchema:Geom2d:structProp.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    auto inst1 = R"({
        "className": "ts.Element",
        "data": {
            "structProp": {
                "P1": 3194,
                "P2": 7305,
                "P3": 3092,
                "P4": 9935
            }
        }
    })"_json;
    auto key1 = InsertInstance(*m_briefcase, inst1);
    Test(
        "verify element instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "structProp");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst2 = R"({
        "className": "ts.Geom2d",
        "data": {
            "G1": 9247,
            "structProp": {
                "P1": 5627,
                "P2": 9315,
                "P3": 9333,
                "P4": 6570
            }
        }
    })"_json;
    auto key2 = InsertInstance(*m_briefcase, inst2);
    Test(
        "verify geom2d instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key2, "G1, structProp");
            ASSERT_STREQ(inst2["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "dd15f16c1053022d6df3f6a8ceb55f2d8f77a4140ef12f4cf3a199861724514a";
    const auto SCHEMA1_HASH_ECDB_MAP = "d6cd2aef1ea2160ed150483729e0203f321e65f67fcf1776e81954cf8038566b";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "e7775dfcaeb21886063311e476adc049aabbfdd5fdf87254ff597e0b448759ed";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>5</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                    <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="structProp" typeName="S" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom2d">
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName="G1" typeName="int" />
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECProperty propertyName="P1" typeName="int" />
                        <ECProperty propertyName="P2" typeName="int" />
                        <ECProperty propertyName="P3" typeName="int" />
                        <ECProperty propertyName="P4" typeName="int" />
                        <ECProperty propertyName="P5" typeName="int" />
                        <ECProperty propertyName="P6" typeName="int" />
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify map for element",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
            Json::Value expected = R"(
                [
                    "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Element:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Element:ECInstanceId:ts_Element:Id",
                    "TestSchema:Element:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Element:structProp.P1:ts_Element_Overflow:os3",
                    "TestSchema:Element:structProp.P2:ts_Element_Overflow:os4",
                    "TestSchema:Element:structProp.P3:ts_Element_Overflow:os5",
                    "TestSchema:Element:structProp.P4:ts_Element_Overflow:os6",
                    "TestSchema:Element:structProp.P5:ts_Element_Overflow:os1",
                    "TestSchema:Element:structProp.P6:ts_Element_Overflow:os2"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );
    Test(
        "verify map for geom2d",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom2d");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom2d:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom2d:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Geom2d:G1:ts_Element:ps5",
                    "TestSchema:Geom2d:structProp.P1:ts_Element_Overflow:os3",
                    "TestSchema:Geom2d:structProp.P2:ts_Element_Overflow:os4",
                    "TestSchema:Geom2d:structProp.P3:ts_Element_Overflow:os5",
                    "TestSchema:Geom2d:structProp.P4:ts_Element_Overflow:os6",
                    "TestSchema:Geom2d:structProp.P5:ts_Element_Overflow:os1",
                    "TestSchema:Geom2d:structProp.P6:ts_Element_Overflow:os2"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );
    // insert a second instance with additional properties
    auto inst3 = R"({
        "className": "ts.Element",
        "data": {
            "structProp": {
                "P1": 4855,
                "P2": 3449,
                "P3": 2623,
                "P4": 6854,
                "P5": 3769,
                "P6": 9612
            }
        }
    })"_json;
    auto key3 = InsertInstance(*m_briefcase, inst3);

    auto inst4 = R"({
        "className": "ts.Geom2d",
        "data": {
            "G1": 2866,
            "structProp": {
                "P1": 9663,
                "P2": 6961,
                "P3": 5681,
                "P4": 6747,
                "P5": 2143,
                "P6": 3404
            }
        }
    })"_json;
    auto key4 = InsertInstance(*m_briefcase, inst4);

    Test(
        "check element before schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "structProp");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check geom2d before schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key2, "G1, structProp");
            ASSERT_STREQ(inst2["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check element after schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key3, "structProp");
            ASSERT_STREQ(inst3["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check geom3d after schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key4, "G1, structProp");
            ASSERT_STREQ(inst4["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check data was moved and left behind",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4 FROM ts_element where id = ?");
            vs->BindId(1, key1.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE (vs->IsColumnNull(0))  << "Expect ps1 to be null";
            ASSERT_TRUE (vs->IsColumnNull(1))  << "Expect ps2 to be null";
            ASSERT_TRUE (vs->IsColumnNull(2))  << "Expect ps3 to be null";
            ASSERT_TRUE (vs->IsColumnNull(3))  << "Expect ps4 to be null";
            ASSERT_TRUE (vs->IsColumnNull(4))  << "Expect ps5 to be not null not used by element";
            }
    );
    Test(
        "check data was moved and left behind",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4, ps5 FROM ts_element where id = ?");
            vs->BindId(1, key2.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE (vs->IsColumnNull(0))  << "Expect ps1 to be null";
            ASSERT_TRUE (vs->IsColumnNull(1))  << "Expect ps2 to be null";
            ASSERT_TRUE (vs->IsColumnNull(2))  << "Expect ps3 to be null";
            ASSERT_TRUE (vs->IsColumnNull(3))  << "Expect ps4 to be null";
            ASSERT_FALSE(vs->IsColumnNull(4))  << "Expect ps5 to be not null (map to g1)";
            }
    );
    Test(
        "Final hash check",
        [&]()
            {
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, OverflowedStructClass_OverflowTableAlreadyExist_CheckDataMoveCorrectly)
    {
    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "ce510eb7d0be3a75330f873efb678f2d688cea07092076cc82b56b4b80ac2f35";
            const auto SCHEMA_HASH_ECDB_MAP = "2eae9b435cceabd71de698f1dd8e9cba678b8121108f7ce1fcc3e51860813950";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "b8e94c37841400f9757e0e288442da9f1b0ac9256478492b694d3b6af807d30e";
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                    <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="structProp" typeName="S" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom2d">
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName="G1" typeName="int" />
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECProperty propertyName="P1" typeName="int" />
                        <ECProperty propertyName="P2" typeName="int" />
                        <ECProperty propertyName="P3" typeName="int" />
                        <ECProperty propertyName="P4" typeName="int" />
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("struct_prop", schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify element mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
            Json::Value expected = R"(
                [
                    "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Element:ECInstanceId:ts_Element:Id",
                    "TestSchema:Element:structProp.P1:ts_Element:ps1",
                    "TestSchema:Element:structProp.P2:ts_Element:ps2",
                    "TestSchema:Element:structProp.P3:ts_Element:ps3",
                    "TestSchema:Element:structProp.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );
    Test(
        "verify geom2d mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom2d");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom2d:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom2d:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Geom2d:G1:ts_Element_Overflow:os1",
                    "TestSchema:Geom2d:structProp.P1:ts_Element:ps1",
                    "TestSchema:Geom2d:structProp.P2:ts_Element:ps2",
                    "TestSchema:Geom2d:structProp.P3:ts_Element:ps3",
                    "TestSchema:Geom2d:structProp.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    auto inst1 = R"({
        "className": "ts.Element",
        "data": {
            "structProp": {
                "P1": 3194,
                "P2": 7305,
                "P3": 3092,
                "P4": 9935
            }
        }
    })"_json;
    auto key1 = InsertInstance(*m_briefcase, inst1);
    Test(
        "verify element instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "structProp");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst2 = R"({
        "className": "ts.Geom2d",
        "data": {
            "G1": 9247,
            "structProp": {
                "P1": 5627,
                "P2": 9315,
                "P3": 9333,
                "P4": 6570
            }
        }
    })"_json;
    auto key2 = InsertInstance(*m_briefcase, inst2);
    Test(
        "verify geom2d instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key2, "G1, structProp");
            ASSERT_STREQ(inst2["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "5919d7b1c50a3c0ddb794a16b0864a10a21013f41b71aeb96360410af71942e2";
    const auto SCHEMA1_HASH_ECDB_MAP = "64945d90feb8b07124e81548483f3da799e4d64ee688cfe5f93ce1a729c8889a";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "ea86fc0107881cc77fabeaf7877ddf1a94b8e00621010b62932e72aa766e6331";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>4</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                    <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="structProp" typeName="S" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom2d">
                        <BaseClass>Element</BaseClass>
                        <ECProperty propertyName="G1" typeName="int" />
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECProperty propertyName="P1" typeName="int" />
                        <ECProperty propertyName="P2" typeName="int" />
                        <ECProperty propertyName="P3" typeName="int" />
                        <ECProperty propertyName="P4" typeName="int" />
                        <ECProperty propertyName="P5" typeName="int" />
                        <ECProperty propertyName="P6" typeName="int" />
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify map for element",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
            Json::Value expected = R"(
                [
                "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                "TestSchema:Element:ECClassId:ts_Element_Overflow:ECClassId",
                "TestSchema:Element:ECInstanceId:ts_Element:Id",
                "TestSchema:Element:ECInstanceId:ts_Element_Overflow:Id",
                "TestSchema:Element:structProp.P1:ts_Element_Overflow:os4",
                "TestSchema:Element:structProp.P2:ts_Element_Overflow:os5",
                "TestSchema:Element:structProp.P3:ts_Element_Overflow:os6",
                "TestSchema:Element:structProp.P4:ts_Element_Overflow:os7",
                "TestSchema:Element:structProp.P5:ts_Element_Overflow:os2",
                "TestSchema:Element:structProp.P6:ts_Element_Overflow:os3"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );
    Test(
        "verify map for geom2d",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom2d");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom2d:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom2d:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Geom2d:G1:ts_Element_Overflow:os1",
                    "TestSchema:Geom2d:structProp.P1:ts_Element_Overflow:os4",
                    "TestSchema:Geom2d:structProp.P2:ts_Element_Overflow:os5",
                    "TestSchema:Geom2d:structProp.P3:ts_Element_Overflow:os6",
                    "TestSchema:Geom2d:structProp.P4:ts_Element_Overflow:os7",
                    "TestSchema:Geom2d:structProp.P5:ts_Element_Overflow:os2",
                    "TestSchema:Geom2d:structProp.P6:ts_Element_Overflow:os3"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    // insert a second instance with additional properties
    auto inst3 = R"({
        "className": "ts.Element",
        "data": {
            "structProp": {
                "P1": 4855,
                "P2": 3449,
                "P3": 2623,
                "P4": 6854,
                "P5": 3769,
                "P6": 9612
            }
        }
    })"_json;
    auto key3 = InsertInstance(*m_briefcase, inst3);

    auto inst4 = R"({
        "className": "ts.Geom2d",
        "data": {
            "G1": 2866,
            "structProp": {
                "P1": 9663,
                "P2": 6961,
                "P3": 5681,
                "P4": 6747,
                "P5": 2143,
                "P6": 3404
            }
        }
    })"_json;
    auto key4 = InsertInstance(*m_briefcase, inst4);

    Test(
        "check element before schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "structProp");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check geom2d before schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key2, "G1, structProp");
            ASSERT_STREQ(inst2["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check element after schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key3, "structProp");
            ASSERT_STREQ(inst3["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check geom3d after schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key4, "G1, structProp");
            ASSERT_STREQ(inst4["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check data was moved and left behind - element",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4 FROM ts_element where id = ?");
            vs->BindId(1, key1.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE (vs->IsColumnNull(0))  << "Expect ps1 to be null";
            ASSERT_TRUE (vs->IsColumnNull(1))  << "Expect ps2 to be null";
            ASSERT_TRUE (vs->IsColumnNull(2))  << "Expect ps3 to be null";
            ASSERT_TRUE (vs->IsColumnNull(3))  << "Expect ps4 to be null";
            ASSERT_TRUE (vs->IsColumnNull(4))  << "Expect ps5 to be not null not used by element";
            }
    );
    Test(
        "check data was moved and left behind - geom2d",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4 FROM ts_element where id = ?");
            vs->BindId(1, key2.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE (vs->IsColumnNull(0))  << "Expect ps1 to be null";
            ASSERT_TRUE (vs->IsColumnNull(1))  << "Expect ps2 to be null";
            ASSERT_TRUE (vs->IsColumnNull(2))  << "Expect ps3 to be null";
            ASSERT_TRUE (vs->IsColumnNull(3))  << "Expect ps4 to be null";
            }
    );

    Test(
        "Check hashes",
        [&]()
            {
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

//---------------------------------------------------------------------------------------
// @bsimethod
//+---------------+---------------+---------------+---------------+---------------+------
TEST_F(SchemaSyncTestFixture, OverflowedStructClass)
    {
    Test(
        "Import initial schema",
        [&]()
            {
            const auto SCHEMA_HASH_ECDB_SCHEMA = "ec048a655e5d0ccfd29cd06365c23e9161224f46344c6d78a6178197ef1ef301";
            const auto SCHEMA_HASH_ECDB_MAP = "e7363dc95eaed6ea937a43ed36e8396f77a60200ab079b5d6adae812d6ac6436";
            const auto SCHEMA_HASH_SQLITE_SCHEMA = "b36128b828d977fe970b87ca3d5196003f5f5f86cd46f90084eeee825ae2506b";
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="S" typeName="S" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom2d">
                        <BaseClass>Element</BaseClass>
                        <ECStructProperty propertyName="G" typeName="G" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom2da">
                        <BaseClass>Geom2d</BaseClass>
                        <ECProperty propertyName="I" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom3d">
                        <BaseClass>Element</BaseClass>
                        <ECStructProperty propertyName="G" typeName="G" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom3da">
                        <BaseClass>Geom3d</BaseClass>
                        <ECProperty propertyName="I" typeName="int" />
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECProperty propertyName="P1" typeName="int" />
                        <ECProperty propertyName="P2" typeName="int" />
                        <ECProperty propertyName="P3" typeName="int" />
                        <ECProperty propertyName="P4" typeName="int" />
                    </ECStructClass>
                    <ECStructClass typeName="G" modifier="None">
                        <ECProperty propertyName="G1" typeName="int" />
                        <ECProperty propertyName="G2" typeName="int" />
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, SetupECDb("struct_prop", schema));
            CheckHashes(*m_briefcase, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP, SCHEMA_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA_HASH_ECDB_SCHEMA, SCHEMA_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify element mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
            Json::Value expected = R"(
                [
                    "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Element:ECInstanceId:ts_Element:Id",
                    "TestSchema:Element:S.P1:ts_Element:ps1",
                    "TestSchema:Element:S.P2:ts_Element:ps2",
                    "TestSchema:Element:S.P3:ts_Element:ps3",
                    "TestSchema:Element:S.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    Test(
        "verify geom2d mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom2d");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom2d:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom2d:G.G1:ts_Element:ps5",
                    "TestSchema:Geom2d:G.G2:ts_Element:ps6",
                    "TestSchema:Geom2d:S.P1:ts_Element:ps1",
                    "TestSchema:Geom2d:S.P2:ts_Element:ps2",
                    "TestSchema:Geom2d:S.P3:ts_Element:ps3",
                    "TestSchema:Geom2d:S.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    Test(
        "verify geom2da mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom2da");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom2da:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom2da:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom2da:G.G1:ts_Element:ps5",
                    "TestSchema:Geom2da:G.G2:ts_Element:ps6",
                    "TestSchema:Geom2da:I:ts_Element:ps7",
                    "TestSchema:Geom2da:S.P1:ts_Element:ps1",
                    "TestSchema:Geom2da:S.P2:ts_Element:ps2",
                    "TestSchema:Geom2da:S.P3:ts_Element:ps3",
                    "TestSchema:Geom2da:S.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    Test(
        "verify geom3d mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom3d");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom3d:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom3d:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom3d:G.G1:ts_Element:ps5",
                    "TestSchema:Geom3d:G.G2:ts_Element:ps6",
                    "TestSchema:Geom3d:S.P1:ts_Element:ps1",
                    "TestSchema:Geom3d:S.P2:ts_Element:ps2",
                    "TestSchema:Geom3d:S.P3:ts_Element:ps3",
                    "TestSchema:Geom3d:S.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    Test(
        "verify geom3da mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom3da");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom3da:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom3da:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom3da:G.G1:ts_Element:ps5",
                    "TestSchema:Geom3da:G.G2:ts_Element:ps6",
                    "TestSchema:Geom3da:I:ts_Element:ps7",
                    "TestSchema:Geom3da:S.P1:ts_Element:ps1",
                    "TestSchema:Geom3da:S.P2:ts_Element:ps2",
                    "TestSchema:Geom3da:S.P3:ts_Element:ps3",
                    "TestSchema:Geom3da:S.P4:ts_Element:ps4"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    auto inst1 = R"({
        "className": "ts.Element",
        "data": {
            "S": {
                "P1": 3194,
                "P2": 7305,
                "P3": 3092,
                "P4": 9935
            }
        }
    })"_json;
    auto key1 = InsertInstance(*m_briefcase, inst1);
    Test(
        "verify element instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "S");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst2 = R"({
        "className": "ts.Geom2d",
        "data": {
            "S": {
                "P1": 2241,
                "P2": 0929,
                "P3": 4361,
                "P4": 9375
            },
            "G" : {
                "G1": 2345,
                "G2": 5675
            }
        }
    })"_json;
    auto key2 = InsertInstance(*m_briefcase, inst2);
    Test(
        "verify geom2d instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key2, "S, G");
            ASSERT_STREQ(inst2["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst3 = R"({
        "className": "ts.Geom2da",
        "data": {
            "S": {
                "P1": 8834,
                "P2": 4765,
                "P3": 1998,
                "P4": 1661
            },
            "G" : {
                "G1": 6213,
                "G2": 1597
            },
            "I": 9154
        }
    })"_json;
    auto key3 = InsertInstance(*m_briefcase, inst3);
    Test(
        "verify geom2da instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key3, "S, G, I");
            ASSERT_STREQ(inst3["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst4 = R"({
        "className": "ts.Geom3d",
        "data": {
            "S": {
                "P1": 7017,
                "P2": 3955,
                "P3": 5015,
                "P4": 6628
            },
            "G" : {
                "G1": 1553,
                "G2": 1605
            }
        }
    })"_json;
    auto key4 = InsertInstance(*m_briefcase, inst4);
    Test(
        "verify geom3d instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key4, "S, G");
            ASSERT_STREQ(inst4["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst5 = R"({
        "className": "ts.Geom3da",
        "data": {
            "S": {
                "P1": 4724,
                "P2": 3456,
                "P3": 6019,
                "P4": 5530
            },
            "G" : {
                "G1": 6595,
                "G2": 8000
            },
            "I": 4478
        }
    })"_json;
    auto key5 = InsertInstance(*m_briefcase, inst5);
    Test(
        "verify geom3da instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key5, "S, G, I");
            ASSERT_STREQ(inst5["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    const auto SCHEMA1_HASH_ECDB_SCHEMA = "fad6adfc63a6c21f551a7105e98aba26b63b3f3e26e61512be8ef18c59ab37c2";
    const auto SCHEMA1_HASH_ECDB_MAP = "53fc11ba801953ade8b480bcacd72d6857a21020ae541fbe16086fbb0402bfb2";
    const auto SCHEMA1_HASH_SQLITE_SCHEMA = "be89d6bf51757e5e6b18f0969e4e5997b5ca7db158ebc8a78cdf9d4f79bef254";
    Test(
        "import edited schema with some changes",
        [&]()
            {
            auto schema = SchemaItem(
                R"xml(<ECSchema schemaName="TestSchema" alias="ts" version="1.0.0" xmlns="http://www.bentley.com/schemas/Bentley.ECXML.3.2">
                    <ECSchemaReference name="ECDbMap" version="02.00.00" alias="ecdbmap" />
                    <ECEntityClass typeName="Element">
                        <ECCustomAttributes>
                            <ShareColumns xmlns="ECDbMap.02.00.00">
                                <MaxSharedColumnsBeforeOverflow>7</MaxSharedColumnsBeforeOverflow>
                            </ShareColumns>
                            <ClassMap xmlns="ECDbMap.02.00.00">
                                <MapStrategy>TablePerHierarchy</MapStrategy>
                            </ClassMap>
                        </ECCustomAttributes>
                        <ECStructProperty propertyName="S" typeName="S" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom2d">
                        <BaseClass>Element</BaseClass>
                        <ECStructProperty propertyName="G" typeName="G" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom2da">
                        <BaseClass>Geom2d</BaseClass>
                        <ECProperty propertyName="I" typeName="int" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom3d">
                        <BaseClass>Element</BaseClass>
                        <ECStructProperty propertyName="G" typeName="G" />
                    </ECEntityClass>
                    <ECEntityClass typeName="Geom3da">
                        <BaseClass>Geom3d</BaseClass>
                        <ECProperty propertyName="I" typeName="int" />
                    </ECEntityClass>
                    <ECStructClass typeName="S" modifier="None">
                        <ECProperty propertyName="P1" typeName="int" />
                        <ECProperty propertyName="P2" typeName="int" />
                        <ECProperty propertyName="P3" typeName="int" />
                        <ECProperty propertyName="P4" typeName="int" />
                        <ECProperty propertyName="P5" typeName="int" />
                        <ECProperty propertyName="P6" typeName="int" />
                    </ECStructClass>
                    <ECStructClass typeName="G" modifier="None">
                        <ECProperty propertyName="G1" typeName="int" />
                        <ECProperty propertyName="G2" typeName="int" />
                    </ECStructClass>
                </ECSchema>)xml"
            );
            ASSERT_EQ(SchemaImportResult::OK, ImportSchema(schema, SchemaManager::SchemaImportOptions::AllowDataTransformDuringSchemaUpgrade));
            ASSERT_EQ(BE_SQLITE_OK, m_briefcase->SaveChanges());
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );

    Test(
        "verify element mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Element");
            Json::Value expected = R"(
                [
                    "TestSchema:Element:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Element:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Element:ECInstanceId:ts_Element:Id",
                    "TestSchema:Element:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Element:S.P1:ts_Element_Overflow:os3",
                    "TestSchema:Element:S.P2:ts_Element_Overflow:os4",
                    "TestSchema:Element:S.P3:ts_Element_Overflow:os5",
                    "TestSchema:Element:S.P4:ts_Element_Overflow:os6",
                    "TestSchema:Element:S.P5:ts_Element_Overflow:os1",
                    "TestSchema:Element:S.P6:ts_Element_Overflow:os2"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    Test(
        "verify geom2d mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom2d");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom2d:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom2d:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom2d:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Geom2d:G.G1:ts_Element:ps5",
                    "TestSchema:Geom2d:G.G2:ts_Element:ps6",
                    "TestSchema:Geom2d:S.P1:ts_Element_Overflow:os3",
                    "TestSchema:Geom2d:S.P2:ts_Element_Overflow:os4",
                    "TestSchema:Geom2d:S.P3:ts_Element_Overflow:os5",
                    "TestSchema:Geom2d:S.P4:ts_Element_Overflow:os6",
                    "TestSchema:Geom2d:S.P5:ts_Element_Overflow:os1",
                    "TestSchema:Geom2d:S.P6:ts_Element_Overflow:os2"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    Test(
        "verify geom2da mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom2da");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom2da:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom2da:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Geom2da:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom2da:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Geom2da:G.G1:ts_Element:ps5",
                    "TestSchema:Geom2da:G.G2:ts_Element:ps6",
                    "TestSchema:Geom2da:I:ts_Element:ps7",
                    "TestSchema:Geom2da:S.P1:ts_Element_Overflow:os3",
                    "TestSchema:Geom2da:S.P2:ts_Element_Overflow:os4",
                    "TestSchema:Geom2da:S.P3:ts_Element_Overflow:os5",
                    "TestSchema:Geom2da:S.P4:ts_Element_Overflow:os6",
                    "TestSchema:Geom2da:S.P5:ts_Element_Overflow:os1",
                    "TestSchema:Geom2da:S.P6:ts_Element_Overflow:os2"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    Test(
        "verify geom3d mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom3d");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom3d:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom3d:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Geom3d:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom3d:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Geom3d:G.G1:ts_Element:ps5",
                    "TestSchema:Geom3d:G.G2:ts_Element:ps6",
                    "TestSchema:Geom3d:S.P1:ts_Element_Overflow:os3",
                    "TestSchema:Geom3d:S.P2:ts_Element_Overflow:os4",
                    "TestSchema:Geom3d:S.P3:ts_Element_Overflow:os5",
                    "TestSchema:Geom3d:S.P4:ts_Element_Overflow:os6",
                    "TestSchema:Geom3d:S.P5:ts_Element_Overflow:os1",
                    "TestSchema:Geom3d:S.P6:ts_Element_Overflow:os2"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    Test(
        "verify geom3da mapping before schema upgrade",
        [&]()
            {
            Json::Value actual = GetPropertyMap(*m_briefcase, "ts.Geom3da");
            Json::Value expected = R"(
                [
                    "TestSchema:Geom3da:ECClassId:ts_Element:ECClassId",
                    "TestSchema:Geom3da:ECClassId:ts_Element_Overflow:ECClassId",
                    "TestSchema:Geom3da:ECInstanceId:ts_Element:Id",
                    "TestSchema:Geom3da:ECInstanceId:ts_Element_Overflow:Id",
                    "TestSchema:Geom3da:G.G1:ts_Element:ps5",
                    "TestSchema:Geom3da:G.G2:ts_Element:ps6",
                    "TestSchema:Geom3da:I:ts_Element:ps7",
                    "TestSchema:Geom3da:S.P1:ts_Element_Overflow:os3",
                    "TestSchema:Geom3da:S.P2:ts_Element_Overflow:os4",
                    "TestSchema:Geom3da:S.P3:ts_Element_Overflow:os5",
                    "TestSchema:Geom3da:S.P4:ts_Element_Overflow:os6",
                    "TestSchema:Geom3da:S.P5:ts_Element_Overflow:os1",
                    "TestSchema:Geom3da:S.P6:ts_Element_Overflow:os2"
                ]
            )"_json;
            ASSERT_STRCASEEQ(expected.toStyledString().c_str(), actual.toStyledString().c_str());
            }
    );

    auto inst6 = R"({
        "className": "ts.Element",
        "data": {
            "S": {
                "P1": 3194,
                "P2": 7305,
                "P3": 3092,
                "P4": 9935,
                "P5": 2345,
                "P6": 7617
            }
        }
    })"_json;
    auto key6 = InsertInstance(*m_briefcase, inst6);
    Test(
        "verify element instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key6, "S");
            ASSERT_STREQ(inst6["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst7 = R"({
        "className": "ts.Geom2d",
        "data": {
            "S": {
                "P1": 2052,
                "P2": 6957,
                "P3": 4117,
                "P4": 3313,
                "P5": 4296,
                "P6": 8375
            },
            "G" : {
                "G1": 7337,
                "G2": 8308
            }
        }
    })"_json;
    auto key7 = InsertInstance(*m_briefcase, inst7);
    Test(
        "verify geom2d instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key7, "S, G");
            ASSERT_STREQ(inst7["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst8 = R"({
        "className": "ts.Geom2da",
        "data": {
            "S": {
                "P1": 0216,
                "P2": 0729,
                "P3": 1331,
                "P4": 8791,
                "P5": 6558,
                "P6": 3267
            },
            "G" : {
                "G1": 2893,
                "G2": 2684
            },
            "I": 8480
        }
    })"_json;
    auto key8 = InsertInstance(*m_briefcase, inst8);
    Test(
        "verify geom2da instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key8, "S, G, I");
            ASSERT_STREQ(inst8["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst9 = R"({
        "className": "ts.Geom3d",
        "data": {
            "S": {
                "P1": 7709,
                "P2": 3660,
                "P3": 3677,
                "P4": 4565,
                "P5": 5576,
                "P6": 0439
            },
            "G" : {
                "G1": 5652,
                "G2": 0269
            }
        }
    })"_json;
    auto key9 = InsertInstance(*m_briefcase, inst9);
    Test(
        "verify geom3d instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key9, "S, G");
            ASSERT_STREQ(inst9["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );

    auto inst10 = R"({
        "className": "ts.Geom3da",
        "data": {
            "S": {
                "P1": 4335,
                "P2": 9415,
                "P3": 2146,
                "P4": 6059,
                "P5": 0582,
                "P6": 8747
            },
            "G" : {
                "G1": 8710,
                "G2": 7719
            },
            "I": 5249
        }
    })"_json;
    auto key10 = InsertInstance(*m_briefcase, inst10);
    Test(
        "verify geom3da instance",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key10, "S, G, I");
            ASSERT_STREQ(inst10["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check element before schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key1, "S");
            ASSERT_STREQ(inst1["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check geom2d before schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key2, "S, G");
            ASSERT_STREQ(inst2["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check geom2da after schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key3, "S, G, I");
            ASSERT_STREQ(inst3["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check geom3d after schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key4, "S, G");
            ASSERT_STREQ(inst4["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check geom3da after schema upgrade",
        [&]()
            {
            auto out = ReadInstance(*m_briefcase, key5, "S, G, I");
            ASSERT_STREQ(inst5["data"].toStyledString().c_str(), out.toStyledString().c_str());
            }
    );
    Test(
        "check data was moved and left behind - element",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4 FROM ts_element where id = ?");
            vs->BindId(1, key1.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE (vs->IsColumnNull(0))  << "Expect ps1 to be null";
            ASSERT_TRUE (vs->IsColumnNull(1))  << "Expect ps2 to be null";
            ASSERT_TRUE (vs->IsColumnNull(2))  << "Expect ps3 to be null";
            ASSERT_TRUE (vs->IsColumnNull(3))  << "Expect ps4 to be null";
            }
    );
    Test(
        "check data was moved and left behind - geom2d",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4 FROM ts_element where id = ?");
            vs->BindId(1, key2.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE  (vs->IsColumnNull(0))  << "Expect ps1 to be null";
            ASSERT_TRUE  (vs->IsColumnNull(1))  << "Expect ps2 to be null";
            ASSERT_TRUE  (vs->IsColumnNull(2))  << "Expect ps3 to be null";
            ASSERT_TRUE  (vs->IsColumnNull(3))  << "Expect ps4 to be null";
            }
    );
    Test(
        "check data was moved and left behind - geom2da",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4 FROM ts_element where id = ?");
            vs->BindId(1, key3.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE (vs->IsColumnNull(0))  << "Expect ps1 to be null";
            ASSERT_TRUE (vs->IsColumnNull(1))  << "Expect ps2 to be null";
            ASSERT_TRUE (vs->IsColumnNull(2))  << "Expect ps3 to be null";
            ASSERT_TRUE (vs->IsColumnNull(3))  << "Expect ps4 to be null";
            }
    );
    Test(
        "check data was moved and left behind - geom3d",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4 FROM ts_element where id = ?");
            vs->BindId(1, key4.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE (vs->IsColumnNull(0))  << "Expect ps1 to be null";
            ASSERT_TRUE (vs->IsColumnNull(1))  << "Expect ps2 to be null";
            ASSERT_TRUE (vs->IsColumnNull(2))  << "Expect ps3 to be null";
            ASSERT_TRUE (vs->IsColumnNull(3))  << "Expect ps4 to be null";
            }
    );
    Test(
        "check data was moved and left behind - geom3da",
        [&]()
            {
            auto vs = m_briefcase->GetCachedStatement("SELECT ps1, ps2, ps3, ps4 FROM ts_element where id = ?");
            vs->BindId(1, key5.GetInstanceId());
            ASSERT_EQ(BE_SQLITE_ROW, vs->Step());
            ASSERT_TRUE (vs->IsColumnNull(0))  << "Expect ps1 to be null";
            ASSERT_TRUE (vs->IsColumnNull(1))  << "Expect ps2 to be null";
            ASSERT_TRUE (vs->IsColumnNull(2))  << "Expect ps3 to be null";
            ASSERT_TRUE (vs->IsColumnNull(3))  << "Expect ps4 to be null";
            }
    );

    Test(
        "Check hashes",
        [&]()
            {
            CheckHashes(*m_briefcase, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP, SCHEMA1_HASH_SQLITE_SCHEMA, false, __LINE__);
            m_schemaChannel->WithReadOnly([&](ECDbR syncDb) { CheckSyncHashes(syncDb, SCHEMA1_HASH_ECDB_SCHEMA, SCHEMA1_HASH_ECDB_MAP); });
            }
    );
    }

END_ECDBUNITTESTS_NAMESPACE

