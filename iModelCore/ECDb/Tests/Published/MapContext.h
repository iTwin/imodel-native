/*--------------------------------------------------------------------------------------+
|
|     $Source: Tests/Published/MapContext.h $
|
|  $Copyright: (c) 2017 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#pragma once
#include "ECSqlTestFrameworkHelper.h"
BEGIN_ECDBUNITTESTS_NAMESPACE

//=======================================================================================
// @bsiclass                                      Affan.Khan                       05/17
//+===============+===============+===============+===============+===============+======
struct MapContext final
    {
    public:
        struct Table;
        struct ClassMap;

        //struct Index final
        //    {
        //    friend MapContext;
        //    Utf8String m_Name;
        //    Utf8String m_isUnique;
        //    Utf8String m_isAutoGenerated;
        //    Utf8String m_AppliesToSubClassesIfPartial;
        //    Utf8String m_rootSchema;
        //    Utf8String m_rotoClass;
        //    };

        struct Column final
            {
            friend MapContext;
            private:
                Utf8String m_name;
                Utf8String m_type;
                Utf8String m_isVirtual;
                Utf8String m_ordinal;
                Utf8String m_notNullConstraint;
                Utf8String m_uniqueConstraint;
                Utf8String m_checkConstraint;
                Utf8String m_defaultConstraint;
                Utf8String m_collationConstraint;
                Utf8String m_ordinalInPrimaryKey;
                Utf8String m_kind;
                Table const& m_table;
            public:
                Column(Table const& table) :m_table(table) {}
                Table const& GetTable() const { return m_table; }
                Utf8StringCR GetName() const { return m_name; }
                Utf8StringCR GetType() const { return m_type; }
                Utf8StringCR GetIsVirtual() const { return m_isVirtual; }
                Utf8StringCR GetOrdinal() const { return m_ordinal; }
                Utf8StringCR GetNotNullConstraint() const { return m_notNullConstraint; }
                Utf8StringCR GetUniqueConstraint() const { return m_uniqueConstraint; }
                Utf8StringCR GetCheckConstraint() const { return m_checkConstraint; }
                Utf8StringCR GetDefaultConstraint() const { return m_defaultConstraint; }
                Utf8StringCR GetCollationConstraint() const { return m_collationConstraint; }
                Utf8StringCR GetOrdinalInPrimaryKey() const { return m_ordinalInPrimaryKey; }
                Utf8StringCR GetKind() const { return m_kind; }
            };
        struct Table final
            {
            friend MapContext;
            private:
                std::map <Utf8String, std::unique_ptr<Column>> m_columns;
                std::vector<Column const*> m_columnsOrdered;
                Utf8String m_name;
                Utf8String m_type;
                Utf8String m_isVirtual;
                Utf8String m_parentTable;
                Utf8String m_exclusiveRootSchema;
                Utf8String m_exclusiveRootClass;

            public:
                Utf8StringCR GetName() const { return m_name; }
                Utf8StringCR GetType() const { return m_type; }
                Utf8StringCR GetIsVirtual() const { return m_isVirtual; }
                Utf8StringCR GetParentTable() const { return m_parentTable; }
                Utf8StringCR GetExclusiveRootSchema() const { return m_exclusiveRootSchema; }
                Utf8StringCR GetExclusiveRootClass() const { return m_exclusiveRootClass; }
                std::vector<Column const*> const& GetColumns() const { return m_columnsOrdered; }
                Column const* FindColumn(Utf8CP name) const { auto itor = m_columns.find(Utf8String(name)); return itor != m_columns.end() ? itor->second.get() : nullptr; }
            };
        struct PropertyMap final
            {
            friend MapContext;
            private:
                Utf8String m_accessString;
                Column const& m_column;
                ClassMap const& m_classMap;
            public:
                PropertyMap(ClassMap const& classMap, Column const& column) :m_classMap(classMap), m_column(column) {}
                ClassMap const& GetClassMap() const { return m_classMap; }
                Column const& GetColumn() const { return m_column; }
                Utf8StringCR GetAccessString() const { return m_accessString; }
            };
        struct ClassMap final
            {
            friend MapContext;
            private:
                std::map <Utf8String, std::unique_ptr<PropertyMap>> m_propertyMaps;
                std::vector<PropertyMap const*> m_propertyMapsOrdered;
                Utf8String m_name;
                Utf8String m_schema;
            public:
                Utf8String GetFullName() const { return m_schema + ":" + m_name; }
                Utf8StringCR GetName() const { return m_name; }
                Utf8StringCR GetSchemaName() const { return m_schema; }
                std::vector<PropertyMap const*> const& GetPropertyMaps() const { return m_propertyMapsOrdered; }
                PropertyMap const* FindPropertyMap(Utf8CP accessString) const { auto itor = m_propertyMaps.find(Utf8String(accessString)); return itor != m_propertyMaps.end() ? itor->second.get() : nullptr; }
            };
    private:
        std::map<Utf8String, std::unique_ptr<ClassMap>> m_classMaps;
        std::map<Utf8String, std::unique_ptr<Table>> m_tables;
        ECDbCR m_ecdb;

    private:
        void LoadTables();
        void LoadColumns(Table& table);
        ClassMap const* LoadClassMap(Utf8CP schemaName, Utf8CP className);

    public:
        MapContext(ECDbCR ecdb):m_ecdb(ecdb){}
        PropertyMap const* FindPropertyMap(Utf8CP schemaName, Utf8CP className, Utf8CP accessString);
        PropertyMap const* FindPropertyMap(Utf8CP schemaName, Utf8CP className, Utf8CP accessString, Utf8CP table);
        PropertyMap const* FindPropertyMap(Utf8CP schemaName, Utf8CP className, Utf8CP accessString, Utf8CP table, Utf8CP column);
        ClassMap const* FindClassMap(Utf8CP schemaName, Utf8CP className);
        Column const* FindColumn(Utf8CP tableName, Utf8CP columnName);
        Table const* FindTable(Utf8CP tableName);
        
        void Clear();
    };
//struct EntityBuilder final
//    {
//    private:
//        ECN::ECEntityClassP m_ecClass;
//    public:
//        EntityBuilder(ECN::ECEntityClassR ecclass)
//            :m_ecClass(&ecclass)
//            {
//            
//            }
//        EntityBuilder MakeSealed();
//        EntityBuilder MakeAbstract();
//        EntityBuilder MakeNone();
//        EntityBuilder SetModifier(ECN::ECClassModifier v);
//        EntityBuilder SetDisplayLabel(Utf8CP displayLabel);
//        EntityBuilder SetDescription(Utf8CP descriptionl);
//        EntityBuilder SetModifier(ECN::ECClassModifier v);
//        PropertyBuilder AddStruct(Utf8CP name, ECStructClassCR type);
//        PropertyBuilder AddBinary(Utf8CP name);
//        PropertyBuilder AddBoolean(Utf8CP name);
//        PropertyBuilder AddDateTime(Utf8CP name);
//        PropertyBuilder AddDouble (Utf8CP name);
//        PropertyBuilder AddInteger(Utf8CP name);
//        PropertyBuilder AddLong(Utf8CP name);
//        PropertyBuilder AddPoint2d(Utf8CP name);
//        PropertyBuilder AddPoint3d(Utf8CP name);
//        PropertyBuilder AddString(Utf8CP name);
//        PropertyBuilder AddGeometry(Utf8CP name, Utf8CP geo);
//        PropertyBuilder AddArrayOfStruct(Utf8CP name, ECStructClassCR type);
//        PropertyBuilder AddArrayOfBinary(Utf8CP name);
//        PropertyBuilder AddArrayOfBoolean(Utf8CP name);
//        PropertyBuilder AddArrayOfDateTime(Utf8CP name);
//        PropertyBuilder AddArrayOfDouble(Utf8CP name);
//        PropertyBuilder AddArrayOfInteger(Utf8CP name);
//        PropertyBuilder AddArrayOfLong(Utf8CP name);
//        PropertyBuilder AddArrayOfPoint2d(Utf8CP name);
//        PropertyBuilder AddArrayOfPoint3d(Utf8CP name);
//        PropertyBuilder AddArrayOfString(Utf8CP name);
//        PropertyBuilder AddArrayOfGeometry(Utf8CP name, Utf8CP geo);
//    };
//struct PropertyBuilder final
//    {
//    private:
//        ECN::ECPropertyP m_property;
//    public:
//        PropertyBuilder(ECN::ECPropertyR property)
//            :m_property(&property)
//            {}
//    };
//struct SchemaBuilder final
//    {
//    private:
//        ECN::ECSchemaP m_ecSchema;
//    public:
//        SchemaBuilder(ECN::ECSchemaR ecSchema)
//            :m_ecSchema(&ecSchema)
//            {}
//        EntityBuilder AddEntity(Utf8CP name = nullptr);
//    }

#define COLUMN_TYPE_ANY "Any"
#define COLUMN_TYPE_BOOLEAN "Boolean"
#define COLUMN_TYPE_BLOB "Blob"
#define COLUMN_TYPE_TIMESTAMP "TimeStamp"
#define COLUMN_TYPE_REAL "Real"
#define COLUMN_TYPE_INTEGER "Integer"
#define COLUMN_TYPE_TEXT "Text"

#define ASSERT_TRUE_CLASSMAP_EXISTS(CONTEXT, SCHEMA, CLASS)    ASSERT_NE(nullptr, CONTEXT.FindClassMap(SCHEMA,CLASS));
#define EXPECT_TRUE_CLASSMAP_EXISTS(CONTEXT, SCHEMA, CLASS)    EXPECT_NE(nullptr, CONTEXT.FindClassMap(SCHEMA,CLASS));
#define ASSERT_FALSE_CLASSMAP_EXISTS(CONTEXT, SCHEMA, CLASS)   ASSERT_EQ(nullptr, CONTEXT.FindClassMap(SCHEMA,CLASS));
#define EXPECT_FALSE_CLASSMAP_EXISTS(CONTEXT, SCHEMA, CLASS)   EXPECT_EQ(nullptr, CONTEXT.FindClassMap(SCHEMA,CLASS));

#define ASSERT_TRUE_PROPERTYMAP_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING)    ASSERT_NE(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING));
#define EXPECT_TRUE_PROPERTYMAP_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING)    EXPECT_NE(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING));
#define ASSERT_FALSE_PROPERTYMAP_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING)   ASSERT_EQ(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING));
#define EXPECT_FALSE_PROPERTYMAP_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING)   EXPECT_EQ(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING));

#define ASSERT_TRUE_PROPERTYMAP_TABLE_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING, TABLE)    ASSERT_NE(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING, TABLE));
#define EXPECT_TRUE_PROPERTYMAP_TABLE_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING, TABLE)    EXPECT_NE(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING, TABLE));
#define ASSERT_FALSE_PROPERTYMAP_TABLE_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING, TABLE)   ASSERT_EQ(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING, TABLE));
#define EXPECT_FALSE_PROPERTYMAP_TABLE_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING, TABLE)   EXPECT_EQ(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING, TABLE));

#define ASSERT_TRUE_PROPERTYMAP_COLUMN_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING, TABLE, COLUMN)    ASSERT_NE(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING, TABLE, COLUMN));
#define EXPECT_TRUE_PROPERTYMAP_COLUMN_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING, TABLE, COLUMN)    EXPECT_NE(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING, TABLE, COLUMN));
#define ASSERT_FALSE_PROPERTYMAP_COLUMN_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING, TABLE, COLUMN)   ASSERT_EQ(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING, TABLE, COLUMN));
#define EXPECT_FALSE_PROPERTYMAP_COLUMN_EXISTS(CONTEXT, SCHEMA, CLASS, ACCESSTRING, TABLE, COLUMN)   EXPECT_EQ(nullptr, CONTEXT.FindPropertyMap(SCHEMA,CLASS, ACCESSTRING, TABLE, COLUMN));

#define ASSERT_TRUE_TABLE_EXISTS(CONTEXT, TABLE)    ASSERT_NE(nullptr, CONTEXT.FindTable(TABLE));
#define EXPECT_TRUE_TABLE_EXISTS(CONTEXT, TABLE)    EXPECT_NE(nullptr, CONTEXT.FindTable(TABLE));
#define ASSERT_FALSE_TABLE_EXISTS(CONTEXT, TABLE)   ASSERT_EQ(nullptr, CONTEXT.FindTable(TABLE));
#define EXPECT_FALSE_TABLE_EXISTS(CONTEXT, TABLE)   EXPECT_EQ(nullptr, CONTEXT.FindTable(TABLE));

#define ASSERT_TRUE_COLUMN_EXISTS(CONTEXT, TABLE, COLUMN)    ASSERT_NE(nullptr, CONTEXT.FindColumn(TABLE, COLUMN));
#define EXPECT_TRUE_COLUMN_EXISTS(CONTEXT, TABLE, COLUMN)    EXPECT_NE(nullptr, CONTEXT.FindColumn(TABLE, COLUMN));
#define ASSERT_FALSE_COLUMN_EXISTS(CONTEXT, TABLE, COLUMN)   ASSERT_EQ(nullptr, CONTEXT.FindColumn(TABLE, COLUMN));
#define EXPECT_FALSE_COLUMN_EXISTS(CONTEXT, TABLE, COLUMN)   EXPECT_EQ(nullptr, CONTEXT.FindColumn(TABLE, COLUMN));


#define ASSERT_TRUE_COLUMN_ISVIRTUAL(CONTEXT, TABLE, COLUMN)    ASSERT_TRUE_COLUMN_EXISTS(ctx,TABLE, COLUMN);\
                                                            ASSERT_STREQ("True", ctx.FindColumn(TABLE,COLUMN)->GetIsVirtual().c_str())

#define ASSERT_FALSE_COLUMN_ISVIRTUAL(CONTEXT, TABLE, COLUMN)    ASSERT_TRUE_COLUMN_EXISTS(ctx,TABLE, COLUMN);\
                                                            ASSERT_STREQ("False", ctx.FindColumn(TABLE,COLUMN)->GetIsVirtual().c_str())

#define ASSERT_TRUE_TABLE_ISVIRTUAL(CONTEXT, TABLE)    ASSERT_TRUE_TABLE_EXISTS(ctx,TABLE);\
                                                            ASSERT_STREQ("True", ctx.FindTable(TABLE)->GetIsVirtual().c_str())

#define ASSERT_FALSE_TABLE_ISVIRTUAL(CONTEXT, TABLE)    ASSERT_TRUE_TABLE_EXISTS(ctx,TABLE);\
                                                            ASSERT_STREQ("False", ctx.FindTable(TABLE)->GetIsVirtual().c_str())

#define ASSERT_EQ_COLUMN_TYPE(CONTEXT, TABLE, COLUMN, TYPE)    ASSERT_TRUE_COLUMN_EXISTS(ctx,TABLE, COLUMN);\
                                                            ASSERT_STREQ(TYPE, ctx.FindColumn(TABLE,COLUMN)->GetType().c_str())

#define ASSERT_TRUE_COLUMN_IS_INTEGER(CONTEXT, TABLE, COLUMN) ASSERT_EQ_COLUMN_TYPE(CONTEXT, TABLE, COLUMN, COLUMN_TYPE_INTEGER) 
#define ASSERT_TRUE_COLUMN_IS_BLOB(CONTEXT, TABLE, COLUMN) ASSERT_EQ_COLUMN_TYPE(CONTEXT, TABLE, COLUMN, COLUMN_TYPE_BLOB) 
#define ASSERT_TRUE_COLUMN_IS_BOOLEAN(CONTEXT, TABLE, COLUMN) ASSERT_EQ_COLUMN_TYPE(CONTEXT, TABLE, COLUMN, COLUMN_TYPE_BOOLEAN) 
#define ASSERT_TRUE_COLUMN_IS_REAL(CONTEXT, TABLE, COLUMN) ASSERT_EQ_COLUMN_TYPE(CONTEXT, TABLE, COLUMN, COLUMN_TYPE_REAL) 
#define ASSERT_TRUE_COLUMN_IS_TEXT(CONTEXT, TABLE, COLUMN) ASSERT_EQ_COLUMN_TYPE(CONTEXT, TABLE, COLUMN, COLUMN_TYPE_TEXT) 
#define ASSERT_TRUE_COLUMN_IS_TIMESTAMP(CONTEXT, TABLE, COLUMN) ASSERT_EQ_COLUMN_TYPE(CONTEXT, TABLE, COLUMN, COLUMN_TYPE_TIMESTAMP) 
#define ASSERT_TRUE_COLUMN_IS_ANY(CONTEXT, TABLE, COLUMN) ASSERT_EQ_COLUMN_TYPE(CONTEXT, TABLE, COLUMN, COLUMN_TYPE_ANY) 


#define ASSERT_EQ_COLUMN_COUNT(ctx, TABLE, EXPECTED_COUNT)  ASSERT_TRUE_TABLE_EXISTS(ctx,TABLE);\
                                                            ASSERT_EQ(EXPECTED_COUNT, ctx.FindTable(TABLE)->GetColumns().size())

#define ASSERT_EQ_PROPERTYMAP_COUNT(ctx, SCHEMA, CLASS, EXPECTED_COUNT)  ASSERT_TRUE_CLASSMAP_EXISTS(ctx, SCHEMA, CLASS);\
                                                            ASSERT_EQ(EXPECTED_COUNT, ctx.FindClassMap( SCHEMA, CLASS)->GetPropertyMaps().size())

END_ECDBUNITTESTS_NAMESPACE