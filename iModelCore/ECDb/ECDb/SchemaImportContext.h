/*--------------------------------------------------------------------------------------+
|
|     $Source: ECDb/SchemaImportContext.h $
|
|  $Copyright: (c) 2015 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#pragma once
#include <ECDb/ECDbSchemaManager.h>
#include "ClassMap.h"
#include "ClassMapInfo.h"
#include "ECDbSql.h"

BEGIN_BENTLEY_SQLITE_EC_NAMESPACE

//=======================================================================================
// @bsiclass                                                Krischan.Eberle      05/2014
//+===============+===============+===============+===============+===============+======
struct SchemaImportContext
    {
public:
    struct ECDbMapMetadata
        {
    public:
        struct NewIndexInfo
            {
        public:
            enum class Scope
                {
                Auto,
                EnforceTable,
                EnforceClass,
                EnforceClassAndSubclasses
                };

        private:
            bool m_isAutoGenerated;
            ECN::ECClassId m_classId;
            Scope m_scope;

        public:
            NewIndexInfo() : m_isAutoGenerated(true), m_classId(ECN::ECClass::UNSET_ECCLASSID), m_scope(Scope::Auto) {}
            NewIndexInfo(bool isAutoGenerated, ECN::ECClassId classId, Scope scope) : m_isAutoGenerated(isAutoGenerated), m_classId(classId), m_scope(scope) {}

            bool IsAutoGenerated() const { return m_isAutoGenerated; }
            bool HasClassId() const { return m_classId != ECN::ECClass::UNSET_ECCLASSID; }
            ECN::ECClassId GetClassId() const { return m_classId; }
            Scope GetScope() const { return m_scope; }
            };

    private:
        ECDbSqlDb& m_ecdbMapDb;

        mutable std::vector<ECDbSqlIndex> m_indexes;
        mutable bmap<ECDbSqlIndex const*, NewIndexInfo> m_newIndexes;

        bmap<ECDbSqlColumn const*, bset<ColumnKind>> m_sharedColumnCache;
        mutable bset<Utf8CP, CompareIUtf8> m_usedIndexNames;

        bool Contains(ECDbSqlIndex const&) const;

        bool ExistsInDb(ECDbCR, ECDbSqlIndex const&) const;
        BentleyStatus CreateInDb(ECDbR, ECDbSqlIndex const&) const;
        BentleyStatus DropInDb(ECDbR, ECDbSqlIndex const&) const;
        BentleyStatus BuildCreateIndexDdl(NativeSqlBuilder& ddl, ECDbCR ecdb, ECDbSqlIndex const&) const;
        
        ECDbSqlIndex* CacheIndex(ECDbIndexId id, ECDbSqlTable& table, Utf8CP indexName, bool isUnique) const;
        ECDbSqlIndex* CacheIndex(ECDbSqlTable&, Utf8CP indexName, bool isUnique, ECN::ECClassId, bool isAutoGenerated, NewIndexInfo::Scope) const;

        BentleyStatus InsertIndexInfoIntoDb(ECDbCR, ECDbSqlIndex const&) const;
        BentleyStatus ReadIndexInfosFromDb(ECDbCR) const;

        bool IsNameInUse(Utf8CP name) const;

    public:
        ECDbMapMetadata(ECDbSqlDb& ecdbMapDb) : m_ecdbMapDb(ecdbMapDb) {}
        BentleyStatus Load();

        void SetColumnIsShared(ECDbSqlColumn const&, ColumnKind);
        bool IsColumnShared(ECDbSqlColumn const&, ColumnKind) const;

        ECDbSqlIndex* CreateIndex(ECDbSqlTable&, Utf8CP indexName, bool isUnique, std::vector<ECDbSqlColumn const*> const&, ECN::ECClassId, bool isAutoGenerated, NewIndexInfo::Scope = NewIndexInfo::Scope::Auto);
        ECDbSqlIndex* CreateIndex(ECDbSqlTable&, Utf8CP indexName, bool isUnique, std::vector<Utf8CP> const& columnNames, ECN::ECClassId, bool isAutoGenerated, NewIndexInfo::Scope = NewIndexInfo::Scope::Auto);

        BentleyStatus CreateOrUpdateIndicesInDb(ECDbR) const;
        };

private:
    ECDbMapMetadata m_ecdbMapDb;

    mutable std::map<ECN::ECClassCP, std::unique_ptr<UserECDbMapStrategy>> m_userStrategyCache;
    std::vector<std::pair<ClassMap const*, std::unique_ptr<ClassMapInfo>>> m_classMapInfoCache;

    UserECDbMapStrategy* GetUserStrategyP(ECN::ECClassCR, ECN::ECDbClassMap const*) const;

public:
    explicit SchemaImportContext (ECDbSqlDb& ecdbMapDb) : m_ecdbMapDb(ecdbMapDb) {}
    BentleyStatus Initialize() { return m_ecdbMapDb.Load(); }

    //! Gets the user map strategy for the specified ECClass.
    //! @return User map strategy. If the class doesn't have one a default strategy is returned. Only in 
    //! case of error, nullptr is returned
    UserECDbMapStrategy const* GetUserStrategy(ECN::ECClassCR, ECN::ECDbClassMap const* = nullptr) const;
    UserECDbMapStrategy* GetUserStrategyP(ECN::ECClassCR) const;

    void CacheClassMapInfo(ClassMap const&, std::unique_ptr<ClassMapInfo>&);
    std::vector<std::pair<ClassMap const*, std::unique_ptr<ClassMapInfo>>> const& GetClassMapInfoCache() const { return m_classMapInfoCache; }

    ECDbMapMetadata& GetECDbMapMetadata() { return m_ecdbMapDb; }
    };

END_BENTLEY_SQLITE_EC_NAMESPACE