/*--------------------------------------------------------------------------------------+
|
|     $Source: ECDb/SchemaImportContext.h $
|
|  $Copyright: (c) 2016 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#pragma once
#include <ECDb/ECDbSchemaManager.h>
#include "ClassMap.h"
#include "ClassMapInfo.h"
#include "ECDbSql.h"
#include "ECSchemaComparer.h"

BEGIN_BENTLEY_SQLITE_EC_NAMESPACE

//======================================================================================
// @bsiclass                                                 Affan.Khan         09/2014
//======================================================================================
struct ECDbSqlIndex
    {
private:
    ECDbIndexId m_id;
    Utf8String m_name;
    ECDbSqlTable* m_table;
    std::vector<ECDbSqlColumn const*> m_columns;
    bool m_isUnique;
    bool m_addColsAreNotNullWhereExp;
    bool m_isAutoGenerated;
    ECN::ECClassId m_classId;
    bool m_appliesToSubclassesIfPartial;

public:
    ECDbSqlIndex(ECDbIndexId id, ECDbSqlTable& table, Utf8CP name, bool isUnique, std::vector<ECDbSqlColumn const*> const& columns, bool addColsAreNotNullWhereExp, bool isAutoGenerated, ECN::ECClassId classId, bool appliesToSubclassesIfPartial)
        :m_id(id), m_name(name), m_table(&table), m_isUnique(isUnique), m_columns(columns), m_addColsAreNotNullWhereExp(addColsAreNotNullWhereExp), m_isAutoGenerated(isAutoGenerated), m_classId(classId), m_appliesToSubclassesIfPartial(appliesToSubclassesIfPartial)
        {
        BeAssert(!Utf8String::IsNullOrEmpty(name) && !m_columns.empty());
        }

    ECDbIndexId GetId() const { BeAssert(m_id != IIdGenerator::UNSET_ID); return m_id; }
    Utf8StringCR GetName() const { return m_name; }
    ECDbSqlTable const& GetTable() const { BeAssert(m_table != nullptr); return *m_table; }
    bool GetIsUnique() const { return m_isUnique; }
    std::vector<ECDbSqlColumn const*> const& GetColumns() const { return m_columns; }
    bool IsAddColumnsAreNotNullWhereExp() const { return m_addColsAreNotNullWhereExp; }
    bool IsAutoGenerated() const { return m_isAutoGenerated; }
    //! If false, the index will not be partial
    bool HasClassId() const { return m_classId != ECN::ECClass::UNSET_ECCLASSID; }
    ECN::ECClassId GetClassId() const { return m_classId; }
    //! If true, the partial index will include subclasses in that table. If false, the partial index
    //! will not include subclasses. This is only relevant if the index is partial at all,
    //! i.e. if HasClassId() is true
    bool AppliesToSubclassesIfPartial() const { return m_appliesToSubclassesIfPartial; }
    };

//=======================================================================================
// @bsiclass                                                Krischan.Eberle      10/2015
//+===============+===============+===============+===============+===============+======
struct SchemaImportECDbMapDb
    {
private:
    ECDbMapDb& m_coreMapDb;

    mutable std::vector<std::unique_ptr<ECDbSqlIndex>> m_indexes;
    mutable bset<Utf8CP, CompareIUtf8> m_usedIndexNames;

    BentleyStatus BuildCreateIndexDdl(NativeSqlBuilder&, Utf8StringR comparableIndexDef, ECDbCR, ECDbSqlIndex const&) const;
    BentleyStatus GenerateIndexWhereClause(NativeSqlBuilder&, ECDbCR, ECDbSqlIndex const&) const;

    ECDbSqlIndex* CacheIndex(ECDbCR, ECDbIndexId, ECDbSqlTable&, Utf8CP indexName, bool isUnique, std::vector<ECDbSqlColumn const*> const&, bool addIsNotNullWhereExp, bool isAutoGenerated, ECN::ECClassId, bool applyToSubclassesIfPartial) const;

    BentleyStatus InsertIndexInfoIntoDb(ECDbCR, ECDbSqlIndex const&) const;
    BentleyStatus ReadIndexInfosFromDb(ECDbCR) const;
    bool IsNameInUse(Utf8CP name) const;

    static BentleyStatus TruncateIndexInfoTables(ECDbCR);

public:
    SchemaImportECDbMapDb(ECDbMapDb& coreECDbMapDb) : m_coreMapDb(coreECDbMapDb) {}
    BentleyStatus Load();

    ECDbSqlIndex* CreateIndex(ECDbCR, ECDbSqlTable&, Utf8CP indexName, bool isUnique, std::vector<ECDbSqlColumn const*> const&, bool addIsNotNullWhereExp, bool isAutoGenerated, ECN::ECClassId, bool applyToSubclassesIfPartial = true);
    ECDbSqlIndex* CreateIndex(ECDbCR, ECDbSqlTable&, Utf8CP indexName, bool isUnique, std::vector<Utf8CP> const& columnNames, bool addIsNotNullWhereExp, bool isAutoGenerated, ECN::ECClassId, bool applyToSubclassesIfPartial = true);

    BentleyStatus CreateOrUpdateIndexesInDb(ECDbR) const;

    std::vector<std::unique_ptr<ECDbSqlIndex>> const& GetIndexes() const { return m_indexes; }
    };
//=======================================================================================
// @bsiclass                                                Affan.Khan            03/2016
//+===============+===============+===============+===============+===============+======
struct ECSchemaCompareContext
    {
private:
    bvector<ECN::ECSchemaCP> m_existingSchemaList;
    bvector<ECN::ECSchemaCP> m_importedSchemaList;
    ECSchemaChanges m_changes;
    bool m_prepared;

    bool AssertIfNotPrepared() const;

public:
    ECSchemaCompareContext() : m_prepared(false) {}
    ~ECSchemaCompareContext() {}

    BentleyStatus Prepare(ECDbSchemaManager const& schemaManager, bvector<ECN::ECSchemaP> const& dependencyOrderedPrimarySchemas);
    bvector<ECN::ECSchemaCP>  const& GetImportingSchemas() const { return m_importedSchemaList; }
    ECN::ECSchemaCP FindExistingSchema(Utf8CP schemaName) const;
    bool IsPrepared() const { return m_prepared; }
    ECSchemaChanges& GetChanges() { return m_changes; }
    bool HasNoSchemasToImport() const { return m_importedSchemaList.empty(); }
    bool RequiresUpdate() const;

    BentleyStatus ReloadECSchemaIfRequired(ECDbSchemaManager const&);
    };
//=======================================================================================
// @bsiclass                                                Krischan.Eberle      05/2014
//+===============+===============+===============+===============+===============+======
struct SchemaImportContext
    {
private:
    std::unique_ptr<SchemaImportECDbMapDb> m_ecdbMapDb;

    mutable std::map<ECN::ECClassCP, std::unique_ptr<UserECDbMapStrategy>> m_userStrategyCache;
    std::map<ClassMap const*, std::unique_ptr<ClassMapInfo>> m_classMapInfoCache;

    ClassMapLoadContext m_loadContext;
    ECSchemaCompareContext m_compareContext;

    UserECDbMapStrategy* GetUserStrategyP(ECN::ECClassCR, ECN::ECDbClassMap const*) const;

public:
    SchemaImportContext() {}
    BentleyStatus Initialize(ECDbSQLManager const& dbSchema, ECDbCR ecdb);

    //! Gets the user map strategy for the specified ECClass.
    //! @return User map strategy. If the class doesn't have one a default strategy is returned. Only in 
    //! case of error, nullptr is returned
    UserECDbMapStrategy const* GetUserStrategy(ECN::ECClassCR, ECN::ECDbClassMap const* = nullptr) const;
    UserECDbMapStrategy* GetUserStrategyP(ECN::ECClassCR) const;

    void CacheClassMapInfo(ClassMap const&, std::unique_ptr<ClassMapInfo>&);
    std::map<ClassMap const*, std::unique_ptr<ClassMapInfo>> const& GetClassMapInfoCache() const { return m_classMapInfoCache; }

    ClassMapLoadContext& GetClassMapLoadContext() { return m_loadContext; }
    SchemaImportECDbMapDb& GetECDbMapDb() { return *m_ecdbMapDb; }
	ECSchemaCompareContext& GetECSchemaCompareContext() { return m_compareContext; }
    };

END_BENTLEY_SQLITE_EC_NAMESPACE