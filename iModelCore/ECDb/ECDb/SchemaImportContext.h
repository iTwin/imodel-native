/*--------------------------------------------------------------------------------------+
|
|     $Source: ECDb/SchemaImportContext.h $
|
|  $Copyright: (c) 2015 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#pragma once
#include <ECDb/ECDbSchemaManager.h>
#include "ClassMap.h"
#include "ClassMapInfo.h"
#include "ECDbSql.h"

BEGIN_BENTLEY_SQLITE_EC_NAMESPACE

//=======================================================================================
// @bsiclass                                                Krischan.Eberle      10/2015
//+===============+===============+===============+===============+===============+======
struct SchemaImportECDbMapDb
    {
public:
    enum class IndexScope
        {
        Auto,
        EnforceTable,
        EnforceClass,
        EnforceClassAndSubclasses
        };

    struct NewIndexInfo
        {
        private:
            bool m_isAutoGenerated;
            ECN::ECClassId m_classId;
            IndexScope m_scope;

        public:
            NewIndexInfo() : m_isAutoGenerated(true), m_classId(ECN::ECClass::UNSET_ECCLASSID), m_scope(IndexScope::Auto) {}
            NewIndexInfo(bool isAutoGenerated, ECN::ECClassId classId, IndexScope scope) : m_isAutoGenerated(isAutoGenerated), m_classId(classId), m_scope(scope) {}

            bool IsAutoGenerated() const { return m_isAutoGenerated; }
            bool HasClassId() const { return m_classId != ECN::ECClass::UNSET_ECCLASSID; }
            ECN::ECClassId GetClassId() const { return m_classId; }
            IndexScope GetScope() const { return m_scope; }
        };

private:
    ECDbMapDb& m_coreMapDb;

    mutable std::vector<ECDbSqlIndex> m_indexes;
    mutable bmap<ECDbSqlIndex const*, NewIndexInfo> m_newIndexes;

    bmap<ECDbSqlColumn const*, bset<ColumnKind>> m_sharedColumnCache;
    mutable bset<Utf8CP, CompareIUtf8> m_usedIndexNames;

    bool Contains(ECDbSqlIndex const&) const;

    bool ExistsInDb(ECDbCR, ECDbSqlIndex const&) const;
    BentleyStatus CreateInDb(ECDbR, ECDbSqlIndex const&) const;
    BentleyStatus DropInDb(ECDbR, ECDbSqlIndex const&) const;
    BentleyStatus BuildCreateIndexDdl(NativeSqlBuilder& ddl, ECDbCR ecdb, ECDbSqlIndex const&) const;

    ECDbSqlIndex* CacheIndex(ECDbIndexId id, ECDbSqlTable& table, Utf8CP indexName, bool isUnique) const;
    ECDbSqlIndex* CacheIndex(ECDbSqlTable&, Utf8CP indexName, bool isUnique, ECN::ECClassId, bool isAutoGenerated, IndexScope) const;

    BentleyStatus InsertIndexInfoIntoDb(ECDbCR, ECDbSqlIndex const&) const;
    BentleyStatus ReadIndexInfosFromDb(ECDbCR) const;

    bool IsNameInUse(Utf8CP name) const;

public:
    SchemaImportECDbMapDb(ECDbMapDb& coreECDbMapDb) : m_coreMapDb(coreECDbMapDb) {}
    BentleyStatus Load();

    void SetColumnIsShared(ECDbSqlColumn const&, ColumnKind);
    bool IsColumnShared(ECDbSqlColumn const&, ColumnKind) const;

    ECDbSqlIndex* CreateIndex(ECDbSqlTable&, Utf8CP indexName, bool isUnique, std::vector<ECDbSqlColumn const*> const&, ECN::ECClassId, bool isAutoGenerated, IndexScope = IndexScope::Auto);
    ECDbSqlIndex* CreateIndex(ECDbSqlTable&, Utf8CP indexName, bool isUnique, std::vector<Utf8CP> const& columnNames, ECN::ECClassId, bool isAutoGenerated, IndexScope = IndexScope::Auto);

    BentleyStatus CreateOrUpdateIndicesInDb(ECDbR) const;
    };

//=======================================================================================
// @bsiclass                                                Krischan.Eberle      05/2014
//+===============+===============+===============+===============+===============+======
struct SchemaImportContext
    {
private:
    SchemaImportECDbMapDb m_ecdbMapDb;

    mutable std::map<ECN::ECClassCP, std::unique_ptr<UserECDbMapStrategy>> m_userStrategyCache;
    std::vector<std::pair<ClassMap const*, std::unique_ptr<ClassMapInfo>>> m_classMapInfoCache;

    UserECDbMapStrategy* GetUserStrategyP(ECN::ECClassCR, ECN::ECDbClassMap const*) const;

public:
    explicit SchemaImportContext (ECDbMapDb& coreECDbMapDb) : m_ecdbMapDb(coreECDbMapDb) {}
    BentleyStatus Initialize() { return m_ecdbMapDb.Load(); }

    //! Gets the user map strategy for the specified ECClass.
    //! @return User map strategy. If the class doesn't have one a default strategy is returned. Only in 
    //! case of error, nullptr is returned
    UserECDbMapStrategy const* GetUserStrategy(ECN::ECClassCR, ECN::ECDbClassMap const* = nullptr) const;
    UserECDbMapStrategy* GetUserStrategyP(ECN::ECClassCR) const;

    void CacheClassMapInfo(ClassMap const&, std::unique_ptr<ClassMapInfo>&);
    std::vector<std::pair<ClassMap const*, std::unique_ptr<ClassMapInfo>>> const& GetClassMapInfoCache() const { return m_classMapInfoCache; }

    SchemaImportECDbMapDb& GetECDbMapDb() { return m_ecdbMapDb; }
    };

END_BENTLEY_SQLITE_EC_NAMESPACE