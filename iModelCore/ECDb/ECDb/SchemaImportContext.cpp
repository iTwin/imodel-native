/*--------------------------------------------------------------------------------------+
|
|     $Source: ECDb/SchemaImportContext.cpp $
|
|  $Copyright: (c) 2015 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#include "ECDbPch.h"
#include "SchemaImportContext.h"

BEGIN_BENTLEY_SQLITE_EC_NAMESPACE

//*************************************************************************************
// SchemaImportContext
//*************************************************************************************
//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle   07/2015
//---------------------------------------------------------------------------------------
UserECDbMapStrategy const* SchemaImportContext::GetUserStrategy(ECClassCR ecclass, ECDbClassMap const* classMapCA) const
    {
    return GetUserStrategyP(ecclass, classMapCA);
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle   07/2015
//---------------------------------------------------------------------------------------
UserECDbMapStrategy* SchemaImportContext::GetUserStrategyP(ECClassCR ecclass) const
    {
    return GetUserStrategyP(ecclass, nullptr);
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle   07/2015
//---------------------------------------------------------------------------------------
UserECDbMapStrategy* SchemaImportContext::GetUserStrategyP(ECClassCR ecclass, ECDbClassMap const* classMapCA) const
    {
    auto it = m_userStrategyCache.find(&ecclass);
    if (it != m_userStrategyCache.end())
        return it->second.get();

    bool hasClassMapCA = true;
    ECDbClassMap classMap;
    if (classMapCA == nullptr)
        {
        hasClassMapCA = ECDbMapCustomAttributeHelper::TryGetClassMap(classMap, ecclass);
        classMapCA = &classMap;
        }

    std::unique_ptr<UserECDbMapStrategy> userStrategy = std::unique_ptr<UserECDbMapStrategy>(new UserECDbMapStrategy());

    if (hasClassMapCA)
        {
        ECDbClassMap::MapStrategy strategy;
        if (ECOBJECTS_STATUS_Success != classMapCA->TryGetMapStrategy(strategy))
            return nullptr; // error

        if (SUCCESS != UserECDbMapStrategy::TryParse(*userStrategy, strategy) || !userStrategy->IsValid())
            return nullptr; // error
        }

    UserECDbMapStrategy* userStrategyP = userStrategy.get();
    m_userStrategyCache[&ecclass] = std::move(userStrategy);
    return userStrategyP;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle   08/2015
//---------------------------------------------------------------------------------------
void SchemaImportContext::CacheClassMapInfo(ClassMap const& classMap, std::unique_ptr<ClassMapInfo>& info)
    {
    m_classMapInfoCache.push_back(std::make_pair(&classMap, std::move(info)));
    }



//****************************************************************************************

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle   10/2015
//---------------------------------------------------------------------------------------
BentleyStatus SchemaImportContext::ECDbMapMetadata::Load()
    {
    //first load generic mapping meta data
    ECDbSQLManager& manager = m_ecdbMapDb.GetManagerR();
    if (!manager.IsLoaded())
        {
        if (SUCCESS != manager.Load())
            return ERROR;
        }
    
    //then load meta data only needed for schema import
    return ReadIndexInfosFromDb(manager.GetECDb());
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Affan.Khan        09/2014
//---------------------------------------------------------------------------------------
ECDbSqlIndex* SchemaImportContext::ECDbMapMetadata::CreateIndex(ECDbSqlTable& table, Utf8CP indexName, bool isUnique, std::vector<ECDbSqlColumn const*> const& columns, ECN::ECClassId classId, bool isAutoGenerated, NewIndexInfo::Scope scope)
    {
    if (columns.empty())
        return nullptr;

    ECDbSqlIndex* index = CacheIndex(table, indexName, isUnique, classId, isAutoGenerated, scope);
    index->AddColumns(columns);

    return index;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Affan.Khan        09/2014
//---------------------------------------------------------------------------------------
ECDbSqlIndex* SchemaImportContext::ECDbMapMetadata::CreateIndex(ECDbSqlTable& table, Utf8CP indexName, bool isUnique, std::vector<Utf8CP> const& columnNames, ECN::ECClassId classId, bool isAutoGenerated, NewIndexInfo::Scope scope)
    {
    if (columnNames.empty())
        return nullptr;

    ECDbSqlIndex* index = CacheIndex(table, indexName, isUnique, classId, isAutoGenerated, scope);
    index->AddColumns(columnNames);

    return index;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Affan.Khan        09/2014
//---------------------------------------------------------------------------------------
ECDbSqlIndex* SchemaImportContext::ECDbMapMetadata::CacheIndex(ECDbSqlTable& table, Utf8CP indexName, bool isUnique, ECN::ECClassId classId, bool isAutoGenerated, NewIndexInfo::Scope scope) const
    {
    Utf8String generatedIndexName;
    if (Utf8String::IsNullOrEmpty(indexName))
        {
        do
            {
            m_ecdbMapDb.GetNameGenerator().Generate(generatedIndexName);
            } while (IsNameInUse(generatedIndexName.c_str()));

            indexName = generatedIndexName.c_str();
        }

    ECDbSqlIndex* index = CacheIndex(m_ecdbMapDb.GetManagerR().GetIdGenerator().NextIndexId(),
                                     table, indexName, isUnique);

    m_newIndexes[index] = NewIndexInfo(isAutoGenerated, classId, scope);
    return index;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Affan.Khan        09/2014
//---------------------------------------------------------------------------------------
ECDbSqlIndex* SchemaImportContext::ECDbMapMetadata::CacheIndex(ECDbIndexId id, ECDbSqlTable& table, Utf8CP indexName, bool isUnique) const
    {
    m_indexes.push_back(ECDbSqlIndex(id, table, indexName, isUnique));
    ECDbSqlIndex* index = &m_indexes.back();

    m_usedIndexNames.insert(index->GetName().c_str());
    return index;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle  10/2015
//---------------------------------------------------------------------------------------
bool SchemaImportContext::ECDbMapMetadata::Contains(ECDbSqlIndex const& index) const
    {
    return true;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle  10/2015
//---------------------------------------------------------------------------------------
bool SchemaImportContext::ECDbMapMetadata::ExistsInDb(ECDbCR ecdb, ECDbSqlIndex const& index) const
    {
    CachedStatementPtr stmt = nullptr;
    if (BE_SQLITE_OK != ecdb.GetCachedStatement(stmt, "select NULL from sqlite_master WHERE type='index' and name=?"))
        {
        BeAssert(false);
        return false;
        }

    stmt->BindText(1, index.GetName().c_str(), Statement::MakeCopy::No);
    return BE_SQLITE_ROW == stmt->Step();
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Affan.Khan        10/2014
//---------------------------------------------------------------------------------------
BentleyStatus SchemaImportContext::ECDbMapMetadata::CreateInDb(ECDbR ecdb, ECDbSqlIndex const& index) const
    {
    if (index.GetColumns().empty())
        {
        BeAssert(false && "Index definition is not valid");
        return ERROR;
        }

    NativeSqlBuilder ddl;
    if (SUCCESS != BuildCreateIndexDdl(ddl, ecdb, index))
        return ERROR;

    if (BE_SQLITE_OK != ecdb.ExecuteSql(ddl.ToString()))
        {
        ecdb.GetECDbImplR().GetIssueReporter().Report(ECDbIssueSeverity::Error, "Failed to create index %s on table %s. Error: %s", index.GetName().c_str(), index.GetTable().GetName().c_str(),
                                                      ecdb.GetLastError());
        BeAssert(false && "Failed to create index");
        return ERROR;
        }

    return SUCCESS;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Affan.Khan        10/2014
//---------------------------------------------------------------------------------------
BentleyStatus SchemaImportContext::ECDbMapMetadata::DropInDb(ECDbR ecdb, ECDbSqlIndex const& index) const
    {
    Utf8String ddl("DROP INDEX [");
    ddl.append(index.GetName()).append("]");

    if (ecdb.ExecuteSql(ddl.c_str()) != BE_SQLITE_OK)
        {
        ecdb.GetECDbImplR().GetIssueReporter().Report(ECDbIssueSeverity::Error, "Failed to drop index %s on table %s. Error: %s", index.GetName().c_str(), index.GetTable().GetName().c_str(),
                                                      ecdb.GetLastError());

        BeAssert(false && "Failed to create index");
        return ERROR;
        }

    return SUCCESS;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                Krischan.Eberle 10/2015
//---------------------------------------------------------------------------------------
BentleyStatus SchemaImportContext::ECDbMapMetadata::BuildCreateIndexDdl(NativeSqlBuilder& ddl, ECDbCR ecdb, ECDbSqlIndex const& index) const
    {
    ddl.Append("CREATE ");
    if (index.GetIsUnique())
        ddl.Append("UNIQUE ");

    Utf8CP indexName = index.GetName().c_str();
    Utf8CP tableName = index.GetTable().GetName().c_str();
    ddl.Append("INDEX ").AppendEscaped(indexName).Append(" ON ").AppendEscaped(tableName).Append(" (");

    bool hasSharedDataColumns = false;
    bool hasSharedConstraintECInstanceIdColumns = false;
    bool isFirstCol = true;
    for (ECDbSqlColumn const* col : index.GetColumns())
        {
        if (!isFirstCol)
            ddl.AppendComma(false);

        ddl.AppendEscaped(col->GetName().c_str());

        if (IsColumnShared(*col, ColumnKind::DataColumn))
            hasSharedDataColumns = true;
        if (IsColumnShared(*col, ColumnKind::ConstraintECInstanceId))
            hasSharedConstraintECInstanceIdColumns = true;

        isFirstCol = false;
        }

    ddl.AppendParenRight();

    bool hasWhere = !index.GetAdditionalWhereExpression().empty();
    if (hasWhere)
        ddl.Append(" WHERE ").AppendParenLeft().Append(index.GetAdditionalWhereExpression().c_str()).AppendParenRight();

    NewIndexInfo const* newIndexInfo = nullptr;
    auto it = m_newIndexes.find(&index);
    if (it != m_newIndexes.end())
        newIndexInfo = &it->second;

    //now add ECClassId filter if needed. As ECClassId filters would slow down INSERT/UPDATE a lot
    //and SQLite doesn't even consider them in many cases in SELECT, the following rules are applied:
    //* If the index has no shared columns, no class id filter will be added, even if the index is defined
    //only for a given subclass in the table. The values in that column will all be NULL as it is not shared
    //and that doesn't matter for the index.
    //* If the index has shared columns, and a class id filter would be required, it is an error if the index is non-unique,
    //and only a warning if it is a unique. 
    //The difference between non-unique and unique indexes is because it is assumed that unique indexes are needed to
    //enforce uniqueness where as non-unique indexes are only for performance which is spoilt by a class id filter.
    ECDbSqlColumn const* classIdCol = nullptr;
    if ((newIndexInfo != nullptr && newIndexInfo->HasClassId()) || !index.GetTable().TryGetECClassIdColumn(classIdCol))
        return SUCCESS;
//    if (index.HasClassId() || !index.GetTable().TryGetECClassIdColumn(classIdCol) ||
//        (!index.GetIsUnique() && index.IsAutoGenerated())) // non-unique auto-generated indexes are always non-partial
//        return SUCCESS;


    BeAssert(classIdCol != nullptr);

    ECClassCP ecclass = ecdb.Schemas().GetECClass(newIndexInfo->GetClassId());
    if (ecclass == nullptr)
        {
        BeAssert(false);
        return ERROR;
        }

    ClassMapCP classMap = ecdb.GetECDbImplR().GetECDbMap().GetClassMapCP(*ecclass);
    if (classMap == nullptr)
        {
        BeAssert(false);
        return ERROR;
        }

    StorageDescription const& storageDescription = classMap->GetStorageDescription();
    std::vector<size_t> nonVirtualPartitionIndices = storageDescription.GetNonVirtualHorizontalPartitionIndices();
    HorizontalPartition const* horizPartition = nullptr;
    if (nonVirtualPartitionIndices.empty())
        horizPartition = &storageDescription.GetRootHorizontalPartition();
    else
        {
        BeAssert(nonVirtualPartitionIndices.size() == 1 && "Check that class only maps to a single table should have been done during class name preparation");
        horizPartition = storageDescription.GetHorizontalPartition(nonVirtualPartitionIndices[0]);
        }

    if (!horizPartition->NeedsClassIdFilter())
        return SUCCESS;

    //for user-defined indexes we warn/fail as schema authors can adjust their schemas
    //for auto-generated indexes we will not fail
  /*  if (!info->IsAutoGenerated())
        {
        if (index.GetIsUnique())
            {
            ecdb.GetECDbImplR().GetIssueReporter().Report(ECDbIssueSeverity::Warning,
                                                          "Index '%s' defined for ECClass '%s' includes a column shared by multiple ECClasses. "
                                                          "This results in a partial index filtered by ECClassId which might impact performance. "
                                                          "Consider changing the ECClass to not share columns.", indexName, ecclass->GetFullName());
            }
        else
            {
            ecdb.GetECDbImplR().GetIssueReporter().Report(ECDbIssueSeverity::Error,
                                                          "Failed to create index '%s' for ECClass '%s'. ECDb does not create indices on columns "
                                                          "shared by multiple ECClasses because they would be partial indexes filtered by ECClassId which might impact performance. "
                                                          "Consider changing the ECClass to not share columns.", indexName, ecclass->GetFullName());
            return ERROR;
            }
        }
    else
        {
        if (index.GetIsUnique())
            {
            ecdb.GetECDbImplR().GetIssueReporter().Report(ECDbIssueSeverity::Warning,
                                                          "ECDb has to create a unique index for ECRelationshipClass '%s' to enforce the cardinality. "
                                                          "This results in a partial index filtered by ECClassId which might impact performance. "
                                                          "Consider changing the ECRelationshipClass to not share a table.", ecclass->GetFullName());
            }

        }*/
    /*    if (hasSharedDataColumns || hasSharedConstraintECInstanceIdColumns)
    {
    if (m_scope == ECDbSqlIndex::Scope::Auto)
    {
    ecdb.GetECDbImplR().GetIssueReporter().Report(ECDbIssueSeverity::Error,
    "Failed to create index '%s' for ECClass '%s'. ECDb does not create indices on columns "
    "shared by multiple ECClasses because they would be partial indexes filtered by ECClassId which might impact performance. "
    "Consider changing the ECClass to not share columns.", m_name.c_str(), ecclass->GetFullName());
    return ERROR;
    }
    else if (m_scope == Scope::EnforceClassAndSubclasses)
    {
    ecdb.GetECDbImplR().GetIssueReporter().Report(ECDbIssueSeverity::Warning,
    "Index '%s' defined for ECClass '%s' includes a column shared by multiple ECClasses. "
    "This results in a partial index filtered by ECClassId which might impact performance. "
    "Consider changing the ECClass to not share columns.", m_name.c_str(), ecclass->GetFullName());
    }
    }

    BeAssert(m_scope != Scope::EnforceTable && "should have been caught before");
    */
    if (hasWhere)
        ddl.AppendSpace().Append(BooleanSqlOperator::And, true).AppendParenLeft();
    else
        ddl.Append(" WHERE ");

    horizPartition->AppendECClassIdFilterSql(classIdCol->GetName().c_str(), ddl);

    if (hasWhere)
        ddl.AppendParenRight();

    return SUCCESS;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle  08/2015
//---------------------------------------------------------------------------------------
BentleyStatus SchemaImportContext::ECDbMapMetadata::CreateOrUpdateIndicesInDb(ECDbR ecdb) const
    {
    for (ECDbSqlIndex const& index : m_indexes)
        {
        //populates the ec_Index table
        if (SUCCESS != InsertIndexInfoIntoDb(ecdb, index))
            return ERROR;

        if (ExistsInDb(ecdb, index))
            {
            if (SUCCESS != DropInDb(ecdb, index))
                return ERROR;
            }

        if (SUCCESS != CreateInDb(ecdb, index))
            return ERROR;
        }

    return SUCCESS;
    }


//---------------------------------------------------------------------------------------
// @bsimethod                                                    Affan.Khan  08/2015
//---------------------------------------------------------------------------------------
BentleyStatus SchemaImportContext::ECDbMapMetadata::ReadIndexInfosFromDb(ECDbCR ecdb) const
    {
    CachedStatementPtr stmt = nullptr;
    ecdb.GetCachedStatement(stmt, "SELECT I.Id, T.Name, I.Name, I.IsUnique, I.AdditionalWhereExpression FROM ec_Index I INNER JOIN ec_Table T ON T.Id = I.TableId");
    if (stmt == nullptr)
        return ERROR;

    while (stmt->Step() == BE_SQLITE_ROW)
        {
        int64_t id = stmt->GetValueInt64(0);
        Utf8CP tableName = stmt->GetValueText(1);
        Utf8CP name = stmt->GetValueText(2);
        bool isUnique = stmt->GetValueInt(3) == 1;

        Utf8CP additionalWhereExpression = !stmt->IsColumnNull(4) ? stmt->GetValueText(4) : nullptr;

        ECDbSqlTable* table = m_ecdbMapDb.FindTableP(tableName);
        if (table == nullptr)
            {
            BeAssert(false && "Failed to find table");
            return ERROR;
            }

        ECDbSqlIndex* index = CacheIndex(id, *table, name, isUnique);

        if (additionalWhereExpression)
            index->SetAdditionalWhereExpression(additionalWhereExpression);

        CachedStatementPtr indexColStmt = nullptr;
        ecdb.GetCachedStatement(indexColStmt, "SELECT C.Name FROM ec_IndexColumn I INNER JOIN ec_Column C ON C.Id = I.ColumnId WHERE I.IndexId = ? ORDER BY I.Ordinal");
        if (indexColStmt == nullptr)
            return ERROR;

        indexColStmt->BindInt64(1, id);
        std::vector<ECDbSqlColumn const*> columns;
        while (indexColStmt->Step() == BE_SQLITE_ROW)
            {
            Utf8CP columnName = indexColStmt->GetValueText(0);
            ECDbSqlColumn const* col = table->FindColumnCP(columnName);
            if (col == nullptr)
                return ERROR;

            columns.push_back(col);
            }

        if (index->AddColumns(columns) != SUCCESS)
            return ERROR;
        }

    return SUCCESS;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Affan.Khan        01/2015
//---------------------------------------------------------------------------------------
BentleyStatus SchemaImportContext::ECDbMapMetadata::InsertIndexInfoIntoDb(ECDbCR ecdb, ECDbSqlIndex const& index) const
    {
    CachedStatementPtr stmt = nullptr;
    ecdb.GetCachedStatement(stmt, "INSERT OR REPLACE INTO ec_Index (Id, TableId, Name, IsUnique, AdditionalWhereExpression) VALUES (?,?,?,?,?)");
    if (stmt == nullptr)
        return ERROR;

    stmt->BindInt64(1, index.GetId());
    stmt->BindInt64(2, index.GetTable().GetId());
    stmt->BindText(3, index.GetName().c_str(), Statement::MakeCopy::No);
    stmt->BindInt(4, index.GetIsUnique() ? 1 : 0);

    if (!index.GetAdditionalWhereExpression().empty())
        stmt->BindText(5, index.GetAdditionalWhereExpression().c_str(), Statement::MakeCopy::No);

    DbResult stat = stmt->Step();
    if (stat != BE_SQLITE_DONE)
        return ERROR;


    CachedStatementPtr indexColStmt = nullptr;
    ecdb.GetCachedStatement(indexColStmt, "INSERT OR REPLACE INTO ec_IndexColumn (IndexId, ColumnId, Ordinal) VALUES (?,?,?)");
    if (indexColStmt == nullptr)
        return ERROR;

    int i = 0;
    for (ECDbSqlColumn const* col : index.GetColumns())
        {
        indexColStmt->BindInt64(1, index.GetId());
        indexColStmt->BindInt64(2, col->GetId());
        indexColStmt->BindInt64(3, i);

        stat = indexColStmt->Step();
        if (stat != BE_SQLITE_DONE)
            return ERROR;

        indexColStmt->Reset();
        indexColStmt->ClearBindings();
        i++;
        }

    return SUCCESS;
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle   10/2015
//---------------------------------------------------------------------------------------
void SchemaImportContext::ECDbMapMetadata::SetColumnIsShared(ECDbSqlColumn const& col, ColumnKind kind)
    {
    m_sharedColumnCache[&col].insert(kind);
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle   10/2015
//---------------------------------------------------------------------------------------
bool SchemaImportContext::ECDbMapMetadata::IsColumnShared(ECDbSqlColumn const& col, ColumnKind kind) const
    {
    auto it = m_sharedColumnCache.find(&col);
    if (it == m_sharedColumnCache.end())
        return false;

    bset<ColumnKind> const& isSharedSet = it->second;
    return isSharedSet.find(kind) != isSharedSet.end();
    }

//---------------------------------------------------------------------------------------
// @bsimethod                                                    Krischan.Eberle  10/2015
//---------------------------------------------------------------------------------------
bool SchemaImportContext::ECDbMapMetadata::IsNameInUse(Utf8CP name) const
    {
    return m_usedIndexNames.find(name) != m_usedIndexNames.end() || m_ecdbMapDb.IsNameInUse(name);
    }

END_BENTLEY_SQLITE_EC_NAMESPACE
