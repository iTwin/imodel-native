// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: allcg.proto

#ifndef PROTOBUF_allcg_2eproto__INCLUDED
#define PROTOBUF_allcg_2eproto__INCLUDED

#include <BeProtobuf/BeProtobuf.h>

#include <BeProtobuf/message.h>
#include <BeProtobuf/repeated_field.h>
#include <BeProtobuf/extension_set.h>
#include <BeProtobuf/generated_enum_reflection.h>
#include <BeProtobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace Bentley {
namespace Geometry {
namespace Proto {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_allcg_2eproto();
void protobuf_AssignDesc_allcg_2eproto();
void protobuf_ShutdownFile_allcg_2eproto();

class DPoint3d;
class DPoint2d;
class DVector3d;
class IPlacement;
class Angle;
class DEllipse3d;
class DTransform3d;
class LoopType;
class ISinglePoint;
class IPoint;
class IPrimitiveCurve;
class ICurve;
class ICurveChain;
class ISolid;
class IAnalyticSolid;
class ISurface;
class ISurfacePatch;
class IParametricSurface;
class IGeometry;
class Block;
class BsplineCurve;
class BsplineSurface;
class CircularArc;
class CircularCone;
class CircularCylinder;
class CircularDisk;
class Coordinate;
class CurveReference;
class EllipticArc;
class EllipticDisk;
class IndexedMesh;
class InterpolatingCurve;
class LineSegment;
class LineString;
class Polygon;
class PrimitiveCurveReference;
class SharedGroupInstance;
class ShelledSolid;
class SingleLineText;
class SkewedCone;
class SolidBySweptSurface;
class Sphere;
class Spiral;
class SurfaceBySweptCurve;
class TorusPipe;
class TransformedGeometry;
class TransitionSpiral;
class Vector;
class AdjacentSurfacePatches;
class Group;
class CurveChain;
class CurveGroup;
class Operation;
class ParametricSurfacePatch;
class PointChain;
class PointGroup;
class SharedGroupDef;
class SolidGroup;
class SurfaceGroup;
class SurfacePatch;

enum LoopType_LoopTypeEnum {
  LoopType_LoopTypeEnum_Parity = 1,
  LoopType_LoopTypeEnum_InteriorToLeft = 2
};
bool LoopType_LoopTypeEnum_IsValid(int value);
const LoopType_LoopTypeEnum LoopType_LoopTypeEnum_LoopTypeEnum_MIN = LoopType_LoopTypeEnum_Parity;
const LoopType_LoopTypeEnum LoopType_LoopTypeEnum_LoopTypeEnum_MAX = LoopType_LoopTypeEnum_InteriorToLeft;
const int LoopType_LoopTypeEnum_LoopTypeEnum_ARRAYSIZE = LoopType_LoopTypeEnum_LoopTypeEnum_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoopType_LoopTypeEnum_descriptor();
inline const ::Bentley::Utf8String& LoopType_LoopTypeEnum_Name(LoopType_LoopTypeEnum value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoopType_LoopTypeEnum_descriptor(), value);
}
inline bool LoopType_LoopTypeEnum_Parse(
    const ::Bentley::Utf8String& name, LoopType_LoopTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoopType_LoopTypeEnum>(
    LoopType_LoopTypeEnum_descriptor(), name, value);
}
// ===================================================================

class DPoint3d : public ::google::protobuf::Message {
 public:
  DPoint3d();
  virtual ~DPoint3d();

  DPoint3d(const DPoint3d& from);

  inline DPoint3d& operator=(const DPoint3d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DPoint3d& default_instance();

  void Swap(DPoint3d* other);

  // implements Message ----------------------------------------------

  DPoint3d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DPoint3d& from);
  void MergeFrom(const DPoint3d& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.DPoint3d)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static DPoint3d* default_instance_;
};
// -------------------------------------------------------------------

class DPoint2d : public ::google::protobuf::Message {
 public:
  DPoint2d();
  virtual ~DPoint2d();

  DPoint2d(const DPoint2d& from);

  inline DPoint2d& operator=(const DPoint2d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DPoint2d& default_instance();

  void Swap(DPoint2d* other);

  // implements Message ----------------------------------------------

  DPoint2d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DPoint2d& from);
  void MergeFrom(const DPoint2d& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.DPoint2d)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static DPoint2d* default_instance_;
};
// -------------------------------------------------------------------

class DVector3d : public ::google::protobuf::Message {
 public:
  DVector3d();
  virtual ~DVector3d();

  DVector3d(const DVector3d& from);

  inline DVector3d& operator=(const DVector3d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DVector3d& default_instance();

  void Swap(DVector3d* other);

  // implements Message ----------------------------------------------

  DVector3d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DVector3d& from);
  void MergeFrom(const DVector3d& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x() const;
  inline void set_x(double value);

  // required double y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline double y() const;
  inline void set_y(double value);

  // required double z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline double z() const;
  inline void set_z(double value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.DVector3d)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_;
  double y_;
  double z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static DVector3d* default_instance_;
};
// -------------------------------------------------------------------

class IPlacement : public ::google::protobuf::Message {
 public:
  IPlacement();
  virtual ~IPlacement();

  IPlacement(const IPlacement& from);

  inline IPlacement& operator=(const IPlacement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPlacement& default_instance();

  void Swap(IPlacement* other);

  // implements Message ----------------------------------------------

  IPlacement* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPlacement& from);
  void MergeFrom(const IPlacement& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.DPoint3d orgin = 1;
  inline bool has_orgin() const;
  inline void clear_orgin();
  static const int kOrginFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::DPoint3d& orgin() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_orgin();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_orgin();
  inline void set_allocated_orgin(::Bentley::Geometry::Proto::DPoint3d* orgin);

  // required .Bentley.Geometry.Proto.DVector3d vectorZ = 2;
  inline bool has_vectorZ() const;
  inline void clear_vectorZ();
  static const int kVectorZFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::DVector3d& vectorZ() const;
  inline ::Bentley::Geometry::Proto::DVector3d* mutable_vectorZ();
  inline ::Bentley::Geometry::Proto::DVector3d* release_vectorZ();
  inline void set_allocated_vectorZ(::Bentley::Geometry::Proto::DVector3d* vectorZ);

  // required .Bentley.Geometry.Proto.DVector3d vectorX = 3;
  inline bool has_vectorX() const;
  inline void clear_vectorX();
  static const int kVectorXFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::DVector3d& vectorX() const;
  inline ::Bentley::Geometry::Proto::DVector3d* mutable_vectorX();
  inline ::Bentley::Geometry::Proto::DVector3d* release_vectorX();
  inline void set_allocated_vectorX(::Bentley::Geometry::Proto::DVector3d* vectorX);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.IPlacement)
 private:
  inline void set_has_orgin();
  inline void clear_has_orgin();
  inline void set_has_vectorZ();
  inline void clear_has_vectorZ();
  inline void set_has_vectorX();
  inline void clear_has_vectorX();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::DPoint3d* orgin_;
  ::Bentley::Geometry::Proto::DVector3d* vectorZ_;
  ::Bentley::Geometry::Proto::DVector3d* vectorX_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static IPlacement* default_instance_;
};
// -------------------------------------------------------------------

class Angle : public ::google::protobuf::Message {
 public:
  Angle();
  virtual ~Angle();

  Angle(const Angle& from);

  inline Angle& operator=(const Angle& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Angle& default_instance();

  void Swap(Angle* other);

  // implements Message ----------------------------------------------

  Angle* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Angle& from);
  void MergeFrom(const Angle& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double degrees = 1;
  inline bool has_degrees() const;
  inline void clear_degrees();
  static const int kDegreesFieldNumber = 1;
  inline double degrees() const;
  inline void set_degrees(double value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.Angle)
 private:
  inline void set_has_degrees();
  inline void clear_has_degrees();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double degrees_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static Angle* default_instance_;
};
// -------------------------------------------------------------------

class DEllipse3d : public ::google::protobuf::Message {
 public:
  DEllipse3d();
  virtual ~DEllipse3d();

  DEllipse3d(const DEllipse3d& from);

  inline DEllipse3d& operator=(const DEllipse3d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DEllipse3d& default_instance();

  void Swap(DEllipse3d* other);

  // implements Message ----------------------------------------------

  DEllipse3d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DEllipse3d& from);
  void MergeFrom(const DEllipse3d& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double centerX = 1;
  inline bool has_centerX() const;
  inline void clear_centerX();
  static const int kCenterXFieldNumber = 1;
  inline double centerX() const;
  inline void set_centerX(double value);

  // required double centerY = 2;
  inline bool has_centerY() const;
  inline void clear_centerY();
  static const int kCenterYFieldNumber = 2;
  inline double centerY() const;
  inline void set_centerY(double value);

  // required double centerZ = 3;
  inline bool has_centerZ() const;
  inline void clear_centerZ();
  static const int kCenterZFieldNumber = 3;
  inline double centerZ() const;
  inline void set_centerZ(double value);

  // required double vector0X = 4;
  inline bool has_vector0X() const;
  inline void clear_vector0X();
  static const int kVector0XFieldNumber = 4;
  inline double vector0X() const;
  inline void set_vector0X(double value);

  // required double vector0Y = 5;
  inline bool has_vector0Y() const;
  inline void clear_vector0Y();
  static const int kVector0YFieldNumber = 5;
  inline double vector0Y() const;
  inline void set_vector0Y(double value);

  // required double vector0Z = 6;
  inline bool has_vector0Z() const;
  inline void clear_vector0Z();
  static const int kVector0ZFieldNumber = 6;
  inline double vector0Z() const;
  inline void set_vector0Z(double value);

  // required double vector90X = 7;
  inline bool has_vector90X() const;
  inline void clear_vector90X();
  static const int kVector90XFieldNumber = 7;
  inline double vector90X() const;
  inline void set_vector90X(double value);

  // required double vector90Y = 8;
  inline bool has_vector90Y() const;
  inline void clear_vector90Y();
  static const int kVector90YFieldNumber = 8;
  inline double vector90Y() const;
  inline void set_vector90Y(double value);

  // required double vector90Z = 9;
  inline bool has_vector90Z() const;
  inline void clear_vector90Z();
  static const int kVector90ZFieldNumber = 9;
  inline double vector90Z() const;
  inline void set_vector90Z(double value);

  // required double startRadians = 10;
  inline bool has_startRadians() const;
  inline void clear_startRadians();
  static const int kStartRadiansFieldNumber = 10;
  inline double startRadians() const;
  inline void set_startRadians(double value);

  // required double sweepRadians = 11;
  inline bool has_sweepRadians() const;
  inline void clear_sweepRadians();
  static const int kSweepRadiansFieldNumber = 11;
  inline double sweepRadians() const;
  inline void set_sweepRadians(double value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.DEllipse3d)
 private:
  inline void set_has_centerX();
  inline void clear_has_centerX();
  inline void set_has_centerY();
  inline void clear_has_centerY();
  inline void set_has_centerZ();
  inline void clear_has_centerZ();
  inline void set_has_vector0X();
  inline void clear_has_vector0X();
  inline void set_has_vector0Y();
  inline void clear_has_vector0Y();
  inline void set_has_vector0Z();
  inline void clear_has_vector0Z();
  inline void set_has_vector90X();
  inline void clear_has_vector90X();
  inline void set_has_vector90Y();
  inline void clear_has_vector90Y();
  inline void set_has_vector90Z();
  inline void clear_has_vector90Z();
  inline void set_has_startRadians();
  inline void clear_has_startRadians();
  inline void set_has_sweepRadians();
  inline void clear_has_sweepRadians();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double centerX_;
  double centerY_;
  double centerZ_;
  double vector0X_;
  double vector0Y_;
  double vector0Z_;
  double vector90X_;
  double vector90Y_;
  double vector90Z_;
  double startRadians_;
  double sweepRadians_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static DEllipse3d* default_instance_;
};
// -------------------------------------------------------------------

class DTransform3d : public ::google::protobuf::Message {
 public:
  DTransform3d();
  virtual ~DTransform3d();

  DTransform3d(const DTransform3d& from);

  inline DTransform3d& operator=(const DTransform3d& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DTransform3d& default_instance();

  void Swap(DTransform3d* other);

  // implements Message ----------------------------------------------

  DTransform3d* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DTransform3d& from);
  void MergeFrom(const DTransform3d& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double axx = 1;
  inline bool has_axx() const;
  inline void clear_axx();
  static const int kAxxFieldNumber = 1;
  inline double axx() const;
  inline void set_axx(double value);

  // required double axy = 2;
  inline bool has_axy() const;
  inline void clear_axy();
  static const int kAxyFieldNumber = 2;
  inline double axy() const;
  inline void set_axy(double value);

  // required double axz = 3;
  inline bool has_axz() const;
  inline void clear_axz();
  static const int kAxzFieldNumber = 3;
  inline double axz() const;
  inline void set_axz(double value);

  // required double axw = 4;
  inline bool has_axw() const;
  inline void clear_axw();
  static const int kAxwFieldNumber = 4;
  inline double axw() const;
  inline void set_axw(double value);

  // required double ayx = 5;
  inline bool has_ayx() const;
  inline void clear_ayx();
  static const int kAyxFieldNumber = 5;
  inline double ayx() const;
  inline void set_ayx(double value);

  // required double ayy = 6;
  inline bool has_ayy() const;
  inline void clear_ayy();
  static const int kAyyFieldNumber = 6;
  inline double ayy() const;
  inline void set_ayy(double value);

  // required double ayz = 7;
  inline bool has_ayz() const;
  inline void clear_ayz();
  static const int kAyzFieldNumber = 7;
  inline double ayz() const;
  inline void set_ayz(double value);

  // required double ayw = 8;
  inline bool has_ayw() const;
  inline void clear_ayw();
  static const int kAywFieldNumber = 8;
  inline double ayw() const;
  inline void set_ayw(double value);

  // required double azx = 9;
  inline bool has_azx() const;
  inline void clear_azx();
  static const int kAzxFieldNumber = 9;
  inline double azx() const;
  inline void set_azx(double value);

  // required double azy = 10;
  inline bool has_azy() const;
  inline void clear_azy();
  static const int kAzyFieldNumber = 10;
  inline double azy() const;
  inline void set_azy(double value);

  // required double azz = 11;
  inline bool has_azz() const;
  inline void clear_azz();
  static const int kAzzFieldNumber = 11;
  inline double azz() const;
  inline void set_azz(double value);

  // required double azw = 12;
  inline bool has_azw() const;
  inline void clear_azw();
  static const int kAzwFieldNumber = 12;
  inline double azw() const;
  inline void set_azw(double value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.DTransform3d)
 private:
  inline void set_has_axx();
  inline void clear_has_axx();
  inline void set_has_axy();
  inline void clear_has_axy();
  inline void set_has_axz();
  inline void clear_has_axz();
  inline void set_has_axw();
  inline void clear_has_axw();
  inline void set_has_ayx();
  inline void clear_has_ayx();
  inline void set_has_ayy();
  inline void clear_has_ayy();
  inline void set_has_ayz();
  inline void clear_has_ayz();
  inline void set_has_ayw();
  inline void clear_has_ayw();
  inline void set_has_azx();
  inline void clear_has_azx();
  inline void set_has_azy();
  inline void clear_has_azy();
  inline void set_has_azz();
  inline void clear_has_azz();
  inline void set_has_azw();
  inline void clear_has_azw();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double axx_;
  double axy_;
  double axz_;
  double axw_;
  double ayx_;
  double ayy_;
  double ayz_;
  double ayw_;
  double azx_;
  double azy_;
  double azz_;
  double azw_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static DTransform3d* default_instance_;
};
// -------------------------------------------------------------------

class LoopType : public ::google::protobuf::Message {
 public:
  LoopType();
  virtual ~LoopType();

  LoopType(const LoopType& from);

  inline LoopType& operator=(const LoopType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoopType& default_instance();

  void Swap(LoopType* other);

  // implements Message ----------------------------------------------

  LoopType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoopType& from);
  void MergeFrom(const LoopType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LoopType_LoopTypeEnum LoopTypeEnum;
  static const LoopTypeEnum Parity = LoopType_LoopTypeEnum_Parity;
  static const LoopTypeEnum InteriorToLeft = LoopType_LoopTypeEnum_InteriorToLeft;
  static inline bool LoopTypeEnum_IsValid(int value) {
    return LoopType_LoopTypeEnum_IsValid(value);
  }
  static const LoopTypeEnum LoopTypeEnum_MIN =
    LoopType_LoopTypeEnum_LoopTypeEnum_MIN;
  static const LoopTypeEnum LoopTypeEnum_MAX =
    LoopType_LoopTypeEnum_LoopTypeEnum_MAX;
  static const int LoopTypeEnum_ARRAYSIZE =
    LoopType_LoopTypeEnum_LoopTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LoopTypeEnum_descriptor() {
    return LoopType_LoopTypeEnum_descriptor();
  }
  static inline const ::Bentley::Utf8String& LoopTypeEnum_Name(LoopTypeEnum value) {
    return LoopType_LoopTypeEnum_Name(value);
  }
  static inline bool LoopTypeEnum_Parse(const ::Bentley::Utf8String& name,
      LoopTypeEnum* value) {
    return LoopType_LoopTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.LoopType.LoopTypeEnum loopType = 1;
  inline bool has_loopType() const;
  inline void clear_loopType();
  static const int kLoopTypeFieldNumber = 1;
  inline ::Bentley::Geometry::Proto::LoopType_LoopTypeEnum loopType() const;
  inline void set_loopType(::Bentley::Geometry::Proto::LoopType_LoopTypeEnum value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.LoopType)
 private:
  inline void set_has_loopType();
  inline void clear_has_loopType();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int loopType_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static LoopType* default_instance_;
};
// -------------------------------------------------------------------

class ISinglePoint : public ::google::protobuf::Message {
 public:
  ISinglePoint();
  virtual ~ISinglePoint();

  ISinglePoint(const ISinglePoint& from);

  inline ISinglePoint& operator=(const ISinglePoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ISinglePoint& default_instance();

  void Swap(ISinglePoint* other);

  // implements Message ----------------------------------------------

  ISinglePoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ISinglePoint& from);
  void MergeFrom(const ISinglePoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.Coordinate coordinate = 1;
  inline bool has_coordinate() const;
  inline void clear_coordinate();
  static const int kCoordinateFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::Coordinate& coordinate() const;
  inline ::Bentley::Geometry::Proto::Coordinate* mutable_coordinate();
  inline ::Bentley::Geometry::Proto::Coordinate* release_coordinate();
  inline void set_allocated_coordinate(::Bentley::Geometry::Proto::Coordinate* coordinate);

  // optional .Bentley.Geometry.Proto.SharedGroupInstance sharedGruopInstance = 2;
  inline bool has_sharedGruopInstance() const;
  inline void clear_sharedGruopInstance();
  static const int kSharedGruopInstanceFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::SharedGroupInstance& sharedGruopInstance() const;
  inline ::Bentley::Geometry::Proto::SharedGroupInstance* mutable_sharedGruopInstance();
  inline ::Bentley::Geometry::Proto::SharedGroupInstance* release_sharedGruopInstance();
  inline void set_allocated_sharedGruopInstance(::Bentley::Geometry::Proto::SharedGroupInstance* sharedGruopInstance);

  // optional .Bentley.Geometry.Proto.SingleLineText singleLineText = 3;
  inline bool has_singleLineText() const;
  inline void clear_singleLineText();
  static const int kSingleLineTextFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::SingleLineText& singleLineText() const;
  inline ::Bentley::Geometry::Proto::SingleLineText* mutable_singleLineText();
  inline ::Bentley::Geometry::Proto::SingleLineText* release_singleLineText();
  inline void set_allocated_singleLineText(::Bentley::Geometry::Proto::SingleLineText* singleLineText);

  // optional .Bentley.Geometry.Proto.TransformedGeometry transformedGeometry = 4;
  inline bool has_transformedGeometry() const;
  inline void clear_transformedGeometry();
  static const int kTransformedGeometryFieldNumber = 4;
  inline const ::Bentley::Geometry::Proto::TransformedGeometry& transformedGeometry() const;
  inline ::Bentley::Geometry::Proto::TransformedGeometry* mutable_transformedGeometry();
  inline ::Bentley::Geometry::Proto::TransformedGeometry* release_transformedGeometry();
  inline void set_allocated_transformedGeometry(::Bentley::Geometry::Proto::TransformedGeometry* transformedGeometry);

  // optional .Bentley.Geometry.Proto.Vector vector = 5;
  inline bool has_vector() const;
  inline void clear_vector();
  static const int kVectorFieldNumber = 5;
  inline const ::Bentley::Geometry::Proto::Vector& vector() const;
  inline ::Bentley::Geometry::Proto::Vector* mutable_vector();
  inline ::Bentley::Geometry::Proto::Vector* release_vector();
  inline void set_allocated_vector(::Bentley::Geometry::Proto::Vector* vector);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.ISinglePoint)
 private:
  inline void set_has_coordinate();
  inline void clear_has_coordinate();
  inline void set_has_sharedGruopInstance();
  inline void clear_has_sharedGruopInstance();
  inline void set_has_singleLineText();
  inline void clear_has_singleLineText();
  inline void set_has_transformedGeometry();
  inline void clear_has_transformedGeometry();
  inline void set_has_vector();
  inline void clear_has_vector();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::Coordinate* coordinate_;
  ::Bentley::Geometry::Proto::SharedGroupInstance* sharedGruopInstance_;
  ::Bentley::Geometry::Proto::SingleLineText* singleLineText_;
  ::Bentley::Geometry::Proto::TransformedGeometry* transformedGeometry_;
  ::Bentley::Geometry::Proto::Vector* vector_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static ISinglePoint* default_instance_;
};
// -------------------------------------------------------------------

class IPoint : public ::google::protobuf::Message {
 public:
  IPoint();
  virtual ~IPoint();

  IPoint(const IPoint& from);

  inline IPoint& operator=(const IPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPoint& default_instance();

  void Swap(IPoint* other);

  // implements Message ----------------------------------------------

  IPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPoint& from);
  void MergeFrom(const IPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.ISinglePoint singlePoint = 1;
  inline bool has_singlePoint() const;
  inline void clear_singlePoint();
  static const int kSinglePointFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ISinglePoint& singlePoint() const;
  inline ::Bentley::Geometry::Proto::ISinglePoint* mutable_singlePoint();
  inline ::Bentley::Geometry::Proto::ISinglePoint* release_singlePoint();
  inline void set_allocated_singlePoint(::Bentley::Geometry::Proto::ISinglePoint* singlePoint);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.IPoint)
 private:
  inline void set_has_singlePoint();
  inline void clear_has_singlePoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::ISinglePoint* singlePoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static IPoint* default_instance_;
};
// -------------------------------------------------------------------

class IPrimitiveCurve : public ::google::protobuf::Message {
 public:
  IPrimitiveCurve();
  virtual ~IPrimitiveCurve();

  IPrimitiveCurve(const IPrimitiveCurve& from);

  inline IPrimitiveCurve& operator=(const IPrimitiveCurve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IPrimitiveCurve& default_instance();

  void Swap(IPrimitiveCurve* other);

  // implements Message ----------------------------------------------

  IPrimitiveCurve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IPrimitiveCurve& from);
  void MergeFrom(const IPrimitiveCurve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.LineSegment lineSegment = 1;
  inline bool has_lineSegment() const;
  inline void clear_lineSegment();
  static const int kLineSegmentFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::LineSegment& lineSegment() const;
  inline ::Bentley::Geometry::Proto::LineSegment* mutable_lineSegment();
  inline ::Bentley::Geometry::Proto::LineSegment* release_lineSegment();
  inline void set_allocated_lineSegment(::Bentley::Geometry::Proto::LineSegment* lineSegment);

  // optional .Bentley.Geometry.Proto.LineString lineString = 2;
  inline bool has_lineString() const;
  inline void clear_lineString();
  static const int kLineStringFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::LineString& lineString() const;
  inline ::Bentley::Geometry::Proto::LineString* mutable_lineString();
  inline ::Bentley::Geometry::Proto::LineString* release_lineString();
  inline void set_allocated_lineString(::Bentley::Geometry::Proto::LineString* lineString);

  // optional .Bentley.Geometry.Proto.CircularArc circularArc = 3;
  inline bool has_circularArc() const;
  inline void clear_circularArc();
  static const int kCircularArcFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::CircularArc& circularArc() const;
  inline ::Bentley::Geometry::Proto::CircularArc* mutable_circularArc();
  inline ::Bentley::Geometry::Proto::CircularArc* release_circularArc();
  inline void set_allocated_circularArc(::Bentley::Geometry::Proto::CircularArc* circularArc);

  // optional .Bentley.Geometry.Proto.EllipticArc ellipticArc = 4;
  inline bool has_ellipticArc() const;
  inline void clear_ellipticArc();
  static const int kEllipticArcFieldNumber = 4;
  inline const ::Bentley::Geometry::Proto::EllipticArc& ellipticArc() const;
  inline ::Bentley::Geometry::Proto::EllipticArc* mutable_ellipticArc();
  inline ::Bentley::Geometry::Proto::EllipticArc* release_ellipticArc();
  inline void set_allocated_ellipticArc(::Bentley::Geometry::Proto::EllipticArc* ellipticArc);

  // optional .Bentley.Geometry.Proto.BsplineCurve bsplineCurve = 5;
  inline bool has_bsplineCurve() const;
  inline void clear_bsplineCurve();
  static const int kBsplineCurveFieldNumber = 5;
  inline const ::Bentley::Geometry::Proto::BsplineCurve& bsplineCurve() const;
  inline ::Bentley::Geometry::Proto::BsplineCurve* mutable_bsplineCurve();
  inline ::Bentley::Geometry::Proto::BsplineCurve* release_bsplineCurve();
  inline void set_allocated_bsplineCurve(::Bentley::Geometry::Proto::BsplineCurve* bsplineCurve);

  // optional .Bentley.Geometry.Proto.TransitionSpiral transitionSpiral = 6;
  inline bool has_transitionSpiral() const;
  inline void clear_transitionSpiral();
  static const int kTransitionSpiralFieldNumber = 6;
  inline const ::Bentley::Geometry::Proto::TransitionSpiral& transitionSpiral() const;
  inline ::Bentley::Geometry::Proto::TransitionSpiral* mutable_transitionSpiral();
  inline ::Bentley::Geometry::Proto::TransitionSpiral* release_transitionSpiral();
  inline void set_allocated_transitionSpiral(::Bentley::Geometry::Proto::TransitionSpiral* transitionSpiral);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.IPrimitiveCurve)
 private:
  inline void set_has_lineSegment();
  inline void clear_has_lineSegment();
  inline void set_has_lineString();
  inline void clear_has_lineString();
  inline void set_has_circularArc();
  inline void clear_has_circularArc();
  inline void set_has_ellipticArc();
  inline void clear_has_ellipticArc();
  inline void set_has_bsplineCurve();
  inline void clear_has_bsplineCurve();
  inline void set_has_transitionSpiral();
  inline void clear_has_transitionSpiral();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::LineSegment* lineSegment_;
  ::Bentley::Geometry::Proto::LineString* lineString_;
  ::Bentley::Geometry::Proto::CircularArc* circularArc_;
  ::Bentley::Geometry::Proto::EllipticArc* ellipticArc_;
  ::Bentley::Geometry::Proto::BsplineCurve* bsplineCurve_;
  ::Bentley::Geometry::Proto::TransitionSpiral* transitionSpiral_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static IPrimitiveCurve* default_instance_;
};
// -------------------------------------------------------------------

class ICurve : public ::google::protobuf::Message {
 public:
  ICurve();
  virtual ~ICurve();

  ICurve(const ICurve& from);

  inline ICurve& operator=(const ICurve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ICurve& default_instance();

  void Swap(ICurve* other);

  // implements Message ----------------------------------------------

  ICurve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ICurve& from);
  void MergeFrom(const ICurve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.IPrimitiveCurve primtiveCurve = 1;
  inline bool has_primtiveCurve() const;
  inline void clear_primtiveCurve();
  static const int kPrimtiveCurveFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPrimitiveCurve& primtiveCurve() const;
  inline ::Bentley::Geometry::Proto::IPrimitiveCurve* mutable_primtiveCurve();
  inline ::Bentley::Geometry::Proto::IPrimitiveCurve* release_primtiveCurve();
  inline void set_allocated_primtiveCurve(::Bentley::Geometry::Proto::IPrimitiveCurve* primtiveCurve);

  // optional .Bentley.Geometry.Proto.CurveChain curveChain = 2;
  inline bool has_curveChain() const;
  inline void clear_curveChain();
  static const int kCurveChainFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::CurveChain& curveChain() const;
  inline ::Bentley::Geometry::Proto::CurveChain* mutable_curveChain();
  inline ::Bentley::Geometry::Proto::CurveChain* release_curveChain();
  inline void set_allocated_curveChain(::Bentley::Geometry::Proto::CurveChain* curveChain);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.ICurve)
 private:
  inline void set_has_primtiveCurve();
  inline void clear_has_primtiveCurve();
  inline void set_has_curveChain();
  inline void clear_has_curveChain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPrimitiveCurve* primtiveCurve_;
  ::Bentley::Geometry::Proto::CurveChain* curveChain_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static ICurve* default_instance_;
};
// -------------------------------------------------------------------

class ICurveChain : public ::google::protobuf::Message {
 public:
  ICurveChain();
  virtual ~ICurveChain();

  ICurveChain(const ICurveChain& from);

  inline ICurveChain& operator=(const ICurveChain& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ICurveChain& default_instance();

  void Swap(ICurveChain* other);

  // implements Message ----------------------------------------------

  ICurveChain* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ICurveChain& from);
  void MergeFrom(const ICurveChain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.CurveChain curveChain = 1;
  inline bool has_curveChain() const;
  inline void clear_curveChain();
  static const int kCurveChainFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::CurveChain& curveChain() const;
  inline ::Bentley::Geometry::Proto::CurveChain* mutable_curveChain();
  inline ::Bentley::Geometry::Proto::CurveChain* release_curveChain();
  inline void set_allocated_curveChain(::Bentley::Geometry::Proto::CurveChain* curveChain);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.ICurveChain)
 private:
  inline void set_has_curveChain();
  inline void clear_has_curveChain();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::CurveChain* curveChain_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static ICurveChain* default_instance_;
};
// -------------------------------------------------------------------

class ISolid : public ::google::protobuf::Message {
 public:
  ISolid();
  virtual ~ISolid();

  ISolid(const ISolid& from);

  inline ISolid& operator=(const ISolid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ISolid& default_instance();

  void Swap(ISolid* other);

  // implements Message ----------------------------------------------

  ISolid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ISolid& from);
  void MergeFrom(const ISolid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.IAnalyticSolid analyticSolid = 1;
  inline bool has_analyticSolid() const;
  inline void clear_analyticSolid();
  static const int kAnalyticSolidFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IAnalyticSolid& analyticSolid() const;
  inline ::Bentley::Geometry::Proto::IAnalyticSolid* mutable_analyticSolid();
  inline ::Bentley::Geometry::Proto::IAnalyticSolid* release_analyticSolid();
  inline void set_allocated_analyticSolid(::Bentley::Geometry::Proto::IAnalyticSolid* analyticSolid);

  // optional .Bentley.Geometry.Proto.SolidBySweptSurface solidBySweptSurface = 102;
  inline bool has_solidBySweptSurface() const;
  inline void clear_solidBySweptSurface();
  static const int kSolidBySweptSurfaceFieldNumber = 102;
  inline const ::Bentley::Geometry::Proto::SolidBySweptSurface& solidBySweptSurface() const;
  inline ::Bentley::Geometry::Proto::SolidBySweptSurface* mutable_solidBySweptSurface();
  inline ::Bentley::Geometry::Proto::SolidBySweptSurface* release_solidBySweptSurface();
  inline void set_allocated_solidBySweptSurface(::Bentley::Geometry::Proto::SolidBySweptSurface* solidBySweptSurface);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.ISolid)
 private:
  inline void set_has_analyticSolid();
  inline void clear_has_analyticSolid();
  inline void set_has_solidBySweptSurface();
  inline void clear_has_solidBySweptSurface();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IAnalyticSolid* analyticSolid_;
  ::Bentley::Geometry::Proto::SolidBySweptSurface* solidBySweptSurface_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static ISolid* default_instance_;
};
// -------------------------------------------------------------------

class IAnalyticSolid : public ::google::protobuf::Message {
 public:
  IAnalyticSolid();
  virtual ~IAnalyticSolid();

  IAnalyticSolid(const IAnalyticSolid& from);

  inline IAnalyticSolid& operator=(const IAnalyticSolid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IAnalyticSolid& default_instance();

  void Swap(IAnalyticSolid* other);

  // implements Message ----------------------------------------------

  IAnalyticSolid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IAnalyticSolid& from);
  void MergeFrom(const IAnalyticSolid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.Block block = 1;
  inline bool has_block() const;
  inline void clear_block();
  static const int kBlockFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::Block& block() const;
  inline ::Bentley::Geometry::Proto::Block* mutable_block();
  inline ::Bentley::Geometry::Proto::Block* release_block();
  inline void set_allocated_block(::Bentley::Geometry::Proto::Block* block);

  // optional .Bentley.Geometry.Proto.CircularCone circularCone = 2;
  inline bool has_circularCone() const;
  inline void clear_circularCone();
  static const int kCircularConeFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::CircularCone& circularCone() const;
  inline ::Bentley::Geometry::Proto::CircularCone* mutable_circularCone();
  inline ::Bentley::Geometry::Proto::CircularCone* release_circularCone();
  inline void set_allocated_circularCone(::Bentley::Geometry::Proto::CircularCone* circularCone);

  // optional .Bentley.Geometry.Proto.SkewedCone skewedCone = 3;
  inline bool has_skewedCone() const;
  inline void clear_skewedCone();
  static const int kSkewedConeFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::SkewedCone& skewedCone() const;
  inline ::Bentley::Geometry::Proto::SkewedCone* mutable_skewedCone();
  inline ::Bentley::Geometry::Proto::SkewedCone* release_skewedCone();
  inline void set_allocated_skewedCone(::Bentley::Geometry::Proto::SkewedCone* skewedCone);

  // optional .Bentley.Geometry.Proto.Sphere sphere = 4;
  inline bool has_sphere() const;
  inline void clear_sphere();
  static const int kSphereFieldNumber = 4;
  inline const ::Bentley::Geometry::Proto::Sphere& sphere() const;
  inline ::Bentley::Geometry::Proto::Sphere* mutable_sphere();
  inline ::Bentley::Geometry::Proto::Sphere* release_sphere();
  inline void set_allocated_sphere(::Bentley::Geometry::Proto::Sphere* sphere);

  // optional .Bentley.Geometry.Proto.TorusPipe torusPipe = 5;
  inline bool has_torusPipe() const;
  inline void clear_torusPipe();
  static const int kTorusPipeFieldNumber = 5;
  inline const ::Bentley::Geometry::Proto::TorusPipe& torusPipe() const;
  inline ::Bentley::Geometry::Proto::TorusPipe* mutable_torusPipe();
  inline ::Bentley::Geometry::Proto::TorusPipe* release_torusPipe();
  inline void set_allocated_torusPipe(::Bentley::Geometry::Proto::TorusPipe* torusPipe);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.IAnalyticSolid)
 private:
  inline void set_has_block();
  inline void clear_has_block();
  inline void set_has_circularCone();
  inline void clear_has_circularCone();
  inline void set_has_skewedCone();
  inline void clear_has_skewedCone();
  inline void set_has_sphere();
  inline void clear_has_sphere();
  inline void set_has_torusPipe();
  inline void clear_has_torusPipe();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::Block* block_;
  ::Bentley::Geometry::Proto::CircularCone* circularCone_;
  ::Bentley::Geometry::Proto::SkewedCone* skewedCone_;
  ::Bentley::Geometry::Proto::Sphere* sphere_;
  ::Bentley::Geometry::Proto::TorusPipe* torusPipe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static IAnalyticSolid* default_instance_;
};
// -------------------------------------------------------------------

class ISurface : public ::google::protobuf::Message {
 public:
  ISurface();
  virtual ~ISurface();

  ISurface(const ISurface& from);

  inline ISurface& operator=(const ISurface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ISurface& default_instance();

  void Swap(ISurface* other);

  // implements Message ----------------------------------------------

  ISurface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ISurface& from);
  void MergeFrom(const ISurface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.Polygon polygon = 1;
  inline bool has_polygon() const;
  inline void clear_polygon();
  static const int kPolygonFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::Polygon& polygon() const;
  inline ::Bentley::Geometry::Proto::Polygon* mutable_polygon();
  inline ::Bentley::Geometry::Proto::Polygon* release_polygon();
  inline void set_allocated_polygon(::Bentley::Geometry::Proto::Polygon* polygon);

  // optional .Bentley.Geometry.Proto.CircularDisk circularDisk = 2;
  inline bool has_circularDisk() const;
  inline void clear_circularDisk();
  static const int kCircularDiskFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::CircularDisk& circularDisk() const;
  inline ::Bentley::Geometry::Proto::CircularDisk* mutable_circularDisk();
  inline ::Bentley::Geometry::Proto::CircularDisk* release_circularDisk();
  inline void set_allocated_circularDisk(::Bentley::Geometry::Proto::CircularDisk* circularDisk);

  // optional .Bentley.Geometry.Proto.EllipticDisk ellipticDisk = 3;
  inline bool has_ellipticDisk() const;
  inline void clear_ellipticDisk();
  static const int kEllipticDiskFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::EllipticDisk& ellipticDisk() const;
  inline ::Bentley::Geometry::Proto::EllipticDisk* mutable_ellipticDisk();
  inline ::Bentley::Geometry::Proto::EllipticDisk* release_ellipticDisk();
  inline void set_allocated_ellipticDisk(::Bentley::Geometry::Proto::EllipticDisk* ellipticDisk);

  // optional .Bentley.Geometry.Proto.BsplineSurface bsplineSuface = 100;
  inline bool has_bsplineSuface() const;
  inline void clear_bsplineSuface();
  static const int kBsplineSufaceFieldNumber = 100;
  inline const ::Bentley::Geometry::Proto::BsplineSurface& bsplineSuface() const;
  inline ::Bentley::Geometry::Proto::BsplineSurface* mutable_bsplineSuface();
  inline ::Bentley::Geometry::Proto::BsplineSurface* release_bsplineSuface();
  inline void set_allocated_bsplineSuface(::Bentley::Geometry::Proto::BsplineSurface* bsplineSuface);

  // optional .Bentley.Geometry.Proto.IndexedMesh indexedMesh = 101;
  inline bool has_indexedMesh() const;
  inline void clear_indexedMesh();
  static const int kIndexedMeshFieldNumber = 101;
  inline const ::Bentley::Geometry::Proto::IndexedMesh& indexedMesh() const;
  inline ::Bentley::Geometry::Proto::IndexedMesh* mutable_indexedMesh();
  inline ::Bentley::Geometry::Proto::IndexedMesh* release_indexedMesh();
  inline void set_allocated_indexedMesh(::Bentley::Geometry::Proto::IndexedMesh* indexedMesh);

  // optional .Bentley.Geometry.Proto.ParametricSurfacePatch parametricSurfacePatch = 102;
  inline bool has_parametricSurfacePatch() const;
  inline void clear_parametricSurfacePatch();
  static const int kParametricSurfacePatchFieldNumber = 102;
  inline const ::Bentley::Geometry::Proto::ParametricSurfacePatch& parametricSurfacePatch() const;
  inline ::Bentley::Geometry::Proto::ParametricSurfacePatch* mutable_parametricSurfacePatch();
  inline ::Bentley::Geometry::Proto::ParametricSurfacePatch* release_parametricSurfacePatch();
  inline void set_allocated_parametricSurfacePatch(::Bentley::Geometry::Proto::ParametricSurfacePatch* parametricSurfacePatch);

  // optional .Bentley.Geometry.Proto.SurfaceBySweptCurve surfaceBySweptCurve = 103;
  inline bool has_surfaceBySweptCurve() const;
  inline void clear_surfaceBySweptCurve();
  static const int kSurfaceBySweptCurveFieldNumber = 103;
  inline const ::Bentley::Geometry::Proto::SurfaceBySweptCurve& surfaceBySweptCurve() const;
  inline ::Bentley::Geometry::Proto::SurfaceBySweptCurve* mutable_surfaceBySweptCurve();
  inline ::Bentley::Geometry::Proto::SurfaceBySweptCurve* release_surfaceBySweptCurve();
  inline void set_allocated_surfaceBySweptCurve(::Bentley::Geometry::Proto::SurfaceBySweptCurve* surfaceBySweptCurve);

  // optional .Bentley.Geometry.Proto.SurfaceGroup surfaceGroup = 104;
  inline bool has_surfaceGroup() const;
  inline void clear_surfaceGroup();
  static const int kSurfaceGroupFieldNumber = 104;
  inline const ::Bentley::Geometry::Proto::SurfaceGroup& surfaceGroup() const;
  inline ::Bentley::Geometry::Proto::SurfaceGroup* mutable_surfaceGroup();
  inline ::Bentley::Geometry::Proto::SurfaceGroup* release_surfaceGroup();
  inline void set_allocated_surfaceGroup(::Bentley::Geometry::Proto::SurfaceGroup* surfaceGroup);

  // optional .Bentley.Geometry.Proto.SurfacePatch surfacePatch = 105;
  inline bool has_surfacePatch() const;
  inline void clear_surfacePatch();
  static const int kSurfacePatchFieldNumber = 105;
  inline const ::Bentley::Geometry::Proto::SurfacePatch& surfacePatch() const;
  inline ::Bentley::Geometry::Proto::SurfacePatch* mutable_surfacePatch();
  inline ::Bentley::Geometry::Proto::SurfacePatch* release_surfacePatch();
  inline void set_allocated_surfacePatch(::Bentley::Geometry::Proto::SurfacePatch* surfacePatch);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.ISurface)
 private:
  inline void set_has_polygon();
  inline void clear_has_polygon();
  inline void set_has_circularDisk();
  inline void clear_has_circularDisk();
  inline void set_has_ellipticDisk();
  inline void clear_has_ellipticDisk();
  inline void set_has_bsplineSuface();
  inline void clear_has_bsplineSuface();
  inline void set_has_indexedMesh();
  inline void clear_has_indexedMesh();
  inline void set_has_parametricSurfacePatch();
  inline void clear_has_parametricSurfacePatch();
  inline void set_has_surfaceBySweptCurve();
  inline void clear_has_surfaceBySweptCurve();
  inline void set_has_surfaceGroup();
  inline void clear_has_surfaceGroup();
  inline void set_has_surfacePatch();
  inline void clear_has_surfacePatch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::Polygon* polygon_;
  ::Bentley::Geometry::Proto::CircularDisk* circularDisk_;
  ::Bentley::Geometry::Proto::EllipticDisk* ellipticDisk_;
  ::Bentley::Geometry::Proto::BsplineSurface* bsplineSuface_;
  ::Bentley::Geometry::Proto::IndexedMesh* indexedMesh_;
  ::Bentley::Geometry::Proto::ParametricSurfacePatch* parametricSurfacePatch_;
  ::Bentley::Geometry::Proto::SurfaceBySweptCurve* surfaceBySweptCurve_;
  ::Bentley::Geometry::Proto::SurfaceGroup* surfaceGroup_;
  ::Bentley::Geometry::Proto::SurfacePatch* surfacePatch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static ISurface* default_instance_;
};
// -------------------------------------------------------------------

class ISurfacePatch : public ::google::protobuf::Message {
 public:
  ISurfacePatch();
  virtual ~ISurfacePatch();

  ISurfacePatch(const ISurfacePatch& from);

  inline ISurfacePatch& operator=(const ISurfacePatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ISurfacePatch& default_instance();

  void Swap(ISurfacePatch* other);

  // implements Message ----------------------------------------------

  ISurfacePatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ISurfacePatch& from);
  void MergeFrom(const ISurfacePatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.ParametricSurfacePatch parametricSurfacePatch = 1;
  inline bool has_parametricSurfacePatch() const;
  inline void clear_parametricSurfacePatch();
  static const int kParametricSurfacePatchFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ParametricSurfacePatch& parametricSurfacePatch() const;
  inline ::Bentley::Geometry::Proto::ParametricSurfacePatch* mutable_parametricSurfacePatch();
  inline ::Bentley::Geometry::Proto::ParametricSurfacePatch* release_parametricSurfacePatch();
  inline void set_allocated_parametricSurfacePatch(::Bentley::Geometry::Proto::ParametricSurfacePatch* parametricSurfacePatch);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.ISurfacePatch)
 private:
  inline void set_has_parametricSurfacePatch();
  inline void clear_has_parametricSurfacePatch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::ParametricSurfacePatch* parametricSurfacePatch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static ISurfacePatch* default_instance_;
};
// -------------------------------------------------------------------

class IParametricSurface : public ::google::protobuf::Message {
 public:
  IParametricSurface();
  virtual ~IParametricSurface();

  IParametricSurface(const IParametricSurface& from);

  inline IParametricSurface& operator=(const IParametricSurface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IParametricSurface& default_instance();

  void Swap(IParametricSurface* other);

  // implements Message ----------------------------------------------

  IParametricSurface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IParametricSurface& from);
  void MergeFrom(const IParametricSurface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.BsplineSurface bsplineSuface = 1;
  inline bool has_bsplineSuface() const;
  inline void clear_bsplineSuface();
  static const int kBsplineSufaceFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::BsplineSurface& bsplineSuface() const;
  inline ::Bentley::Geometry::Proto::BsplineSurface* mutable_bsplineSuface();
  inline ::Bentley::Geometry::Proto::BsplineSurface* release_bsplineSuface();
  inline void set_allocated_bsplineSuface(::Bentley::Geometry::Proto::BsplineSurface* bsplineSuface);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.IParametricSurface)
 private:
  inline void set_has_bsplineSuface();
  inline void clear_has_bsplineSuface();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::BsplineSurface* bsplineSuface_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static IParametricSurface* default_instance_;
};
// -------------------------------------------------------------------

class IGeometry : public ::google::protobuf::Message {
 public:
  IGeometry();
  virtual ~IGeometry();

  IGeometry(const IGeometry& from);

  inline IGeometry& operator=(const IGeometry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IGeometry& default_instance();

  void Swap(IGeometry* other);

  // implements Message ----------------------------------------------

  IGeometry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IGeometry& from);
  void MergeFrom(const IGeometry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .Bentley.Geometry.Proto.IPoint point = 1;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPoint& point() const;
  inline ::Bentley::Geometry::Proto::IPoint* mutable_point();
  inline ::Bentley::Geometry::Proto::IPoint* release_point();
  inline void set_allocated_point(::Bentley::Geometry::Proto::IPoint* point);

  // optional .Bentley.Geometry.Proto.ICurve curve = 2;
  inline bool has_curve() const;
  inline void clear_curve();
  static const int kCurveFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::ICurve& curve() const;
  inline ::Bentley::Geometry::Proto::ICurve* mutable_curve();
  inline ::Bentley::Geometry::Proto::ICurve* release_curve();
  inline void set_allocated_curve(::Bentley::Geometry::Proto::ICurve* curve);

  // optional .Bentley.Geometry.Proto.ISurface surface = 3;
  inline bool has_surface() const;
  inline void clear_surface();
  static const int kSurfaceFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::ISurface& surface() const;
  inline ::Bentley::Geometry::Proto::ISurface* mutable_surface();
  inline ::Bentley::Geometry::Proto::ISurface* release_surface();
  inline void set_allocated_surface(::Bentley::Geometry::Proto::ISurface* surface);

  // optional .Bentley.Geometry.Proto.ISolid solid = 4;
  inline bool has_solid() const;
  inline void clear_solid();
  static const int kSolidFieldNumber = 4;
  inline const ::Bentley::Geometry::Proto::ISolid& solid() const;
  inline ::Bentley::Geometry::Proto::ISolid* mutable_solid();
  inline ::Bentley::Geometry::Proto::ISolid* release_solid();
  inline void set_allocated_solid(::Bentley::Geometry::Proto::ISolid* solid);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.IGeometry)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_curve();
  inline void clear_has_curve();
  inline void set_has_surface();
  inline void clear_has_surface();
  inline void set_has_solid();
  inline void clear_has_solid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPoint* point_;
  ::Bentley::Geometry::Proto::ICurve* curve_;
  ::Bentley::Geometry::Proto::ISurface* surface_;
  ::Bentley::Geometry::Proto::ISolid* solid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static IGeometry* default_instance_;
};
// -------------------------------------------------------------------

class Block : public ::google::protobuf::Message {
 public:
  Block();
  virtual ~Block();

  Block(const Block& from);

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Block& default_instance();

  void Swap(Block* other);

  // implements Message ----------------------------------------------

  Block* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Block& from);
  void MergeFrom(const Block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required .Bentley.Geometry.Proto.DPoint3d cornerA = 2;
  inline bool has_cornerA() const;
  inline void clear_cornerA();
  static const int kCornerAFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::DPoint3d& cornerA() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_cornerA();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_cornerA();
  inline void set_allocated_cornerA(::Bentley::Geometry::Proto::DPoint3d* cornerA);

  // required .Bentley.Geometry.Proto.DPoint3d cornerB = 3;
  inline bool has_cornerB() const;
  inline void clear_cornerB();
  static const int kCornerBFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::DPoint3d& cornerB() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_cornerB();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_cornerB();
  inline void set_allocated_cornerB(::Bentley::Geometry::Proto::DPoint3d* cornerB);

  // required bool bSolidFlag = 4;
  inline bool has_bSolidFlag() const;
  inline void clear_bSolidFlag();
  static const int kBSolidFlagFieldNumber = 4;
  inline bool bSolidFlag() const;
  inline void set_bSolidFlag(bool value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.Block)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_cornerA();
  inline void clear_has_cornerA();
  inline void set_has_cornerB();
  inline void clear_has_cornerB();
  inline void set_has_bSolidFlag();
  inline void clear_has_bSolidFlag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  ::Bentley::Geometry::Proto::DPoint3d* cornerA_;
  ::Bentley::Geometry::Proto::DPoint3d* cornerB_;
  bool bSolidFlag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static Block* default_instance_;
};
// -------------------------------------------------------------------

class BsplineCurve : public ::google::protobuf::Message {
 public:
  BsplineCurve();
  virtual ~BsplineCurve();

  BsplineCurve(const BsplineCurve& from);

  inline BsplineCurve& operator=(const BsplineCurve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BsplineCurve& default_instance();

  void Swap(BsplineCurve* other);

  // implements Message ----------------------------------------------

  BsplineCurve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BsplineCurve& from);
  void MergeFrom(const BsplineCurve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 Order = 1;
  inline bool has_Order() const;
  inline void clear_Order();
  static const int kOrderFieldNumber = 1;
  inline ::google::protobuf::int32 Order() const;
  inline void set_Order(::google::protobuf::int32 value);

  // required bool Closed = 2;
  inline bool has_Closed() const;
  inline void clear_Closed();
  static const int kClosedFieldNumber = 2;
  inline bool Closed() const;
  inline void set_Closed(bool value);

  // repeated .Bentley.Geometry.Proto.DPoint3d ControlPoint = 3;
  inline int ControlPoint_size() const;
  inline void clear_ControlPoint();
  static const int kControlPointFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::DPoint3d& ControlPoint(int index) const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_ControlPoint(int index);
  inline ::Bentley::Geometry::Proto::DPoint3d* add_ControlPoint();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
      ControlPoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
      mutable_ControlPoint();

  // repeated double Weight = 4;
  inline int Weight_size() const;
  inline void clear_Weight();
  static const int kWeightFieldNumber = 4;
  inline double Weight(int index) const;
  inline void set_Weight(int index, double value);
  inline void add_Weight(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      Weight() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_Weight();

  // repeated double Knot = 5;
  inline int Knot_size() const;
  inline void clear_Knot();
  static const int kKnotFieldNumber = 5;
  inline double Knot(int index) const;
  inline void set_Knot(int index, double value);
  inline void add_Knot(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      Knot() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_Knot();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.BsplineCurve)
 private:
  inline void set_has_Order();
  inline void clear_has_Order();
  inline void set_has_Closed();
  inline void clear_has_Closed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 Order_;
  bool Closed_;
  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d > ControlPoint_;
  ::google::protobuf::RepeatedField< double > Weight_;
  ::google::protobuf::RepeatedField< double > Knot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static BsplineCurve* default_instance_;
};
// -------------------------------------------------------------------

class BsplineSurface : public ::google::protobuf::Message {
 public:
  BsplineSurface();
  virtual ~BsplineSurface();

  BsplineSurface(const BsplineSurface& from);

  inline BsplineSurface& operator=(const BsplineSurface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BsplineSurface& default_instance();

  void Swap(BsplineSurface* other);

  // implements Message ----------------------------------------------

  BsplineSurface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BsplineSurface& from);
  void MergeFrom(const BsplineSurface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 OrderU = 1;
  inline bool has_OrderU() const;
  inline void clear_OrderU();
  static const int kOrderUFieldNumber = 1;
  inline ::google::protobuf::int32 OrderU() const;
  inline void set_OrderU(::google::protobuf::int32 value);

  // required bool ClosedU = 2;
  inline bool has_ClosedU() const;
  inline void clear_ClosedU();
  static const int kClosedUFieldNumber = 2;
  inline bool ClosedU() const;
  inline void set_ClosedU(bool value);

  // required int32 NumUControlPoint = 3;
  inline bool has_NumUControlPoint() const;
  inline void clear_NumUControlPoint();
  static const int kNumUControlPointFieldNumber = 3;
  inline ::google::protobuf::int32 NumUControlPoint() const;
  inline void set_NumUControlPoint(::google::protobuf::int32 value);

  // required int32 OrderV = 4;
  inline bool has_OrderV() const;
  inline void clear_OrderV();
  static const int kOrderVFieldNumber = 4;
  inline ::google::protobuf::int32 OrderV() const;
  inline void set_OrderV(::google::protobuf::int32 value);

  // required bool ClosedV = 5;
  inline bool has_ClosedV() const;
  inline void clear_ClosedV();
  static const int kClosedVFieldNumber = 5;
  inline bool ClosedV() const;
  inline void set_ClosedV(bool value);

  // required int32 NumVControlPoint = 6;
  inline bool has_NumVControlPoint() const;
  inline void clear_NumVControlPoint();
  static const int kNumVControlPointFieldNumber = 6;
  inline ::google::protobuf::int32 NumVControlPoint() const;
  inline void set_NumVControlPoint(::google::protobuf::int32 value);

  // repeated .Bentley.Geometry.Proto.DPoint3d ControlPoint = 7;
  inline int ControlPoint_size() const;
  inline void clear_ControlPoint();
  static const int kControlPointFieldNumber = 7;
  inline const ::Bentley::Geometry::Proto::DPoint3d& ControlPoint(int index) const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_ControlPoint(int index);
  inline ::Bentley::Geometry::Proto::DPoint3d* add_ControlPoint();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
      ControlPoint() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
      mutable_ControlPoint();

  // repeated double Weight = 8;
  inline int Weight_size() const;
  inline void clear_Weight();
  static const int kWeightFieldNumber = 8;
  inline double Weight(int index) const;
  inline void set_Weight(int index, double value);
  inline void add_Weight(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      Weight() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_Weight();

  // repeated double KnotU = 9;
  inline int KnotU_size() const;
  inline void clear_KnotU();
  static const int kKnotUFieldNumber = 9;
  inline double KnotU(int index) const;
  inline void set_KnotU(int index, double value);
  inline void add_KnotU(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      KnotU() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_KnotU();

  // repeated double KnotV = 10;
  inline int KnotV_size() const;
  inline void clear_KnotV();
  static const int kKnotVFieldNumber = 10;
  inline double KnotV(int index) const;
  inline void set_KnotV(int index, double value);
  inline void add_KnotV(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      KnotV() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_KnotV();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.BsplineSurface)
 private:
  inline void set_has_OrderU();
  inline void clear_has_OrderU();
  inline void set_has_ClosedU();
  inline void clear_has_ClosedU();
  inline void set_has_NumUControlPoint();
  inline void clear_has_NumUControlPoint();
  inline void set_has_OrderV();
  inline void clear_has_OrderV();
  inline void set_has_ClosedV();
  inline void clear_has_ClosedV();
  inline void set_has_NumVControlPoint();
  inline void clear_has_NumVControlPoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 OrderU_;
  ::google::protobuf::int32 NumUControlPoint_;
  bool ClosedU_;
  bool ClosedV_;
  ::google::protobuf::int32 OrderV_;
  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d > ControlPoint_;
  ::google::protobuf::RepeatedField< double > Weight_;
  ::google::protobuf::RepeatedField< double > KnotU_;
  ::google::protobuf::RepeatedField< double > KnotV_;
  ::google::protobuf::int32 NumVControlPoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static BsplineSurface* default_instance_;
};
// -------------------------------------------------------------------

class CircularArc : public ::google::protobuf::Message {
 public:
  CircularArc();
  virtual ~CircularArc();

  CircularArc(const CircularArc& from);

  inline CircularArc& operator=(const CircularArc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CircularArc& default_instance();

  void Swap(CircularArc* other);

  // implements Message ----------------------------------------------

  CircularArc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CircularArc& from);
  void MergeFrom(const CircularArc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required double radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline double radius() const;
  inline void set_radius(double value);

  // required .Bentley.Geometry.Proto.Angle startAngle = 3;
  inline bool has_startAngle() const;
  inline void clear_startAngle();
  static const int kStartAngleFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::Angle& startAngle() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_startAngle();
  inline ::Bentley::Geometry::Proto::Angle* release_startAngle();
  inline void set_allocated_startAngle(::Bentley::Geometry::Proto::Angle* startAngle);

  // required .Bentley.Geometry.Proto.Angle sweepAngle = 4;
  inline bool has_sweepAngle() const;
  inline void clear_sweepAngle();
  static const int kSweepAngleFieldNumber = 4;
  inline const ::Bentley::Geometry::Proto::Angle& sweepAngle() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_sweepAngle();
  inline ::Bentley::Geometry::Proto::Angle* release_sweepAngle();
  inline void set_allocated_sweepAngle(::Bentley::Geometry::Proto::Angle* sweepAngle);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.CircularArc)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_startAngle();
  inline void clear_has_startAngle();
  inline void set_has_sweepAngle();
  inline void clear_has_sweepAngle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  double radius_;
  ::Bentley::Geometry::Proto::Angle* startAngle_;
  ::Bentley::Geometry::Proto::Angle* sweepAngle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static CircularArc* default_instance_;
};
// -------------------------------------------------------------------

class CircularCone : public ::google::protobuf::Message {
 public:
  CircularCone();
  virtual ~CircularCone();

  CircularCone(const CircularCone& from);

  inline CircularCone& operator=(const CircularCone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CircularCone& default_instance();

  void Swap(CircularCone* other);

  // implements Message ----------------------------------------------

  CircularCone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CircularCone& from);
  void MergeFrom(const CircularCone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required double height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline double height() const;
  inline void set_height(double value);

  // required double radiusA = 3;
  inline bool has_radiusA() const;
  inline void clear_radiusA();
  static const int kRadiusAFieldNumber = 3;
  inline double radiusA() const;
  inline void set_radiusA(double value);

  // required double radiusB = 4;
  inline bool has_radiusB() const;
  inline void clear_radiusB();
  static const int kRadiusBFieldNumber = 4;
  inline double radiusB() const;
  inline void set_radiusB(double value);

  // required bool bSolidFlag = 5;
  inline bool has_bSolidFlag() const;
  inline void clear_bSolidFlag();
  static const int kBSolidFlagFieldNumber = 5;
  inline bool bSolidFlag() const;
  inline void set_bSolidFlag(bool value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.CircularCone)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_radiusA();
  inline void clear_has_radiusA();
  inline void set_has_radiusB();
  inline void clear_has_radiusB();
  inline void set_has_bSolidFlag();
  inline void clear_has_bSolidFlag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  double height_;
  double radiusA_;
  double radiusB_;
  bool bSolidFlag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static CircularCone* default_instance_;
};
// -------------------------------------------------------------------

class CircularCylinder : public ::google::protobuf::Message {
 public:
  CircularCylinder();
  virtual ~CircularCylinder();

  CircularCylinder(const CircularCylinder& from);

  inline CircularCylinder& operator=(const CircularCylinder& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CircularCylinder& default_instance();

  void Swap(CircularCylinder* other);

  // implements Message ----------------------------------------------

  CircularCylinder* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CircularCylinder& from);
  void MergeFrom(const CircularCylinder& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required double height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline double height() const;
  inline void set_height(double value);

  // required double radius = 3;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 3;
  inline double radius() const;
  inline void set_radius(double value);

  // required bool bSolidFlag = 4;
  inline bool has_bSolidFlag() const;
  inline void clear_bSolidFlag();
  static const int kBSolidFlagFieldNumber = 4;
  inline bool bSolidFlag() const;
  inline void set_bSolidFlag(bool value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.CircularCylinder)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_bSolidFlag();
  inline void clear_has_bSolidFlag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  double height_;
  double radius_;
  bool bSolidFlag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static CircularCylinder* default_instance_;
};
// -------------------------------------------------------------------

class CircularDisk : public ::google::protobuf::Message {
 public:
  CircularDisk();
  virtual ~CircularDisk();

  CircularDisk(const CircularDisk& from);

  inline CircularDisk& operator=(const CircularDisk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CircularDisk& default_instance();

  void Swap(CircularDisk* other);

  // implements Message ----------------------------------------------

  CircularDisk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CircularDisk& from);
  void MergeFrom(const CircularDisk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required double radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline double radius() const;
  inline void set_radius(double value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.CircularDisk)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  double radius_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static CircularDisk* default_instance_;
};
// -------------------------------------------------------------------

class Coordinate : public ::google::protobuf::Message {
 public:
  Coordinate();
  virtual ~Coordinate();

  Coordinate(const Coordinate& from);

  inline Coordinate& operator=(const Coordinate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coordinate& default_instance();

  void Swap(Coordinate* other);

  // implements Message ----------------------------------------------

  Coordinate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Coordinate& from);
  void MergeFrom(const Coordinate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.DPoint3d xyz = 1;
  inline bool has_xyz() const;
  inline void clear_xyz();
  static const int kXyzFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::DPoint3d& xyz() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_xyz();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_xyz();
  inline void set_allocated_xyz(::Bentley::Geometry::Proto::DPoint3d* xyz);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.Coordinate)
 private:
  inline void set_has_xyz();
  inline void clear_has_xyz();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::DPoint3d* xyz_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static Coordinate* default_instance_;
};
// -------------------------------------------------------------------

class CurveReference : public ::google::protobuf::Message {
 public:
  CurveReference();
  virtual ~CurveReference();

  CurveReference(const CurveReference& from);

  inline CurveReference& operator=(const CurveReference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurveReference& default_instance();

  void Swap(CurveReference* other);

  // implements Message ----------------------------------------------

  CurveReference* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurveReference& from);
  void MergeFrom(const CurveReference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.ICurve ParentCurve = 1;
  inline bool has_ParentCurve() const;
  inline void clear_ParentCurve();
  static const int kParentCurveFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ICurve& ParentCurve() const;
  inline ::Bentley::Geometry::Proto::ICurve* mutable_ParentCurve();
  inline ::Bentley::Geometry::Proto::ICurve* release_ParentCurve();
  inline void set_allocated_ParentCurve(::Bentley::Geometry::Proto::ICurve* ParentCurve);

  // required bool Reversed = 2;
  inline bool has_Reversed() const;
  inline void clear_Reversed();
  static const int kReversedFieldNumber = 2;
  inline bool Reversed() const;
  inline void set_Reversed(bool value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.CurveReference)
 private:
  inline void set_has_ParentCurve();
  inline void clear_has_ParentCurve();
  inline void set_has_Reversed();
  inline void clear_has_Reversed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::ICurve* ParentCurve_;
  bool Reversed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static CurveReference* default_instance_;
};
// -------------------------------------------------------------------

class EllipticArc : public ::google::protobuf::Message {
 public:
  EllipticArc();
  virtual ~EllipticArc();

  EllipticArc(const EllipticArc& from);

  inline EllipticArc& operator=(const EllipticArc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EllipticArc& default_instance();

  void Swap(EllipticArc* other);

  // implements Message ----------------------------------------------

  EllipticArc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EllipticArc& from);
  void MergeFrom(const EllipticArc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required double radiusA = 2;
  inline bool has_radiusA() const;
  inline void clear_radiusA();
  static const int kRadiusAFieldNumber = 2;
  inline double radiusA() const;
  inline void set_radiusA(double value);

  // required double radiusB = 3;
  inline bool has_radiusB() const;
  inline void clear_radiusB();
  static const int kRadiusBFieldNumber = 3;
  inline double radiusB() const;
  inline void set_radiusB(double value);

  // required .Bentley.Geometry.Proto.Angle startAngle = 4;
  inline bool has_startAngle() const;
  inline void clear_startAngle();
  static const int kStartAngleFieldNumber = 4;
  inline const ::Bentley::Geometry::Proto::Angle& startAngle() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_startAngle();
  inline ::Bentley::Geometry::Proto::Angle* release_startAngle();
  inline void set_allocated_startAngle(::Bentley::Geometry::Proto::Angle* startAngle);

  // required .Bentley.Geometry.Proto.Angle sweepAngle = 5;
  inline bool has_sweepAngle() const;
  inline void clear_sweepAngle();
  static const int kSweepAngleFieldNumber = 5;
  inline const ::Bentley::Geometry::Proto::Angle& sweepAngle() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_sweepAngle();
  inline ::Bentley::Geometry::Proto::Angle* release_sweepAngle();
  inline void set_allocated_sweepAngle(::Bentley::Geometry::Proto::Angle* sweepAngle);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.EllipticArc)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_radiusA();
  inline void clear_has_radiusA();
  inline void set_has_radiusB();
  inline void clear_has_radiusB();
  inline void set_has_startAngle();
  inline void clear_has_startAngle();
  inline void set_has_sweepAngle();
  inline void clear_has_sweepAngle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  double radiusA_;
  double radiusB_;
  ::Bentley::Geometry::Proto::Angle* startAngle_;
  ::Bentley::Geometry::Proto::Angle* sweepAngle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static EllipticArc* default_instance_;
};
// -------------------------------------------------------------------

class EllipticDisk : public ::google::protobuf::Message {
 public:
  EllipticDisk();
  virtual ~EllipticDisk();

  EllipticDisk(const EllipticDisk& from);

  inline EllipticDisk& operator=(const EllipticDisk& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EllipticDisk& default_instance();

  void Swap(EllipticDisk* other);

  // implements Message ----------------------------------------------

  EllipticDisk* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EllipticDisk& from);
  void MergeFrom(const EllipticDisk& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required double radiusA = 2;
  inline bool has_radiusA() const;
  inline void clear_radiusA();
  static const int kRadiusAFieldNumber = 2;
  inline double radiusA() const;
  inline void set_radiusA(double value);

  // required double radiusB = 3;
  inline bool has_radiusB() const;
  inline void clear_radiusB();
  static const int kRadiusBFieldNumber = 3;
  inline double radiusB() const;
  inline void set_radiusB(double value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.EllipticDisk)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_radiusA();
  inline void clear_has_radiusA();
  inline void set_has_radiusB();
  inline void clear_has_radiusB();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  double radiusA_;
  double radiusB_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static EllipticDisk* default_instance_;
};
// -------------------------------------------------------------------

class IndexedMesh : public ::google::protobuf::Message {
 public:
  IndexedMesh();
  virtual ~IndexedMesh();

  IndexedMesh(const IndexedMesh& from);

  inline IndexedMesh& operator=(const IndexedMesh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexedMesh& default_instance();

  void Swap(IndexedMesh* other);

  // implements Message ----------------------------------------------

  IndexedMesh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexedMesh& from);
  void MergeFrom(const IndexedMesh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.DPoint3d Coord = 1;
  inline int Coord_size() const;
  inline void clear_Coord();
  static const int kCoordFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::DPoint3d& Coord(int index) const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_Coord(int index);
  inline ::Bentley::Geometry::Proto::DPoint3d* add_Coord();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
      Coord() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
      mutable_Coord();

  // repeated int32 CoordIndex = 2;
  inline int CoordIndex_size() const;
  inline void clear_CoordIndex();
  static const int kCoordIndexFieldNumber = 2;
  inline ::google::protobuf::int32 CoordIndex(int index) const;
  inline void set_CoordIndex(int index, ::google::protobuf::int32 value);
  inline void add_CoordIndex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      CoordIndex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_CoordIndex();

  // repeated .Bentley.Geometry.Proto.DPoint2d Param = 3;
  inline int Param_size() const;
  inline void clear_Param();
  static const int kParamFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::DPoint2d& Param(int index) const;
  inline ::Bentley::Geometry::Proto::DPoint2d* mutable_Param(int index);
  inline ::Bentley::Geometry::Proto::DPoint2d* add_Param();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint2d >&
      Param() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint2d >*
      mutable_Param();

  // repeated int32 ParamIndex = 4;
  inline int ParamIndex_size() const;
  inline void clear_ParamIndex();
  static const int kParamIndexFieldNumber = 4;
  inline ::google::protobuf::int32 ParamIndex(int index) const;
  inline void set_ParamIndex(int index, ::google::protobuf::int32 value);
  inline void add_ParamIndex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ParamIndex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ParamIndex();

  // repeated .Bentley.Geometry.Proto.DVector3d Normal = 5;
  inline int Normal_size() const;
  inline void clear_Normal();
  static const int kNormalFieldNumber = 5;
  inline const ::Bentley::Geometry::Proto::DVector3d& Normal(int index) const;
  inline ::Bentley::Geometry::Proto::DVector3d* mutable_Normal(int index);
  inline ::Bentley::Geometry::Proto::DVector3d* add_Normal();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d >&
      Normal() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d >*
      mutable_Normal();

  // repeated int32 NormalIndex = 6;
  inline int NormalIndex_size() const;
  inline void clear_NormalIndex();
  static const int kNormalIndexFieldNumber = 6;
  inline ::google::protobuf::int32 NormalIndex(int index) const;
  inline void set_NormalIndex(int index, ::google::protobuf::int32 value);
  inline void add_NormalIndex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      NormalIndex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_NormalIndex();

  // repeated .Bentley.Geometry.Proto.DVector3d Color = 7;
  inline int Color_size() const;
  inline void clear_Color();
  static const int kColorFieldNumber = 7;
  inline const ::Bentley::Geometry::Proto::DVector3d& Color(int index) const;
  inline ::Bentley::Geometry::Proto::DVector3d* mutable_Color(int index);
  inline ::Bentley::Geometry::Proto::DVector3d* add_Color();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d >&
      Color() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d >*
      mutable_Color();

  // repeated int32 ColorIndex = 8;
  inline int ColorIndex_size() const;
  inline void clear_ColorIndex();
  static const int kColorIndexFieldNumber = 8;
  inline ::google::protobuf::int32 ColorIndex(int index) const;
  inline void set_ColorIndex(int index, ::google::protobuf::int32 value);
  inline void add_ColorIndex(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      ColorIndex() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_ColorIndex();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.IndexedMesh)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d > Coord_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > CoordIndex_;
  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint2d > Param_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ParamIndex_;
  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d > Normal_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > NormalIndex_;
  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d > Color_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > ColorIndex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static IndexedMesh* default_instance_;
};
// -------------------------------------------------------------------

class InterpolatingCurve : public ::google::protobuf::Message {
 public:
  InterpolatingCurve();
  virtual ~InterpolatingCurve();

  InterpolatingCurve(const InterpolatingCurve& from);

  inline InterpolatingCurve& operator=(const InterpolatingCurve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InterpolatingCurve& default_instance();

  void Swap(InterpolatingCurve* other);

  // implements Message ----------------------------------------------

  InterpolatingCurve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InterpolatingCurve& from);
  void MergeFrom(const InterpolatingCurve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 EndConditionCode = 1;
  inline bool has_EndConditionCode() const;
  inline void clear_EndConditionCode();
  static const int kEndConditionCodeFieldNumber = 1;
  inline ::google::protobuf::int32 EndConditionCode() const;
  inline void set_EndConditionCode(::google::protobuf::int32 value);

  // required int32 KnotCode = 2;
  inline bool has_KnotCode() const;
  inline void clear_KnotCode();
  static const int kKnotCodeFieldNumber = 2;
  inline ::google::protobuf::int32 KnotCode() const;
  inline void set_KnotCode(::google::protobuf::int32 value);

  // required .Bentley.Geometry.Proto.DVector3d StartVector = 3;
  inline bool has_StartVector() const;
  inline void clear_StartVector();
  static const int kStartVectorFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::DVector3d& StartVector() const;
  inline ::Bentley::Geometry::Proto::DVector3d* mutable_StartVector();
  inline ::Bentley::Geometry::Proto::DVector3d* release_StartVector();
  inline void set_allocated_StartVector(::Bentley::Geometry::Proto::DVector3d* StartVector);

  // required .Bentley.Geometry.Proto.DVector3d EndVector = 4;
  inline bool has_EndVector() const;
  inline void clear_EndVector();
  static const int kEndVectorFieldNumber = 4;
  inline const ::Bentley::Geometry::Proto::DVector3d& EndVector() const;
  inline ::Bentley::Geometry::Proto::DVector3d* mutable_EndVector();
  inline ::Bentley::Geometry::Proto::DVector3d* release_EndVector();
  inline void set_allocated_EndVector(::Bentley::Geometry::Proto::DVector3d* EndVector);

  // repeated .Bentley.Geometry.Proto.DPoint3d Point = 5;
  inline int Point_size() const;
  inline void clear_Point();
  static const int kPointFieldNumber = 5;
  inline const ::Bentley::Geometry::Proto::DPoint3d& Point(int index) const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_Point(int index);
  inline ::Bentley::Geometry::Proto::DPoint3d* add_Point();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
      Point() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
      mutable_Point();

  // repeated double Knot = 6;
  inline int Knot_size() const;
  inline void clear_Knot();
  static const int kKnotFieldNumber = 6;
  inline double Knot(int index) const;
  inline void set_Knot(int index, double value);
  inline void add_Knot(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      Knot() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_Knot();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.InterpolatingCurve)
 private:
  inline void set_has_EndConditionCode();
  inline void clear_has_EndConditionCode();
  inline void set_has_KnotCode();
  inline void clear_has_KnotCode();
  inline void set_has_StartVector();
  inline void clear_has_StartVector();
  inline void set_has_EndVector();
  inline void clear_has_EndVector();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 EndConditionCode_;
  ::google::protobuf::int32 KnotCode_;
  ::Bentley::Geometry::Proto::DVector3d* StartVector_;
  ::Bentley::Geometry::Proto::DVector3d* EndVector_;
  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d > Point_;
  ::google::protobuf::RepeatedField< double > Knot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static InterpolatingCurve* default_instance_;
};
// -------------------------------------------------------------------

class LineSegment : public ::google::protobuf::Message {
 public:
  LineSegment();
  virtual ~LineSegment();

  LineSegment(const LineSegment& from);

  inline LineSegment& operator=(const LineSegment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineSegment& default_instance();

  void Swap(LineSegment* other);

  // implements Message ----------------------------------------------

  LineSegment* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineSegment& from);
  void MergeFrom(const LineSegment& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.DPoint3d startPoint = 1;
  inline bool has_startPoint() const;
  inline void clear_startPoint();
  static const int kStartPointFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::DPoint3d& startPoint() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_startPoint();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_startPoint();
  inline void set_allocated_startPoint(::Bentley::Geometry::Proto::DPoint3d* startPoint);

  // required .Bentley.Geometry.Proto.DPoint3d endPoint = 2;
  inline bool has_endPoint() const;
  inline void clear_endPoint();
  static const int kEndPointFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::DPoint3d& endPoint() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_endPoint();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_endPoint();
  inline void set_allocated_endPoint(::Bentley::Geometry::Proto::DPoint3d* endPoint);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.LineSegment)
 private:
  inline void set_has_startPoint();
  inline void clear_has_startPoint();
  inline void set_has_endPoint();
  inline void clear_has_endPoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::DPoint3d* startPoint_;
  ::Bentley::Geometry::Proto::DPoint3d* endPoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static LineSegment* default_instance_;
};
// -------------------------------------------------------------------

class LineString : public ::google::protobuf::Message {
 public:
  LineString();
  virtual ~LineString();

  LineString(const LineString& from);

  inline LineString& operator=(const LineString& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineString& default_instance();

  void Swap(LineString* other);

  // implements Message ----------------------------------------------

  LineString* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LineString& from);
  void MergeFrom(const LineString& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.DPoint3d Point = 1;
  inline int Point_size() const;
  inline void clear_Point();
  static const int kPointFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::DPoint3d& Point(int index) const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_Point(int index);
  inline ::Bentley::Geometry::Proto::DPoint3d* add_Point();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
      Point() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
      mutable_Point();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.LineString)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d > Point_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static LineString* default_instance_;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  void Swap(Polygon* other);

  // implements Message ----------------------------------------------

  Polygon* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.DPoint3d Point = 1;
  inline int Point_size() const;
  inline void clear_Point();
  static const int kPointFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::DPoint3d& Point(int index) const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_Point(int index);
  inline ::Bentley::Geometry::Proto::DPoint3d* add_Point();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
      Point() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
      mutable_Point();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.Polygon)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d > Point_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static Polygon* default_instance_;
};
// -------------------------------------------------------------------

class PrimitiveCurveReference : public ::google::protobuf::Message {
 public:
  PrimitiveCurveReference();
  virtual ~PrimitiveCurveReference();

  PrimitiveCurveReference(const PrimitiveCurveReference& from);

  inline PrimitiveCurveReference& operator=(const PrimitiveCurveReference& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrimitiveCurveReference& default_instance();

  void Swap(PrimitiveCurveReference* other);

  // implements Message ----------------------------------------------

  PrimitiveCurveReference* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrimitiveCurveReference& from);
  void MergeFrom(const PrimitiveCurveReference& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPrimitiveCurve ParentCurve = 1;
  inline bool has_ParentCurve() const;
  inline void clear_ParentCurve();
  static const int kParentCurveFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPrimitiveCurve& ParentCurve() const;
  inline ::Bentley::Geometry::Proto::IPrimitiveCurve* mutable_ParentCurve();
  inline ::Bentley::Geometry::Proto::IPrimitiveCurve* release_ParentCurve();
  inline void set_allocated_ParentCurve(::Bentley::Geometry::Proto::IPrimitiveCurve* ParentCurve);

  // required bool Reversed = 2;
  inline bool has_Reversed() const;
  inline void clear_Reversed();
  static const int kReversedFieldNumber = 2;
  inline bool Reversed() const;
  inline void set_Reversed(bool value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.PrimitiveCurveReference)
 private:
  inline void set_has_ParentCurve();
  inline void clear_has_ParentCurve();
  inline void set_has_Reversed();
  inline void clear_has_Reversed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPrimitiveCurve* ParentCurve_;
  bool Reversed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static PrimitiveCurveReference* default_instance_;
};
// -------------------------------------------------------------------

class SharedGroupInstance : public ::google::protobuf::Message {
 public:
  SharedGroupInstance();
  virtual ~SharedGroupInstance();

  SharedGroupInstance(const SharedGroupInstance& from);

  inline SharedGroupInstance& operator=(const SharedGroupInstance& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SharedGroupInstance& default_instance();

  void Swap(SharedGroupInstance* other);

  // implements Message ----------------------------------------------

  SharedGroupInstance* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SharedGroupInstance& from);
  void MergeFrom(const SharedGroupInstance& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string SharedGroupName = 1;
  inline bool has_SharedGroupName() const;
  inline void clear_SharedGroupName();
  static const int kSharedGroupNameFieldNumber = 1;
  inline const ::Bentley::Utf8String& SharedGroupName() const;
  inline void set_SharedGroupName(const ::Bentley::Utf8String& value);
  inline void set_SharedGroupName(const char* value);
  inline void set_SharedGroupName(const char* value, size_t size);
  inline ::Bentley::Utf8String* mutable_SharedGroupName();
  inline ::Bentley::Utf8String* release_SharedGroupName();
  inline void set_allocated_SharedGroupName(::Bentley::Utf8String* SharedGroupName);

  // required .Bentley.Geometry.Proto.DTransform3d Transform = 2;
  inline bool has_Transform() const;
  inline void clear_Transform();
  static const int kTransformFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::DTransform3d& Transform() const;
  inline ::Bentley::Geometry::Proto::DTransform3d* mutable_Transform();
  inline ::Bentley::Geometry::Proto::DTransform3d* release_Transform();
  inline void set_allocated_Transform(::Bentley::Geometry::Proto::DTransform3d* Transform);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.SharedGroupInstance)
 private:
  inline void set_has_SharedGroupName();
  inline void clear_has_SharedGroupName();
  inline void set_has_Transform();
  inline void clear_has_Transform();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Utf8String* SharedGroupName_;
  ::Bentley::Geometry::Proto::DTransform3d* Transform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static SharedGroupInstance* default_instance_;
};
// -------------------------------------------------------------------

class ShelledSolid : public ::google::protobuf::Message {
 public:
  ShelledSolid();
  virtual ~ShelledSolid();

  ShelledSolid(const ShelledSolid& from);

  inline ShelledSolid& operator=(const ShelledSolid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShelledSolid& default_instance();

  void Swap(ShelledSolid* other);

  // implements Message ----------------------------------------------

  ShelledSolid* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShelledSolid& from);
  void MergeFrom(const ShelledSolid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.ISurface BoundingSurface = 1;
  inline bool has_BoundingSurface() const;
  inline void clear_BoundingSurface();
  static const int kBoundingSurfaceFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ISurface& BoundingSurface() const;
  inline ::Bentley::Geometry::Proto::ISurface* mutable_BoundingSurface();
  inline ::Bentley::Geometry::Proto::ISurface* release_BoundingSurface();
  inline void set_allocated_BoundingSurface(::Bentley::Geometry::Proto::ISurface* BoundingSurface);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.ShelledSolid)
 private:
  inline void set_has_BoundingSurface();
  inline void clear_has_BoundingSurface();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::ISurface* BoundingSurface_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static ShelledSolid* default_instance_;
};
// -------------------------------------------------------------------

class SingleLineText : public ::google::protobuf::Message {
 public:
  SingleLineText();
  virtual ~SingleLineText();

  SingleLineText(const SingleLineText& from);

  inline SingleLineText& operator=(const SingleLineText& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleLineText& default_instance();

  void Swap(SingleLineText* other);

  // implements Message ----------------------------------------------

  SingleLineText* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleLineText& from);
  void MergeFrom(const SingleLineText& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required string textString = 2;
  inline bool has_textString() const;
  inline void clear_textString();
  static const int kTextStringFieldNumber = 2;
  inline const ::Bentley::Utf8String& textString() const;
  inline void set_textString(const ::Bentley::Utf8String& value);
  inline void set_textString(const char* value);
  inline void set_textString(const char* value, size_t size);
  inline ::Bentley::Utf8String* mutable_textString();
  inline ::Bentley::Utf8String* release_textString();
  inline void set_allocated_textString(::Bentley::Utf8String* textString);

  // required string fontName = 3;
  inline bool has_fontName() const;
  inline void clear_fontName();
  static const int kFontNameFieldNumber = 3;
  inline const ::Bentley::Utf8String& fontName() const;
  inline void set_fontName(const ::Bentley::Utf8String& value);
  inline void set_fontName(const char* value);
  inline void set_fontName(const char* value, size_t size);
  inline ::Bentley::Utf8String* mutable_fontName();
  inline ::Bentley::Utf8String* release_fontName();
  inline void set_allocated_fontName(::Bentley::Utf8String* fontName);

  // required double characterXSize = 4;
  inline bool has_characterXSize() const;
  inline void clear_characterXSize();
  static const int kCharacterXSizeFieldNumber = 4;
  inline double characterXSize() const;
  inline void set_characterXSize(double value);

  // required double characterYSize = 5;
  inline bool has_characterYSize() const;
  inline void clear_characterYSize();
  static const int kCharacterYSizeFieldNumber = 5;
  inline double characterYSize() const;
  inline void set_characterYSize(double value);

  // required int32 justification = 6;
  inline bool has_justification() const;
  inline void clear_justification();
  static const int kJustificationFieldNumber = 6;
  inline ::google::protobuf::int32 justification() const;
  inline void set_justification(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.SingleLineText)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_textString();
  inline void clear_has_textString();
  inline void set_has_fontName();
  inline void clear_has_fontName();
  inline void set_has_characterXSize();
  inline void clear_has_characterXSize();
  inline void set_has_characterYSize();
  inline void clear_has_characterYSize();
  inline void set_has_justification();
  inline void clear_has_justification();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  ::Bentley::Utf8String* textString_;
  ::Bentley::Utf8String* fontName_;
  double characterXSize_;
  double characterYSize_;
  ::google::protobuf::int32 justification_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static SingleLineText* default_instance_;
};
// -------------------------------------------------------------------

class SkewedCone : public ::google::protobuf::Message {
 public:
  SkewedCone();
  virtual ~SkewedCone();

  SkewedCone(const SkewedCone& from);

  inline SkewedCone& operator=(const SkewedCone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SkewedCone& default_instance();

  void Swap(SkewedCone* other);

  // implements Message ----------------------------------------------

  SkewedCone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SkewedCone& from);
  void MergeFrom(const SkewedCone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required .Bentley.Geometry.Proto.DPoint3d centerB = 2;
  inline bool has_centerB() const;
  inline void clear_centerB();
  static const int kCenterBFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::DPoint3d& centerB() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_centerB();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_centerB();
  inline void set_allocated_centerB(::Bentley::Geometry::Proto::DPoint3d* centerB);

  // required double radiusA = 3;
  inline bool has_radiusA() const;
  inline void clear_radiusA();
  static const int kRadiusAFieldNumber = 3;
  inline double radiusA() const;
  inline void set_radiusA(double value);

  // required double radiusB = 4;
  inline bool has_radiusB() const;
  inline void clear_radiusB();
  static const int kRadiusBFieldNumber = 4;
  inline double radiusB() const;
  inline void set_radiusB(double value);

  // required bool bSolidFlag = 5;
  inline bool has_bSolidFlag() const;
  inline void clear_bSolidFlag();
  static const int kBSolidFlagFieldNumber = 5;
  inline bool bSolidFlag() const;
  inline void set_bSolidFlag(bool value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.SkewedCone)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_centerB();
  inline void clear_has_centerB();
  inline void set_has_radiusA();
  inline void clear_has_radiusA();
  inline void set_has_radiusB();
  inline void clear_has_radiusB();
  inline void set_has_bSolidFlag();
  inline void clear_has_bSolidFlag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  ::Bentley::Geometry::Proto::DPoint3d* centerB_;
  double radiusA_;
  double radiusB_;
  bool bSolidFlag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static SkewedCone* default_instance_;
};
// -------------------------------------------------------------------

class SolidBySweptSurface : public ::google::protobuf::Message {
 public:
  SolidBySweptSurface();
  virtual ~SolidBySweptSurface();

  SolidBySweptSurface(const SolidBySweptSurface& from);

  inline SolidBySweptSurface& operator=(const SolidBySweptSurface& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolidBySweptSurface& default_instance();

  void Swap(SolidBySweptSurface* other);

  // implements Message ----------------------------------------------

  SolidBySweptSurface* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolidBySweptSurface& from);
  void MergeFrom(const SolidBySweptSurface& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.ISurface BaseGeometry = 1;
  inline bool has_BaseGeometry() const;
  inline void clear_BaseGeometry();
  static const int kBaseGeometryFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ISurface& BaseGeometry() const;
  inline ::Bentley::Geometry::Proto::ISurface* mutable_BaseGeometry();
  inline ::Bentley::Geometry::Proto::ISurface* release_BaseGeometry();
  inline void set_allocated_BaseGeometry(::Bentley::Geometry::Proto::ISurface* BaseGeometry);

  // required .Bentley.Geometry.Proto.ICurve RailCurve = 2;
  inline bool has_RailCurve() const;
  inline void clear_RailCurve();
  static const int kRailCurveFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::ICurve& RailCurve() const;
  inline ::Bentley::Geometry::Proto::ICurve* mutable_RailCurve();
  inline ::Bentley::Geometry::Proto::ICurve* release_RailCurve();
  inline void set_allocated_RailCurve(::Bentley::Geometry::Proto::ICurve* RailCurve);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.SolidBySweptSurface)
 private:
  inline void set_has_BaseGeometry();
  inline void clear_has_BaseGeometry();
  inline void set_has_RailCurve();
  inline void clear_has_RailCurve();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::ISurface* BaseGeometry_;
  ::Bentley::Geometry::Proto::ICurve* RailCurve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static SolidBySweptSurface* default_instance_;
};
// -------------------------------------------------------------------

class Sphere : public ::google::protobuf::Message {
 public:
  Sphere();
  virtual ~Sphere();

  Sphere(const Sphere& from);

  inline Sphere& operator=(const Sphere& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sphere& default_instance();

  void Swap(Sphere* other);

  // implements Message ----------------------------------------------

  Sphere* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Sphere& from);
  void MergeFrom(const Sphere& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required double radius = 2;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 2;
  inline double radius() const;
  inline void set_radius(double value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.Sphere)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  double radius_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static Sphere* default_instance_;
};
// -------------------------------------------------------------------

class Spiral : public ::google::protobuf::Message {
 public:
  Spiral();
  virtual ~Spiral();

  Spiral(const Spiral& from);

  inline Spiral& operator=(const Spiral& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Spiral& default_instance();

  void Swap(Spiral* other);

  // implements Message ----------------------------------------------

  Spiral* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Spiral& from);
  void MergeFrom(const Spiral& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string SpiralType = 1;
  inline bool has_SpiralType() const;
  inline void clear_SpiralType();
  static const int kSpiralTypeFieldNumber = 1;
  inline const ::Bentley::Utf8String& SpiralType() const;
  inline void set_SpiralType(const ::Bentley::Utf8String& value);
  inline void set_SpiralType(const char* value);
  inline void set_SpiralType(const char* value, size_t size);
  inline ::Bentley::Utf8String* mutable_SpiralType();
  inline ::Bentley::Utf8String* release_SpiralType();
  inline void set_allocated_SpiralType(::Bentley::Utf8String* SpiralType);

  // required .Bentley.Geometry.Proto.DPoint3d StartPoint = 2;
  inline bool has_StartPoint() const;
  inline void clear_StartPoint();
  static const int kStartPointFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::DPoint3d& StartPoint() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_StartPoint();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_StartPoint();
  inline void set_allocated_StartPoint(::Bentley::Geometry::Proto::DPoint3d* StartPoint);

  // required .Bentley.Geometry.Proto.Angle StartBearing = 3;
  inline bool has_StartBearing() const;
  inline void clear_StartBearing();
  static const int kStartBearingFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::Angle& StartBearing() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_StartBearing();
  inline ::Bentley::Geometry::Proto::Angle* release_StartBearing();
  inline void set_allocated_StartBearing(::Bentley::Geometry::Proto::Angle* StartBearing);

  // required double StartCurvature = 4;
  inline bool has_StartCurvature() const;
  inline void clear_StartCurvature();
  static const int kStartCurvatureFieldNumber = 4;
  inline double StartCurvature() const;
  inline void set_StartCurvature(double value);

  // required .Bentley.Geometry.Proto.DPoint3d EndPoint = 5;
  inline bool has_EndPoint() const;
  inline void clear_EndPoint();
  static const int kEndPointFieldNumber = 5;
  inline const ::Bentley::Geometry::Proto::DPoint3d& EndPoint() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_EndPoint();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_EndPoint();
  inline void set_allocated_EndPoint(::Bentley::Geometry::Proto::DPoint3d* EndPoint);

  // required .Bentley.Geometry.Proto.Angle EndBearing = 6;
  inline bool has_EndBearing() const;
  inline void clear_EndBearing();
  static const int kEndBearingFieldNumber = 6;
  inline const ::Bentley::Geometry::Proto::Angle& EndBearing() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_EndBearing();
  inline ::Bentley::Geometry::Proto::Angle* release_EndBearing();
  inline void set_allocated_EndBearing(::Bentley::Geometry::Proto::Angle* EndBearing);

  // required double EndCurvature = 7;
  inline bool has_EndCurvature() const;
  inline void clear_EndCurvature();
  static const int kEndCurvatureFieldNumber = 7;
  inline double EndCurvature() const;
  inline void set_EndCurvature(double value);

  // required .Bentley.Geometry.Proto.IGeometry Geometry = 8;
  inline bool has_Geometry() const;
  inline void clear_Geometry();
  static const int kGeometryFieldNumber = 8;
  inline const ::Bentley::Geometry::Proto::IGeometry& Geometry() const;
  inline ::Bentley::Geometry::Proto::IGeometry* mutable_Geometry();
  inline ::Bentley::Geometry::Proto::IGeometry* release_Geometry();
  inline void set_allocated_Geometry(::Bentley::Geometry::Proto::IGeometry* Geometry);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.Spiral)
 private:
  inline void set_has_SpiralType();
  inline void clear_has_SpiralType();
  inline void set_has_StartPoint();
  inline void clear_has_StartPoint();
  inline void set_has_StartBearing();
  inline void clear_has_StartBearing();
  inline void set_has_StartCurvature();
  inline void clear_has_StartCurvature();
  inline void set_has_EndPoint();
  inline void clear_has_EndPoint();
  inline void set_has_EndBearing();
  inline void clear_has_EndBearing();
  inline void set_has_EndCurvature();
  inline void clear_has_EndCurvature();
  inline void set_has_Geometry();
  inline void clear_has_Geometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Utf8String* SpiralType_;
  ::Bentley::Geometry::Proto::DPoint3d* StartPoint_;
  ::Bentley::Geometry::Proto::Angle* StartBearing_;
  double StartCurvature_;
  ::Bentley::Geometry::Proto::DPoint3d* EndPoint_;
  ::Bentley::Geometry::Proto::Angle* EndBearing_;
  double EndCurvature_;
  ::Bentley::Geometry::Proto::IGeometry* Geometry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static Spiral* default_instance_;
};
// -------------------------------------------------------------------

class SurfaceBySweptCurve : public ::google::protobuf::Message {
 public:
  SurfaceBySweptCurve();
  virtual ~SurfaceBySweptCurve();

  SurfaceBySweptCurve(const SurfaceBySweptCurve& from);

  inline SurfaceBySweptCurve& operator=(const SurfaceBySweptCurve& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceBySweptCurve& default_instance();

  void Swap(SurfaceBySweptCurve* other);

  // implements Message ----------------------------------------------

  SurfaceBySweptCurve* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SurfaceBySweptCurve& from);
  void MergeFrom(const SurfaceBySweptCurve& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.ICurve BaseGeometry = 1;
  inline bool has_BaseGeometry() const;
  inline void clear_BaseGeometry();
  static const int kBaseGeometryFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ICurve& BaseGeometry() const;
  inline ::Bentley::Geometry::Proto::ICurve* mutable_BaseGeometry();
  inline ::Bentley::Geometry::Proto::ICurve* release_BaseGeometry();
  inline void set_allocated_BaseGeometry(::Bentley::Geometry::Proto::ICurve* BaseGeometry);

  // required .Bentley.Geometry.Proto.ICurve RailCurve = 2;
  inline bool has_RailCurve() const;
  inline void clear_RailCurve();
  static const int kRailCurveFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::ICurve& RailCurve() const;
  inline ::Bentley::Geometry::Proto::ICurve* mutable_RailCurve();
  inline ::Bentley::Geometry::Proto::ICurve* release_RailCurve();
  inline void set_allocated_RailCurve(::Bentley::Geometry::Proto::ICurve* RailCurve);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.SurfaceBySweptCurve)
 private:
  inline void set_has_BaseGeometry();
  inline void clear_has_BaseGeometry();
  inline void set_has_RailCurve();
  inline void clear_has_RailCurve();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::ICurve* BaseGeometry_;
  ::Bentley::Geometry::Proto::ICurve* RailCurve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static SurfaceBySweptCurve* default_instance_;
};
// -------------------------------------------------------------------

class TorusPipe : public ::google::protobuf::Message {
 public:
  TorusPipe();
  virtual ~TorusPipe();

  TorusPipe(const TorusPipe& from);

  inline TorusPipe& operator=(const TorusPipe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TorusPipe& default_instance();

  void Swap(TorusPipe* other);

  // implements Message ----------------------------------------------

  TorusPipe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TorusPipe& from);
  void MergeFrom(const TorusPipe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IPlacement placement = 1;
  inline bool has_placement() const;
  inline void clear_placement();
  static const int kPlacementFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPlacement& placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_placement();
  inline void set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement);

  // required double radiusA = 2;
  inline bool has_radiusA() const;
  inline void clear_radiusA();
  static const int kRadiusAFieldNumber = 2;
  inline double radiusA() const;
  inline void set_radiusA(double value);

  // required double radiusB = 3;
  inline bool has_radiusB() const;
  inline void clear_radiusB();
  static const int kRadiusBFieldNumber = 3;
  inline double radiusB() const;
  inline void set_radiusB(double value);

  // required .Bentley.Geometry.Proto.Angle startAngle = 4;
  inline bool has_startAngle() const;
  inline void clear_startAngle();
  static const int kStartAngleFieldNumber = 4;
  inline const ::Bentley::Geometry::Proto::Angle& startAngle() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_startAngle();
  inline ::Bentley::Geometry::Proto::Angle* release_startAngle();
  inline void set_allocated_startAngle(::Bentley::Geometry::Proto::Angle* startAngle);

  // required .Bentley.Geometry.Proto.Angle sweepAngle = 5;
  inline bool has_sweepAngle() const;
  inline void clear_sweepAngle();
  static const int kSweepAngleFieldNumber = 5;
  inline const ::Bentley::Geometry::Proto::Angle& sweepAngle() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_sweepAngle();
  inline ::Bentley::Geometry::Proto::Angle* release_sweepAngle();
  inline void set_allocated_sweepAngle(::Bentley::Geometry::Proto::Angle* sweepAngle);

  // required bool bSolidFlag = 6;
  inline bool has_bSolidFlag() const;
  inline void clear_bSolidFlag();
  static const int kBSolidFlagFieldNumber = 6;
  inline bool bSolidFlag() const;
  inline void set_bSolidFlag(bool value);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.TorusPipe)
 private:
  inline void set_has_placement();
  inline void clear_has_placement();
  inline void set_has_radiusA();
  inline void clear_has_radiusA();
  inline void set_has_radiusB();
  inline void clear_has_radiusB();
  inline void set_has_startAngle();
  inline void clear_has_startAngle();
  inline void set_has_sweepAngle();
  inline void clear_has_sweepAngle();
  inline void set_has_bSolidFlag();
  inline void clear_has_bSolidFlag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IPlacement* placement_;
  double radiusA_;
  double radiusB_;
  ::Bentley::Geometry::Proto::Angle* startAngle_;
  ::Bentley::Geometry::Proto::Angle* sweepAngle_;
  bool bSolidFlag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static TorusPipe* default_instance_;
};
// -------------------------------------------------------------------

class TransformedGeometry : public ::google::protobuf::Message {
 public:
  TransformedGeometry();
  virtual ~TransformedGeometry();

  TransformedGeometry(const TransformedGeometry& from);

  inline TransformedGeometry& operator=(const TransformedGeometry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransformedGeometry& default_instance();

  void Swap(TransformedGeometry* other);

  // implements Message ----------------------------------------------

  TransformedGeometry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransformedGeometry& from);
  void MergeFrom(const TransformedGeometry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.DTransform3d Transform = 1;
  inline bool has_Transform() const;
  inline void clear_Transform();
  static const int kTransformFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::DTransform3d& Transform() const;
  inline ::Bentley::Geometry::Proto::DTransform3d* mutable_Transform();
  inline ::Bentley::Geometry::Proto::DTransform3d* release_Transform();
  inline void set_allocated_Transform(::Bentley::Geometry::Proto::DTransform3d* Transform);

  // required .Bentley.Geometry.Proto.IGeometry Geometry = 2;
  inline bool has_Geometry() const;
  inline void clear_Geometry();
  static const int kGeometryFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::IGeometry& Geometry() const;
  inline ::Bentley::Geometry::Proto::IGeometry* mutable_Geometry();
  inline ::Bentley::Geometry::Proto::IGeometry* release_Geometry();
  inline void set_allocated_Geometry(::Bentley::Geometry::Proto::IGeometry* Geometry);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.TransformedGeometry)
 private:
  inline void set_has_Transform();
  inline void clear_has_Transform();
  inline void set_has_Geometry();
  inline void clear_has_Geometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::DTransform3d* Transform_;
  ::Bentley::Geometry::Proto::IGeometry* Geometry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static TransformedGeometry* default_instance_;
};
// -------------------------------------------------------------------

class TransitionSpiral : public ::google::protobuf::Message {
 public:
  TransitionSpiral();
  virtual ~TransitionSpiral();

  TransitionSpiral(const TransitionSpiral& from);

  inline TransitionSpiral& operator=(const TransitionSpiral& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransitionSpiral& default_instance();

  void Swap(TransitionSpiral* other);

  // implements Message ----------------------------------------------

  TransitionSpiral* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransitionSpiral& from);
  void MergeFrom(const TransitionSpiral& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string SpiralType = 1;
  inline bool has_SpiralType() const;
  inline void clear_SpiralType();
  static const int kSpiralTypeFieldNumber = 1;
  inline const ::Bentley::Utf8String& SpiralType() const;
  inline void set_SpiralType(const ::Bentley::Utf8String& value);
  inline void set_SpiralType(const char* value);
  inline void set_SpiralType(const char* value, size_t size);
  inline ::Bentley::Utf8String* mutable_SpiralType();
  inline ::Bentley::Utf8String* release_SpiralType();
  inline void set_allocated_SpiralType(::Bentley::Utf8String* SpiralType);

  // required .Bentley.Geometry.Proto.IPlacement Placement = 2;
  inline bool has_Placement() const;
  inline void clear_Placement();
  static const int kPlacementFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::IPlacement& Placement() const;
  inline ::Bentley::Geometry::Proto::IPlacement* mutable_Placement();
  inline ::Bentley::Geometry::Proto::IPlacement* release_Placement();
  inline void set_allocated_Placement(::Bentley::Geometry::Proto::IPlacement* Placement);

  // required .Bentley.Geometry.Proto.Angle StartBearing = 3;
  inline bool has_StartBearing() const;
  inline void clear_StartBearing();
  static const int kStartBearingFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::Angle& StartBearing() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_StartBearing();
  inline ::Bentley::Geometry::Proto::Angle* release_StartBearing();
  inline void set_allocated_StartBearing(::Bentley::Geometry::Proto::Angle* StartBearing);

  // required double StartRadius = 4;
  inline bool has_StartRadius() const;
  inline void clear_StartRadius();
  static const int kStartRadiusFieldNumber = 4;
  inline double StartRadius() const;
  inline void set_StartRadius(double value);

  // required .Bentley.Geometry.Proto.Angle EndBearing = 5;
  inline bool has_EndBearing() const;
  inline void clear_EndBearing();
  static const int kEndBearingFieldNumber = 5;
  inline const ::Bentley::Geometry::Proto::Angle& EndBearing() const;
  inline ::Bentley::Geometry::Proto::Angle* mutable_EndBearing();
  inline ::Bentley::Geometry::Proto::Angle* release_EndBearing();
  inline void set_allocated_EndBearing(::Bentley::Geometry::Proto::Angle* EndBearing);

  // required double EndRadius = 6;
  inline bool has_EndRadius() const;
  inline void clear_EndRadius();
  static const int kEndRadiusFieldNumber = 6;
  inline double EndRadius() const;
  inline void set_EndRadius(double value);

  // required double ActiveStartFraction = 7;
  inline bool has_ActiveStartFraction() const;
  inline void clear_ActiveStartFraction();
  static const int kActiveStartFractionFieldNumber = 7;
  inline double ActiveStartFraction() const;
  inline void set_ActiveStartFraction(double value);

  // required double ActiveEndFraction = 8;
  inline bool has_ActiveEndFraction() const;
  inline void clear_ActiveEndFraction();
  static const int kActiveEndFractionFieldNumber = 8;
  inline double ActiveEndFraction() const;
  inline void set_ActiveEndFraction(double value);

  // required .Bentley.Geometry.Proto.IGeometry Geometry = 9;
  inline bool has_Geometry() const;
  inline void clear_Geometry();
  static const int kGeometryFieldNumber = 9;
  inline const ::Bentley::Geometry::Proto::IGeometry& Geometry() const;
  inline ::Bentley::Geometry::Proto::IGeometry* mutable_Geometry();
  inline ::Bentley::Geometry::Proto::IGeometry* release_Geometry();
  inline void set_allocated_Geometry(::Bentley::Geometry::Proto::IGeometry* Geometry);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.TransitionSpiral)
 private:
  inline void set_has_SpiralType();
  inline void clear_has_SpiralType();
  inline void set_has_Placement();
  inline void clear_has_Placement();
  inline void set_has_StartBearing();
  inline void clear_has_StartBearing();
  inline void set_has_StartRadius();
  inline void clear_has_StartRadius();
  inline void set_has_EndBearing();
  inline void clear_has_EndBearing();
  inline void set_has_EndRadius();
  inline void clear_has_EndRadius();
  inline void set_has_ActiveStartFraction();
  inline void clear_has_ActiveStartFraction();
  inline void set_has_ActiveEndFraction();
  inline void clear_has_ActiveEndFraction();
  inline void set_has_Geometry();
  inline void clear_has_Geometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Utf8String* SpiralType_;
  ::Bentley::Geometry::Proto::IPlacement* Placement_;
  ::Bentley::Geometry::Proto::Angle* StartBearing_;
  double StartRadius_;
  ::Bentley::Geometry::Proto::Angle* EndBearing_;
  double EndRadius_;
  double ActiveStartFraction_;
  double ActiveEndFraction_;
  ::Bentley::Geometry::Proto::IGeometry* Geometry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static TransitionSpiral* default_instance_;
};
// -------------------------------------------------------------------

class Vector : public ::google::protobuf::Message {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();

  void Swap(Vector* other);

  // implements Message ----------------------------------------------

  Vector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.DPoint3d xyz = 1;
  inline bool has_xyz() const;
  inline void clear_xyz();
  static const int kXyzFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::DPoint3d& xyz() const;
  inline ::Bentley::Geometry::Proto::DPoint3d* mutable_xyz();
  inline ::Bentley::Geometry::Proto::DPoint3d* release_xyz();
  inline void set_allocated_xyz(::Bentley::Geometry::Proto::DPoint3d* xyz);

  // required .Bentley.Geometry.Proto.DVector3d vector = 2;
  inline bool has_vector() const;
  inline void clear_vector();
  static const int kVectorFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::DVector3d& vector() const;
  inline ::Bentley::Geometry::Proto::DVector3d* mutable_vector();
  inline ::Bentley::Geometry::Proto::DVector3d* release_vector();
  inline void set_allocated_vector(::Bentley::Geometry::Proto::DVector3d* vector);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.Vector)
 private:
  inline void set_has_xyz();
  inline void clear_has_xyz();
  inline void set_has_vector();
  inline void clear_has_vector();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::DPoint3d* xyz_;
  ::Bentley::Geometry::Proto::DVector3d* vector_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static Vector* default_instance_;
};
// -------------------------------------------------------------------

class AdjacentSurfacePatches : public ::google::protobuf::Message {
 public:
  AdjacentSurfacePatches();
  virtual ~AdjacentSurfacePatches();

  AdjacentSurfacePatches(const AdjacentSurfacePatches& from);

  inline AdjacentSurfacePatches& operator=(const AdjacentSurfacePatches& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdjacentSurfacePatches& default_instance();

  void Swap(AdjacentSurfacePatches* other);

  // implements Message ----------------------------------------------

  AdjacentSurfacePatches* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdjacentSurfacePatches& from);
  void MergeFrom(const AdjacentSurfacePatches& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.ISurfacePatch Patch = 1;
  inline int Patch_size() const;
  inline void clear_Patch();
  static const int kPatchFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ISurfacePatch& Patch(int index) const;
  inline ::Bentley::Geometry::Proto::ISurfacePatch* mutable_Patch(int index);
  inline ::Bentley::Geometry::Proto::ISurfacePatch* add_Patch();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurfacePatch >&
      Patch() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurfacePatch >*
      mutable_Patch();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.AdjacentSurfacePatches)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurfacePatch > Patch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static AdjacentSurfacePatches* default_instance_;
};
// -------------------------------------------------------------------

class Group : public ::google::protobuf::Message {
 public:
  Group();
  virtual ~Group();

  Group(const Group& from);

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Group& default_instance();

  void Swap(Group* other);

  // implements Message ----------------------------------------------

  Group* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Group& from);
  void MergeFrom(const Group& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.IGeometry Member = 1;
  inline int Member_size() const;
  inline void clear_Member();
  static const int kMemberFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IGeometry& Member(int index) const;
  inline ::Bentley::Geometry::Proto::IGeometry* mutable_Member(int index);
  inline ::Bentley::Geometry::Proto::IGeometry* add_Member();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry >&
      Member() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry >*
      mutable_Member();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.Group)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry > Member_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static Group* default_instance_;
};
// -------------------------------------------------------------------

class CurveChain : public ::google::protobuf::Message {
 public:
  CurveChain();
  virtual ~CurveChain();

  CurveChain(const CurveChain& from);

  inline CurveChain& operator=(const CurveChain& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurveChain& default_instance();

  void Swap(CurveChain* other);

  // implements Message ----------------------------------------------

  CurveChain* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurveChain& from);
  void MergeFrom(const CurveChain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.IPrimitiveCurve Curve = 1;
  inline int Curve_size() const;
  inline void clear_Curve();
  static const int kCurveFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPrimitiveCurve& Curve(int index) const;
  inline ::Bentley::Geometry::Proto::IPrimitiveCurve* mutable_Curve(int index);
  inline ::Bentley::Geometry::Proto::IPrimitiveCurve* add_Curve();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPrimitiveCurve >&
      Curve() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPrimitiveCurve >*
      mutable_Curve();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.CurveChain)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPrimitiveCurve > Curve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static CurveChain* default_instance_;
};
// -------------------------------------------------------------------

class CurveGroup : public ::google::protobuf::Message {
 public:
  CurveGroup();
  virtual ~CurveGroup();

  CurveGroup(const CurveGroup& from);

  inline CurveGroup& operator=(const CurveGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CurveGroup& default_instance();

  void Swap(CurveGroup* other);

  // implements Message ----------------------------------------------

  CurveGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CurveGroup& from);
  void MergeFrom(const CurveGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.ICurve Curve = 1;
  inline int Curve_size() const;
  inline void clear_Curve();
  static const int kCurveFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ICurve& Curve(int index) const;
  inline ::Bentley::Geometry::Proto::ICurve* mutable_Curve(int index);
  inline ::Bentley::Geometry::Proto::ICurve* add_Curve();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurve >&
      Curve() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurve >*
      mutable_Curve();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.CurveGroup)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurve > Curve_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static CurveGroup* default_instance_;
};
// -------------------------------------------------------------------

class Operation : public ::google::protobuf::Message {
 public:
  Operation();
  virtual ~Operation();

  Operation(const Operation& from);

  inline Operation& operator=(const Operation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Operation& default_instance();

  void Swap(Operation* other);

  // implements Message ----------------------------------------------

  Operation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Operation& from);
  void MergeFrom(const Operation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_Name() const;
  inline void clear_Name();
  static const int kNameFieldNumber = 1;
  inline const ::Bentley::Utf8String& Name() const;
  inline void set_Name(const ::Bentley::Utf8String& value);
  inline void set_Name(const char* value);
  inline void set_Name(const char* value, size_t size);
  inline ::Bentley::Utf8String* mutable_Name();
  inline ::Bentley::Utf8String* release_Name();
  inline void set_allocated_Name(::Bentley::Utf8String* Name);

  // repeated .Bentley.Geometry.Proto.IGeometry Member = 2;
  inline int Member_size() const;
  inline void clear_Member();
  static const int kMemberFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::IGeometry& Member(int index) const;
  inline ::Bentley::Geometry::Proto::IGeometry* mutable_Member(int index);
  inline ::Bentley::Geometry::Proto::IGeometry* add_Member();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry >&
      Member() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry >*
      mutable_Member();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.Operation)
 private:
  inline void set_has_Name();
  inline void clear_has_Name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Utf8String* Name_;
  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry > Member_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static Operation* default_instance_;
};
// -------------------------------------------------------------------

class ParametricSurfacePatch : public ::google::protobuf::Message {
 public:
  ParametricSurfacePatch();
  virtual ~ParametricSurfacePatch();

  ParametricSurfacePatch(const ParametricSurfacePatch& from);

  inline ParametricSurfacePatch& operator=(const ParametricSurfacePatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParametricSurfacePatch& default_instance();

  void Swap(ParametricSurfacePatch* other);

  // implements Message ----------------------------------------------

  ParametricSurfacePatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParametricSurfacePatch& from);
  void MergeFrom(const ParametricSurfacePatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.IParametricSurface Surface = 1;
  inline bool has_Surface() const;
  inline void clear_Surface();
  static const int kSurfaceFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IParametricSurface& Surface() const;
  inline ::Bentley::Geometry::Proto::IParametricSurface* mutable_Surface();
  inline ::Bentley::Geometry::Proto::IParametricSurface* release_Surface();
  inline void set_allocated_Surface(::Bentley::Geometry::Proto::IParametricSurface* Surface);

  // repeated .Bentley.Geometry.Proto.ICurveChain CurveChain = 2;
  inline int CurveChain_size() const;
  inline void clear_CurveChain();
  static const int kCurveChainFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::ICurveChain& CurveChain(int index) const;
  inline ::Bentley::Geometry::Proto::ICurveChain* mutable_CurveChain(int index);
  inline ::Bentley::Geometry::Proto::ICurveChain* add_CurveChain();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain >&
      CurveChain() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain >*
      mutable_CurveChain();

  // required .Bentley.Geometry.Proto.LoopType LoopType = 3;
  inline bool has_LoopType() const;
  inline void clear_LoopType();
  static const int kLoopTypeFieldNumber = 3;
  inline const ::Bentley::Geometry::Proto::LoopType& LoopType() const;
  inline ::Bentley::Geometry::Proto::LoopType* mutable_LoopType();
  inline ::Bentley::Geometry::Proto::LoopType* release_LoopType();
  inline void set_allocated_LoopType(::Bentley::Geometry::Proto::LoopType* LoopType);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.ParametricSurfacePatch)
 private:
  inline void set_has_Surface();
  inline void clear_has_Surface();
  inline void set_has_LoopType();
  inline void clear_has_LoopType();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::IParametricSurface* Surface_;
  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain > CurveChain_;
  ::Bentley::Geometry::Proto::LoopType* LoopType_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static ParametricSurfacePatch* default_instance_;
};
// -------------------------------------------------------------------

class PointChain : public ::google::protobuf::Message {
 public:
  PointChain();
  virtual ~PointChain();

  PointChain(const PointChain& from);

  inline PointChain& operator=(const PointChain& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointChain& default_instance();

  void Swap(PointChain* other);

  // implements Message ----------------------------------------------

  PointChain* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointChain& from);
  void MergeFrom(const PointChain& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.ISinglePoint Point = 1;
  inline int Point_size() const;
  inline void clear_Point();
  static const int kPointFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ISinglePoint& Point(int index) const;
  inline ::Bentley::Geometry::Proto::ISinglePoint* mutable_Point(int index);
  inline ::Bentley::Geometry::Proto::ISinglePoint* add_Point();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISinglePoint >&
      Point() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISinglePoint >*
      mutable_Point();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.PointChain)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISinglePoint > Point_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static PointChain* default_instance_;
};
// -------------------------------------------------------------------

class PointGroup : public ::google::protobuf::Message {
 public:
  PointGroup();
  virtual ~PointGroup();

  PointGroup(const PointGroup& from);

  inline PointGroup& operator=(const PointGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointGroup& default_instance();

  void Swap(PointGroup* other);

  // implements Message ----------------------------------------------

  PointGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PointGroup& from);
  void MergeFrom(const PointGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.IPoint Member = 1;
  inline int Member_size() const;
  inline void clear_Member();
  static const int kMemberFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::IPoint& Member(int index) const;
  inline ::Bentley::Geometry::Proto::IPoint* mutable_Member(int index);
  inline ::Bentley::Geometry::Proto::IPoint* add_Member();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPoint >&
      Member() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPoint >*
      mutable_Member();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.PointGroup)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPoint > Member_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static PointGroup* default_instance_;
};
// -------------------------------------------------------------------

class SharedGroupDef : public ::google::protobuf::Message {
 public:
  SharedGroupDef();
  virtual ~SharedGroupDef();

  SharedGroupDef(const SharedGroupDef& from);

  inline SharedGroupDef& operator=(const SharedGroupDef& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SharedGroupDef& default_instance();

  void Swap(SharedGroupDef* other);

  // implements Message ----------------------------------------------

  SharedGroupDef* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SharedGroupDef& from);
  void MergeFrom(const SharedGroupDef& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string Name = 1;
  inline bool has_Name() const;
  inline void clear_Name();
  static const int kNameFieldNumber = 1;
  inline const ::Bentley::Utf8String& Name() const;
  inline void set_Name(const ::Bentley::Utf8String& value);
  inline void set_Name(const char* value);
  inline void set_Name(const char* value, size_t size);
  inline ::Bentley::Utf8String* mutable_Name();
  inline ::Bentley::Utf8String* release_Name();
  inline void set_allocated_Name(::Bentley::Utf8String* Name);

  // required .Bentley.Geometry.Proto.IGeometry Geometry = 2;
  inline bool has_Geometry() const;
  inline void clear_Geometry();
  static const int kGeometryFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::IGeometry& Geometry() const;
  inline ::Bentley::Geometry::Proto::IGeometry* mutable_Geometry();
  inline ::Bentley::Geometry::Proto::IGeometry* release_Geometry();
  inline void set_allocated_Geometry(::Bentley::Geometry::Proto::IGeometry* Geometry);

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.SharedGroupDef)
 private:
  inline void set_has_Name();
  inline void clear_has_Name();
  inline void set_has_Geometry();
  inline void clear_has_Geometry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Utf8String* Name_;
  ::Bentley::Geometry::Proto::IGeometry* Geometry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static SharedGroupDef* default_instance_;
};
// -------------------------------------------------------------------

class SolidGroup : public ::google::protobuf::Message {
 public:
  SolidGroup();
  virtual ~SolidGroup();

  SolidGroup(const SolidGroup& from);

  inline SolidGroup& operator=(const SolidGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SolidGroup& default_instance();

  void Swap(SolidGroup* other);

  // implements Message ----------------------------------------------

  SolidGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SolidGroup& from);
  void MergeFrom(const SolidGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.ISolid Solid = 1;
  inline int Solid_size() const;
  inline void clear_Solid();
  static const int kSolidFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ISolid& Solid(int index) const;
  inline ::Bentley::Geometry::Proto::ISolid* mutable_Solid(int index);
  inline ::Bentley::Geometry::Proto::ISolid* add_Solid();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISolid >&
      Solid() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISolid >*
      mutable_Solid();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.SolidGroup)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISolid > Solid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static SolidGroup* default_instance_;
};
// -------------------------------------------------------------------

class SurfaceGroup : public ::google::protobuf::Message {
 public:
  SurfaceGroup();
  virtual ~SurfaceGroup();

  SurfaceGroup(const SurfaceGroup& from);

  inline SurfaceGroup& operator=(const SurfaceGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceGroup& default_instance();

  void Swap(SurfaceGroup* other);

  // implements Message ----------------------------------------------

  SurfaceGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SurfaceGroup& from);
  void MergeFrom(const SurfaceGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Bentley.Geometry.Proto.ISurface Surface = 1;
  inline int Surface_size() const;
  inline void clear_Surface();
  static const int kSurfaceFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ISurface& Surface(int index) const;
  inline ::Bentley::Geometry::Proto::ISurface* mutable_Surface(int index);
  inline ::Bentley::Geometry::Proto::ISurface* add_Surface();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurface >&
      Surface() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurface >*
      mutable_Surface();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.SurfaceGroup)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurface > Surface_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static SurfaceGroup* default_instance_;
};
// -------------------------------------------------------------------

class SurfacePatch : public ::google::protobuf::Message {
 public:
  SurfacePatch();
  virtual ~SurfacePatch();

  SurfacePatch(const SurfacePatch& from);

  inline SurfacePatch& operator=(const SurfacePatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfacePatch& default_instance();

  void Swap(SurfacePatch* other);

  // implements Message ----------------------------------------------

  SurfacePatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SurfacePatch& from);
  void MergeFrom(const SurfacePatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .Bentley.Geometry.Proto.ICurveChain ExteriorLoop = 1;
  inline bool has_ExteriorLoop() const;
  inline void clear_ExteriorLoop();
  static const int kExteriorLoopFieldNumber = 1;
  inline const ::Bentley::Geometry::Proto::ICurveChain& ExteriorLoop() const;
  inline ::Bentley::Geometry::Proto::ICurveChain* mutable_ExteriorLoop();
  inline ::Bentley::Geometry::Proto::ICurveChain* release_ExteriorLoop();
  inline void set_allocated_ExteriorLoop(::Bentley::Geometry::Proto::ICurveChain* ExteriorLoop);

  // repeated .Bentley.Geometry.Proto.ICurveChain HoleLoop = 2;
  inline int HoleLoop_size() const;
  inline void clear_HoleLoop();
  static const int kHoleLoopFieldNumber = 2;
  inline const ::Bentley::Geometry::Proto::ICurveChain& HoleLoop(int index) const;
  inline ::Bentley::Geometry::Proto::ICurveChain* mutable_HoleLoop(int index);
  inline ::Bentley::Geometry::Proto::ICurveChain* add_HoleLoop();
  inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain >&
      HoleLoop() const;
  inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain >*
      mutable_HoleLoop();

  // @@protoc_insertion_point(class_scope:Bentley.Geometry.Proto.SurfacePatch)
 private:
  inline void set_has_ExteriorLoop();
  inline void clear_has_ExteriorLoop();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::Bentley::Geometry::Proto::ICurveChain* ExteriorLoop_;
  ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain > HoleLoop_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_allcg_2eproto();
  friend void protobuf_AssignDesc_allcg_2eproto();
  friend void protobuf_ShutdownFile_allcg_2eproto();

  void InitAsDefaultInstance();
  static SurfacePatch* default_instance_;
};
// ===================================================================


// ===================================================================

// DPoint3d

// required double x = 1;
inline bool DPoint3d::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DPoint3d::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DPoint3d::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DPoint3d::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double DPoint3d::x() const {
  return x_;
}
inline void DPoint3d::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool DPoint3d::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DPoint3d::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DPoint3d::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DPoint3d::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double DPoint3d::y() const {
  return y_;
}
inline void DPoint3d::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool DPoint3d::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DPoint3d::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DPoint3d::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DPoint3d::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double DPoint3d::z() const {
  return z_;
}
inline void DPoint3d::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// DPoint2d

// required double x = 1;
inline bool DPoint2d::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DPoint2d::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DPoint2d::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DPoint2d::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double DPoint2d::x() const {
  return x_;
}
inline void DPoint2d::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool DPoint2d::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DPoint2d::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DPoint2d::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DPoint2d::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double DPoint2d::y() const {
  return y_;
}
inline void DPoint2d::set_y(double value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// DVector3d

// required double x = 1;
inline bool DVector3d::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DVector3d::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DVector3d::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DVector3d::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double DVector3d::x() const {
  return x_;
}
inline void DVector3d::set_x(double value) {
  set_has_x();
  x_ = value;
}

// required double y = 2;
inline bool DVector3d::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DVector3d::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DVector3d::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DVector3d::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double DVector3d::y() const {
  return y_;
}
inline void DVector3d::set_y(double value) {
  set_has_y();
  y_ = value;
}

// required double z = 3;
inline bool DVector3d::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DVector3d::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DVector3d::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DVector3d::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline double DVector3d::z() const {
  return z_;
}
inline void DVector3d::set_z(double value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// IPlacement

// required .Bentley.Geometry.Proto.DPoint3d orgin = 1;
inline bool IPlacement::has_orgin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IPlacement::set_has_orgin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IPlacement::clear_has_orgin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IPlacement::clear_orgin() {
  if (orgin_ != NULL) orgin_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_orgin();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& IPlacement::orgin() const {
  return orgin_ != NULL ? *orgin_ : *default_instance_->orgin_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* IPlacement::mutable_orgin() {
  set_has_orgin();
  if (orgin_ == NULL) orgin_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return orgin_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* IPlacement::release_orgin() {
  clear_has_orgin();
  ::Bentley::Geometry::Proto::DPoint3d* temp = orgin_;
  orgin_ = NULL;
  return temp;
}
inline void IPlacement::set_allocated_orgin(::Bentley::Geometry::Proto::DPoint3d* orgin) {
  delete orgin_;
  orgin_ = orgin;
  if (orgin) {
    set_has_orgin();
  } else {
    clear_has_orgin();
  }
}

// required .Bentley.Geometry.Proto.DVector3d vectorZ = 2;
inline bool IPlacement::has_vectorZ() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IPlacement::set_has_vectorZ() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IPlacement::clear_has_vectorZ() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IPlacement::clear_vectorZ() {
  if (vectorZ_ != NULL) vectorZ_->::Bentley::Geometry::Proto::DVector3d::Clear();
  clear_has_vectorZ();
}
inline const ::Bentley::Geometry::Proto::DVector3d& IPlacement::vectorZ() const {
  return vectorZ_ != NULL ? *vectorZ_ : *default_instance_->vectorZ_;
}
inline ::Bentley::Geometry::Proto::DVector3d* IPlacement::mutable_vectorZ() {
  set_has_vectorZ();
  if (vectorZ_ == NULL) vectorZ_ = new ::Bentley::Geometry::Proto::DVector3d;
  return vectorZ_;
}
inline ::Bentley::Geometry::Proto::DVector3d* IPlacement::release_vectorZ() {
  clear_has_vectorZ();
  ::Bentley::Geometry::Proto::DVector3d* temp = vectorZ_;
  vectorZ_ = NULL;
  return temp;
}
inline void IPlacement::set_allocated_vectorZ(::Bentley::Geometry::Proto::DVector3d* vectorZ) {
  delete vectorZ_;
  vectorZ_ = vectorZ;
  if (vectorZ) {
    set_has_vectorZ();
  } else {
    clear_has_vectorZ();
  }
}

// required .Bentley.Geometry.Proto.DVector3d vectorX = 3;
inline bool IPlacement::has_vectorX() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IPlacement::set_has_vectorX() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IPlacement::clear_has_vectorX() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IPlacement::clear_vectorX() {
  if (vectorX_ != NULL) vectorX_->::Bentley::Geometry::Proto::DVector3d::Clear();
  clear_has_vectorX();
}
inline const ::Bentley::Geometry::Proto::DVector3d& IPlacement::vectorX() const {
  return vectorX_ != NULL ? *vectorX_ : *default_instance_->vectorX_;
}
inline ::Bentley::Geometry::Proto::DVector3d* IPlacement::mutable_vectorX() {
  set_has_vectorX();
  if (vectorX_ == NULL) vectorX_ = new ::Bentley::Geometry::Proto::DVector3d;
  return vectorX_;
}
inline ::Bentley::Geometry::Proto::DVector3d* IPlacement::release_vectorX() {
  clear_has_vectorX();
  ::Bentley::Geometry::Proto::DVector3d* temp = vectorX_;
  vectorX_ = NULL;
  return temp;
}
inline void IPlacement::set_allocated_vectorX(::Bentley::Geometry::Proto::DVector3d* vectorX) {
  delete vectorX_;
  vectorX_ = vectorX;
  if (vectorX) {
    set_has_vectorX();
  } else {
    clear_has_vectorX();
  }
}

// -------------------------------------------------------------------

// Angle

// required double degrees = 1;
inline bool Angle::has_degrees() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Angle::set_has_degrees() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Angle::clear_has_degrees() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Angle::clear_degrees() {
  degrees_ = 0;
  clear_has_degrees();
}
inline double Angle::degrees() const {
  return degrees_;
}
inline void Angle::set_degrees(double value) {
  set_has_degrees();
  degrees_ = value;
}

// -------------------------------------------------------------------

// DEllipse3d

// required double centerX = 1;
inline bool DEllipse3d::has_centerX() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DEllipse3d::set_has_centerX() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DEllipse3d::clear_has_centerX() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DEllipse3d::clear_centerX() {
  centerX_ = 0;
  clear_has_centerX();
}
inline double DEllipse3d::centerX() const {
  return centerX_;
}
inline void DEllipse3d::set_centerX(double value) {
  set_has_centerX();
  centerX_ = value;
}

// required double centerY = 2;
inline bool DEllipse3d::has_centerY() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DEllipse3d::set_has_centerY() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DEllipse3d::clear_has_centerY() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DEllipse3d::clear_centerY() {
  centerY_ = 0;
  clear_has_centerY();
}
inline double DEllipse3d::centerY() const {
  return centerY_;
}
inline void DEllipse3d::set_centerY(double value) {
  set_has_centerY();
  centerY_ = value;
}

// required double centerZ = 3;
inline bool DEllipse3d::has_centerZ() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DEllipse3d::set_has_centerZ() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DEllipse3d::clear_has_centerZ() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DEllipse3d::clear_centerZ() {
  centerZ_ = 0;
  clear_has_centerZ();
}
inline double DEllipse3d::centerZ() const {
  return centerZ_;
}
inline void DEllipse3d::set_centerZ(double value) {
  set_has_centerZ();
  centerZ_ = value;
}

// required double vector0X = 4;
inline bool DEllipse3d::has_vector0X() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DEllipse3d::set_has_vector0X() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DEllipse3d::clear_has_vector0X() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DEllipse3d::clear_vector0X() {
  vector0X_ = 0;
  clear_has_vector0X();
}
inline double DEllipse3d::vector0X() const {
  return vector0X_;
}
inline void DEllipse3d::set_vector0X(double value) {
  set_has_vector0X();
  vector0X_ = value;
}

// required double vector0Y = 5;
inline bool DEllipse3d::has_vector0Y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DEllipse3d::set_has_vector0Y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DEllipse3d::clear_has_vector0Y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DEllipse3d::clear_vector0Y() {
  vector0Y_ = 0;
  clear_has_vector0Y();
}
inline double DEllipse3d::vector0Y() const {
  return vector0Y_;
}
inline void DEllipse3d::set_vector0Y(double value) {
  set_has_vector0Y();
  vector0Y_ = value;
}

// required double vector0Z = 6;
inline bool DEllipse3d::has_vector0Z() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DEllipse3d::set_has_vector0Z() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DEllipse3d::clear_has_vector0Z() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DEllipse3d::clear_vector0Z() {
  vector0Z_ = 0;
  clear_has_vector0Z();
}
inline double DEllipse3d::vector0Z() const {
  return vector0Z_;
}
inline void DEllipse3d::set_vector0Z(double value) {
  set_has_vector0Z();
  vector0Z_ = value;
}

// required double vector90X = 7;
inline bool DEllipse3d::has_vector90X() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DEllipse3d::set_has_vector90X() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DEllipse3d::clear_has_vector90X() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DEllipse3d::clear_vector90X() {
  vector90X_ = 0;
  clear_has_vector90X();
}
inline double DEllipse3d::vector90X() const {
  return vector90X_;
}
inline void DEllipse3d::set_vector90X(double value) {
  set_has_vector90X();
  vector90X_ = value;
}

// required double vector90Y = 8;
inline bool DEllipse3d::has_vector90Y() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DEllipse3d::set_has_vector90Y() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DEllipse3d::clear_has_vector90Y() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DEllipse3d::clear_vector90Y() {
  vector90Y_ = 0;
  clear_has_vector90Y();
}
inline double DEllipse3d::vector90Y() const {
  return vector90Y_;
}
inline void DEllipse3d::set_vector90Y(double value) {
  set_has_vector90Y();
  vector90Y_ = value;
}

// required double vector90Z = 9;
inline bool DEllipse3d::has_vector90Z() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DEllipse3d::set_has_vector90Z() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DEllipse3d::clear_has_vector90Z() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DEllipse3d::clear_vector90Z() {
  vector90Z_ = 0;
  clear_has_vector90Z();
}
inline double DEllipse3d::vector90Z() const {
  return vector90Z_;
}
inline void DEllipse3d::set_vector90Z(double value) {
  set_has_vector90Z();
  vector90Z_ = value;
}

// required double startRadians = 10;
inline bool DEllipse3d::has_startRadians() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DEllipse3d::set_has_startRadians() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DEllipse3d::clear_has_startRadians() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DEllipse3d::clear_startRadians() {
  startRadians_ = 0;
  clear_has_startRadians();
}
inline double DEllipse3d::startRadians() const {
  return startRadians_;
}
inline void DEllipse3d::set_startRadians(double value) {
  set_has_startRadians();
  startRadians_ = value;
}

// required double sweepRadians = 11;
inline bool DEllipse3d::has_sweepRadians() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DEllipse3d::set_has_sweepRadians() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DEllipse3d::clear_has_sweepRadians() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DEllipse3d::clear_sweepRadians() {
  sweepRadians_ = 0;
  clear_has_sweepRadians();
}
inline double DEllipse3d::sweepRadians() const {
  return sweepRadians_;
}
inline void DEllipse3d::set_sweepRadians(double value) {
  set_has_sweepRadians();
  sweepRadians_ = value;
}

// -------------------------------------------------------------------

// DTransform3d

// required double axx = 1;
inline bool DTransform3d::has_axx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DTransform3d::set_has_axx() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DTransform3d::clear_has_axx() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DTransform3d::clear_axx() {
  axx_ = 0;
  clear_has_axx();
}
inline double DTransform3d::axx() const {
  return axx_;
}
inline void DTransform3d::set_axx(double value) {
  set_has_axx();
  axx_ = value;
}

// required double axy = 2;
inline bool DTransform3d::has_axy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DTransform3d::set_has_axy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DTransform3d::clear_has_axy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DTransform3d::clear_axy() {
  axy_ = 0;
  clear_has_axy();
}
inline double DTransform3d::axy() const {
  return axy_;
}
inline void DTransform3d::set_axy(double value) {
  set_has_axy();
  axy_ = value;
}

// required double axz = 3;
inline bool DTransform3d::has_axz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DTransform3d::set_has_axz() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DTransform3d::clear_has_axz() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DTransform3d::clear_axz() {
  axz_ = 0;
  clear_has_axz();
}
inline double DTransform3d::axz() const {
  return axz_;
}
inline void DTransform3d::set_axz(double value) {
  set_has_axz();
  axz_ = value;
}

// required double axw = 4;
inline bool DTransform3d::has_axw() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DTransform3d::set_has_axw() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DTransform3d::clear_has_axw() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DTransform3d::clear_axw() {
  axw_ = 0;
  clear_has_axw();
}
inline double DTransform3d::axw() const {
  return axw_;
}
inline void DTransform3d::set_axw(double value) {
  set_has_axw();
  axw_ = value;
}

// required double ayx = 5;
inline bool DTransform3d::has_ayx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DTransform3d::set_has_ayx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DTransform3d::clear_has_ayx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DTransform3d::clear_ayx() {
  ayx_ = 0;
  clear_has_ayx();
}
inline double DTransform3d::ayx() const {
  return ayx_;
}
inline void DTransform3d::set_ayx(double value) {
  set_has_ayx();
  ayx_ = value;
}

// required double ayy = 6;
inline bool DTransform3d::has_ayy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DTransform3d::set_has_ayy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DTransform3d::clear_has_ayy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DTransform3d::clear_ayy() {
  ayy_ = 0;
  clear_has_ayy();
}
inline double DTransform3d::ayy() const {
  return ayy_;
}
inline void DTransform3d::set_ayy(double value) {
  set_has_ayy();
  ayy_ = value;
}

// required double ayz = 7;
inline bool DTransform3d::has_ayz() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DTransform3d::set_has_ayz() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DTransform3d::clear_has_ayz() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DTransform3d::clear_ayz() {
  ayz_ = 0;
  clear_has_ayz();
}
inline double DTransform3d::ayz() const {
  return ayz_;
}
inline void DTransform3d::set_ayz(double value) {
  set_has_ayz();
  ayz_ = value;
}

// required double ayw = 8;
inline bool DTransform3d::has_ayw() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DTransform3d::set_has_ayw() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DTransform3d::clear_has_ayw() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DTransform3d::clear_ayw() {
  ayw_ = 0;
  clear_has_ayw();
}
inline double DTransform3d::ayw() const {
  return ayw_;
}
inline void DTransform3d::set_ayw(double value) {
  set_has_ayw();
  ayw_ = value;
}

// required double azx = 9;
inline bool DTransform3d::has_azx() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DTransform3d::set_has_azx() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DTransform3d::clear_has_azx() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DTransform3d::clear_azx() {
  azx_ = 0;
  clear_has_azx();
}
inline double DTransform3d::azx() const {
  return azx_;
}
inline void DTransform3d::set_azx(double value) {
  set_has_azx();
  azx_ = value;
}

// required double azy = 10;
inline bool DTransform3d::has_azy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DTransform3d::set_has_azy() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DTransform3d::clear_has_azy() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DTransform3d::clear_azy() {
  azy_ = 0;
  clear_has_azy();
}
inline double DTransform3d::azy() const {
  return azy_;
}
inline void DTransform3d::set_azy(double value) {
  set_has_azy();
  azy_ = value;
}

// required double azz = 11;
inline bool DTransform3d::has_azz() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DTransform3d::set_has_azz() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DTransform3d::clear_has_azz() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DTransform3d::clear_azz() {
  azz_ = 0;
  clear_has_azz();
}
inline double DTransform3d::azz() const {
  return azz_;
}
inline void DTransform3d::set_azz(double value) {
  set_has_azz();
  azz_ = value;
}

// required double azw = 12;
inline bool DTransform3d::has_azw() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DTransform3d::set_has_azw() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DTransform3d::clear_has_azw() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DTransform3d::clear_azw() {
  azw_ = 0;
  clear_has_azw();
}
inline double DTransform3d::azw() const {
  return azw_;
}
inline void DTransform3d::set_azw(double value) {
  set_has_azw();
  azw_ = value;
}

// -------------------------------------------------------------------

// LoopType

// required .Bentley.Geometry.Proto.LoopType.LoopTypeEnum loopType = 1;
inline bool LoopType::has_loopType() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoopType::set_has_loopType() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoopType::clear_has_loopType() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoopType::clear_loopType() {
  loopType_ = 1;
  clear_has_loopType();
}
inline ::Bentley::Geometry::Proto::LoopType_LoopTypeEnum LoopType::loopType() const {
  return static_cast< ::Bentley::Geometry::Proto::LoopType_LoopTypeEnum >(loopType_);
}
inline void LoopType::set_loopType(::Bentley::Geometry::Proto::LoopType_LoopTypeEnum value) {
  assert(::Bentley::Geometry::Proto::LoopType_LoopTypeEnum_IsValid(value));
  set_has_loopType();
  loopType_ = value;
}

// -------------------------------------------------------------------

// ISinglePoint

// optional .Bentley.Geometry.Proto.Coordinate coordinate = 1;
inline bool ISinglePoint::has_coordinate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ISinglePoint::set_has_coordinate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ISinglePoint::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ISinglePoint::clear_coordinate() {
  if (coordinate_ != NULL) coordinate_->::Bentley::Geometry::Proto::Coordinate::Clear();
  clear_has_coordinate();
}
inline const ::Bentley::Geometry::Proto::Coordinate& ISinglePoint::coordinate() const {
  return coordinate_ != NULL ? *coordinate_ : *default_instance_->coordinate_;
}
inline ::Bentley::Geometry::Proto::Coordinate* ISinglePoint::mutable_coordinate() {
  set_has_coordinate();
  if (coordinate_ == NULL) coordinate_ = new ::Bentley::Geometry::Proto::Coordinate;
  return coordinate_;
}
inline ::Bentley::Geometry::Proto::Coordinate* ISinglePoint::release_coordinate() {
  clear_has_coordinate();
  ::Bentley::Geometry::Proto::Coordinate* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline void ISinglePoint::set_allocated_coordinate(::Bentley::Geometry::Proto::Coordinate* coordinate) {
  delete coordinate_;
  coordinate_ = coordinate;
  if (coordinate) {
    set_has_coordinate();
  } else {
    clear_has_coordinate();
  }
}

// optional .Bentley.Geometry.Proto.SharedGroupInstance sharedGruopInstance = 2;
inline bool ISinglePoint::has_sharedGruopInstance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ISinglePoint::set_has_sharedGruopInstance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ISinglePoint::clear_has_sharedGruopInstance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ISinglePoint::clear_sharedGruopInstance() {
  if (sharedGruopInstance_ != NULL) sharedGruopInstance_->::Bentley::Geometry::Proto::SharedGroupInstance::Clear();
  clear_has_sharedGruopInstance();
}
inline const ::Bentley::Geometry::Proto::SharedGroupInstance& ISinglePoint::sharedGruopInstance() const {
  return sharedGruopInstance_ != NULL ? *sharedGruopInstance_ : *default_instance_->sharedGruopInstance_;
}
inline ::Bentley::Geometry::Proto::SharedGroupInstance* ISinglePoint::mutable_sharedGruopInstance() {
  set_has_sharedGruopInstance();
  if (sharedGruopInstance_ == NULL) sharedGruopInstance_ = new ::Bentley::Geometry::Proto::SharedGroupInstance;
  return sharedGruopInstance_;
}
inline ::Bentley::Geometry::Proto::SharedGroupInstance* ISinglePoint::release_sharedGruopInstance() {
  clear_has_sharedGruopInstance();
  ::Bentley::Geometry::Proto::SharedGroupInstance* temp = sharedGruopInstance_;
  sharedGruopInstance_ = NULL;
  return temp;
}
inline void ISinglePoint::set_allocated_sharedGruopInstance(::Bentley::Geometry::Proto::SharedGroupInstance* sharedGruopInstance) {
  delete sharedGruopInstance_;
  sharedGruopInstance_ = sharedGruopInstance;
  if (sharedGruopInstance) {
    set_has_sharedGruopInstance();
  } else {
    clear_has_sharedGruopInstance();
  }
}

// optional .Bentley.Geometry.Proto.SingleLineText singleLineText = 3;
inline bool ISinglePoint::has_singleLineText() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ISinglePoint::set_has_singleLineText() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ISinglePoint::clear_has_singleLineText() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ISinglePoint::clear_singleLineText() {
  if (singleLineText_ != NULL) singleLineText_->::Bentley::Geometry::Proto::SingleLineText::Clear();
  clear_has_singleLineText();
}
inline const ::Bentley::Geometry::Proto::SingleLineText& ISinglePoint::singleLineText() const {
  return singleLineText_ != NULL ? *singleLineText_ : *default_instance_->singleLineText_;
}
inline ::Bentley::Geometry::Proto::SingleLineText* ISinglePoint::mutable_singleLineText() {
  set_has_singleLineText();
  if (singleLineText_ == NULL) singleLineText_ = new ::Bentley::Geometry::Proto::SingleLineText;
  return singleLineText_;
}
inline ::Bentley::Geometry::Proto::SingleLineText* ISinglePoint::release_singleLineText() {
  clear_has_singleLineText();
  ::Bentley::Geometry::Proto::SingleLineText* temp = singleLineText_;
  singleLineText_ = NULL;
  return temp;
}
inline void ISinglePoint::set_allocated_singleLineText(::Bentley::Geometry::Proto::SingleLineText* singleLineText) {
  delete singleLineText_;
  singleLineText_ = singleLineText;
  if (singleLineText) {
    set_has_singleLineText();
  } else {
    clear_has_singleLineText();
  }
}

// optional .Bentley.Geometry.Proto.TransformedGeometry transformedGeometry = 4;
inline bool ISinglePoint::has_transformedGeometry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ISinglePoint::set_has_transformedGeometry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ISinglePoint::clear_has_transformedGeometry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ISinglePoint::clear_transformedGeometry() {
  if (transformedGeometry_ != NULL) transformedGeometry_->::Bentley::Geometry::Proto::TransformedGeometry::Clear();
  clear_has_transformedGeometry();
}
inline const ::Bentley::Geometry::Proto::TransformedGeometry& ISinglePoint::transformedGeometry() const {
  return transformedGeometry_ != NULL ? *transformedGeometry_ : *default_instance_->transformedGeometry_;
}
inline ::Bentley::Geometry::Proto::TransformedGeometry* ISinglePoint::mutable_transformedGeometry() {
  set_has_transformedGeometry();
  if (transformedGeometry_ == NULL) transformedGeometry_ = new ::Bentley::Geometry::Proto::TransformedGeometry;
  return transformedGeometry_;
}
inline ::Bentley::Geometry::Proto::TransformedGeometry* ISinglePoint::release_transformedGeometry() {
  clear_has_transformedGeometry();
  ::Bentley::Geometry::Proto::TransformedGeometry* temp = transformedGeometry_;
  transformedGeometry_ = NULL;
  return temp;
}
inline void ISinglePoint::set_allocated_transformedGeometry(::Bentley::Geometry::Proto::TransformedGeometry* transformedGeometry) {
  delete transformedGeometry_;
  transformedGeometry_ = transformedGeometry;
  if (transformedGeometry) {
    set_has_transformedGeometry();
  } else {
    clear_has_transformedGeometry();
  }
}

// optional .Bentley.Geometry.Proto.Vector vector = 5;
inline bool ISinglePoint::has_vector() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ISinglePoint::set_has_vector() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ISinglePoint::clear_has_vector() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ISinglePoint::clear_vector() {
  if (vector_ != NULL) vector_->::Bentley::Geometry::Proto::Vector::Clear();
  clear_has_vector();
}
inline const ::Bentley::Geometry::Proto::Vector& ISinglePoint::vector() const {
  return vector_ != NULL ? *vector_ : *default_instance_->vector_;
}
inline ::Bentley::Geometry::Proto::Vector* ISinglePoint::mutable_vector() {
  set_has_vector();
  if (vector_ == NULL) vector_ = new ::Bentley::Geometry::Proto::Vector;
  return vector_;
}
inline ::Bentley::Geometry::Proto::Vector* ISinglePoint::release_vector() {
  clear_has_vector();
  ::Bentley::Geometry::Proto::Vector* temp = vector_;
  vector_ = NULL;
  return temp;
}
inline void ISinglePoint::set_allocated_vector(::Bentley::Geometry::Proto::Vector* vector) {
  delete vector_;
  vector_ = vector;
  if (vector) {
    set_has_vector();
  } else {
    clear_has_vector();
  }
}

// -------------------------------------------------------------------

// IPoint

// optional .Bentley.Geometry.Proto.ISinglePoint singlePoint = 1;
inline bool IPoint::has_singlePoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IPoint::set_has_singlePoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IPoint::clear_has_singlePoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IPoint::clear_singlePoint() {
  if (singlePoint_ != NULL) singlePoint_->::Bentley::Geometry::Proto::ISinglePoint::Clear();
  clear_has_singlePoint();
}
inline const ::Bentley::Geometry::Proto::ISinglePoint& IPoint::singlePoint() const {
  return singlePoint_ != NULL ? *singlePoint_ : *default_instance_->singlePoint_;
}
inline ::Bentley::Geometry::Proto::ISinglePoint* IPoint::mutable_singlePoint() {
  set_has_singlePoint();
  if (singlePoint_ == NULL) singlePoint_ = new ::Bentley::Geometry::Proto::ISinglePoint;
  return singlePoint_;
}
inline ::Bentley::Geometry::Proto::ISinglePoint* IPoint::release_singlePoint() {
  clear_has_singlePoint();
  ::Bentley::Geometry::Proto::ISinglePoint* temp = singlePoint_;
  singlePoint_ = NULL;
  return temp;
}
inline void IPoint::set_allocated_singlePoint(::Bentley::Geometry::Proto::ISinglePoint* singlePoint) {
  delete singlePoint_;
  singlePoint_ = singlePoint;
  if (singlePoint) {
    set_has_singlePoint();
  } else {
    clear_has_singlePoint();
  }
}

// -------------------------------------------------------------------

// IPrimitiveCurve

// optional .Bentley.Geometry.Proto.LineSegment lineSegment = 1;
inline bool IPrimitiveCurve::has_lineSegment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IPrimitiveCurve::set_has_lineSegment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IPrimitiveCurve::clear_has_lineSegment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IPrimitiveCurve::clear_lineSegment() {
  if (lineSegment_ != NULL) lineSegment_->::Bentley::Geometry::Proto::LineSegment::Clear();
  clear_has_lineSegment();
}
inline const ::Bentley::Geometry::Proto::LineSegment& IPrimitiveCurve::lineSegment() const {
  return lineSegment_ != NULL ? *lineSegment_ : *default_instance_->lineSegment_;
}
inline ::Bentley::Geometry::Proto::LineSegment* IPrimitiveCurve::mutable_lineSegment() {
  set_has_lineSegment();
  if (lineSegment_ == NULL) lineSegment_ = new ::Bentley::Geometry::Proto::LineSegment;
  return lineSegment_;
}
inline ::Bentley::Geometry::Proto::LineSegment* IPrimitiveCurve::release_lineSegment() {
  clear_has_lineSegment();
  ::Bentley::Geometry::Proto::LineSegment* temp = lineSegment_;
  lineSegment_ = NULL;
  return temp;
}
inline void IPrimitiveCurve::set_allocated_lineSegment(::Bentley::Geometry::Proto::LineSegment* lineSegment) {
  delete lineSegment_;
  lineSegment_ = lineSegment;
  if (lineSegment) {
    set_has_lineSegment();
  } else {
    clear_has_lineSegment();
  }
}

// optional .Bentley.Geometry.Proto.LineString lineString = 2;
inline bool IPrimitiveCurve::has_lineString() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IPrimitiveCurve::set_has_lineString() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IPrimitiveCurve::clear_has_lineString() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IPrimitiveCurve::clear_lineString() {
  if (lineString_ != NULL) lineString_->::Bentley::Geometry::Proto::LineString::Clear();
  clear_has_lineString();
}
inline const ::Bentley::Geometry::Proto::LineString& IPrimitiveCurve::lineString() const {
  return lineString_ != NULL ? *lineString_ : *default_instance_->lineString_;
}
inline ::Bentley::Geometry::Proto::LineString* IPrimitiveCurve::mutable_lineString() {
  set_has_lineString();
  if (lineString_ == NULL) lineString_ = new ::Bentley::Geometry::Proto::LineString;
  return lineString_;
}
inline ::Bentley::Geometry::Proto::LineString* IPrimitiveCurve::release_lineString() {
  clear_has_lineString();
  ::Bentley::Geometry::Proto::LineString* temp = lineString_;
  lineString_ = NULL;
  return temp;
}
inline void IPrimitiveCurve::set_allocated_lineString(::Bentley::Geometry::Proto::LineString* lineString) {
  delete lineString_;
  lineString_ = lineString;
  if (lineString) {
    set_has_lineString();
  } else {
    clear_has_lineString();
  }
}

// optional .Bentley.Geometry.Proto.CircularArc circularArc = 3;
inline bool IPrimitiveCurve::has_circularArc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IPrimitiveCurve::set_has_circularArc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IPrimitiveCurve::clear_has_circularArc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IPrimitiveCurve::clear_circularArc() {
  if (circularArc_ != NULL) circularArc_->::Bentley::Geometry::Proto::CircularArc::Clear();
  clear_has_circularArc();
}
inline const ::Bentley::Geometry::Proto::CircularArc& IPrimitiveCurve::circularArc() const {
  return circularArc_ != NULL ? *circularArc_ : *default_instance_->circularArc_;
}
inline ::Bentley::Geometry::Proto::CircularArc* IPrimitiveCurve::mutable_circularArc() {
  set_has_circularArc();
  if (circularArc_ == NULL) circularArc_ = new ::Bentley::Geometry::Proto::CircularArc;
  return circularArc_;
}
inline ::Bentley::Geometry::Proto::CircularArc* IPrimitiveCurve::release_circularArc() {
  clear_has_circularArc();
  ::Bentley::Geometry::Proto::CircularArc* temp = circularArc_;
  circularArc_ = NULL;
  return temp;
}
inline void IPrimitiveCurve::set_allocated_circularArc(::Bentley::Geometry::Proto::CircularArc* circularArc) {
  delete circularArc_;
  circularArc_ = circularArc;
  if (circularArc) {
    set_has_circularArc();
  } else {
    clear_has_circularArc();
  }
}

// optional .Bentley.Geometry.Proto.EllipticArc ellipticArc = 4;
inline bool IPrimitiveCurve::has_ellipticArc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IPrimitiveCurve::set_has_ellipticArc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IPrimitiveCurve::clear_has_ellipticArc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IPrimitiveCurve::clear_ellipticArc() {
  if (ellipticArc_ != NULL) ellipticArc_->::Bentley::Geometry::Proto::EllipticArc::Clear();
  clear_has_ellipticArc();
}
inline const ::Bentley::Geometry::Proto::EllipticArc& IPrimitiveCurve::ellipticArc() const {
  return ellipticArc_ != NULL ? *ellipticArc_ : *default_instance_->ellipticArc_;
}
inline ::Bentley::Geometry::Proto::EllipticArc* IPrimitiveCurve::mutable_ellipticArc() {
  set_has_ellipticArc();
  if (ellipticArc_ == NULL) ellipticArc_ = new ::Bentley::Geometry::Proto::EllipticArc;
  return ellipticArc_;
}
inline ::Bentley::Geometry::Proto::EllipticArc* IPrimitiveCurve::release_ellipticArc() {
  clear_has_ellipticArc();
  ::Bentley::Geometry::Proto::EllipticArc* temp = ellipticArc_;
  ellipticArc_ = NULL;
  return temp;
}
inline void IPrimitiveCurve::set_allocated_ellipticArc(::Bentley::Geometry::Proto::EllipticArc* ellipticArc) {
  delete ellipticArc_;
  ellipticArc_ = ellipticArc;
  if (ellipticArc) {
    set_has_ellipticArc();
  } else {
    clear_has_ellipticArc();
  }
}

// optional .Bentley.Geometry.Proto.BsplineCurve bsplineCurve = 5;
inline bool IPrimitiveCurve::has_bsplineCurve() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IPrimitiveCurve::set_has_bsplineCurve() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IPrimitiveCurve::clear_has_bsplineCurve() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IPrimitiveCurve::clear_bsplineCurve() {
  if (bsplineCurve_ != NULL) bsplineCurve_->::Bentley::Geometry::Proto::BsplineCurve::Clear();
  clear_has_bsplineCurve();
}
inline const ::Bentley::Geometry::Proto::BsplineCurve& IPrimitiveCurve::bsplineCurve() const {
  return bsplineCurve_ != NULL ? *bsplineCurve_ : *default_instance_->bsplineCurve_;
}
inline ::Bentley::Geometry::Proto::BsplineCurve* IPrimitiveCurve::mutable_bsplineCurve() {
  set_has_bsplineCurve();
  if (bsplineCurve_ == NULL) bsplineCurve_ = new ::Bentley::Geometry::Proto::BsplineCurve;
  return bsplineCurve_;
}
inline ::Bentley::Geometry::Proto::BsplineCurve* IPrimitiveCurve::release_bsplineCurve() {
  clear_has_bsplineCurve();
  ::Bentley::Geometry::Proto::BsplineCurve* temp = bsplineCurve_;
  bsplineCurve_ = NULL;
  return temp;
}
inline void IPrimitiveCurve::set_allocated_bsplineCurve(::Bentley::Geometry::Proto::BsplineCurve* bsplineCurve) {
  delete bsplineCurve_;
  bsplineCurve_ = bsplineCurve;
  if (bsplineCurve) {
    set_has_bsplineCurve();
  } else {
    clear_has_bsplineCurve();
  }
}

// optional .Bentley.Geometry.Proto.TransitionSpiral transitionSpiral = 6;
inline bool IPrimitiveCurve::has_transitionSpiral() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IPrimitiveCurve::set_has_transitionSpiral() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IPrimitiveCurve::clear_has_transitionSpiral() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IPrimitiveCurve::clear_transitionSpiral() {
  if (transitionSpiral_ != NULL) transitionSpiral_->::Bentley::Geometry::Proto::TransitionSpiral::Clear();
  clear_has_transitionSpiral();
}
inline const ::Bentley::Geometry::Proto::TransitionSpiral& IPrimitiveCurve::transitionSpiral() const {
  return transitionSpiral_ != NULL ? *transitionSpiral_ : *default_instance_->transitionSpiral_;
}
inline ::Bentley::Geometry::Proto::TransitionSpiral* IPrimitiveCurve::mutable_transitionSpiral() {
  set_has_transitionSpiral();
  if (transitionSpiral_ == NULL) transitionSpiral_ = new ::Bentley::Geometry::Proto::TransitionSpiral;
  return transitionSpiral_;
}
inline ::Bentley::Geometry::Proto::TransitionSpiral* IPrimitiveCurve::release_transitionSpiral() {
  clear_has_transitionSpiral();
  ::Bentley::Geometry::Proto::TransitionSpiral* temp = transitionSpiral_;
  transitionSpiral_ = NULL;
  return temp;
}
inline void IPrimitiveCurve::set_allocated_transitionSpiral(::Bentley::Geometry::Proto::TransitionSpiral* transitionSpiral) {
  delete transitionSpiral_;
  transitionSpiral_ = transitionSpiral;
  if (transitionSpiral) {
    set_has_transitionSpiral();
  } else {
    clear_has_transitionSpiral();
  }
}

// -------------------------------------------------------------------

// ICurve

// optional .Bentley.Geometry.Proto.IPrimitiveCurve primtiveCurve = 1;
inline bool ICurve::has_primtiveCurve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ICurve::set_has_primtiveCurve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ICurve::clear_has_primtiveCurve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ICurve::clear_primtiveCurve() {
  if (primtiveCurve_ != NULL) primtiveCurve_->::Bentley::Geometry::Proto::IPrimitiveCurve::Clear();
  clear_has_primtiveCurve();
}
inline const ::Bentley::Geometry::Proto::IPrimitiveCurve& ICurve::primtiveCurve() const {
  return primtiveCurve_ != NULL ? *primtiveCurve_ : *default_instance_->primtiveCurve_;
}
inline ::Bentley::Geometry::Proto::IPrimitiveCurve* ICurve::mutable_primtiveCurve() {
  set_has_primtiveCurve();
  if (primtiveCurve_ == NULL) primtiveCurve_ = new ::Bentley::Geometry::Proto::IPrimitiveCurve;
  return primtiveCurve_;
}
inline ::Bentley::Geometry::Proto::IPrimitiveCurve* ICurve::release_primtiveCurve() {
  clear_has_primtiveCurve();
  ::Bentley::Geometry::Proto::IPrimitiveCurve* temp = primtiveCurve_;
  primtiveCurve_ = NULL;
  return temp;
}
inline void ICurve::set_allocated_primtiveCurve(::Bentley::Geometry::Proto::IPrimitiveCurve* primtiveCurve) {
  delete primtiveCurve_;
  primtiveCurve_ = primtiveCurve;
  if (primtiveCurve) {
    set_has_primtiveCurve();
  } else {
    clear_has_primtiveCurve();
  }
}

// optional .Bentley.Geometry.Proto.CurveChain curveChain = 2;
inline bool ICurve::has_curveChain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ICurve::set_has_curveChain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ICurve::clear_has_curveChain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ICurve::clear_curveChain() {
  if (curveChain_ != NULL) curveChain_->::Bentley::Geometry::Proto::CurveChain::Clear();
  clear_has_curveChain();
}
inline const ::Bentley::Geometry::Proto::CurveChain& ICurve::curveChain() const {
  return curveChain_ != NULL ? *curveChain_ : *default_instance_->curveChain_;
}
inline ::Bentley::Geometry::Proto::CurveChain* ICurve::mutable_curveChain() {
  set_has_curveChain();
  if (curveChain_ == NULL) curveChain_ = new ::Bentley::Geometry::Proto::CurveChain;
  return curveChain_;
}
inline ::Bentley::Geometry::Proto::CurveChain* ICurve::release_curveChain() {
  clear_has_curveChain();
  ::Bentley::Geometry::Proto::CurveChain* temp = curveChain_;
  curveChain_ = NULL;
  return temp;
}
inline void ICurve::set_allocated_curveChain(::Bentley::Geometry::Proto::CurveChain* curveChain) {
  delete curveChain_;
  curveChain_ = curveChain;
  if (curveChain) {
    set_has_curveChain();
  } else {
    clear_has_curveChain();
  }
}

// -------------------------------------------------------------------

// ICurveChain

// optional .Bentley.Geometry.Proto.CurveChain curveChain = 1;
inline bool ICurveChain::has_curveChain() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ICurveChain::set_has_curveChain() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ICurveChain::clear_has_curveChain() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ICurveChain::clear_curveChain() {
  if (curveChain_ != NULL) curveChain_->::Bentley::Geometry::Proto::CurveChain::Clear();
  clear_has_curveChain();
}
inline const ::Bentley::Geometry::Proto::CurveChain& ICurveChain::curveChain() const {
  return curveChain_ != NULL ? *curveChain_ : *default_instance_->curveChain_;
}
inline ::Bentley::Geometry::Proto::CurveChain* ICurveChain::mutable_curveChain() {
  set_has_curveChain();
  if (curveChain_ == NULL) curveChain_ = new ::Bentley::Geometry::Proto::CurveChain;
  return curveChain_;
}
inline ::Bentley::Geometry::Proto::CurveChain* ICurveChain::release_curveChain() {
  clear_has_curveChain();
  ::Bentley::Geometry::Proto::CurveChain* temp = curveChain_;
  curveChain_ = NULL;
  return temp;
}
inline void ICurveChain::set_allocated_curveChain(::Bentley::Geometry::Proto::CurveChain* curveChain) {
  delete curveChain_;
  curveChain_ = curveChain;
  if (curveChain) {
    set_has_curveChain();
  } else {
    clear_has_curveChain();
  }
}

// -------------------------------------------------------------------

// ISolid

// optional .Bentley.Geometry.Proto.IAnalyticSolid analyticSolid = 1;
inline bool ISolid::has_analyticSolid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ISolid::set_has_analyticSolid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ISolid::clear_has_analyticSolid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ISolid::clear_analyticSolid() {
  if (analyticSolid_ != NULL) analyticSolid_->::Bentley::Geometry::Proto::IAnalyticSolid::Clear();
  clear_has_analyticSolid();
}
inline const ::Bentley::Geometry::Proto::IAnalyticSolid& ISolid::analyticSolid() const {
  return analyticSolid_ != NULL ? *analyticSolid_ : *default_instance_->analyticSolid_;
}
inline ::Bentley::Geometry::Proto::IAnalyticSolid* ISolid::mutable_analyticSolid() {
  set_has_analyticSolid();
  if (analyticSolid_ == NULL) analyticSolid_ = new ::Bentley::Geometry::Proto::IAnalyticSolid;
  return analyticSolid_;
}
inline ::Bentley::Geometry::Proto::IAnalyticSolid* ISolid::release_analyticSolid() {
  clear_has_analyticSolid();
  ::Bentley::Geometry::Proto::IAnalyticSolid* temp = analyticSolid_;
  analyticSolid_ = NULL;
  return temp;
}
inline void ISolid::set_allocated_analyticSolid(::Bentley::Geometry::Proto::IAnalyticSolid* analyticSolid) {
  delete analyticSolid_;
  analyticSolid_ = analyticSolid;
  if (analyticSolid) {
    set_has_analyticSolid();
  } else {
    clear_has_analyticSolid();
  }
}

// optional .Bentley.Geometry.Proto.SolidBySweptSurface solidBySweptSurface = 102;
inline bool ISolid::has_solidBySweptSurface() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ISolid::set_has_solidBySweptSurface() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ISolid::clear_has_solidBySweptSurface() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ISolid::clear_solidBySweptSurface() {
  if (solidBySweptSurface_ != NULL) solidBySweptSurface_->::Bentley::Geometry::Proto::SolidBySweptSurface::Clear();
  clear_has_solidBySweptSurface();
}
inline const ::Bentley::Geometry::Proto::SolidBySweptSurface& ISolid::solidBySweptSurface() const {
  return solidBySweptSurface_ != NULL ? *solidBySweptSurface_ : *default_instance_->solidBySweptSurface_;
}
inline ::Bentley::Geometry::Proto::SolidBySweptSurface* ISolid::mutable_solidBySweptSurface() {
  set_has_solidBySweptSurface();
  if (solidBySweptSurface_ == NULL) solidBySweptSurface_ = new ::Bentley::Geometry::Proto::SolidBySweptSurface;
  return solidBySweptSurface_;
}
inline ::Bentley::Geometry::Proto::SolidBySweptSurface* ISolid::release_solidBySweptSurface() {
  clear_has_solidBySweptSurface();
  ::Bentley::Geometry::Proto::SolidBySweptSurface* temp = solidBySweptSurface_;
  solidBySweptSurface_ = NULL;
  return temp;
}
inline void ISolid::set_allocated_solidBySweptSurface(::Bentley::Geometry::Proto::SolidBySweptSurface* solidBySweptSurface) {
  delete solidBySweptSurface_;
  solidBySweptSurface_ = solidBySweptSurface;
  if (solidBySweptSurface) {
    set_has_solidBySweptSurface();
  } else {
    clear_has_solidBySweptSurface();
  }
}

// -------------------------------------------------------------------

// IAnalyticSolid

// optional .Bentley.Geometry.Proto.Block block = 1;
inline bool IAnalyticSolid::has_block() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IAnalyticSolid::set_has_block() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IAnalyticSolid::clear_has_block() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IAnalyticSolid::clear_block() {
  if (block_ != NULL) block_->::Bentley::Geometry::Proto::Block::Clear();
  clear_has_block();
}
inline const ::Bentley::Geometry::Proto::Block& IAnalyticSolid::block() const {
  return block_ != NULL ? *block_ : *default_instance_->block_;
}
inline ::Bentley::Geometry::Proto::Block* IAnalyticSolid::mutable_block() {
  set_has_block();
  if (block_ == NULL) block_ = new ::Bentley::Geometry::Proto::Block;
  return block_;
}
inline ::Bentley::Geometry::Proto::Block* IAnalyticSolid::release_block() {
  clear_has_block();
  ::Bentley::Geometry::Proto::Block* temp = block_;
  block_ = NULL;
  return temp;
}
inline void IAnalyticSolid::set_allocated_block(::Bentley::Geometry::Proto::Block* block) {
  delete block_;
  block_ = block;
  if (block) {
    set_has_block();
  } else {
    clear_has_block();
  }
}

// optional .Bentley.Geometry.Proto.CircularCone circularCone = 2;
inline bool IAnalyticSolid::has_circularCone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IAnalyticSolid::set_has_circularCone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IAnalyticSolid::clear_has_circularCone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IAnalyticSolid::clear_circularCone() {
  if (circularCone_ != NULL) circularCone_->::Bentley::Geometry::Proto::CircularCone::Clear();
  clear_has_circularCone();
}
inline const ::Bentley::Geometry::Proto::CircularCone& IAnalyticSolid::circularCone() const {
  return circularCone_ != NULL ? *circularCone_ : *default_instance_->circularCone_;
}
inline ::Bentley::Geometry::Proto::CircularCone* IAnalyticSolid::mutable_circularCone() {
  set_has_circularCone();
  if (circularCone_ == NULL) circularCone_ = new ::Bentley::Geometry::Proto::CircularCone;
  return circularCone_;
}
inline ::Bentley::Geometry::Proto::CircularCone* IAnalyticSolid::release_circularCone() {
  clear_has_circularCone();
  ::Bentley::Geometry::Proto::CircularCone* temp = circularCone_;
  circularCone_ = NULL;
  return temp;
}
inline void IAnalyticSolid::set_allocated_circularCone(::Bentley::Geometry::Proto::CircularCone* circularCone) {
  delete circularCone_;
  circularCone_ = circularCone;
  if (circularCone) {
    set_has_circularCone();
  } else {
    clear_has_circularCone();
  }
}

// optional .Bentley.Geometry.Proto.SkewedCone skewedCone = 3;
inline bool IAnalyticSolid::has_skewedCone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IAnalyticSolid::set_has_skewedCone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IAnalyticSolid::clear_has_skewedCone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IAnalyticSolid::clear_skewedCone() {
  if (skewedCone_ != NULL) skewedCone_->::Bentley::Geometry::Proto::SkewedCone::Clear();
  clear_has_skewedCone();
}
inline const ::Bentley::Geometry::Proto::SkewedCone& IAnalyticSolid::skewedCone() const {
  return skewedCone_ != NULL ? *skewedCone_ : *default_instance_->skewedCone_;
}
inline ::Bentley::Geometry::Proto::SkewedCone* IAnalyticSolid::mutable_skewedCone() {
  set_has_skewedCone();
  if (skewedCone_ == NULL) skewedCone_ = new ::Bentley::Geometry::Proto::SkewedCone;
  return skewedCone_;
}
inline ::Bentley::Geometry::Proto::SkewedCone* IAnalyticSolid::release_skewedCone() {
  clear_has_skewedCone();
  ::Bentley::Geometry::Proto::SkewedCone* temp = skewedCone_;
  skewedCone_ = NULL;
  return temp;
}
inline void IAnalyticSolid::set_allocated_skewedCone(::Bentley::Geometry::Proto::SkewedCone* skewedCone) {
  delete skewedCone_;
  skewedCone_ = skewedCone;
  if (skewedCone) {
    set_has_skewedCone();
  } else {
    clear_has_skewedCone();
  }
}

// optional .Bentley.Geometry.Proto.Sphere sphere = 4;
inline bool IAnalyticSolid::has_sphere() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IAnalyticSolid::set_has_sphere() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IAnalyticSolid::clear_has_sphere() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IAnalyticSolid::clear_sphere() {
  if (sphere_ != NULL) sphere_->::Bentley::Geometry::Proto::Sphere::Clear();
  clear_has_sphere();
}
inline const ::Bentley::Geometry::Proto::Sphere& IAnalyticSolid::sphere() const {
  return sphere_ != NULL ? *sphere_ : *default_instance_->sphere_;
}
inline ::Bentley::Geometry::Proto::Sphere* IAnalyticSolid::mutable_sphere() {
  set_has_sphere();
  if (sphere_ == NULL) sphere_ = new ::Bentley::Geometry::Proto::Sphere;
  return sphere_;
}
inline ::Bentley::Geometry::Proto::Sphere* IAnalyticSolid::release_sphere() {
  clear_has_sphere();
  ::Bentley::Geometry::Proto::Sphere* temp = sphere_;
  sphere_ = NULL;
  return temp;
}
inline void IAnalyticSolid::set_allocated_sphere(::Bentley::Geometry::Proto::Sphere* sphere) {
  delete sphere_;
  sphere_ = sphere;
  if (sphere) {
    set_has_sphere();
  } else {
    clear_has_sphere();
  }
}

// optional .Bentley.Geometry.Proto.TorusPipe torusPipe = 5;
inline bool IAnalyticSolid::has_torusPipe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IAnalyticSolid::set_has_torusPipe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IAnalyticSolid::clear_has_torusPipe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IAnalyticSolid::clear_torusPipe() {
  if (torusPipe_ != NULL) torusPipe_->::Bentley::Geometry::Proto::TorusPipe::Clear();
  clear_has_torusPipe();
}
inline const ::Bentley::Geometry::Proto::TorusPipe& IAnalyticSolid::torusPipe() const {
  return torusPipe_ != NULL ? *torusPipe_ : *default_instance_->torusPipe_;
}
inline ::Bentley::Geometry::Proto::TorusPipe* IAnalyticSolid::mutable_torusPipe() {
  set_has_torusPipe();
  if (torusPipe_ == NULL) torusPipe_ = new ::Bentley::Geometry::Proto::TorusPipe;
  return torusPipe_;
}
inline ::Bentley::Geometry::Proto::TorusPipe* IAnalyticSolid::release_torusPipe() {
  clear_has_torusPipe();
  ::Bentley::Geometry::Proto::TorusPipe* temp = torusPipe_;
  torusPipe_ = NULL;
  return temp;
}
inline void IAnalyticSolid::set_allocated_torusPipe(::Bentley::Geometry::Proto::TorusPipe* torusPipe) {
  delete torusPipe_;
  torusPipe_ = torusPipe;
  if (torusPipe) {
    set_has_torusPipe();
  } else {
    clear_has_torusPipe();
  }
}

// -------------------------------------------------------------------

// ISurface

// optional .Bentley.Geometry.Proto.Polygon polygon = 1;
inline bool ISurface::has_polygon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ISurface::set_has_polygon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ISurface::clear_has_polygon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ISurface::clear_polygon() {
  if (polygon_ != NULL) polygon_->::Bentley::Geometry::Proto::Polygon::Clear();
  clear_has_polygon();
}
inline const ::Bentley::Geometry::Proto::Polygon& ISurface::polygon() const {
  return polygon_ != NULL ? *polygon_ : *default_instance_->polygon_;
}
inline ::Bentley::Geometry::Proto::Polygon* ISurface::mutable_polygon() {
  set_has_polygon();
  if (polygon_ == NULL) polygon_ = new ::Bentley::Geometry::Proto::Polygon;
  return polygon_;
}
inline ::Bentley::Geometry::Proto::Polygon* ISurface::release_polygon() {
  clear_has_polygon();
  ::Bentley::Geometry::Proto::Polygon* temp = polygon_;
  polygon_ = NULL;
  return temp;
}
inline void ISurface::set_allocated_polygon(::Bentley::Geometry::Proto::Polygon* polygon) {
  delete polygon_;
  polygon_ = polygon;
  if (polygon) {
    set_has_polygon();
  } else {
    clear_has_polygon();
  }
}

// optional .Bentley.Geometry.Proto.CircularDisk circularDisk = 2;
inline bool ISurface::has_circularDisk() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ISurface::set_has_circularDisk() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ISurface::clear_has_circularDisk() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ISurface::clear_circularDisk() {
  if (circularDisk_ != NULL) circularDisk_->::Bentley::Geometry::Proto::CircularDisk::Clear();
  clear_has_circularDisk();
}
inline const ::Bentley::Geometry::Proto::CircularDisk& ISurface::circularDisk() const {
  return circularDisk_ != NULL ? *circularDisk_ : *default_instance_->circularDisk_;
}
inline ::Bentley::Geometry::Proto::CircularDisk* ISurface::mutable_circularDisk() {
  set_has_circularDisk();
  if (circularDisk_ == NULL) circularDisk_ = new ::Bentley::Geometry::Proto::CircularDisk;
  return circularDisk_;
}
inline ::Bentley::Geometry::Proto::CircularDisk* ISurface::release_circularDisk() {
  clear_has_circularDisk();
  ::Bentley::Geometry::Proto::CircularDisk* temp = circularDisk_;
  circularDisk_ = NULL;
  return temp;
}
inline void ISurface::set_allocated_circularDisk(::Bentley::Geometry::Proto::CircularDisk* circularDisk) {
  delete circularDisk_;
  circularDisk_ = circularDisk;
  if (circularDisk) {
    set_has_circularDisk();
  } else {
    clear_has_circularDisk();
  }
}

// optional .Bentley.Geometry.Proto.EllipticDisk ellipticDisk = 3;
inline bool ISurface::has_ellipticDisk() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ISurface::set_has_ellipticDisk() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ISurface::clear_has_ellipticDisk() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ISurface::clear_ellipticDisk() {
  if (ellipticDisk_ != NULL) ellipticDisk_->::Bentley::Geometry::Proto::EllipticDisk::Clear();
  clear_has_ellipticDisk();
}
inline const ::Bentley::Geometry::Proto::EllipticDisk& ISurface::ellipticDisk() const {
  return ellipticDisk_ != NULL ? *ellipticDisk_ : *default_instance_->ellipticDisk_;
}
inline ::Bentley::Geometry::Proto::EllipticDisk* ISurface::mutable_ellipticDisk() {
  set_has_ellipticDisk();
  if (ellipticDisk_ == NULL) ellipticDisk_ = new ::Bentley::Geometry::Proto::EllipticDisk;
  return ellipticDisk_;
}
inline ::Bentley::Geometry::Proto::EllipticDisk* ISurface::release_ellipticDisk() {
  clear_has_ellipticDisk();
  ::Bentley::Geometry::Proto::EllipticDisk* temp = ellipticDisk_;
  ellipticDisk_ = NULL;
  return temp;
}
inline void ISurface::set_allocated_ellipticDisk(::Bentley::Geometry::Proto::EllipticDisk* ellipticDisk) {
  delete ellipticDisk_;
  ellipticDisk_ = ellipticDisk;
  if (ellipticDisk) {
    set_has_ellipticDisk();
  } else {
    clear_has_ellipticDisk();
  }
}

// optional .Bentley.Geometry.Proto.BsplineSurface bsplineSuface = 100;
inline bool ISurface::has_bsplineSuface() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ISurface::set_has_bsplineSuface() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ISurface::clear_has_bsplineSuface() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ISurface::clear_bsplineSuface() {
  if (bsplineSuface_ != NULL) bsplineSuface_->::Bentley::Geometry::Proto::BsplineSurface::Clear();
  clear_has_bsplineSuface();
}
inline const ::Bentley::Geometry::Proto::BsplineSurface& ISurface::bsplineSuface() const {
  return bsplineSuface_ != NULL ? *bsplineSuface_ : *default_instance_->bsplineSuface_;
}
inline ::Bentley::Geometry::Proto::BsplineSurface* ISurface::mutable_bsplineSuface() {
  set_has_bsplineSuface();
  if (bsplineSuface_ == NULL) bsplineSuface_ = new ::Bentley::Geometry::Proto::BsplineSurface;
  return bsplineSuface_;
}
inline ::Bentley::Geometry::Proto::BsplineSurface* ISurface::release_bsplineSuface() {
  clear_has_bsplineSuface();
  ::Bentley::Geometry::Proto::BsplineSurface* temp = bsplineSuface_;
  bsplineSuface_ = NULL;
  return temp;
}
inline void ISurface::set_allocated_bsplineSuface(::Bentley::Geometry::Proto::BsplineSurface* bsplineSuface) {
  delete bsplineSuface_;
  bsplineSuface_ = bsplineSuface;
  if (bsplineSuface) {
    set_has_bsplineSuface();
  } else {
    clear_has_bsplineSuface();
  }
}

// optional .Bentley.Geometry.Proto.IndexedMesh indexedMesh = 101;
inline bool ISurface::has_indexedMesh() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ISurface::set_has_indexedMesh() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ISurface::clear_has_indexedMesh() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ISurface::clear_indexedMesh() {
  if (indexedMesh_ != NULL) indexedMesh_->::Bentley::Geometry::Proto::IndexedMesh::Clear();
  clear_has_indexedMesh();
}
inline const ::Bentley::Geometry::Proto::IndexedMesh& ISurface::indexedMesh() const {
  return indexedMesh_ != NULL ? *indexedMesh_ : *default_instance_->indexedMesh_;
}
inline ::Bentley::Geometry::Proto::IndexedMesh* ISurface::mutable_indexedMesh() {
  set_has_indexedMesh();
  if (indexedMesh_ == NULL) indexedMesh_ = new ::Bentley::Geometry::Proto::IndexedMesh;
  return indexedMesh_;
}
inline ::Bentley::Geometry::Proto::IndexedMesh* ISurface::release_indexedMesh() {
  clear_has_indexedMesh();
  ::Bentley::Geometry::Proto::IndexedMesh* temp = indexedMesh_;
  indexedMesh_ = NULL;
  return temp;
}
inline void ISurface::set_allocated_indexedMesh(::Bentley::Geometry::Proto::IndexedMesh* indexedMesh) {
  delete indexedMesh_;
  indexedMesh_ = indexedMesh;
  if (indexedMesh) {
    set_has_indexedMesh();
  } else {
    clear_has_indexedMesh();
  }
}

// optional .Bentley.Geometry.Proto.ParametricSurfacePatch parametricSurfacePatch = 102;
inline bool ISurface::has_parametricSurfacePatch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ISurface::set_has_parametricSurfacePatch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ISurface::clear_has_parametricSurfacePatch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ISurface::clear_parametricSurfacePatch() {
  if (parametricSurfacePatch_ != NULL) parametricSurfacePatch_->::Bentley::Geometry::Proto::ParametricSurfacePatch::Clear();
  clear_has_parametricSurfacePatch();
}
inline const ::Bentley::Geometry::Proto::ParametricSurfacePatch& ISurface::parametricSurfacePatch() const {
  return parametricSurfacePatch_ != NULL ? *parametricSurfacePatch_ : *default_instance_->parametricSurfacePatch_;
}
inline ::Bentley::Geometry::Proto::ParametricSurfacePatch* ISurface::mutable_parametricSurfacePatch() {
  set_has_parametricSurfacePatch();
  if (parametricSurfacePatch_ == NULL) parametricSurfacePatch_ = new ::Bentley::Geometry::Proto::ParametricSurfacePatch;
  return parametricSurfacePatch_;
}
inline ::Bentley::Geometry::Proto::ParametricSurfacePatch* ISurface::release_parametricSurfacePatch() {
  clear_has_parametricSurfacePatch();
  ::Bentley::Geometry::Proto::ParametricSurfacePatch* temp = parametricSurfacePatch_;
  parametricSurfacePatch_ = NULL;
  return temp;
}
inline void ISurface::set_allocated_parametricSurfacePatch(::Bentley::Geometry::Proto::ParametricSurfacePatch* parametricSurfacePatch) {
  delete parametricSurfacePatch_;
  parametricSurfacePatch_ = parametricSurfacePatch;
  if (parametricSurfacePatch) {
    set_has_parametricSurfacePatch();
  } else {
    clear_has_parametricSurfacePatch();
  }
}

// optional .Bentley.Geometry.Proto.SurfaceBySweptCurve surfaceBySweptCurve = 103;
inline bool ISurface::has_surfaceBySweptCurve() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ISurface::set_has_surfaceBySweptCurve() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ISurface::clear_has_surfaceBySweptCurve() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ISurface::clear_surfaceBySweptCurve() {
  if (surfaceBySweptCurve_ != NULL) surfaceBySweptCurve_->::Bentley::Geometry::Proto::SurfaceBySweptCurve::Clear();
  clear_has_surfaceBySweptCurve();
}
inline const ::Bentley::Geometry::Proto::SurfaceBySweptCurve& ISurface::surfaceBySweptCurve() const {
  return surfaceBySweptCurve_ != NULL ? *surfaceBySweptCurve_ : *default_instance_->surfaceBySweptCurve_;
}
inline ::Bentley::Geometry::Proto::SurfaceBySweptCurve* ISurface::mutable_surfaceBySweptCurve() {
  set_has_surfaceBySweptCurve();
  if (surfaceBySweptCurve_ == NULL) surfaceBySweptCurve_ = new ::Bentley::Geometry::Proto::SurfaceBySweptCurve;
  return surfaceBySweptCurve_;
}
inline ::Bentley::Geometry::Proto::SurfaceBySweptCurve* ISurface::release_surfaceBySweptCurve() {
  clear_has_surfaceBySweptCurve();
  ::Bentley::Geometry::Proto::SurfaceBySweptCurve* temp = surfaceBySweptCurve_;
  surfaceBySweptCurve_ = NULL;
  return temp;
}
inline void ISurface::set_allocated_surfaceBySweptCurve(::Bentley::Geometry::Proto::SurfaceBySweptCurve* surfaceBySweptCurve) {
  delete surfaceBySweptCurve_;
  surfaceBySweptCurve_ = surfaceBySweptCurve;
  if (surfaceBySweptCurve) {
    set_has_surfaceBySweptCurve();
  } else {
    clear_has_surfaceBySweptCurve();
  }
}

// optional .Bentley.Geometry.Proto.SurfaceGroup surfaceGroup = 104;
inline bool ISurface::has_surfaceGroup() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ISurface::set_has_surfaceGroup() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ISurface::clear_has_surfaceGroup() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ISurface::clear_surfaceGroup() {
  if (surfaceGroup_ != NULL) surfaceGroup_->::Bentley::Geometry::Proto::SurfaceGroup::Clear();
  clear_has_surfaceGroup();
}
inline const ::Bentley::Geometry::Proto::SurfaceGroup& ISurface::surfaceGroup() const {
  return surfaceGroup_ != NULL ? *surfaceGroup_ : *default_instance_->surfaceGroup_;
}
inline ::Bentley::Geometry::Proto::SurfaceGroup* ISurface::mutable_surfaceGroup() {
  set_has_surfaceGroup();
  if (surfaceGroup_ == NULL) surfaceGroup_ = new ::Bentley::Geometry::Proto::SurfaceGroup;
  return surfaceGroup_;
}
inline ::Bentley::Geometry::Proto::SurfaceGroup* ISurface::release_surfaceGroup() {
  clear_has_surfaceGroup();
  ::Bentley::Geometry::Proto::SurfaceGroup* temp = surfaceGroup_;
  surfaceGroup_ = NULL;
  return temp;
}
inline void ISurface::set_allocated_surfaceGroup(::Bentley::Geometry::Proto::SurfaceGroup* surfaceGroup) {
  delete surfaceGroup_;
  surfaceGroup_ = surfaceGroup;
  if (surfaceGroup) {
    set_has_surfaceGroup();
  } else {
    clear_has_surfaceGroup();
  }
}

// optional .Bentley.Geometry.Proto.SurfacePatch surfacePatch = 105;
inline bool ISurface::has_surfacePatch() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ISurface::set_has_surfacePatch() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ISurface::clear_has_surfacePatch() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ISurface::clear_surfacePatch() {
  if (surfacePatch_ != NULL) surfacePatch_->::Bentley::Geometry::Proto::SurfacePatch::Clear();
  clear_has_surfacePatch();
}
inline const ::Bentley::Geometry::Proto::SurfacePatch& ISurface::surfacePatch() const {
  return surfacePatch_ != NULL ? *surfacePatch_ : *default_instance_->surfacePatch_;
}
inline ::Bentley::Geometry::Proto::SurfacePatch* ISurface::mutable_surfacePatch() {
  set_has_surfacePatch();
  if (surfacePatch_ == NULL) surfacePatch_ = new ::Bentley::Geometry::Proto::SurfacePatch;
  return surfacePatch_;
}
inline ::Bentley::Geometry::Proto::SurfacePatch* ISurface::release_surfacePatch() {
  clear_has_surfacePatch();
  ::Bentley::Geometry::Proto::SurfacePatch* temp = surfacePatch_;
  surfacePatch_ = NULL;
  return temp;
}
inline void ISurface::set_allocated_surfacePatch(::Bentley::Geometry::Proto::SurfacePatch* surfacePatch) {
  delete surfacePatch_;
  surfacePatch_ = surfacePatch;
  if (surfacePatch) {
    set_has_surfacePatch();
  } else {
    clear_has_surfacePatch();
  }
}

// -------------------------------------------------------------------

// ISurfacePatch

// optional .Bentley.Geometry.Proto.ParametricSurfacePatch parametricSurfacePatch = 1;
inline bool ISurfacePatch::has_parametricSurfacePatch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ISurfacePatch::set_has_parametricSurfacePatch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ISurfacePatch::clear_has_parametricSurfacePatch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ISurfacePatch::clear_parametricSurfacePatch() {
  if (parametricSurfacePatch_ != NULL) parametricSurfacePatch_->::Bentley::Geometry::Proto::ParametricSurfacePatch::Clear();
  clear_has_parametricSurfacePatch();
}
inline const ::Bentley::Geometry::Proto::ParametricSurfacePatch& ISurfacePatch::parametricSurfacePatch() const {
  return parametricSurfacePatch_ != NULL ? *parametricSurfacePatch_ : *default_instance_->parametricSurfacePatch_;
}
inline ::Bentley::Geometry::Proto::ParametricSurfacePatch* ISurfacePatch::mutable_parametricSurfacePatch() {
  set_has_parametricSurfacePatch();
  if (parametricSurfacePatch_ == NULL) parametricSurfacePatch_ = new ::Bentley::Geometry::Proto::ParametricSurfacePatch;
  return parametricSurfacePatch_;
}
inline ::Bentley::Geometry::Proto::ParametricSurfacePatch* ISurfacePatch::release_parametricSurfacePatch() {
  clear_has_parametricSurfacePatch();
  ::Bentley::Geometry::Proto::ParametricSurfacePatch* temp = parametricSurfacePatch_;
  parametricSurfacePatch_ = NULL;
  return temp;
}
inline void ISurfacePatch::set_allocated_parametricSurfacePatch(::Bentley::Geometry::Proto::ParametricSurfacePatch* parametricSurfacePatch) {
  delete parametricSurfacePatch_;
  parametricSurfacePatch_ = parametricSurfacePatch;
  if (parametricSurfacePatch) {
    set_has_parametricSurfacePatch();
  } else {
    clear_has_parametricSurfacePatch();
  }
}

// -------------------------------------------------------------------

// IParametricSurface

// optional .Bentley.Geometry.Proto.BsplineSurface bsplineSuface = 1;
inline bool IParametricSurface::has_bsplineSuface() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IParametricSurface::set_has_bsplineSuface() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IParametricSurface::clear_has_bsplineSuface() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IParametricSurface::clear_bsplineSuface() {
  if (bsplineSuface_ != NULL) bsplineSuface_->::Bentley::Geometry::Proto::BsplineSurface::Clear();
  clear_has_bsplineSuface();
}
inline const ::Bentley::Geometry::Proto::BsplineSurface& IParametricSurface::bsplineSuface() const {
  return bsplineSuface_ != NULL ? *bsplineSuface_ : *default_instance_->bsplineSuface_;
}
inline ::Bentley::Geometry::Proto::BsplineSurface* IParametricSurface::mutable_bsplineSuface() {
  set_has_bsplineSuface();
  if (bsplineSuface_ == NULL) bsplineSuface_ = new ::Bentley::Geometry::Proto::BsplineSurface;
  return bsplineSuface_;
}
inline ::Bentley::Geometry::Proto::BsplineSurface* IParametricSurface::release_bsplineSuface() {
  clear_has_bsplineSuface();
  ::Bentley::Geometry::Proto::BsplineSurface* temp = bsplineSuface_;
  bsplineSuface_ = NULL;
  return temp;
}
inline void IParametricSurface::set_allocated_bsplineSuface(::Bentley::Geometry::Proto::BsplineSurface* bsplineSuface) {
  delete bsplineSuface_;
  bsplineSuface_ = bsplineSuface;
  if (bsplineSuface) {
    set_has_bsplineSuface();
  } else {
    clear_has_bsplineSuface();
  }
}

// -------------------------------------------------------------------

// IGeometry

// optional .Bentley.Geometry.Proto.IPoint point = 1;
inline bool IGeometry::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IGeometry::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IGeometry::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IGeometry::clear_point() {
  if (point_ != NULL) point_->::Bentley::Geometry::Proto::IPoint::Clear();
  clear_has_point();
}
inline const ::Bentley::Geometry::Proto::IPoint& IGeometry::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::Bentley::Geometry::Proto::IPoint* IGeometry::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::Bentley::Geometry::Proto::IPoint;
  return point_;
}
inline ::Bentley::Geometry::Proto::IPoint* IGeometry::release_point() {
  clear_has_point();
  ::Bentley::Geometry::Proto::IPoint* temp = point_;
  point_ = NULL;
  return temp;
}
inline void IGeometry::set_allocated_point(::Bentley::Geometry::Proto::IPoint* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
}

// optional .Bentley.Geometry.Proto.ICurve curve = 2;
inline bool IGeometry::has_curve() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IGeometry::set_has_curve() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IGeometry::clear_has_curve() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IGeometry::clear_curve() {
  if (curve_ != NULL) curve_->::Bentley::Geometry::Proto::ICurve::Clear();
  clear_has_curve();
}
inline const ::Bentley::Geometry::Proto::ICurve& IGeometry::curve() const {
  return curve_ != NULL ? *curve_ : *default_instance_->curve_;
}
inline ::Bentley::Geometry::Proto::ICurve* IGeometry::mutable_curve() {
  set_has_curve();
  if (curve_ == NULL) curve_ = new ::Bentley::Geometry::Proto::ICurve;
  return curve_;
}
inline ::Bentley::Geometry::Proto::ICurve* IGeometry::release_curve() {
  clear_has_curve();
  ::Bentley::Geometry::Proto::ICurve* temp = curve_;
  curve_ = NULL;
  return temp;
}
inline void IGeometry::set_allocated_curve(::Bentley::Geometry::Proto::ICurve* curve) {
  delete curve_;
  curve_ = curve;
  if (curve) {
    set_has_curve();
  } else {
    clear_has_curve();
  }
}

// optional .Bentley.Geometry.Proto.ISurface surface = 3;
inline bool IGeometry::has_surface() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IGeometry::set_has_surface() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IGeometry::clear_has_surface() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IGeometry::clear_surface() {
  if (surface_ != NULL) surface_->::Bentley::Geometry::Proto::ISurface::Clear();
  clear_has_surface();
}
inline const ::Bentley::Geometry::Proto::ISurface& IGeometry::surface() const {
  return surface_ != NULL ? *surface_ : *default_instance_->surface_;
}
inline ::Bentley::Geometry::Proto::ISurface* IGeometry::mutable_surface() {
  set_has_surface();
  if (surface_ == NULL) surface_ = new ::Bentley::Geometry::Proto::ISurface;
  return surface_;
}
inline ::Bentley::Geometry::Proto::ISurface* IGeometry::release_surface() {
  clear_has_surface();
  ::Bentley::Geometry::Proto::ISurface* temp = surface_;
  surface_ = NULL;
  return temp;
}
inline void IGeometry::set_allocated_surface(::Bentley::Geometry::Proto::ISurface* surface) {
  delete surface_;
  surface_ = surface;
  if (surface) {
    set_has_surface();
  } else {
    clear_has_surface();
  }
}

// optional .Bentley.Geometry.Proto.ISolid solid = 4;
inline bool IGeometry::has_solid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IGeometry::set_has_solid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IGeometry::clear_has_solid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IGeometry::clear_solid() {
  if (solid_ != NULL) solid_->::Bentley::Geometry::Proto::ISolid::Clear();
  clear_has_solid();
}
inline const ::Bentley::Geometry::Proto::ISolid& IGeometry::solid() const {
  return solid_ != NULL ? *solid_ : *default_instance_->solid_;
}
inline ::Bentley::Geometry::Proto::ISolid* IGeometry::mutable_solid() {
  set_has_solid();
  if (solid_ == NULL) solid_ = new ::Bentley::Geometry::Proto::ISolid;
  return solid_;
}
inline ::Bentley::Geometry::Proto::ISolid* IGeometry::release_solid() {
  clear_has_solid();
  ::Bentley::Geometry::Proto::ISolid* temp = solid_;
  solid_ = NULL;
  return temp;
}
inline void IGeometry::set_allocated_solid(::Bentley::Geometry::Proto::ISolid* solid) {
  delete solid_;
  solid_ = solid;
  if (solid) {
    set_has_solid();
  } else {
    clear_has_solid();
  }
}

// -------------------------------------------------------------------

// Block

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool Block::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Block::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Block::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Block::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& Block::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* Block::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* Block::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void Block::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required .Bentley.Geometry.Proto.DPoint3d cornerA = 2;
inline bool Block::has_cornerA() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Block::set_has_cornerA() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Block::clear_has_cornerA() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Block::clear_cornerA() {
  if (cornerA_ != NULL) cornerA_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_cornerA();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& Block::cornerA() const {
  return cornerA_ != NULL ? *cornerA_ : *default_instance_->cornerA_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Block::mutable_cornerA() {
  set_has_cornerA();
  if (cornerA_ == NULL) cornerA_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return cornerA_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Block::release_cornerA() {
  clear_has_cornerA();
  ::Bentley::Geometry::Proto::DPoint3d* temp = cornerA_;
  cornerA_ = NULL;
  return temp;
}
inline void Block::set_allocated_cornerA(::Bentley::Geometry::Proto::DPoint3d* cornerA) {
  delete cornerA_;
  cornerA_ = cornerA;
  if (cornerA) {
    set_has_cornerA();
  } else {
    clear_has_cornerA();
  }
}

// required .Bentley.Geometry.Proto.DPoint3d cornerB = 3;
inline bool Block::has_cornerB() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Block::set_has_cornerB() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Block::clear_has_cornerB() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Block::clear_cornerB() {
  if (cornerB_ != NULL) cornerB_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_cornerB();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& Block::cornerB() const {
  return cornerB_ != NULL ? *cornerB_ : *default_instance_->cornerB_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Block::mutable_cornerB() {
  set_has_cornerB();
  if (cornerB_ == NULL) cornerB_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return cornerB_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Block::release_cornerB() {
  clear_has_cornerB();
  ::Bentley::Geometry::Proto::DPoint3d* temp = cornerB_;
  cornerB_ = NULL;
  return temp;
}
inline void Block::set_allocated_cornerB(::Bentley::Geometry::Proto::DPoint3d* cornerB) {
  delete cornerB_;
  cornerB_ = cornerB;
  if (cornerB) {
    set_has_cornerB();
  } else {
    clear_has_cornerB();
  }
}

// required bool bSolidFlag = 4;
inline bool Block::has_bSolidFlag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Block::set_has_bSolidFlag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Block::clear_has_bSolidFlag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Block::clear_bSolidFlag() {
  bSolidFlag_ = false;
  clear_has_bSolidFlag();
}
inline bool Block::bSolidFlag() const {
  return bSolidFlag_;
}
inline void Block::set_bSolidFlag(bool value) {
  set_has_bSolidFlag();
  bSolidFlag_ = value;
}

// -------------------------------------------------------------------

// BsplineCurve

// required int32 Order = 1;
inline bool BsplineCurve::has_Order() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BsplineCurve::set_has_Order() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BsplineCurve::clear_has_Order() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BsplineCurve::clear_Order() {
  Order_ = 0;
  clear_has_Order();
}
inline ::google::protobuf::int32 BsplineCurve::Order() const {
  return Order_;
}
inline void BsplineCurve::set_Order(::google::protobuf::int32 value) {
  set_has_Order();
  Order_ = value;
}

// required bool Closed = 2;
inline bool BsplineCurve::has_Closed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BsplineCurve::set_has_Closed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BsplineCurve::clear_has_Closed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BsplineCurve::clear_Closed() {
  Closed_ = false;
  clear_has_Closed();
}
inline bool BsplineCurve::Closed() const {
  return Closed_;
}
inline void BsplineCurve::set_Closed(bool value) {
  set_has_Closed();
  Closed_ = value;
}

// repeated .Bentley.Geometry.Proto.DPoint3d ControlPoint = 3;
inline int BsplineCurve::ControlPoint_size() const {
  return ControlPoint_.size();
}
inline void BsplineCurve::clear_ControlPoint() {
  ControlPoint_.Clear();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& BsplineCurve::ControlPoint(int index) const {
  return ControlPoint_.Get(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* BsplineCurve::mutable_ControlPoint(int index) {
  return ControlPoint_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* BsplineCurve::add_ControlPoint() {
  return ControlPoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
BsplineCurve::ControlPoint() const {
  return ControlPoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
BsplineCurve::mutable_ControlPoint() {
  return &ControlPoint_;
}

// repeated double Weight = 4;
inline int BsplineCurve::Weight_size() const {
  return Weight_.size();
}
inline void BsplineCurve::clear_Weight() {
  Weight_.Clear();
}
inline double BsplineCurve::Weight(int index) const {
  return Weight_.Get(index);
}
inline void BsplineCurve::set_Weight(int index, double value) {
  Weight_.Set(index, value);
}
inline void BsplineCurve::add_Weight(double value) {
  Weight_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
BsplineCurve::Weight() const {
  return Weight_;
}
inline ::google::protobuf::RepeatedField< double >*
BsplineCurve::mutable_Weight() {
  return &Weight_;
}

// repeated double Knot = 5;
inline int BsplineCurve::Knot_size() const {
  return Knot_.size();
}
inline void BsplineCurve::clear_Knot() {
  Knot_.Clear();
}
inline double BsplineCurve::Knot(int index) const {
  return Knot_.Get(index);
}
inline void BsplineCurve::set_Knot(int index, double value) {
  Knot_.Set(index, value);
}
inline void BsplineCurve::add_Knot(double value) {
  Knot_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
BsplineCurve::Knot() const {
  return Knot_;
}
inline ::google::protobuf::RepeatedField< double >*
BsplineCurve::mutable_Knot() {
  return &Knot_;
}

// -------------------------------------------------------------------

// BsplineSurface

// required int32 OrderU = 1;
inline bool BsplineSurface::has_OrderU() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BsplineSurface::set_has_OrderU() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BsplineSurface::clear_has_OrderU() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BsplineSurface::clear_OrderU() {
  OrderU_ = 0;
  clear_has_OrderU();
}
inline ::google::protobuf::int32 BsplineSurface::OrderU() const {
  return OrderU_;
}
inline void BsplineSurface::set_OrderU(::google::protobuf::int32 value) {
  set_has_OrderU();
  OrderU_ = value;
}

// required bool ClosedU = 2;
inline bool BsplineSurface::has_ClosedU() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BsplineSurface::set_has_ClosedU() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BsplineSurface::clear_has_ClosedU() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BsplineSurface::clear_ClosedU() {
  ClosedU_ = false;
  clear_has_ClosedU();
}
inline bool BsplineSurface::ClosedU() const {
  return ClosedU_;
}
inline void BsplineSurface::set_ClosedU(bool value) {
  set_has_ClosedU();
  ClosedU_ = value;
}

// required int32 NumUControlPoint = 3;
inline bool BsplineSurface::has_NumUControlPoint() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BsplineSurface::set_has_NumUControlPoint() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BsplineSurface::clear_has_NumUControlPoint() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BsplineSurface::clear_NumUControlPoint() {
  NumUControlPoint_ = 0;
  clear_has_NumUControlPoint();
}
inline ::google::protobuf::int32 BsplineSurface::NumUControlPoint() const {
  return NumUControlPoint_;
}
inline void BsplineSurface::set_NumUControlPoint(::google::protobuf::int32 value) {
  set_has_NumUControlPoint();
  NumUControlPoint_ = value;
}

// required int32 OrderV = 4;
inline bool BsplineSurface::has_OrderV() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BsplineSurface::set_has_OrderV() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BsplineSurface::clear_has_OrderV() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BsplineSurface::clear_OrderV() {
  OrderV_ = 0;
  clear_has_OrderV();
}
inline ::google::protobuf::int32 BsplineSurface::OrderV() const {
  return OrderV_;
}
inline void BsplineSurface::set_OrderV(::google::protobuf::int32 value) {
  set_has_OrderV();
  OrderV_ = value;
}

// required bool ClosedV = 5;
inline bool BsplineSurface::has_ClosedV() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BsplineSurface::set_has_ClosedV() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BsplineSurface::clear_has_ClosedV() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BsplineSurface::clear_ClosedV() {
  ClosedV_ = false;
  clear_has_ClosedV();
}
inline bool BsplineSurface::ClosedV() const {
  return ClosedV_;
}
inline void BsplineSurface::set_ClosedV(bool value) {
  set_has_ClosedV();
  ClosedV_ = value;
}

// required int32 NumVControlPoint = 6;
inline bool BsplineSurface::has_NumVControlPoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BsplineSurface::set_has_NumVControlPoint() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BsplineSurface::clear_has_NumVControlPoint() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BsplineSurface::clear_NumVControlPoint() {
  NumVControlPoint_ = 0;
  clear_has_NumVControlPoint();
}
inline ::google::protobuf::int32 BsplineSurface::NumVControlPoint() const {
  return NumVControlPoint_;
}
inline void BsplineSurface::set_NumVControlPoint(::google::protobuf::int32 value) {
  set_has_NumVControlPoint();
  NumVControlPoint_ = value;
}

// repeated .Bentley.Geometry.Proto.DPoint3d ControlPoint = 7;
inline int BsplineSurface::ControlPoint_size() const {
  return ControlPoint_.size();
}
inline void BsplineSurface::clear_ControlPoint() {
  ControlPoint_.Clear();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& BsplineSurface::ControlPoint(int index) const {
  return ControlPoint_.Get(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* BsplineSurface::mutable_ControlPoint(int index) {
  return ControlPoint_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* BsplineSurface::add_ControlPoint() {
  return ControlPoint_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
BsplineSurface::ControlPoint() const {
  return ControlPoint_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
BsplineSurface::mutable_ControlPoint() {
  return &ControlPoint_;
}

// repeated double Weight = 8;
inline int BsplineSurface::Weight_size() const {
  return Weight_.size();
}
inline void BsplineSurface::clear_Weight() {
  Weight_.Clear();
}
inline double BsplineSurface::Weight(int index) const {
  return Weight_.Get(index);
}
inline void BsplineSurface::set_Weight(int index, double value) {
  Weight_.Set(index, value);
}
inline void BsplineSurface::add_Weight(double value) {
  Weight_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
BsplineSurface::Weight() const {
  return Weight_;
}
inline ::google::protobuf::RepeatedField< double >*
BsplineSurface::mutable_Weight() {
  return &Weight_;
}

// repeated double KnotU = 9;
inline int BsplineSurface::KnotU_size() const {
  return KnotU_.size();
}
inline void BsplineSurface::clear_KnotU() {
  KnotU_.Clear();
}
inline double BsplineSurface::KnotU(int index) const {
  return KnotU_.Get(index);
}
inline void BsplineSurface::set_KnotU(int index, double value) {
  KnotU_.Set(index, value);
}
inline void BsplineSurface::add_KnotU(double value) {
  KnotU_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
BsplineSurface::KnotU() const {
  return KnotU_;
}
inline ::google::protobuf::RepeatedField< double >*
BsplineSurface::mutable_KnotU() {
  return &KnotU_;
}

// repeated double KnotV = 10;
inline int BsplineSurface::KnotV_size() const {
  return KnotV_.size();
}
inline void BsplineSurface::clear_KnotV() {
  KnotV_.Clear();
}
inline double BsplineSurface::KnotV(int index) const {
  return KnotV_.Get(index);
}
inline void BsplineSurface::set_KnotV(int index, double value) {
  KnotV_.Set(index, value);
}
inline void BsplineSurface::add_KnotV(double value) {
  KnotV_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
BsplineSurface::KnotV() const {
  return KnotV_;
}
inline ::google::protobuf::RepeatedField< double >*
BsplineSurface::mutable_KnotV() {
  return &KnotV_;
}

// -------------------------------------------------------------------

// CircularArc

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool CircularArc::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CircularArc::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CircularArc::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CircularArc::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& CircularArc::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* CircularArc::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* CircularArc::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void CircularArc::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required double radius = 2;
inline bool CircularArc::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CircularArc::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CircularArc::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CircularArc::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double CircularArc::radius() const {
  return radius_;
}
inline void CircularArc::set_radius(double value) {
  set_has_radius();
  radius_ = value;
}

// required .Bentley.Geometry.Proto.Angle startAngle = 3;
inline bool CircularArc::has_startAngle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CircularArc::set_has_startAngle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CircularArc::clear_has_startAngle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CircularArc::clear_startAngle() {
  if (startAngle_ != NULL) startAngle_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_startAngle();
}
inline const ::Bentley::Geometry::Proto::Angle& CircularArc::startAngle() const {
  return startAngle_ != NULL ? *startAngle_ : *default_instance_->startAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* CircularArc::mutable_startAngle() {
  set_has_startAngle();
  if (startAngle_ == NULL) startAngle_ = new ::Bentley::Geometry::Proto::Angle;
  return startAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* CircularArc::release_startAngle() {
  clear_has_startAngle();
  ::Bentley::Geometry::Proto::Angle* temp = startAngle_;
  startAngle_ = NULL;
  return temp;
}
inline void CircularArc::set_allocated_startAngle(::Bentley::Geometry::Proto::Angle* startAngle) {
  delete startAngle_;
  startAngle_ = startAngle;
  if (startAngle) {
    set_has_startAngle();
  } else {
    clear_has_startAngle();
  }
}

// required .Bentley.Geometry.Proto.Angle sweepAngle = 4;
inline bool CircularArc::has_sweepAngle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CircularArc::set_has_sweepAngle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CircularArc::clear_has_sweepAngle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CircularArc::clear_sweepAngle() {
  if (sweepAngle_ != NULL) sweepAngle_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_sweepAngle();
}
inline const ::Bentley::Geometry::Proto::Angle& CircularArc::sweepAngle() const {
  return sweepAngle_ != NULL ? *sweepAngle_ : *default_instance_->sweepAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* CircularArc::mutable_sweepAngle() {
  set_has_sweepAngle();
  if (sweepAngle_ == NULL) sweepAngle_ = new ::Bentley::Geometry::Proto::Angle;
  return sweepAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* CircularArc::release_sweepAngle() {
  clear_has_sweepAngle();
  ::Bentley::Geometry::Proto::Angle* temp = sweepAngle_;
  sweepAngle_ = NULL;
  return temp;
}
inline void CircularArc::set_allocated_sweepAngle(::Bentley::Geometry::Proto::Angle* sweepAngle) {
  delete sweepAngle_;
  sweepAngle_ = sweepAngle;
  if (sweepAngle) {
    set_has_sweepAngle();
  } else {
    clear_has_sweepAngle();
  }
}

// -------------------------------------------------------------------

// CircularCone

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool CircularCone::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CircularCone::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CircularCone::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CircularCone::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& CircularCone::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* CircularCone::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* CircularCone::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void CircularCone::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required double height = 2;
inline bool CircularCone::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CircularCone::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CircularCone::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CircularCone::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double CircularCone::height() const {
  return height_;
}
inline void CircularCone::set_height(double value) {
  set_has_height();
  height_ = value;
}

// required double radiusA = 3;
inline bool CircularCone::has_radiusA() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CircularCone::set_has_radiusA() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CircularCone::clear_has_radiusA() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CircularCone::clear_radiusA() {
  radiusA_ = 0;
  clear_has_radiusA();
}
inline double CircularCone::radiusA() const {
  return radiusA_;
}
inline void CircularCone::set_radiusA(double value) {
  set_has_radiusA();
  radiusA_ = value;
}

// required double radiusB = 4;
inline bool CircularCone::has_radiusB() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CircularCone::set_has_radiusB() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CircularCone::clear_has_radiusB() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CircularCone::clear_radiusB() {
  radiusB_ = 0;
  clear_has_radiusB();
}
inline double CircularCone::radiusB() const {
  return radiusB_;
}
inline void CircularCone::set_radiusB(double value) {
  set_has_radiusB();
  radiusB_ = value;
}

// required bool bSolidFlag = 5;
inline bool CircularCone::has_bSolidFlag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CircularCone::set_has_bSolidFlag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CircularCone::clear_has_bSolidFlag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CircularCone::clear_bSolidFlag() {
  bSolidFlag_ = false;
  clear_has_bSolidFlag();
}
inline bool CircularCone::bSolidFlag() const {
  return bSolidFlag_;
}
inline void CircularCone::set_bSolidFlag(bool value) {
  set_has_bSolidFlag();
  bSolidFlag_ = value;
}

// -------------------------------------------------------------------

// CircularCylinder

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool CircularCylinder::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CircularCylinder::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CircularCylinder::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CircularCylinder::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& CircularCylinder::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* CircularCylinder::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* CircularCylinder::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void CircularCylinder::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required double height = 2;
inline bool CircularCylinder::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CircularCylinder::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CircularCylinder::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CircularCylinder::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double CircularCylinder::height() const {
  return height_;
}
inline void CircularCylinder::set_height(double value) {
  set_has_height();
  height_ = value;
}

// required double radius = 3;
inline bool CircularCylinder::has_radius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CircularCylinder::set_has_radius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CircularCylinder::clear_has_radius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CircularCylinder::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double CircularCylinder::radius() const {
  return radius_;
}
inline void CircularCylinder::set_radius(double value) {
  set_has_radius();
  radius_ = value;
}

// required bool bSolidFlag = 4;
inline bool CircularCylinder::has_bSolidFlag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CircularCylinder::set_has_bSolidFlag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CircularCylinder::clear_has_bSolidFlag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CircularCylinder::clear_bSolidFlag() {
  bSolidFlag_ = false;
  clear_has_bSolidFlag();
}
inline bool CircularCylinder::bSolidFlag() const {
  return bSolidFlag_;
}
inline void CircularCylinder::set_bSolidFlag(bool value) {
  set_has_bSolidFlag();
  bSolidFlag_ = value;
}

// -------------------------------------------------------------------

// CircularDisk

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool CircularDisk::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CircularDisk::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CircularDisk::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CircularDisk::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& CircularDisk::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* CircularDisk::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* CircularDisk::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void CircularDisk::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required double radius = 2;
inline bool CircularDisk::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CircularDisk::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CircularDisk::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CircularDisk::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double CircularDisk::radius() const {
  return radius_;
}
inline void CircularDisk::set_radius(double value) {
  set_has_radius();
  radius_ = value;
}

// -------------------------------------------------------------------

// Coordinate

// required .Bentley.Geometry.Proto.DPoint3d xyz = 1;
inline bool Coordinate::has_xyz() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Coordinate::set_has_xyz() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Coordinate::clear_has_xyz() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Coordinate::clear_xyz() {
  if (xyz_ != NULL) xyz_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_xyz();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& Coordinate::xyz() const {
  return xyz_ != NULL ? *xyz_ : *default_instance_->xyz_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Coordinate::mutable_xyz() {
  set_has_xyz();
  if (xyz_ == NULL) xyz_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return xyz_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Coordinate::release_xyz() {
  clear_has_xyz();
  ::Bentley::Geometry::Proto::DPoint3d* temp = xyz_;
  xyz_ = NULL;
  return temp;
}
inline void Coordinate::set_allocated_xyz(::Bentley::Geometry::Proto::DPoint3d* xyz) {
  delete xyz_;
  xyz_ = xyz;
  if (xyz) {
    set_has_xyz();
  } else {
    clear_has_xyz();
  }
}

// -------------------------------------------------------------------

// CurveReference

// required .Bentley.Geometry.Proto.ICurve ParentCurve = 1;
inline bool CurveReference::has_ParentCurve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CurveReference::set_has_ParentCurve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CurveReference::clear_has_ParentCurve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CurveReference::clear_ParentCurve() {
  if (ParentCurve_ != NULL) ParentCurve_->::Bentley::Geometry::Proto::ICurve::Clear();
  clear_has_ParentCurve();
}
inline const ::Bentley::Geometry::Proto::ICurve& CurveReference::ParentCurve() const {
  return ParentCurve_ != NULL ? *ParentCurve_ : *default_instance_->ParentCurve_;
}
inline ::Bentley::Geometry::Proto::ICurve* CurveReference::mutable_ParentCurve() {
  set_has_ParentCurve();
  if (ParentCurve_ == NULL) ParentCurve_ = new ::Bentley::Geometry::Proto::ICurve;
  return ParentCurve_;
}
inline ::Bentley::Geometry::Proto::ICurve* CurveReference::release_ParentCurve() {
  clear_has_ParentCurve();
  ::Bentley::Geometry::Proto::ICurve* temp = ParentCurve_;
  ParentCurve_ = NULL;
  return temp;
}
inline void CurveReference::set_allocated_ParentCurve(::Bentley::Geometry::Proto::ICurve* ParentCurve) {
  delete ParentCurve_;
  ParentCurve_ = ParentCurve;
  if (ParentCurve) {
    set_has_ParentCurve();
  } else {
    clear_has_ParentCurve();
  }
}

// required bool Reversed = 2;
inline bool CurveReference::has_Reversed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CurveReference::set_has_Reversed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CurveReference::clear_has_Reversed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CurveReference::clear_Reversed() {
  Reversed_ = false;
  clear_has_Reversed();
}
inline bool CurveReference::Reversed() const {
  return Reversed_;
}
inline void CurveReference::set_Reversed(bool value) {
  set_has_Reversed();
  Reversed_ = value;
}

// -------------------------------------------------------------------

// EllipticArc

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool EllipticArc::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EllipticArc::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EllipticArc::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EllipticArc::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& EllipticArc::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* EllipticArc::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* EllipticArc::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void EllipticArc::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required double radiusA = 2;
inline bool EllipticArc::has_radiusA() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EllipticArc::set_has_radiusA() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EllipticArc::clear_has_radiusA() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EllipticArc::clear_radiusA() {
  radiusA_ = 0;
  clear_has_radiusA();
}
inline double EllipticArc::radiusA() const {
  return radiusA_;
}
inline void EllipticArc::set_radiusA(double value) {
  set_has_radiusA();
  radiusA_ = value;
}

// required double radiusB = 3;
inline bool EllipticArc::has_radiusB() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EllipticArc::set_has_radiusB() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EllipticArc::clear_has_radiusB() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EllipticArc::clear_radiusB() {
  radiusB_ = 0;
  clear_has_radiusB();
}
inline double EllipticArc::radiusB() const {
  return radiusB_;
}
inline void EllipticArc::set_radiusB(double value) {
  set_has_radiusB();
  radiusB_ = value;
}

// required .Bentley.Geometry.Proto.Angle startAngle = 4;
inline bool EllipticArc::has_startAngle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EllipticArc::set_has_startAngle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EllipticArc::clear_has_startAngle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EllipticArc::clear_startAngle() {
  if (startAngle_ != NULL) startAngle_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_startAngle();
}
inline const ::Bentley::Geometry::Proto::Angle& EllipticArc::startAngle() const {
  return startAngle_ != NULL ? *startAngle_ : *default_instance_->startAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* EllipticArc::mutable_startAngle() {
  set_has_startAngle();
  if (startAngle_ == NULL) startAngle_ = new ::Bentley::Geometry::Proto::Angle;
  return startAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* EllipticArc::release_startAngle() {
  clear_has_startAngle();
  ::Bentley::Geometry::Proto::Angle* temp = startAngle_;
  startAngle_ = NULL;
  return temp;
}
inline void EllipticArc::set_allocated_startAngle(::Bentley::Geometry::Proto::Angle* startAngle) {
  delete startAngle_;
  startAngle_ = startAngle;
  if (startAngle) {
    set_has_startAngle();
  } else {
    clear_has_startAngle();
  }
}

// required .Bentley.Geometry.Proto.Angle sweepAngle = 5;
inline bool EllipticArc::has_sweepAngle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EllipticArc::set_has_sweepAngle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EllipticArc::clear_has_sweepAngle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EllipticArc::clear_sweepAngle() {
  if (sweepAngle_ != NULL) sweepAngle_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_sweepAngle();
}
inline const ::Bentley::Geometry::Proto::Angle& EllipticArc::sweepAngle() const {
  return sweepAngle_ != NULL ? *sweepAngle_ : *default_instance_->sweepAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* EllipticArc::mutable_sweepAngle() {
  set_has_sweepAngle();
  if (sweepAngle_ == NULL) sweepAngle_ = new ::Bentley::Geometry::Proto::Angle;
  return sweepAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* EllipticArc::release_sweepAngle() {
  clear_has_sweepAngle();
  ::Bentley::Geometry::Proto::Angle* temp = sweepAngle_;
  sweepAngle_ = NULL;
  return temp;
}
inline void EllipticArc::set_allocated_sweepAngle(::Bentley::Geometry::Proto::Angle* sweepAngle) {
  delete sweepAngle_;
  sweepAngle_ = sweepAngle;
  if (sweepAngle) {
    set_has_sweepAngle();
  } else {
    clear_has_sweepAngle();
  }
}

// -------------------------------------------------------------------

// EllipticDisk

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool EllipticDisk::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EllipticDisk::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EllipticDisk::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EllipticDisk::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& EllipticDisk::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* EllipticDisk::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* EllipticDisk::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void EllipticDisk::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required double radiusA = 2;
inline bool EllipticDisk::has_radiusA() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EllipticDisk::set_has_radiusA() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EllipticDisk::clear_has_radiusA() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EllipticDisk::clear_radiusA() {
  radiusA_ = 0;
  clear_has_radiusA();
}
inline double EllipticDisk::radiusA() const {
  return radiusA_;
}
inline void EllipticDisk::set_radiusA(double value) {
  set_has_radiusA();
  radiusA_ = value;
}

// required double radiusB = 3;
inline bool EllipticDisk::has_radiusB() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EllipticDisk::set_has_radiusB() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EllipticDisk::clear_has_radiusB() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EllipticDisk::clear_radiusB() {
  radiusB_ = 0;
  clear_has_radiusB();
}
inline double EllipticDisk::radiusB() const {
  return radiusB_;
}
inline void EllipticDisk::set_radiusB(double value) {
  set_has_radiusB();
  radiusB_ = value;
}

// -------------------------------------------------------------------

// IndexedMesh

// repeated .Bentley.Geometry.Proto.DPoint3d Coord = 1;
inline int IndexedMesh::Coord_size() const {
  return Coord_.size();
}
inline void IndexedMesh::clear_Coord() {
  Coord_.Clear();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& IndexedMesh::Coord(int index) const {
  return Coord_.Get(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* IndexedMesh::mutable_Coord(int index) {
  return Coord_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* IndexedMesh::add_Coord() {
  return Coord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
IndexedMesh::Coord() const {
  return Coord_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
IndexedMesh::mutable_Coord() {
  return &Coord_;
}

// repeated int32 CoordIndex = 2;
inline int IndexedMesh::CoordIndex_size() const {
  return CoordIndex_.size();
}
inline void IndexedMesh::clear_CoordIndex() {
  CoordIndex_.Clear();
}
inline ::google::protobuf::int32 IndexedMesh::CoordIndex(int index) const {
  return CoordIndex_.Get(index);
}
inline void IndexedMesh::set_CoordIndex(int index, ::google::protobuf::int32 value) {
  CoordIndex_.Set(index, value);
}
inline void IndexedMesh::add_CoordIndex(::google::protobuf::int32 value) {
  CoordIndex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
IndexedMesh::CoordIndex() const {
  return CoordIndex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
IndexedMesh::mutable_CoordIndex() {
  return &CoordIndex_;
}

// repeated .Bentley.Geometry.Proto.DPoint2d Param = 3;
inline int IndexedMesh::Param_size() const {
  return Param_.size();
}
inline void IndexedMesh::clear_Param() {
  Param_.Clear();
}
inline const ::Bentley::Geometry::Proto::DPoint2d& IndexedMesh::Param(int index) const {
  return Param_.Get(index);
}
inline ::Bentley::Geometry::Proto::DPoint2d* IndexedMesh::mutable_Param(int index) {
  return Param_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::DPoint2d* IndexedMesh::add_Param() {
  return Param_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint2d >&
IndexedMesh::Param() const {
  return Param_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint2d >*
IndexedMesh::mutable_Param() {
  return &Param_;
}

// repeated int32 ParamIndex = 4;
inline int IndexedMesh::ParamIndex_size() const {
  return ParamIndex_.size();
}
inline void IndexedMesh::clear_ParamIndex() {
  ParamIndex_.Clear();
}
inline ::google::protobuf::int32 IndexedMesh::ParamIndex(int index) const {
  return ParamIndex_.Get(index);
}
inline void IndexedMesh::set_ParamIndex(int index, ::google::protobuf::int32 value) {
  ParamIndex_.Set(index, value);
}
inline void IndexedMesh::add_ParamIndex(::google::protobuf::int32 value) {
  ParamIndex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
IndexedMesh::ParamIndex() const {
  return ParamIndex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
IndexedMesh::mutable_ParamIndex() {
  return &ParamIndex_;
}

// repeated .Bentley.Geometry.Proto.DVector3d Normal = 5;
inline int IndexedMesh::Normal_size() const {
  return Normal_.size();
}
inline void IndexedMesh::clear_Normal() {
  Normal_.Clear();
}
inline const ::Bentley::Geometry::Proto::DVector3d& IndexedMesh::Normal(int index) const {
  return Normal_.Get(index);
}
inline ::Bentley::Geometry::Proto::DVector3d* IndexedMesh::mutable_Normal(int index) {
  return Normal_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::DVector3d* IndexedMesh::add_Normal() {
  return Normal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d >&
IndexedMesh::Normal() const {
  return Normal_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d >*
IndexedMesh::mutable_Normal() {
  return &Normal_;
}

// repeated int32 NormalIndex = 6;
inline int IndexedMesh::NormalIndex_size() const {
  return NormalIndex_.size();
}
inline void IndexedMesh::clear_NormalIndex() {
  NormalIndex_.Clear();
}
inline ::google::protobuf::int32 IndexedMesh::NormalIndex(int index) const {
  return NormalIndex_.Get(index);
}
inline void IndexedMesh::set_NormalIndex(int index, ::google::protobuf::int32 value) {
  NormalIndex_.Set(index, value);
}
inline void IndexedMesh::add_NormalIndex(::google::protobuf::int32 value) {
  NormalIndex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
IndexedMesh::NormalIndex() const {
  return NormalIndex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
IndexedMesh::mutable_NormalIndex() {
  return &NormalIndex_;
}

// repeated .Bentley.Geometry.Proto.DVector3d Color = 7;
inline int IndexedMesh::Color_size() const {
  return Color_.size();
}
inline void IndexedMesh::clear_Color() {
  Color_.Clear();
}
inline const ::Bentley::Geometry::Proto::DVector3d& IndexedMesh::Color(int index) const {
  return Color_.Get(index);
}
inline ::Bentley::Geometry::Proto::DVector3d* IndexedMesh::mutable_Color(int index) {
  return Color_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::DVector3d* IndexedMesh::add_Color() {
  return Color_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d >&
IndexedMesh::Color() const {
  return Color_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DVector3d >*
IndexedMesh::mutable_Color() {
  return &Color_;
}

// repeated int32 ColorIndex = 8;
inline int IndexedMesh::ColorIndex_size() const {
  return ColorIndex_.size();
}
inline void IndexedMesh::clear_ColorIndex() {
  ColorIndex_.Clear();
}
inline ::google::protobuf::int32 IndexedMesh::ColorIndex(int index) const {
  return ColorIndex_.Get(index);
}
inline void IndexedMesh::set_ColorIndex(int index, ::google::protobuf::int32 value) {
  ColorIndex_.Set(index, value);
}
inline void IndexedMesh::add_ColorIndex(::google::protobuf::int32 value) {
  ColorIndex_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
IndexedMesh::ColorIndex() const {
  return ColorIndex_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
IndexedMesh::mutable_ColorIndex() {
  return &ColorIndex_;
}

// -------------------------------------------------------------------

// InterpolatingCurve

// required int32 EndConditionCode = 1;
inline bool InterpolatingCurve::has_EndConditionCode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InterpolatingCurve::set_has_EndConditionCode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InterpolatingCurve::clear_has_EndConditionCode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InterpolatingCurve::clear_EndConditionCode() {
  EndConditionCode_ = 0;
  clear_has_EndConditionCode();
}
inline ::google::protobuf::int32 InterpolatingCurve::EndConditionCode() const {
  return EndConditionCode_;
}
inline void InterpolatingCurve::set_EndConditionCode(::google::protobuf::int32 value) {
  set_has_EndConditionCode();
  EndConditionCode_ = value;
}

// required int32 KnotCode = 2;
inline bool InterpolatingCurve::has_KnotCode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InterpolatingCurve::set_has_KnotCode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InterpolatingCurve::clear_has_KnotCode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InterpolatingCurve::clear_KnotCode() {
  KnotCode_ = 0;
  clear_has_KnotCode();
}
inline ::google::protobuf::int32 InterpolatingCurve::KnotCode() const {
  return KnotCode_;
}
inline void InterpolatingCurve::set_KnotCode(::google::protobuf::int32 value) {
  set_has_KnotCode();
  KnotCode_ = value;
}

// required .Bentley.Geometry.Proto.DVector3d StartVector = 3;
inline bool InterpolatingCurve::has_StartVector() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InterpolatingCurve::set_has_StartVector() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InterpolatingCurve::clear_has_StartVector() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InterpolatingCurve::clear_StartVector() {
  if (StartVector_ != NULL) StartVector_->::Bentley::Geometry::Proto::DVector3d::Clear();
  clear_has_StartVector();
}
inline const ::Bentley::Geometry::Proto::DVector3d& InterpolatingCurve::StartVector() const {
  return StartVector_ != NULL ? *StartVector_ : *default_instance_->StartVector_;
}
inline ::Bentley::Geometry::Proto::DVector3d* InterpolatingCurve::mutable_StartVector() {
  set_has_StartVector();
  if (StartVector_ == NULL) StartVector_ = new ::Bentley::Geometry::Proto::DVector3d;
  return StartVector_;
}
inline ::Bentley::Geometry::Proto::DVector3d* InterpolatingCurve::release_StartVector() {
  clear_has_StartVector();
  ::Bentley::Geometry::Proto::DVector3d* temp = StartVector_;
  StartVector_ = NULL;
  return temp;
}
inline void InterpolatingCurve::set_allocated_StartVector(::Bentley::Geometry::Proto::DVector3d* StartVector) {
  delete StartVector_;
  StartVector_ = StartVector;
  if (StartVector) {
    set_has_StartVector();
  } else {
    clear_has_StartVector();
  }
}

// required .Bentley.Geometry.Proto.DVector3d EndVector = 4;
inline bool InterpolatingCurve::has_EndVector() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InterpolatingCurve::set_has_EndVector() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InterpolatingCurve::clear_has_EndVector() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InterpolatingCurve::clear_EndVector() {
  if (EndVector_ != NULL) EndVector_->::Bentley::Geometry::Proto::DVector3d::Clear();
  clear_has_EndVector();
}
inline const ::Bentley::Geometry::Proto::DVector3d& InterpolatingCurve::EndVector() const {
  return EndVector_ != NULL ? *EndVector_ : *default_instance_->EndVector_;
}
inline ::Bentley::Geometry::Proto::DVector3d* InterpolatingCurve::mutable_EndVector() {
  set_has_EndVector();
  if (EndVector_ == NULL) EndVector_ = new ::Bentley::Geometry::Proto::DVector3d;
  return EndVector_;
}
inline ::Bentley::Geometry::Proto::DVector3d* InterpolatingCurve::release_EndVector() {
  clear_has_EndVector();
  ::Bentley::Geometry::Proto::DVector3d* temp = EndVector_;
  EndVector_ = NULL;
  return temp;
}
inline void InterpolatingCurve::set_allocated_EndVector(::Bentley::Geometry::Proto::DVector3d* EndVector) {
  delete EndVector_;
  EndVector_ = EndVector;
  if (EndVector) {
    set_has_EndVector();
  } else {
    clear_has_EndVector();
  }
}

// repeated .Bentley.Geometry.Proto.DPoint3d Point = 5;
inline int InterpolatingCurve::Point_size() const {
  return Point_.size();
}
inline void InterpolatingCurve::clear_Point() {
  Point_.Clear();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& InterpolatingCurve::Point(int index) const {
  return Point_.Get(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* InterpolatingCurve::mutable_Point(int index) {
  return Point_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* InterpolatingCurve::add_Point() {
  return Point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
InterpolatingCurve::Point() const {
  return Point_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
InterpolatingCurve::mutable_Point() {
  return &Point_;
}

// repeated double Knot = 6;
inline int InterpolatingCurve::Knot_size() const {
  return Knot_.size();
}
inline void InterpolatingCurve::clear_Knot() {
  Knot_.Clear();
}
inline double InterpolatingCurve::Knot(int index) const {
  return Knot_.Get(index);
}
inline void InterpolatingCurve::set_Knot(int index, double value) {
  Knot_.Set(index, value);
}
inline void InterpolatingCurve::add_Knot(double value) {
  Knot_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
InterpolatingCurve::Knot() const {
  return Knot_;
}
inline ::google::protobuf::RepeatedField< double >*
InterpolatingCurve::mutable_Knot() {
  return &Knot_;
}

// -------------------------------------------------------------------

// LineSegment

// required .Bentley.Geometry.Proto.DPoint3d startPoint = 1;
inline bool LineSegment::has_startPoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineSegment::set_has_startPoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineSegment::clear_has_startPoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineSegment::clear_startPoint() {
  if (startPoint_ != NULL) startPoint_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_startPoint();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& LineSegment::startPoint() const {
  return startPoint_ != NULL ? *startPoint_ : *default_instance_->startPoint_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* LineSegment::mutable_startPoint() {
  set_has_startPoint();
  if (startPoint_ == NULL) startPoint_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return startPoint_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* LineSegment::release_startPoint() {
  clear_has_startPoint();
  ::Bentley::Geometry::Proto::DPoint3d* temp = startPoint_;
  startPoint_ = NULL;
  return temp;
}
inline void LineSegment::set_allocated_startPoint(::Bentley::Geometry::Proto::DPoint3d* startPoint) {
  delete startPoint_;
  startPoint_ = startPoint;
  if (startPoint) {
    set_has_startPoint();
  } else {
    clear_has_startPoint();
  }
}

// required .Bentley.Geometry.Proto.DPoint3d endPoint = 2;
inline bool LineSegment::has_endPoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineSegment::set_has_endPoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineSegment::clear_has_endPoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineSegment::clear_endPoint() {
  if (endPoint_ != NULL) endPoint_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_endPoint();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& LineSegment::endPoint() const {
  return endPoint_ != NULL ? *endPoint_ : *default_instance_->endPoint_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* LineSegment::mutable_endPoint() {
  set_has_endPoint();
  if (endPoint_ == NULL) endPoint_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return endPoint_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* LineSegment::release_endPoint() {
  clear_has_endPoint();
  ::Bentley::Geometry::Proto::DPoint3d* temp = endPoint_;
  endPoint_ = NULL;
  return temp;
}
inline void LineSegment::set_allocated_endPoint(::Bentley::Geometry::Proto::DPoint3d* endPoint) {
  delete endPoint_;
  endPoint_ = endPoint;
  if (endPoint) {
    set_has_endPoint();
  } else {
    clear_has_endPoint();
  }
}

// -------------------------------------------------------------------

// LineString

// repeated .Bentley.Geometry.Proto.DPoint3d Point = 1;
inline int LineString::Point_size() const {
  return Point_.size();
}
inline void LineString::clear_Point() {
  Point_.Clear();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& LineString::Point(int index) const {
  return Point_.Get(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* LineString::mutable_Point(int index) {
  return Point_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* LineString::add_Point() {
  return Point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
LineString::Point() const {
  return Point_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
LineString::mutable_Point() {
  return &Point_;
}

// -------------------------------------------------------------------

// Polygon

// repeated .Bentley.Geometry.Proto.DPoint3d Point = 1;
inline int Polygon::Point_size() const {
  return Point_.size();
}
inline void Polygon::clear_Point() {
  Point_.Clear();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& Polygon::Point(int index) const {
  return Point_.Get(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* Polygon::mutable_Point(int index) {
  return Point_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::DPoint3d* Polygon::add_Point() {
  return Point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >&
Polygon::Point() const {
  return Point_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::DPoint3d >*
Polygon::mutable_Point() {
  return &Point_;
}

// -------------------------------------------------------------------

// PrimitiveCurveReference

// required .Bentley.Geometry.Proto.IPrimitiveCurve ParentCurve = 1;
inline bool PrimitiveCurveReference::has_ParentCurve() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PrimitiveCurveReference::set_has_ParentCurve() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PrimitiveCurveReference::clear_has_ParentCurve() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PrimitiveCurveReference::clear_ParentCurve() {
  if (ParentCurve_ != NULL) ParentCurve_->::Bentley::Geometry::Proto::IPrimitiveCurve::Clear();
  clear_has_ParentCurve();
}
inline const ::Bentley::Geometry::Proto::IPrimitiveCurve& PrimitiveCurveReference::ParentCurve() const {
  return ParentCurve_ != NULL ? *ParentCurve_ : *default_instance_->ParentCurve_;
}
inline ::Bentley::Geometry::Proto::IPrimitiveCurve* PrimitiveCurveReference::mutable_ParentCurve() {
  set_has_ParentCurve();
  if (ParentCurve_ == NULL) ParentCurve_ = new ::Bentley::Geometry::Proto::IPrimitiveCurve;
  return ParentCurve_;
}
inline ::Bentley::Geometry::Proto::IPrimitiveCurve* PrimitiveCurveReference::release_ParentCurve() {
  clear_has_ParentCurve();
  ::Bentley::Geometry::Proto::IPrimitiveCurve* temp = ParentCurve_;
  ParentCurve_ = NULL;
  return temp;
}
inline void PrimitiveCurveReference::set_allocated_ParentCurve(::Bentley::Geometry::Proto::IPrimitiveCurve* ParentCurve) {
  delete ParentCurve_;
  ParentCurve_ = ParentCurve;
  if (ParentCurve) {
    set_has_ParentCurve();
  } else {
    clear_has_ParentCurve();
  }
}

// required bool Reversed = 2;
inline bool PrimitiveCurveReference::has_Reversed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PrimitiveCurveReference::set_has_Reversed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PrimitiveCurveReference::clear_has_Reversed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PrimitiveCurveReference::clear_Reversed() {
  Reversed_ = false;
  clear_has_Reversed();
}
inline bool PrimitiveCurveReference::Reversed() const {
  return Reversed_;
}
inline void PrimitiveCurveReference::set_Reversed(bool value) {
  set_has_Reversed();
  Reversed_ = value;
}

// -------------------------------------------------------------------

// SharedGroupInstance

// required string SharedGroupName = 1;
inline bool SharedGroupInstance::has_SharedGroupName() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SharedGroupInstance::set_has_SharedGroupName() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SharedGroupInstance::clear_has_SharedGroupName() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SharedGroupInstance::clear_SharedGroupName() {
  if (SharedGroupName_ != &::google::protobuf::internal::kEmptyString) {
    SharedGroupName_->clear();
  }
  clear_has_SharedGroupName();
}
inline const ::Bentley::Utf8String& SharedGroupInstance::SharedGroupName() const {
  return *SharedGroupName_;
}
inline void SharedGroupInstance::set_SharedGroupName(const ::Bentley::Utf8String& value) {
  set_has_SharedGroupName();
  if (SharedGroupName_ == &::google::protobuf::internal::kEmptyString) {
    SharedGroupName_ = new ::Bentley::Utf8String;
  }
  SharedGroupName_->assign(value);
}
inline void SharedGroupInstance::set_SharedGroupName(const char* value) {
  set_has_SharedGroupName();
  if (SharedGroupName_ == &::google::protobuf::internal::kEmptyString) {
    SharedGroupName_ = new ::Bentley::Utf8String;
  }
  SharedGroupName_->assign(value);
}
inline void SharedGroupInstance::set_SharedGroupName(const char* value, size_t size) {
  set_has_SharedGroupName();
  if (SharedGroupName_ == &::google::protobuf::internal::kEmptyString) {
    SharedGroupName_ = new ::Bentley::Utf8String;
  }
  SharedGroupName_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::Bentley::Utf8String* SharedGroupInstance::mutable_SharedGroupName() {
  set_has_SharedGroupName();
  if (SharedGroupName_ == &::google::protobuf::internal::kEmptyString) {
    SharedGroupName_ = new ::Bentley::Utf8String;
  }
  return SharedGroupName_;
}
inline ::Bentley::Utf8String* SharedGroupInstance::release_SharedGroupName() {
  clear_has_SharedGroupName();
  if (SharedGroupName_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::Bentley::Utf8String* temp = SharedGroupName_;
    SharedGroupName_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SharedGroupInstance::set_allocated_SharedGroupName(::Bentley::Utf8String* SharedGroupName) {
  if (SharedGroupName_ != &::google::protobuf::internal::kEmptyString) {
    delete SharedGroupName_;
  }
  if (SharedGroupName) {
    set_has_SharedGroupName();
    SharedGroupName_ = SharedGroupName;
  } else {
    clear_has_SharedGroupName();
    SharedGroupName_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Bentley.Geometry.Proto.DTransform3d Transform = 2;
inline bool SharedGroupInstance::has_Transform() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SharedGroupInstance::set_has_Transform() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SharedGroupInstance::clear_has_Transform() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SharedGroupInstance::clear_Transform() {
  if (Transform_ != NULL) Transform_->::Bentley::Geometry::Proto::DTransform3d::Clear();
  clear_has_Transform();
}
inline const ::Bentley::Geometry::Proto::DTransform3d& SharedGroupInstance::Transform() const {
  return Transform_ != NULL ? *Transform_ : *default_instance_->Transform_;
}
inline ::Bentley::Geometry::Proto::DTransform3d* SharedGroupInstance::mutable_Transform() {
  set_has_Transform();
  if (Transform_ == NULL) Transform_ = new ::Bentley::Geometry::Proto::DTransform3d;
  return Transform_;
}
inline ::Bentley::Geometry::Proto::DTransform3d* SharedGroupInstance::release_Transform() {
  clear_has_Transform();
  ::Bentley::Geometry::Proto::DTransform3d* temp = Transform_;
  Transform_ = NULL;
  return temp;
}
inline void SharedGroupInstance::set_allocated_Transform(::Bentley::Geometry::Proto::DTransform3d* Transform) {
  delete Transform_;
  Transform_ = Transform;
  if (Transform) {
    set_has_Transform();
  } else {
    clear_has_Transform();
  }
}

// -------------------------------------------------------------------

// ShelledSolid

// required .Bentley.Geometry.Proto.ISurface BoundingSurface = 1;
inline bool ShelledSolid::has_BoundingSurface() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShelledSolid::set_has_BoundingSurface() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShelledSolid::clear_has_BoundingSurface() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShelledSolid::clear_BoundingSurface() {
  if (BoundingSurface_ != NULL) BoundingSurface_->::Bentley::Geometry::Proto::ISurface::Clear();
  clear_has_BoundingSurface();
}
inline const ::Bentley::Geometry::Proto::ISurface& ShelledSolid::BoundingSurface() const {
  return BoundingSurface_ != NULL ? *BoundingSurface_ : *default_instance_->BoundingSurface_;
}
inline ::Bentley::Geometry::Proto::ISurface* ShelledSolid::mutable_BoundingSurface() {
  set_has_BoundingSurface();
  if (BoundingSurface_ == NULL) BoundingSurface_ = new ::Bentley::Geometry::Proto::ISurface;
  return BoundingSurface_;
}
inline ::Bentley::Geometry::Proto::ISurface* ShelledSolid::release_BoundingSurface() {
  clear_has_BoundingSurface();
  ::Bentley::Geometry::Proto::ISurface* temp = BoundingSurface_;
  BoundingSurface_ = NULL;
  return temp;
}
inline void ShelledSolid::set_allocated_BoundingSurface(::Bentley::Geometry::Proto::ISurface* BoundingSurface) {
  delete BoundingSurface_;
  BoundingSurface_ = BoundingSurface;
  if (BoundingSurface) {
    set_has_BoundingSurface();
  } else {
    clear_has_BoundingSurface();
  }
}

// -------------------------------------------------------------------

// SingleLineText

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool SingleLineText::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SingleLineText::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SingleLineText::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SingleLineText::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& SingleLineText::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* SingleLineText::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* SingleLineText::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void SingleLineText::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required string textString = 2;
inline bool SingleLineText::has_textString() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SingleLineText::set_has_textString() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SingleLineText::clear_has_textString() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SingleLineText::clear_textString() {
  if (textString_ != &::google::protobuf::internal::kEmptyString) {
    textString_->clear();
  }
  clear_has_textString();
}
inline const ::Bentley::Utf8String& SingleLineText::textString() const {
  return *textString_;
}
inline void SingleLineText::set_textString(const ::Bentley::Utf8String& value) {
  set_has_textString();
  if (textString_ == &::google::protobuf::internal::kEmptyString) {
    textString_ = new ::Bentley::Utf8String;
  }
  textString_->assign(value);
}
inline void SingleLineText::set_textString(const char* value) {
  set_has_textString();
  if (textString_ == &::google::protobuf::internal::kEmptyString) {
    textString_ = new ::Bentley::Utf8String;
  }
  textString_->assign(value);
}
inline void SingleLineText::set_textString(const char* value, size_t size) {
  set_has_textString();
  if (textString_ == &::google::protobuf::internal::kEmptyString) {
    textString_ = new ::Bentley::Utf8String;
  }
  textString_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::Bentley::Utf8String* SingleLineText::mutable_textString() {
  set_has_textString();
  if (textString_ == &::google::protobuf::internal::kEmptyString) {
    textString_ = new ::Bentley::Utf8String;
  }
  return textString_;
}
inline ::Bentley::Utf8String* SingleLineText::release_textString() {
  clear_has_textString();
  if (textString_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::Bentley::Utf8String* temp = textString_;
    textString_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SingleLineText::set_allocated_textString(::Bentley::Utf8String* textString) {
  if (textString_ != &::google::protobuf::internal::kEmptyString) {
    delete textString_;
  }
  if (textString) {
    set_has_textString();
    textString_ = textString;
  } else {
    clear_has_textString();
    textString_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string fontName = 3;
inline bool SingleLineText::has_fontName() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SingleLineText::set_has_fontName() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SingleLineText::clear_has_fontName() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SingleLineText::clear_fontName() {
  if (fontName_ != &::google::protobuf::internal::kEmptyString) {
    fontName_->clear();
  }
  clear_has_fontName();
}
inline const ::Bentley::Utf8String& SingleLineText::fontName() const {
  return *fontName_;
}
inline void SingleLineText::set_fontName(const ::Bentley::Utf8String& value) {
  set_has_fontName();
  if (fontName_ == &::google::protobuf::internal::kEmptyString) {
    fontName_ = new ::Bentley::Utf8String;
  }
  fontName_->assign(value);
}
inline void SingleLineText::set_fontName(const char* value) {
  set_has_fontName();
  if (fontName_ == &::google::protobuf::internal::kEmptyString) {
    fontName_ = new ::Bentley::Utf8String;
  }
  fontName_->assign(value);
}
inline void SingleLineText::set_fontName(const char* value, size_t size) {
  set_has_fontName();
  if (fontName_ == &::google::protobuf::internal::kEmptyString) {
    fontName_ = new ::Bentley::Utf8String;
  }
  fontName_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::Bentley::Utf8String* SingleLineText::mutable_fontName() {
  set_has_fontName();
  if (fontName_ == &::google::protobuf::internal::kEmptyString) {
    fontName_ = new ::Bentley::Utf8String;
  }
  return fontName_;
}
inline ::Bentley::Utf8String* SingleLineText::release_fontName() {
  clear_has_fontName();
  if (fontName_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::Bentley::Utf8String* temp = fontName_;
    fontName_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SingleLineText::set_allocated_fontName(::Bentley::Utf8String* fontName) {
  if (fontName_ != &::google::protobuf::internal::kEmptyString) {
    delete fontName_;
  }
  if (fontName) {
    set_has_fontName();
    fontName_ = fontName;
  } else {
    clear_has_fontName();
    fontName_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double characterXSize = 4;
inline bool SingleLineText::has_characterXSize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SingleLineText::set_has_characterXSize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SingleLineText::clear_has_characterXSize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SingleLineText::clear_characterXSize() {
  characterXSize_ = 0;
  clear_has_characterXSize();
}
inline double SingleLineText::characterXSize() const {
  return characterXSize_;
}
inline void SingleLineText::set_characterXSize(double value) {
  set_has_characterXSize();
  characterXSize_ = value;
}

// required double characterYSize = 5;
inline bool SingleLineText::has_characterYSize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SingleLineText::set_has_characterYSize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SingleLineText::clear_has_characterYSize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SingleLineText::clear_characterYSize() {
  characterYSize_ = 0;
  clear_has_characterYSize();
}
inline double SingleLineText::characterYSize() const {
  return characterYSize_;
}
inline void SingleLineText::set_characterYSize(double value) {
  set_has_characterYSize();
  characterYSize_ = value;
}

// required int32 justification = 6;
inline bool SingleLineText::has_justification() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SingleLineText::set_has_justification() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SingleLineText::clear_has_justification() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SingleLineText::clear_justification() {
  justification_ = 0;
  clear_has_justification();
}
inline ::google::protobuf::int32 SingleLineText::justification() const {
  return justification_;
}
inline void SingleLineText::set_justification(::google::protobuf::int32 value) {
  set_has_justification();
  justification_ = value;
}

// -------------------------------------------------------------------

// SkewedCone

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool SkewedCone::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SkewedCone::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SkewedCone::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SkewedCone::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& SkewedCone::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* SkewedCone::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* SkewedCone::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void SkewedCone::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required .Bentley.Geometry.Proto.DPoint3d centerB = 2;
inline bool SkewedCone::has_centerB() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SkewedCone::set_has_centerB() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SkewedCone::clear_has_centerB() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SkewedCone::clear_centerB() {
  if (centerB_ != NULL) centerB_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_centerB();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& SkewedCone::centerB() const {
  return centerB_ != NULL ? *centerB_ : *default_instance_->centerB_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* SkewedCone::mutable_centerB() {
  set_has_centerB();
  if (centerB_ == NULL) centerB_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return centerB_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* SkewedCone::release_centerB() {
  clear_has_centerB();
  ::Bentley::Geometry::Proto::DPoint3d* temp = centerB_;
  centerB_ = NULL;
  return temp;
}
inline void SkewedCone::set_allocated_centerB(::Bentley::Geometry::Proto::DPoint3d* centerB) {
  delete centerB_;
  centerB_ = centerB;
  if (centerB) {
    set_has_centerB();
  } else {
    clear_has_centerB();
  }
}

// required double radiusA = 3;
inline bool SkewedCone::has_radiusA() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SkewedCone::set_has_radiusA() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SkewedCone::clear_has_radiusA() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SkewedCone::clear_radiusA() {
  radiusA_ = 0;
  clear_has_radiusA();
}
inline double SkewedCone::radiusA() const {
  return radiusA_;
}
inline void SkewedCone::set_radiusA(double value) {
  set_has_radiusA();
  radiusA_ = value;
}

// required double radiusB = 4;
inline bool SkewedCone::has_radiusB() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SkewedCone::set_has_radiusB() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SkewedCone::clear_has_radiusB() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SkewedCone::clear_radiusB() {
  radiusB_ = 0;
  clear_has_radiusB();
}
inline double SkewedCone::radiusB() const {
  return radiusB_;
}
inline void SkewedCone::set_radiusB(double value) {
  set_has_radiusB();
  radiusB_ = value;
}

// required bool bSolidFlag = 5;
inline bool SkewedCone::has_bSolidFlag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SkewedCone::set_has_bSolidFlag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SkewedCone::clear_has_bSolidFlag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SkewedCone::clear_bSolidFlag() {
  bSolidFlag_ = false;
  clear_has_bSolidFlag();
}
inline bool SkewedCone::bSolidFlag() const {
  return bSolidFlag_;
}
inline void SkewedCone::set_bSolidFlag(bool value) {
  set_has_bSolidFlag();
  bSolidFlag_ = value;
}

// -------------------------------------------------------------------

// SolidBySweptSurface

// required .Bentley.Geometry.Proto.ISurface BaseGeometry = 1;
inline bool SolidBySweptSurface::has_BaseGeometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SolidBySweptSurface::set_has_BaseGeometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SolidBySweptSurface::clear_has_BaseGeometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SolidBySweptSurface::clear_BaseGeometry() {
  if (BaseGeometry_ != NULL) BaseGeometry_->::Bentley::Geometry::Proto::ISurface::Clear();
  clear_has_BaseGeometry();
}
inline const ::Bentley::Geometry::Proto::ISurface& SolidBySweptSurface::BaseGeometry() const {
  return BaseGeometry_ != NULL ? *BaseGeometry_ : *default_instance_->BaseGeometry_;
}
inline ::Bentley::Geometry::Proto::ISurface* SolidBySweptSurface::mutable_BaseGeometry() {
  set_has_BaseGeometry();
  if (BaseGeometry_ == NULL) BaseGeometry_ = new ::Bentley::Geometry::Proto::ISurface;
  return BaseGeometry_;
}
inline ::Bentley::Geometry::Proto::ISurface* SolidBySweptSurface::release_BaseGeometry() {
  clear_has_BaseGeometry();
  ::Bentley::Geometry::Proto::ISurface* temp = BaseGeometry_;
  BaseGeometry_ = NULL;
  return temp;
}
inline void SolidBySweptSurface::set_allocated_BaseGeometry(::Bentley::Geometry::Proto::ISurface* BaseGeometry) {
  delete BaseGeometry_;
  BaseGeometry_ = BaseGeometry;
  if (BaseGeometry) {
    set_has_BaseGeometry();
  } else {
    clear_has_BaseGeometry();
  }
}

// required .Bentley.Geometry.Proto.ICurve RailCurve = 2;
inline bool SolidBySweptSurface::has_RailCurve() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SolidBySweptSurface::set_has_RailCurve() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SolidBySweptSurface::clear_has_RailCurve() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SolidBySweptSurface::clear_RailCurve() {
  if (RailCurve_ != NULL) RailCurve_->::Bentley::Geometry::Proto::ICurve::Clear();
  clear_has_RailCurve();
}
inline const ::Bentley::Geometry::Proto::ICurve& SolidBySweptSurface::RailCurve() const {
  return RailCurve_ != NULL ? *RailCurve_ : *default_instance_->RailCurve_;
}
inline ::Bentley::Geometry::Proto::ICurve* SolidBySweptSurface::mutable_RailCurve() {
  set_has_RailCurve();
  if (RailCurve_ == NULL) RailCurve_ = new ::Bentley::Geometry::Proto::ICurve;
  return RailCurve_;
}
inline ::Bentley::Geometry::Proto::ICurve* SolidBySweptSurface::release_RailCurve() {
  clear_has_RailCurve();
  ::Bentley::Geometry::Proto::ICurve* temp = RailCurve_;
  RailCurve_ = NULL;
  return temp;
}
inline void SolidBySweptSurface::set_allocated_RailCurve(::Bentley::Geometry::Proto::ICurve* RailCurve) {
  delete RailCurve_;
  RailCurve_ = RailCurve;
  if (RailCurve) {
    set_has_RailCurve();
  } else {
    clear_has_RailCurve();
  }
}

// -------------------------------------------------------------------

// Sphere

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool Sphere::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sphere::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sphere::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sphere::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& Sphere::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* Sphere::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* Sphere::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void Sphere::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required double radius = 2;
inline bool Sphere::has_radius() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sphere::set_has_radius() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sphere::clear_has_radius() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sphere::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline double Sphere::radius() const {
  return radius_;
}
inline void Sphere::set_radius(double value) {
  set_has_radius();
  radius_ = value;
}

// -------------------------------------------------------------------

// Spiral

// required string SpiralType = 1;
inline bool Spiral::has_SpiralType() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Spiral::set_has_SpiralType() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Spiral::clear_has_SpiralType() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Spiral::clear_SpiralType() {
  if (SpiralType_ != &::google::protobuf::internal::kEmptyString) {
    SpiralType_->clear();
  }
  clear_has_SpiralType();
}
inline const ::Bentley::Utf8String& Spiral::SpiralType() const {
  return *SpiralType_;
}
inline void Spiral::set_SpiralType(const ::Bentley::Utf8String& value) {
  set_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    SpiralType_ = new ::Bentley::Utf8String;
  }
  SpiralType_->assign(value);
}
inline void Spiral::set_SpiralType(const char* value) {
  set_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    SpiralType_ = new ::Bentley::Utf8String;
  }
  SpiralType_->assign(value);
}
inline void Spiral::set_SpiralType(const char* value, size_t size) {
  set_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    SpiralType_ = new ::Bentley::Utf8String;
  }
  SpiralType_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::Bentley::Utf8String* Spiral::mutable_SpiralType() {
  set_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    SpiralType_ = new ::Bentley::Utf8String;
  }
  return SpiralType_;
}
inline ::Bentley::Utf8String* Spiral::release_SpiralType() {
  clear_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::Bentley::Utf8String* temp = SpiralType_;
    SpiralType_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Spiral::set_allocated_SpiralType(::Bentley::Utf8String* SpiralType) {
  if (SpiralType_ != &::google::protobuf::internal::kEmptyString) {
    delete SpiralType_;
  }
  if (SpiralType) {
    set_has_SpiralType();
    SpiralType_ = SpiralType;
  } else {
    clear_has_SpiralType();
    SpiralType_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Bentley.Geometry.Proto.DPoint3d StartPoint = 2;
inline bool Spiral::has_StartPoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Spiral::set_has_StartPoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Spiral::clear_has_StartPoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Spiral::clear_StartPoint() {
  if (StartPoint_ != NULL) StartPoint_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_StartPoint();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& Spiral::StartPoint() const {
  return StartPoint_ != NULL ? *StartPoint_ : *default_instance_->StartPoint_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Spiral::mutable_StartPoint() {
  set_has_StartPoint();
  if (StartPoint_ == NULL) StartPoint_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return StartPoint_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Spiral::release_StartPoint() {
  clear_has_StartPoint();
  ::Bentley::Geometry::Proto::DPoint3d* temp = StartPoint_;
  StartPoint_ = NULL;
  return temp;
}
inline void Spiral::set_allocated_StartPoint(::Bentley::Geometry::Proto::DPoint3d* StartPoint) {
  delete StartPoint_;
  StartPoint_ = StartPoint;
  if (StartPoint) {
    set_has_StartPoint();
  } else {
    clear_has_StartPoint();
  }
}

// required .Bentley.Geometry.Proto.Angle StartBearing = 3;
inline bool Spiral::has_StartBearing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Spiral::set_has_StartBearing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Spiral::clear_has_StartBearing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Spiral::clear_StartBearing() {
  if (StartBearing_ != NULL) StartBearing_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_StartBearing();
}
inline const ::Bentley::Geometry::Proto::Angle& Spiral::StartBearing() const {
  return StartBearing_ != NULL ? *StartBearing_ : *default_instance_->StartBearing_;
}
inline ::Bentley::Geometry::Proto::Angle* Spiral::mutable_StartBearing() {
  set_has_StartBearing();
  if (StartBearing_ == NULL) StartBearing_ = new ::Bentley::Geometry::Proto::Angle;
  return StartBearing_;
}
inline ::Bentley::Geometry::Proto::Angle* Spiral::release_StartBearing() {
  clear_has_StartBearing();
  ::Bentley::Geometry::Proto::Angle* temp = StartBearing_;
  StartBearing_ = NULL;
  return temp;
}
inline void Spiral::set_allocated_StartBearing(::Bentley::Geometry::Proto::Angle* StartBearing) {
  delete StartBearing_;
  StartBearing_ = StartBearing;
  if (StartBearing) {
    set_has_StartBearing();
  } else {
    clear_has_StartBearing();
  }
}

// required double StartCurvature = 4;
inline bool Spiral::has_StartCurvature() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Spiral::set_has_StartCurvature() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Spiral::clear_has_StartCurvature() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Spiral::clear_StartCurvature() {
  StartCurvature_ = 0;
  clear_has_StartCurvature();
}
inline double Spiral::StartCurvature() const {
  return StartCurvature_;
}
inline void Spiral::set_StartCurvature(double value) {
  set_has_StartCurvature();
  StartCurvature_ = value;
}

// required .Bentley.Geometry.Proto.DPoint3d EndPoint = 5;
inline bool Spiral::has_EndPoint() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Spiral::set_has_EndPoint() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Spiral::clear_has_EndPoint() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Spiral::clear_EndPoint() {
  if (EndPoint_ != NULL) EndPoint_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_EndPoint();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& Spiral::EndPoint() const {
  return EndPoint_ != NULL ? *EndPoint_ : *default_instance_->EndPoint_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Spiral::mutable_EndPoint() {
  set_has_EndPoint();
  if (EndPoint_ == NULL) EndPoint_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return EndPoint_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Spiral::release_EndPoint() {
  clear_has_EndPoint();
  ::Bentley::Geometry::Proto::DPoint3d* temp = EndPoint_;
  EndPoint_ = NULL;
  return temp;
}
inline void Spiral::set_allocated_EndPoint(::Bentley::Geometry::Proto::DPoint3d* EndPoint) {
  delete EndPoint_;
  EndPoint_ = EndPoint;
  if (EndPoint) {
    set_has_EndPoint();
  } else {
    clear_has_EndPoint();
  }
}

// required .Bentley.Geometry.Proto.Angle EndBearing = 6;
inline bool Spiral::has_EndBearing() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Spiral::set_has_EndBearing() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Spiral::clear_has_EndBearing() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Spiral::clear_EndBearing() {
  if (EndBearing_ != NULL) EndBearing_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_EndBearing();
}
inline const ::Bentley::Geometry::Proto::Angle& Spiral::EndBearing() const {
  return EndBearing_ != NULL ? *EndBearing_ : *default_instance_->EndBearing_;
}
inline ::Bentley::Geometry::Proto::Angle* Spiral::mutable_EndBearing() {
  set_has_EndBearing();
  if (EndBearing_ == NULL) EndBearing_ = new ::Bentley::Geometry::Proto::Angle;
  return EndBearing_;
}
inline ::Bentley::Geometry::Proto::Angle* Spiral::release_EndBearing() {
  clear_has_EndBearing();
  ::Bentley::Geometry::Proto::Angle* temp = EndBearing_;
  EndBearing_ = NULL;
  return temp;
}
inline void Spiral::set_allocated_EndBearing(::Bentley::Geometry::Proto::Angle* EndBearing) {
  delete EndBearing_;
  EndBearing_ = EndBearing;
  if (EndBearing) {
    set_has_EndBearing();
  } else {
    clear_has_EndBearing();
  }
}

// required double EndCurvature = 7;
inline bool Spiral::has_EndCurvature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Spiral::set_has_EndCurvature() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Spiral::clear_has_EndCurvature() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Spiral::clear_EndCurvature() {
  EndCurvature_ = 0;
  clear_has_EndCurvature();
}
inline double Spiral::EndCurvature() const {
  return EndCurvature_;
}
inline void Spiral::set_EndCurvature(double value) {
  set_has_EndCurvature();
  EndCurvature_ = value;
}

// required .Bentley.Geometry.Proto.IGeometry Geometry = 8;
inline bool Spiral::has_Geometry() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Spiral::set_has_Geometry() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Spiral::clear_has_Geometry() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Spiral::clear_Geometry() {
  if (Geometry_ != NULL) Geometry_->::Bentley::Geometry::Proto::IGeometry::Clear();
  clear_has_Geometry();
}
inline const ::Bentley::Geometry::Proto::IGeometry& Spiral::Geometry() const {
  return Geometry_ != NULL ? *Geometry_ : *default_instance_->Geometry_;
}
inline ::Bentley::Geometry::Proto::IGeometry* Spiral::mutable_Geometry() {
  set_has_Geometry();
  if (Geometry_ == NULL) Geometry_ = new ::Bentley::Geometry::Proto::IGeometry;
  return Geometry_;
}
inline ::Bentley::Geometry::Proto::IGeometry* Spiral::release_Geometry() {
  clear_has_Geometry();
  ::Bentley::Geometry::Proto::IGeometry* temp = Geometry_;
  Geometry_ = NULL;
  return temp;
}
inline void Spiral::set_allocated_Geometry(::Bentley::Geometry::Proto::IGeometry* Geometry) {
  delete Geometry_;
  Geometry_ = Geometry;
  if (Geometry) {
    set_has_Geometry();
  } else {
    clear_has_Geometry();
  }
}

// -------------------------------------------------------------------

// SurfaceBySweptCurve

// required .Bentley.Geometry.Proto.ICurve BaseGeometry = 1;
inline bool SurfaceBySweptCurve::has_BaseGeometry() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SurfaceBySweptCurve::set_has_BaseGeometry() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SurfaceBySweptCurve::clear_has_BaseGeometry() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SurfaceBySweptCurve::clear_BaseGeometry() {
  if (BaseGeometry_ != NULL) BaseGeometry_->::Bentley::Geometry::Proto::ICurve::Clear();
  clear_has_BaseGeometry();
}
inline const ::Bentley::Geometry::Proto::ICurve& SurfaceBySweptCurve::BaseGeometry() const {
  return BaseGeometry_ != NULL ? *BaseGeometry_ : *default_instance_->BaseGeometry_;
}
inline ::Bentley::Geometry::Proto::ICurve* SurfaceBySweptCurve::mutable_BaseGeometry() {
  set_has_BaseGeometry();
  if (BaseGeometry_ == NULL) BaseGeometry_ = new ::Bentley::Geometry::Proto::ICurve;
  return BaseGeometry_;
}
inline ::Bentley::Geometry::Proto::ICurve* SurfaceBySweptCurve::release_BaseGeometry() {
  clear_has_BaseGeometry();
  ::Bentley::Geometry::Proto::ICurve* temp = BaseGeometry_;
  BaseGeometry_ = NULL;
  return temp;
}
inline void SurfaceBySweptCurve::set_allocated_BaseGeometry(::Bentley::Geometry::Proto::ICurve* BaseGeometry) {
  delete BaseGeometry_;
  BaseGeometry_ = BaseGeometry;
  if (BaseGeometry) {
    set_has_BaseGeometry();
  } else {
    clear_has_BaseGeometry();
  }
}

// required .Bentley.Geometry.Proto.ICurve RailCurve = 2;
inline bool SurfaceBySweptCurve::has_RailCurve() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SurfaceBySweptCurve::set_has_RailCurve() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SurfaceBySweptCurve::clear_has_RailCurve() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SurfaceBySweptCurve::clear_RailCurve() {
  if (RailCurve_ != NULL) RailCurve_->::Bentley::Geometry::Proto::ICurve::Clear();
  clear_has_RailCurve();
}
inline const ::Bentley::Geometry::Proto::ICurve& SurfaceBySweptCurve::RailCurve() const {
  return RailCurve_ != NULL ? *RailCurve_ : *default_instance_->RailCurve_;
}
inline ::Bentley::Geometry::Proto::ICurve* SurfaceBySweptCurve::mutable_RailCurve() {
  set_has_RailCurve();
  if (RailCurve_ == NULL) RailCurve_ = new ::Bentley::Geometry::Proto::ICurve;
  return RailCurve_;
}
inline ::Bentley::Geometry::Proto::ICurve* SurfaceBySweptCurve::release_RailCurve() {
  clear_has_RailCurve();
  ::Bentley::Geometry::Proto::ICurve* temp = RailCurve_;
  RailCurve_ = NULL;
  return temp;
}
inline void SurfaceBySweptCurve::set_allocated_RailCurve(::Bentley::Geometry::Proto::ICurve* RailCurve) {
  delete RailCurve_;
  RailCurve_ = RailCurve;
  if (RailCurve) {
    set_has_RailCurve();
  } else {
    clear_has_RailCurve();
  }
}

// -------------------------------------------------------------------

// TorusPipe

// required .Bentley.Geometry.Proto.IPlacement placement = 1;
inline bool TorusPipe::has_placement() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TorusPipe::set_has_placement() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TorusPipe::clear_has_placement() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TorusPipe::clear_placement() {
  if (placement_ != NULL) placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& TorusPipe::placement() const {
  return placement_ != NULL ? *placement_ : *default_instance_->placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* TorusPipe::mutable_placement() {
  set_has_placement();
  if (placement_ == NULL) placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* TorusPipe::release_placement() {
  clear_has_placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = placement_;
  placement_ = NULL;
  return temp;
}
inline void TorusPipe::set_allocated_placement(::Bentley::Geometry::Proto::IPlacement* placement) {
  delete placement_;
  placement_ = placement;
  if (placement) {
    set_has_placement();
  } else {
    clear_has_placement();
  }
}

// required double radiusA = 2;
inline bool TorusPipe::has_radiusA() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TorusPipe::set_has_radiusA() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TorusPipe::clear_has_radiusA() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TorusPipe::clear_radiusA() {
  radiusA_ = 0;
  clear_has_radiusA();
}
inline double TorusPipe::radiusA() const {
  return radiusA_;
}
inline void TorusPipe::set_radiusA(double value) {
  set_has_radiusA();
  radiusA_ = value;
}

// required double radiusB = 3;
inline bool TorusPipe::has_radiusB() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TorusPipe::set_has_radiusB() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TorusPipe::clear_has_radiusB() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TorusPipe::clear_radiusB() {
  radiusB_ = 0;
  clear_has_radiusB();
}
inline double TorusPipe::radiusB() const {
  return radiusB_;
}
inline void TorusPipe::set_radiusB(double value) {
  set_has_radiusB();
  radiusB_ = value;
}

// required .Bentley.Geometry.Proto.Angle startAngle = 4;
inline bool TorusPipe::has_startAngle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TorusPipe::set_has_startAngle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TorusPipe::clear_has_startAngle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TorusPipe::clear_startAngle() {
  if (startAngle_ != NULL) startAngle_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_startAngle();
}
inline const ::Bentley::Geometry::Proto::Angle& TorusPipe::startAngle() const {
  return startAngle_ != NULL ? *startAngle_ : *default_instance_->startAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* TorusPipe::mutable_startAngle() {
  set_has_startAngle();
  if (startAngle_ == NULL) startAngle_ = new ::Bentley::Geometry::Proto::Angle;
  return startAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* TorusPipe::release_startAngle() {
  clear_has_startAngle();
  ::Bentley::Geometry::Proto::Angle* temp = startAngle_;
  startAngle_ = NULL;
  return temp;
}
inline void TorusPipe::set_allocated_startAngle(::Bentley::Geometry::Proto::Angle* startAngle) {
  delete startAngle_;
  startAngle_ = startAngle;
  if (startAngle) {
    set_has_startAngle();
  } else {
    clear_has_startAngle();
  }
}

// required .Bentley.Geometry.Proto.Angle sweepAngle = 5;
inline bool TorusPipe::has_sweepAngle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TorusPipe::set_has_sweepAngle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TorusPipe::clear_has_sweepAngle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TorusPipe::clear_sweepAngle() {
  if (sweepAngle_ != NULL) sweepAngle_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_sweepAngle();
}
inline const ::Bentley::Geometry::Proto::Angle& TorusPipe::sweepAngle() const {
  return sweepAngle_ != NULL ? *sweepAngle_ : *default_instance_->sweepAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* TorusPipe::mutable_sweepAngle() {
  set_has_sweepAngle();
  if (sweepAngle_ == NULL) sweepAngle_ = new ::Bentley::Geometry::Proto::Angle;
  return sweepAngle_;
}
inline ::Bentley::Geometry::Proto::Angle* TorusPipe::release_sweepAngle() {
  clear_has_sweepAngle();
  ::Bentley::Geometry::Proto::Angle* temp = sweepAngle_;
  sweepAngle_ = NULL;
  return temp;
}
inline void TorusPipe::set_allocated_sweepAngle(::Bentley::Geometry::Proto::Angle* sweepAngle) {
  delete sweepAngle_;
  sweepAngle_ = sweepAngle;
  if (sweepAngle) {
    set_has_sweepAngle();
  } else {
    clear_has_sweepAngle();
  }
}

// required bool bSolidFlag = 6;
inline bool TorusPipe::has_bSolidFlag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TorusPipe::set_has_bSolidFlag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TorusPipe::clear_has_bSolidFlag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TorusPipe::clear_bSolidFlag() {
  bSolidFlag_ = false;
  clear_has_bSolidFlag();
}
inline bool TorusPipe::bSolidFlag() const {
  return bSolidFlag_;
}
inline void TorusPipe::set_bSolidFlag(bool value) {
  set_has_bSolidFlag();
  bSolidFlag_ = value;
}

// -------------------------------------------------------------------

// TransformedGeometry

// required .Bentley.Geometry.Proto.DTransform3d Transform = 1;
inline bool TransformedGeometry::has_Transform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransformedGeometry::set_has_Transform() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransformedGeometry::clear_has_Transform() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransformedGeometry::clear_Transform() {
  if (Transform_ != NULL) Transform_->::Bentley::Geometry::Proto::DTransform3d::Clear();
  clear_has_Transform();
}
inline const ::Bentley::Geometry::Proto::DTransform3d& TransformedGeometry::Transform() const {
  return Transform_ != NULL ? *Transform_ : *default_instance_->Transform_;
}
inline ::Bentley::Geometry::Proto::DTransform3d* TransformedGeometry::mutable_Transform() {
  set_has_Transform();
  if (Transform_ == NULL) Transform_ = new ::Bentley::Geometry::Proto::DTransform3d;
  return Transform_;
}
inline ::Bentley::Geometry::Proto::DTransform3d* TransformedGeometry::release_Transform() {
  clear_has_Transform();
  ::Bentley::Geometry::Proto::DTransform3d* temp = Transform_;
  Transform_ = NULL;
  return temp;
}
inline void TransformedGeometry::set_allocated_Transform(::Bentley::Geometry::Proto::DTransform3d* Transform) {
  delete Transform_;
  Transform_ = Transform;
  if (Transform) {
    set_has_Transform();
  } else {
    clear_has_Transform();
  }
}

// required .Bentley.Geometry.Proto.IGeometry Geometry = 2;
inline bool TransformedGeometry::has_Geometry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransformedGeometry::set_has_Geometry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransformedGeometry::clear_has_Geometry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransformedGeometry::clear_Geometry() {
  if (Geometry_ != NULL) Geometry_->::Bentley::Geometry::Proto::IGeometry::Clear();
  clear_has_Geometry();
}
inline const ::Bentley::Geometry::Proto::IGeometry& TransformedGeometry::Geometry() const {
  return Geometry_ != NULL ? *Geometry_ : *default_instance_->Geometry_;
}
inline ::Bentley::Geometry::Proto::IGeometry* TransformedGeometry::mutable_Geometry() {
  set_has_Geometry();
  if (Geometry_ == NULL) Geometry_ = new ::Bentley::Geometry::Proto::IGeometry;
  return Geometry_;
}
inline ::Bentley::Geometry::Proto::IGeometry* TransformedGeometry::release_Geometry() {
  clear_has_Geometry();
  ::Bentley::Geometry::Proto::IGeometry* temp = Geometry_;
  Geometry_ = NULL;
  return temp;
}
inline void TransformedGeometry::set_allocated_Geometry(::Bentley::Geometry::Proto::IGeometry* Geometry) {
  delete Geometry_;
  Geometry_ = Geometry;
  if (Geometry) {
    set_has_Geometry();
  } else {
    clear_has_Geometry();
  }
}

// -------------------------------------------------------------------

// TransitionSpiral

// required string SpiralType = 1;
inline bool TransitionSpiral::has_SpiralType() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransitionSpiral::set_has_SpiralType() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransitionSpiral::clear_has_SpiralType() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransitionSpiral::clear_SpiralType() {
  if (SpiralType_ != &::google::protobuf::internal::kEmptyString) {
    SpiralType_->clear();
  }
  clear_has_SpiralType();
}
inline const ::Bentley::Utf8String& TransitionSpiral::SpiralType() const {
  return *SpiralType_;
}
inline void TransitionSpiral::set_SpiralType(const ::Bentley::Utf8String& value) {
  set_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    SpiralType_ = new ::Bentley::Utf8String;
  }
  SpiralType_->assign(value);
}
inline void TransitionSpiral::set_SpiralType(const char* value) {
  set_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    SpiralType_ = new ::Bentley::Utf8String;
  }
  SpiralType_->assign(value);
}
inline void TransitionSpiral::set_SpiralType(const char* value, size_t size) {
  set_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    SpiralType_ = new ::Bentley::Utf8String;
  }
  SpiralType_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::Bentley::Utf8String* TransitionSpiral::mutable_SpiralType() {
  set_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    SpiralType_ = new ::Bentley::Utf8String;
  }
  return SpiralType_;
}
inline ::Bentley::Utf8String* TransitionSpiral::release_SpiralType() {
  clear_has_SpiralType();
  if (SpiralType_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::Bentley::Utf8String* temp = SpiralType_;
    SpiralType_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TransitionSpiral::set_allocated_SpiralType(::Bentley::Utf8String* SpiralType) {
  if (SpiralType_ != &::google::protobuf::internal::kEmptyString) {
    delete SpiralType_;
  }
  if (SpiralType) {
    set_has_SpiralType();
    SpiralType_ = SpiralType;
  } else {
    clear_has_SpiralType();
    SpiralType_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Bentley.Geometry.Proto.IPlacement Placement = 2;
inline bool TransitionSpiral::has_Placement() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransitionSpiral::set_has_Placement() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransitionSpiral::clear_has_Placement() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransitionSpiral::clear_Placement() {
  if (Placement_ != NULL) Placement_->::Bentley::Geometry::Proto::IPlacement::Clear();
  clear_has_Placement();
}
inline const ::Bentley::Geometry::Proto::IPlacement& TransitionSpiral::Placement() const {
  return Placement_ != NULL ? *Placement_ : *default_instance_->Placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* TransitionSpiral::mutable_Placement() {
  set_has_Placement();
  if (Placement_ == NULL) Placement_ = new ::Bentley::Geometry::Proto::IPlacement;
  return Placement_;
}
inline ::Bentley::Geometry::Proto::IPlacement* TransitionSpiral::release_Placement() {
  clear_has_Placement();
  ::Bentley::Geometry::Proto::IPlacement* temp = Placement_;
  Placement_ = NULL;
  return temp;
}
inline void TransitionSpiral::set_allocated_Placement(::Bentley::Geometry::Proto::IPlacement* Placement) {
  delete Placement_;
  Placement_ = Placement;
  if (Placement) {
    set_has_Placement();
  } else {
    clear_has_Placement();
  }
}

// required .Bentley.Geometry.Proto.Angle StartBearing = 3;
inline bool TransitionSpiral::has_StartBearing() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransitionSpiral::set_has_StartBearing() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransitionSpiral::clear_has_StartBearing() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransitionSpiral::clear_StartBearing() {
  if (StartBearing_ != NULL) StartBearing_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_StartBearing();
}
inline const ::Bentley::Geometry::Proto::Angle& TransitionSpiral::StartBearing() const {
  return StartBearing_ != NULL ? *StartBearing_ : *default_instance_->StartBearing_;
}
inline ::Bentley::Geometry::Proto::Angle* TransitionSpiral::mutable_StartBearing() {
  set_has_StartBearing();
  if (StartBearing_ == NULL) StartBearing_ = new ::Bentley::Geometry::Proto::Angle;
  return StartBearing_;
}
inline ::Bentley::Geometry::Proto::Angle* TransitionSpiral::release_StartBearing() {
  clear_has_StartBearing();
  ::Bentley::Geometry::Proto::Angle* temp = StartBearing_;
  StartBearing_ = NULL;
  return temp;
}
inline void TransitionSpiral::set_allocated_StartBearing(::Bentley::Geometry::Proto::Angle* StartBearing) {
  delete StartBearing_;
  StartBearing_ = StartBearing;
  if (StartBearing) {
    set_has_StartBearing();
  } else {
    clear_has_StartBearing();
  }
}

// required double StartRadius = 4;
inline bool TransitionSpiral::has_StartRadius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransitionSpiral::set_has_StartRadius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransitionSpiral::clear_has_StartRadius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransitionSpiral::clear_StartRadius() {
  StartRadius_ = 0;
  clear_has_StartRadius();
}
inline double TransitionSpiral::StartRadius() const {
  return StartRadius_;
}
inline void TransitionSpiral::set_StartRadius(double value) {
  set_has_StartRadius();
  StartRadius_ = value;
}

// required .Bentley.Geometry.Proto.Angle EndBearing = 5;
inline bool TransitionSpiral::has_EndBearing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransitionSpiral::set_has_EndBearing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransitionSpiral::clear_has_EndBearing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransitionSpiral::clear_EndBearing() {
  if (EndBearing_ != NULL) EndBearing_->::Bentley::Geometry::Proto::Angle::Clear();
  clear_has_EndBearing();
}
inline const ::Bentley::Geometry::Proto::Angle& TransitionSpiral::EndBearing() const {
  return EndBearing_ != NULL ? *EndBearing_ : *default_instance_->EndBearing_;
}
inline ::Bentley::Geometry::Proto::Angle* TransitionSpiral::mutable_EndBearing() {
  set_has_EndBearing();
  if (EndBearing_ == NULL) EndBearing_ = new ::Bentley::Geometry::Proto::Angle;
  return EndBearing_;
}
inline ::Bentley::Geometry::Proto::Angle* TransitionSpiral::release_EndBearing() {
  clear_has_EndBearing();
  ::Bentley::Geometry::Proto::Angle* temp = EndBearing_;
  EndBearing_ = NULL;
  return temp;
}
inline void TransitionSpiral::set_allocated_EndBearing(::Bentley::Geometry::Proto::Angle* EndBearing) {
  delete EndBearing_;
  EndBearing_ = EndBearing;
  if (EndBearing) {
    set_has_EndBearing();
  } else {
    clear_has_EndBearing();
  }
}

// required double EndRadius = 6;
inline bool TransitionSpiral::has_EndRadius() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransitionSpiral::set_has_EndRadius() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransitionSpiral::clear_has_EndRadius() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransitionSpiral::clear_EndRadius() {
  EndRadius_ = 0;
  clear_has_EndRadius();
}
inline double TransitionSpiral::EndRadius() const {
  return EndRadius_;
}
inline void TransitionSpiral::set_EndRadius(double value) {
  set_has_EndRadius();
  EndRadius_ = value;
}

// required double ActiveStartFraction = 7;
inline bool TransitionSpiral::has_ActiveStartFraction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransitionSpiral::set_has_ActiveStartFraction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransitionSpiral::clear_has_ActiveStartFraction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransitionSpiral::clear_ActiveStartFraction() {
  ActiveStartFraction_ = 0;
  clear_has_ActiveStartFraction();
}
inline double TransitionSpiral::ActiveStartFraction() const {
  return ActiveStartFraction_;
}
inline void TransitionSpiral::set_ActiveStartFraction(double value) {
  set_has_ActiveStartFraction();
  ActiveStartFraction_ = value;
}

// required double ActiveEndFraction = 8;
inline bool TransitionSpiral::has_ActiveEndFraction() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransitionSpiral::set_has_ActiveEndFraction() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransitionSpiral::clear_has_ActiveEndFraction() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransitionSpiral::clear_ActiveEndFraction() {
  ActiveEndFraction_ = 0;
  clear_has_ActiveEndFraction();
}
inline double TransitionSpiral::ActiveEndFraction() const {
  return ActiveEndFraction_;
}
inline void TransitionSpiral::set_ActiveEndFraction(double value) {
  set_has_ActiveEndFraction();
  ActiveEndFraction_ = value;
}

// required .Bentley.Geometry.Proto.IGeometry Geometry = 9;
inline bool TransitionSpiral::has_Geometry() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TransitionSpiral::set_has_Geometry() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TransitionSpiral::clear_has_Geometry() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TransitionSpiral::clear_Geometry() {
  if (Geometry_ != NULL) Geometry_->::Bentley::Geometry::Proto::IGeometry::Clear();
  clear_has_Geometry();
}
inline const ::Bentley::Geometry::Proto::IGeometry& TransitionSpiral::Geometry() const {
  return Geometry_ != NULL ? *Geometry_ : *default_instance_->Geometry_;
}
inline ::Bentley::Geometry::Proto::IGeometry* TransitionSpiral::mutable_Geometry() {
  set_has_Geometry();
  if (Geometry_ == NULL) Geometry_ = new ::Bentley::Geometry::Proto::IGeometry;
  return Geometry_;
}
inline ::Bentley::Geometry::Proto::IGeometry* TransitionSpiral::release_Geometry() {
  clear_has_Geometry();
  ::Bentley::Geometry::Proto::IGeometry* temp = Geometry_;
  Geometry_ = NULL;
  return temp;
}
inline void TransitionSpiral::set_allocated_Geometry(::Bentley::Geometry::Proto::IGeometry* Geometry) {
  delete Geometry_;
  Geometry_ = Geometry;
  if (Geometry) {
    set_has_Geometry();
  } else {
    clear_has_Geometry();
  }
}

// -------------------------------------------------------------------

// Vector

// required .Bentley.Geometry.Proto.DPoint3d xyz = 1;
inline bool Vector::has_xyz() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector::set_has_xyz() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector::clear_has_xyz() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector::clear_xyz() {
  if (xyz_ != NULL) xyz_->::Bentley::Geometry::Proto::DPoint3d::Clear();
  clear_has_xyz();
}
inline const ::Bentley::Geometry::Proto::DPoint3d& Vector::xyz() const {
  return xyz_ != NULL ? *xyz_ : *default_instance_->xyz_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Vector::mutable_xyz() {
  set_has_xyz();
  if (xyz_ == NULL) xyz_ = new ::Bentley::Geometry::Proto::DPoint3d;
  return xyz_;
}
inline ::Bentley::Geometry::Proto::DPoint3d* Vector::release_xyz() {
  clear_has_xyz();
  ::Bentley::Geometry::Proto::DPoint3d* temp = xyz_;
  xyz_ = NULL;
  return temp;
}
inline void Vector::set_allocated_xyz(::Bentley::Geometry::Proto::DPoint3d* xyz) {
  delete xyz_;
  xyz_ = xyz;
  if (xyz) {
    set_has_xyz();
  } else {
    clear_has_xyz();
  }
}

// required .Bentley.Geometry.Proto.DVector3d vector = 2;
inline bool Vector::has_vector() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector::set_has_vector() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector::clear_has_vector() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector::clear_vector() {
  if (vector_ != NULL) vector_->::Bentley::Geometry::Proto::DVector3d::Clear();
  clear_has_vector();
}
inline const ::Bentley::Geometry::Proto::DVector3d& Vector::vector() const {
  return vector_ != NULL ? *vector_ : *default_instance_->vector_;
}
inline ::Bentley::Geometry::Proto::DVector3d* Vector::mutable_vector() {
  set_has_vector();
  if (vector_ == NULL) vector_ = new ::Bentley::Geometry::Proto::DVector3d;
  return vector_;
}
inline ::Bentley::Geometry::Proto::DVector3d* Vector::release_vector() {
  clear_has_vector();
  ::Bentley::Geometry::Proto::DVector3d* temp = vector_;
  vector_ = NULL;
  return temp;
}
inline void Vector::set_allocated_vector(::Bentley::Geometry::Proto::DVector3d* vector) {
  delete vector_;
  vector_ = vector;
  if (vector) {
    set_has_vector();
  } else {
    clear_has_vector();
  }
}

// -------------------------------------------------------------------

// AdjacentSurfacePatches

// repeated .Bentley.Geometry.Proto.ISurfacePatch Patch = 1;
inline int AdjacentSurfacePatches::Patch_size() const {
  return Patch_.size();
}
inline void AdjacentSurfacePatches::clear_Patch() {
  Patch_.Clear();
}
inline const ::Bentley::Geometry::Proto::ISurfacePatch& AdjacentSurfacePatches::Patch(int index) const {
  return Patch_.Get(index);
}
inline ::Bentley::Geometry::Proto::ISurfacePatch* AdjacentSurfacePatches::mutable_Patch(int index) {
  return Patch_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::ISurfacePatch* AdjacentSurfacePatches::add_Patch() {
  return Patch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurfacePatch >&
AdjacentSurfacePatches::Patch() const {
  return Patch_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurfacePatch >*
AdjacentSurfacePatches::mutable_Patch() {
  return &Patch_;
}

// -------------------------------------------------------------------

// Group

// repeated .Bentley.Geometry.Proto.IGeometry Member = 1;
inline int Group::Member_size() const {
  return Member_.size();
}
inline void Group::clear_Member() {
  Member_.Clear();
}
inline const ::Bentley::Geometry::Proto::IGeometry& Group::Member(int index) const {
  return Member_.Get(index);
}
inline ::Bentley::Geometry::Proto::IGeometry* Group::mutable_Member(int index) {
  return Member_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::IGeometry* Group::add_Member() {
  return Member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry >&
Group::Member() const {
  return Member_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry >*
Group::mutable_Member() {
  return &Member_;
}

// -------------------------------------------------------------------

// CurveChain

// repeated .Bentley.Geometry.Proto.IPrimitiveCurve Curve = 1;
inline int CurveChain::Curve_size() const {
  return Curve_.size();
}
inline void CurveChain::clear_Curve() {
  Curve_.Clear();
}
inline const ::Bentley::Geometry::Proto::IPrimitiveCurve& CurveChain::Curve(int index) const {
  return Curve_.Get(index);
}
inline ::Bentley::Geometry::Proto::IPrimitiveCurve* CurveChain::mutable_Curve(int index) {
  return Curve_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::IPrimitiveCurve* CurveChain::add_Curve() {
  return Curve_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPrimitiveCurve >&
CurveChain::Curve() const {
  return Curve_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPrimitiveCurve >*
CurveChain::mutable_Curve() {
  return &Curve_;
}

// -------------------------------------------------------------------

// CurveGroup

// repeated .Bentley.Geometry.Proto.ICurve Curve = 1;
inline int CurveGroup::Curve_size() const {
  return Curve_.size();
}
inline void CurveGroup::clear_Curve() {
  Curve_.Clear();
}
inline const ::Bentley::Geometry::Proto::ICurve& CurveGroup::Curve(int index) const {
  return Curve_.Get(index);
}
inline ::Bentley::Geometry::Proto::ICurve* CurveGroup::mutable_Curve(int index) {
  return Curve_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::ICurve* CurveGroup::add_Curve() {
  return Curve_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurve >&
CurveGroup::Curve() const {
  return Curve_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurve >*
CurveGroup::mutable_Curve() {
  return &Curve_;
}

// -------------------------------------------------------------------

// Operation

// required string Name = 1;
inline bool Operation::has_Name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Operation::set_has_Name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Operation::clear_has_Name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Operation::clear_Name() {
  if (Name_ != &::google::protobuf::internal::kEmptyString) {
    Name_->clear();
  }
  clear_has_Name();
}
inline const ::Bentley::Utf8String& Operation::Name() const {
  return *Name_;
}
inline void Operation::set_Name(const ::Bentley::Utf8String& value) {
  set_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    Name_ = new ::Bentley::Utf8String;
  }
  Name_->assign(value);
}
inline void Operation::set_Name(const char* value) {
  set_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    Name_ = new ::Bentley::Utf8String;
  }
  Name_->assign(value);
}
inline void Operation::set_Name(const char* value, size_t size) {
  set_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    Name_ = new ::Bentley::Utf8String;
  }
  Name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::Bentley::Utf8String* Operation::mutable_Name() {
  set_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    Name_ = new ::Bentley::Utf8String;
  }
  return Name_;
}
inline ::Bentley::Utf8String* Operation::release_Name() {
  clear_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::Bentley::Utf8String* temp = Name_;
    Name_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Operation::set_allocated_Name(::Bentley::Utf8String* Name) {
  if (Name_ != &::google::protobuf::internal::kEmptyString) {
    delete Name_;
  }
  if (Name) {
    set_has_Name();
    Name_ = Name;
  } else {
    clear_has_Name();
    Name_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .Bentley.Geometry.Proto.IGeometry Member = 2;
inline int Operation::Member_size() const {
  return Member_.size();
}
inline void Operation::clear_Member() {
  Member_.Clear();
}
inline const ::Bentley::Geometry::Proto::IGeometry& Operation::Member(int index) const {
  return Member_.Get(index);
}
inline ::Bentley::Geometry::Proto::IGeometry* Operation::mutable_Member(int index) {
  return Member_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::IGeometry* Operation::add_Member() {
  return Member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry >&
Operation::Member() const {
  return Member_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IGeometry >*
Operation::mutable_Member() {
  return &Member_;
}

// -------------------------------------------------------------------

// ParametricSurfacePatch

// required .Bentley.Geometry.Proto.IParametricSurface Surface = 1;
inline bool ParametricSurfacePatch::has_Surface() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParametricSurfacePatch::set_has_Surface() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParametricSurfacePatch::clear_has_Surface() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParametricSurfacePatch::clear_Surface() {
  if (Surface_ != NULL) Surface_->::Bentley::Geometry::Proto::IParametricSurface::Clear();
  clear_has_Surface();
}
inline const ::Bentley::Geometry::Proto::IParametricSurface& ParametricSurfacePatch::Surface() const {
  return Surface_ != NULL ? *Surface_ : *default_instance_->Surface_;
}
inline ::Bentley::Geometry::Proto::IParametricSurface* ParametricSurfacePatch::mutable_Surface() {
  set_has_Surface();
  if (Surface_ == NULL) Surface_ = new ::Bentley::Geometry::Proto::IParametricSurface;
  return Surface_;
}
inline ::Bentley::Geometry::Proto::IParametricSurface* ParametricSurfacePatch::release_Surface() {
  clear_has_Surface();
  ::Bentley::Geometry::Proto::IParametricSurface* temp = Surface_;
  Surface_ = NULL;
  return temp;
}
inline void ParametricSurfacePatch::set_allocated_Surface(::Bentley::Geometry::Proto::IParametricSurface* Surface) {
  delete Surface_;
  Surface_ = Surface;
  if (Surface) {
    set_has_Surface();
  } else {
    clear_has_Surface();
  }
}

// repeated .Bentley.Geometry.Proto.ICurveChain CurveChain = 2;
inline int ParametricSurfacePatch::CurveChain_size() const {
  return CurveChain_.size();
}
inline void ParametricSurfacePatch::clear_CurveChain() {
  CurveChain_.Clear();
}
inline const ::Bentley::Geometry::Proto::ICurveChain& ParametricSurfacePatch::CurveChain(int index) const {
  return CurveChain_.Get(index);
}
inline ::Bentley::Geometry::Proto::ICurveChain* ParametricSurfacePatch::mutable_CurveChain(int index) {
  return CurveChain_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::ICurveChain* ParametricSurfacePatch::add_CurveChain() {
  return CurveChain_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain >&
ParametricSurfacePatch::CurveChain() const {
  return CurveChain_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain >*
ParametricSurfacePatch::mutable_CurveChain() {
  return &CurveChain_;
}

// required .Bentley.Geometry.Proto.LoopType LoopType = 3;
inline bool ParametricSurfacePatch::has_LoopType() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParametricSurfacePatch::set_has_LoopType() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParametricSurfacePatch::clear_has_LoopType() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParametricSurfacePatch::clear_LoopType() {
  if (LoopType_ != NULL) LoopType_->::Bentley::Geometry::Proto::LoopType::Clear();
  clear_has_LoopType();
}
inline const ::Bentley::Geometry::Proto::LoopType& ParametricSurfacePatch::LoopType() const {
  return LoopType_ != NULL ? *LoopType_ : *default_instance_->LoopType_;
}
inline ::Bentley::Geometry::Proto::LoopType* ParametricSurfacePatch::mutable_LoopType() {
  set_has_LoopType();
  if (LoopType_ == NULL) LoopType_ = new ::Bentley::Geometry::Proto::LoopType;
  return LoopType_;
}
inline ::Bentley::Geometry::Proto::LoopType* ParametricSurfacePatch::release_LoopType() {
  clear_has_LoopType();
  ::Bentley::Geometry::Proto::LoopType* temp = LoopType_;
  LoopType_ = NULL;
  return temp;
}
inline void ParametricSurfacePatch::set_allocated_LoopType(::Bentley::Geometry::Proto::LoopType* LoopType) {
  delete LoopType_;
  LoopType_ = LoopType;
  if (LoopType) {
    set_has_LoopType();
  } else {
    clear_has_LoopType();
  }
}

// -------------------------------------------------------------------

// PointChain

// repeated .Bentley.Geometry.Proto.ISinglePoint Point = 1;
inline int PointChain::Point_size() const {
  return Point_.size();
}
inline void PointChain::clear_Point() {
  Point_.Clear();
}
inline const ::Bentley::Geometry::Proto::ISinglePoint& PointChain::Point(int index) const {
  return Point_.Get(index);
}
inline ::Bentley::Geometry::Proto::ISinglePoint* PointChain::mutable_Point(int index) {
  return Point_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::ISinglePoint* PointChain::add_Point() {
  return Point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISinglePoint >&
PointChain::Point() const {
  return Point_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISinglePoint >*
PointChain::mutable_Point() {
  return &Point_;
}

// -------------------------------------------------------------------

// PointGroup

// repeated .Bentley.Geometry.Proto.IPoint Member = 1;
inline int PointGroup::Member_size() const {
  return Member_.size();
}
inline void PointGroup::clear_Member() {
  Member_.Clear();
}
inline const ::Bentley::Geometry::Proto::IPoint& PointGroup::Member(int index) const {
  return Member_.Get(index);
}
inline ::Bentley::Geometry::Proto::IPoint* PointGroup::mutable_Member(int index) {
  return Member_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::IPoint* PointGroup::add_Member() {
  return Member_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPoint >&
PointGroup::Member() const {
  return Member_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::IPoint >*
PointGroup::mutable_Member() {
  return &Member_;
}

// -------------------------------------------------------------------

// SharedGroupDef

// required string Name = 1;
inline bool SharedGroupDef::has_Name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SharedGroupDef::set_has_Name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SharedGroupDef::clear_has_Name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SharedGroupDef::clear_Name() {
  if (Name_ != &::google::protobuf::internal::kEmptyString) {
    Name_->clear();
  }
  clear_has_Name();
}
inline const ::Bentley::Utf8String& SharedGroupDef::Name() const {
  return *Name_;
}
inline void SharedGroupDef::set_Name(const ::Bentley::Utf8String& value) {
  set_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    Name_ = new ::Bentley::Utf8String;
  }
  Name_->assign(value);
}
inline void SharedGroupDef::set_Name(const char* value) {
  set_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    Name_ = new ::Bentley::Utf8String;
  }
  Name_->assign(value);
}
inline void SharedGroupDef::set_Name(const char* value, size_t size) {
  set_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    Name_ = new ::Bentley::Utf8String;
  }
  Name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::Bentley::Utf8String* SharedGroupDef::mutable_Name() {
  set_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    Name_ = new ::Bentley::Utf8String;
  }
  return Name_;
}
inline ::Bentley::Utf8String* SharedGroupDef::release_Name() {
  clear_has_Name();
  if (Name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::Bentley::Utf8String* temp = Name_;
    Name_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SharedGroupDef::set_allocated_Name(::Bentley::Utf8String* Name) {
  if (Name_ != &::google::protobuf::internal::kEmptyString) {
    delete Name_;
  }
  if (Name) {
    set_has_Name();
    Name_ = Name;
  } else {
    clear_has_Name();
    Name_ = const_cast< ::Bentley::Utf8String*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .Bentley.Geometry.Proto.IGeometry Geometry = 2;
inline bool SharedGroupDef::has_Geometry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SharedGroupDef::set_has_Geometry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SharedGroupDef::clear_has_Geometry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SharedGroupDef::clear_Geometry() {
  if (Geometry_ != NULL) Geometry_->::Bentley::Geometry::Proto::IGeometry::Clear();
  clear_has_Geometry();
}
inline const ::Bentley::Geometry::Proto::IGeometry& SharedGroupDef::Geometry() const {
  return Geometry_ != NULL ? *Geometry_ : *default_instance_->Geometry_;
}
inline ::Bentley::Geometry::Proto::IGeometry* SharedGroupDef::mutable_Geometry() {
  set_has_Geometry();
  if (Geometry_ == NULL) Geometry_ = new ::Bentley::Geometry::Proto::IGeometry;
  return Geometry_;
}
inline ::Bentley::Geometry::Proto::IGeometry* SharedGroupDef::release_Geometry() {
  clear_has_Geometry();
  ::Bentley::Geometry::Proto::IGeometry* temp = Geometry_;
  Geometry_ = NULL;
  return temp;
}
inline void SharedGroupDef::set_allocated_Geometry(::Bentley::Geometry::Proto::IGeometry* Geometry) {
  delete Geometry_;
  Geometry_ = Geometry;
  if (Geometry) {
    set_has_Geometry();
  } else {
    clear_has_Geometry();
  }
}

// -------------------------------------------------------------------

// SolidGroup

// repeated .Bentley.Geometry.Proto.ISolid Solid = 1;
inline int SolidGroup::Solid_size() const {
  return Solid_.size();
}
inline void SolidGroup::clear_Solid() {
  Solid_.Clear();
}
inline const ::Bentley::Geometry::Proto::ISolid& SolidGroup::Solid(int index) const {
  return Solid_.Get(index);
}
inline ::Bentley::Geometry::Proto::ISolid* SolidGroup::mutable_Solid(int index) {
  return Solid_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::ISolid* SolidGroup::add_Solid() {
  return Solid_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISolid >&
SolidGroup::Solid() const {
  return Solid_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISolid >*
SolidGroup::mutable_Solid() {
  return &Solid_;
}

// -------------------------------------------------------------------

// SurfaceGroup

// repeated .Bentley.Geometry.Proto.ISurface Surface = 1;
inline int SurfaceGroup::Surface_size() const {
  return Surface_.size();
}
inline void SurfaceGroup::clear_Surface() {
  Surface_.Clear();
}
inline const ::Bentley::Geometry::Proto::ISurface& SurfaceGroup::Surface(int index) const {
  return Surface_.Get(index);
}
inline ::Bentley::Geometry::Proto::ISurface* SurfaceGroup::mutable_Surface(int index) {
  return Surface_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::ISurface* SurfaceGroup::add_Surface() {
  return Surface_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurface >&
SurfaceGroup::Surface() const {
  return Surface_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ISurface >*
SurfaceGroup::mutable_Surface() {
  return &Surface_;
}

// -------------------------------------------------------------------

// SurfacePatch

// required .Bentley.Geometry.Proto.ICurveChain ExteriorLoop = 1;
inline bool SurfacePatch::has_ExteriorLoop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SurfacePatch::set_has_ExteriorLoop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SurfacePatch::clear_has_ExteriorLoop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SurfacePatch::clear_ExteriorLoop() {
  if (ExteriorLoop_ != NULL) ExteriorLoop_->::Bentley::Geometry::Proto::ICurveChain::Clear();
  clear_has_ExteriorLoop();
}
inline const ::Bentley::Geometry::Proto::ICurveChain& SurfacePatch::ExteriorLoop() const {
  return ExteriorLoop_ != NULL ? *ExteriorLoop_ : *default_instance_->ExteriorLoop_;
}
inline ::Bentley::Geometry::Proto::ICurveChain* SurfacePatch::mutable_ExteriorLoop() {
  set_has_ExteriorLoop();
  if (ExteriorLoop_ == NULL) ExteriorLoop_ = new ::Bentley::Geometry::Proto::ICurveChain;
  return ExteriorLoop_;
}
inline ::Bentley::Geometry::Proto::ICurveChain* SurfacePatch::release_ExteriorLoop() {
  clear_has_ExteriorLoop();
  ::Bentley::Geometry::Proto::ICurveChain* temp = ExteriorLoop_;
  ExteriorLoop_ = NULL;
  return temp;
}
inline void SurfacePatch::set_allocated_ExteriorLoop(::Bentley::Geometry::Proto::ICurveChain* ExteriorLoop) {
  delete ExteriorLoop_;
  ExteriorLoop_ = ExteriorLoop;
  if (ExteriorLoop) {
    set_has_ExteriorLoop();
  } else {
    clear_has_ExteriorLoop();
  }
}

// repeated .Bentley.Geometry.Proto.ICurveChain HoleLoop = 2;
inline int SurfacePatch::HoleLoop_size() const {
  return HoleLoop_.size();
}
inline void SurfacePatch::clear_HoleLoop() {
  HoleLoop_.Clear();
}
inline const ::Bentley::Geometry::Proto::ICurveChain& SurfacePatch::HoleLoop(int index) const {
  return HoleLoop_.Get(index);
}
inline ::Bentley::Geometry::Proto::ICurveChain* SurfacePatch::mutable_HoleLoop(int index) {
  return HoleLoop_.Mutable(index);
}
inline ::Bentley::Geometry::Proto::ICurveChain* SurfacePatch::add_HoleLoop() {
  return HoleLoop_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain >&
SurfacePatch::HoleLoop() const {
  return HoleLoop_;
}
inline ::google::protobuf::RepeatedPtrField< ::Bentley::Geometry::Proto::ICurveChain >*
SurfacePatch::mutable_HoleLoop() {
  return &HoleLoop_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace Proto
}  // namespace Geometry
}  // namespace Bentley

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Bentley::Geometry::Proto::LoopType_LoopTypeEnum>() {
  return ::Bentley::Geometry::Proto::LoopType_LoopTypeEnum_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_allcg_2eproto__INCLUDED
