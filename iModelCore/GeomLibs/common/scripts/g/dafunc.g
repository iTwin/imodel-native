! gema patterns to transform native functions into JNI-callable methods
\B=@DAFUNC_NONEDITMESSAGE{}
\E=@DAFUNC_NONEDITMESSAGE{}
DAFUNC_NONEDITMESSAGE:=\
\/\* ************ DO NOT EDIT THIS FILE ***************** \*\/\n\
\/\* ********* THIS IS MACHINE GENERATED CODE *********** \*\/\n

@define{@read{@getenv{GEMADIR}g\\domains.g}}

\/\*\SMETHOD(<I>,<I>,none)\S\*\/=

! DOMAIN: Default
! PATTERN: <Comment block> + Public + func type and name + arglist
! ACTION:  The pattern followed by ;

\/\*\WVBSUB(<I>)\S\*\/\S\
<FUNCTIONCOMMENT>\W\N\
Public\S<I>\S<I><OPTIONALCOMMENT>\W(<DAFUNCARGLIST>)=\
\n\/\* BEGIN_NONEDITABLE_CODE \*\/\
\n\#if defined(__midl)\
\n@DAFUNC_StripComment3{@DAFUNC_StripComment2{@DAFUNC_StripComment{$2}}}\
\n@DAFUNC_HelpString{$1}\
\nHRESULT $1\
\n@DATypes{@DAFUNC_StripExtraCommas{(\
@DAFUNC_ParamListToInList{$6}\
@DAFUNC_ParamListToOutList{$6}\
@DAFUNC_ReturnTypeToOutList{$3,@DAFUNC_ParamListOutputParams{$6},}\
\n)\;}}\
\n\#else\
\nSTDMETHODIMP $1\
\n@DATypes{@DAFUNC_StripExtraCommas{(\
@DAFUNC_ParamListToDAInputArgList{$6}\
@DAFUNC_ParamListToDAOutputArgList{$6}\
@DAFUNC_DeclareResultParam{$3,@DAFUNC_ParamListOutputParams{$6},}\
\n)}}\
\n\t\{\
@DAFUNC_DeclareHRESULT{}\
@DAFUNC_DeclareLocals{$6}\
@DAFUNC_DeclareResult{@DAFUNC_SimpleCTypeOf{$3}}\
\n\
@DAFUNC_ParamListToConvertToLocal{$6}\
\n\
\n\t@JNI_AssignResult{@DAFUNC_SimpleCTypeOf{$3}}$4\
\n\t\t\
(@DAFUNC_ParamListToNativeCallArgs{$6}\
\n\t\t)\;\
\n\
@DAFUNC_CopyCToDA{$6}\
@DAFUNC_ReturnResult{$3,@DAFUNC_ParamListOutputParams{$6},}\
@DAFUNC_ReturnHRESULT{}\
\n\t\}\
\n\#endif\
\n\/\* END_NONEDITABLE_CODE \*\/\n


?=

! This catches JNIMETHOD, JAVAMETHOD, METHOD, CSIMETHOD, possibly with qualifiers.
FUNCTIONCOMMENT:\W\/\*\W<I>THOD(<t>)\W\*\/=
FUNCTIONCOMMENT:\W\/\*\W<I>THOD<I>(<t>)\W\*\/=
FUNCTIONCOMMENT:\W\/\*<T>\*\/=\/\*$1\*\/
FUNCTIONCOMMENT:=@end

DAFUNCARGLIST:<arglist>=@DAFUNC_RenameArgs{$0}

! Convert microstation types to analgous Automation types:
DATypes:\IDPoint3d\W\*=Point3d \*
DATypes:\IDVec3d\W\*=Vector3d \*
DATypes:\IDRange3d\W\*=Range3d \*
DATypes:\IDPoint2d\W\*=Point2d \*
DATypes:\IRotMatrix\W\*=Matrix3d \*
DATypes:\ITransform\W\*=Transform3d \*
DATypes:?=?

DAStripConst:\Iconst\I=
DAStripConst:\Ip<K><i>=$1$2
DAStripConst:?=?


DAFUNC_RenameArgs:int <I>=int @DAFUNC_CapitalizeVarName{$1}
DAFUNC_RenameArgs:double <I>=double @DAFUNC_CapitalizeVarName{$1}
DAFUNC_RenameArgs:\*\Wp<K><i>=\* $1$2
DAFUNC_RenameArgs:?=?

DAFUNC_CapitalizeVarName:?<u>=@upcase{?}$2


DAFUNC_ParamListToDAInputArgList:const <I>\W\*\W<I>=\n$1\t\*$2,
DAFUNC_ParamListToDAInputArgList:<I> <I>=\n$1\t$2,
DAFUNC_ParamListToDAInputArgList:?=

DAFUNC_ParamListToDAOutputArgList:<I>\W\*\W<I>=\n$1\t\*$2,
DAFUNC_ParamListToDAOutputArgList:const <I>\W\*\W<I>=
DAFUNC_ParamListToDAOutputArgList:<I>\W\*\W<I>=\n$1\t\*$2,
DAFUNC_ParamListToDAOutputArgList:?=

DAFUNC_ParamListOutputParams:<I>\W\*\W<I>=\n$1\t\*$2,
DAFUNC_ParamListOutputParams:const <I>\W\*\W<I>=
DAFUNC_ParamListOutputParams:?=

DAFUNC_StripExtraCommas:,\P\W,=
DAFUNC_StripExtraCommas:,\P\W)=
DAFUNC_StripExtraCommas:?=?

! Invoke with formalReturnType,outputArgTypes,
! where both commas are always there!!
DAFUNC_DeclareResultParam:void,*,=@end
!DAFUNC_DeclareResultParam:void,\W<I>\W\*\W<I>\W,=\n$1\t\*Result@end
DAFUNC_DeclareResultParam:double,\W,=,\ndouble \*Result@end
DAFUNC_DeclareResultParam:BoolInt,,=,\nVARIANT_BOOL \*Result@end
! RULE: Any BoolInt func which also returns other parameters
!   traps into E_FAIL of the function result is false
DAFUNC_DeclareResultParam:BoolInt,\W<I>\W\*\W<I>\W,=
DAFUNC_DeclareResultParam:\W=


DAFUNC_HelpString:<I>=\
\[\n\
helpstring(\"method $1\"),\n\
helpcontext(IDH_MTH@upcase{$1})\n\
\]

DAFUNC_VerbFromNativeName:<I>_<I>=$2
DAFUNC_VerbFromNativeName:?=?

DAFUNC_DeclareHRESULT:=\n\tHRESULT hr \= S_OK\;

DAFUNC_ReturnHRESULT:=\n\treturn hr\;

DAFUNC_ParamListToInList:\Wconst <I>\W\*\W<I>=\n[in] $1\t\*$2,
DAFUNC_ParamListToInList:\W<I>\W<I>=\n[in] $1\t$2,
DAFUNC_ParamListToInList:?=

! Mark ALL outputs as retval -- beware of native functions with both retval and param out.
DAFUNC_ParamListToOutList:\Wconst <I>\W\*\W<I>=
DAFUNC_ParamListToOutList:\W<I>\W\*\W<I>=\n[out, retval] $1\t\*$2,
DAFUNC_ParamListToOutList:?=

! void is ok with anything...
DAFUNC_ReturnTypeToOutList:void,*=
! BoolInt with another output returns the other and raises an exception...
DAFUNC_ReturnTypeToOutList:BoolInt,\W<I>\W\*\W<I>*=
! BoolInt alone is returned
DAFUNC_ReturnTypeToOutList:BoolInt,\W,=\
                            \n[out, retval] VARIANT_BOOL\t\*Result
DAFUNC_ReturnTypeToOutList:<I>,\W,=\n[out, retval] $1\t\*Result
DAFUNC_ReturnTypeToOutList:?*=\nERROR -- unexpected return type combination ($0)

DAFUNC_DeclareResult:void=
DAFUNC_DeclareResult:<I>=\n\t$1 result\;

! This is the chance to mangle the arg list structure.
! These are just prettyprint:
DAFUNC_ArgList:<I> \*\W<I>=\n$1\t\*$2
DAFUNC_ArgList:<I> <I>=\n$1\t$2
DAFUNC_ArgList:,=,
DAFUNC_ArgList:?=


DAFUNC_StripComment:\@bsihdr<u>\n=
! Eliminate funky banner lines.
DAFUNC_StripComment:/[-+=][-+=][-+=][-+=]*/=

! Ignore return notations -- These are subsumed by description
DAFUNC_StripComment:\@return <u>\P\@=

! RULE: Output parameters and instance are going to be function values. Omit this tag.
DAFUNC_StripComment:\@instance \<\=<u>\P\@=
DAFUNC_StripComment:\@instance <I> \<\=<u>\P\@=
DAFUNC_StripComment:\@param <I> \<\=<u>\P\@=
DAFUNC_StripComment:\@instance <I> OUT <u>\P\@=
DAFUNC_StripComment:\@param <I> OUT <u>\P\@=


! RULE: Input instance var is just another param.
DAFUNC_StripComment:\@instance <I> \=\>=\@param $1
DAFUNC_StripComment:\@instance <I> IN=\@param $1

DAFUNC_StripComment:\@indexVerb <u>\n=
DAFUNC_StripComment:\@see <u>\n=
! RULE: Vars passed by pointer are named pXxxx.  Remove the leading p from any
!  word that looks like this.
DAFUNC_StripComment:\=\>=
DAFUNC_StripComment:\IIN\I=
DAFUNC_StripComment:?=?


DAFUNC_StripComment2:\@param=\@Param
DAFUNC_StripComment2:\@description=\@Description
DAFUNC_StripComment2:\Ip<K>=$1
DAFUNC_StripComment2:\/\*\*\/=
DAFUNC_StripComment2:\/\*\*=$0
DAFUNC_StripComment2:\* \P\*=
DAFUNC_StripComment2:?=?

DAFUNC_StripComment3:\@Param <I>=\@Param @DAFUNC_CapitalizeVarName{$1}
DAFUNC_StripComment2:?=?


DAFUNC_ParamListToInOutList:\W<I>\W\*\W<I>=\n[in,out] $1\t$2

! Declare pointers for matrix data, structs for points, guess for others:
DAFUNC_DeclareLocals:const DPoint3d\W\*\W<I>=\n\tDPoint3d @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:const DVec3d\W\*\W<I>=\n\tDVec3d @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:const DRange3d\W\*\W<I>=\n\tDRange3d @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:const DPoint2d\W\*\W<I>=\n\tDPoint2d @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:const RotMatrix\W\*\W<I>=\n\tRotMatrix @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:const Transform\W\*\W<I>=\n\tstruct transform @DAFUNC_CParamNameToLocalCName{$1}\;

DAFUNC_DeclareLocals:DPoint3d\W\*\W<I>=\n\tDPoint3d @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:DVec3d\W\*\W<I>=\n\tDVec3d @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:DRange3d\W\*\W<I>=\n\tDRange3d @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:DPoint2d\W\*\W<I>=\n\tDPoint2d @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:RotMatrix\W\*\W<I>=\n\tRotMatrix @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:Transform\W\*\W<I>=\n\tstruct transform @DAFUNC_CParamNameToLocalCName{$1}\;
DAFUNC_DeclareLocals:?=

DAFUNC_SimpleCTypeOf:BoolInt=int
DAFUNC_SimpleCTypeOf:StatusInt=int
DAFUNC_SimpleCTypeOf:BoolStat=int
DAFUNC_SimpleCTypeOf:?=?

! ********************  ASSUMPTION: Any nonconst structure is output only !!!
DAFUNC_ParamListToConvertToLocal:const DPoint3d \*\W<I>=\n\tConvertDAPoint3dToCDPoint3d \
                    (@DAFUNC_CParamNameToDAName{$1},@DAFUNC_CParamNameToLocalCName{$1})\;

DAFUNC_ParamListToConvertToLocal:const DVec3d \*\W<I>=\n\tConvertDAVector3dToCDVec3d \
                    (@DAFUNC_CParamNameToDAName{$1},@DAFUNC_CParamNameToLocalCName{$1})\;

DAFUNC_ParamListToConvertToLocal:const DRange3d \*\W<I>=\n\tConvertDARange3dToCDRange3d \
                    (@DAFUNC_CParamNameToDAName{$1},@DAFUNC_CParamNameToLocalCName{$1})\;

DAFUNC_ParamListToConvertToLocal:const DPoint2d \*\W<I>=\n\tConvertDAPoint2dToCDPoint2d \
                    (@DAFUNC_CParamNameToDAName{$1},@DAFUNC_CParamNameToLocalCName{$1})\;
DAFUNC_ParamListToConvertToLocal:const RotMatrix \*\W<I>=\n\tConvertDAMatrix3dToCRotMatrix \
                    (@DAFUNC_CParamNameToDAName{$1},@DAFUNC_CParamNameToLocalCName{$1})\;
DAFUNC_ParamListToConvertToLocal:const Transform \*\W<I>=\n\tConvertDATransform3dToCTransform \
                    (@DAFUNC_CParamNameToDAName{$1},@DAFUNC_CParamNameToLocalCName{$1})\;
DAFUNC_ParamListToConvertToLocal:BoolInt \*\W<I>=\n\tConvertDAVARIANT_BOOLToCBoolInt \
                    (@DAFUNC_CParamNameToDAName{$1},@DAFUNC_CParamNameToLocalCName{$1})\;
DAFUNC_ParamListToConvertToLocal:?=


! Objects that are COPIED to locals must be copied back.
! For instance, DPoint:
DAFUNC_CopyCToDA:const <I> \*\W<I>=     ! Any const struct is ok

DAFUNC_CopyCToDA:DPoint3d \*\W<I>=\n\tConvertCDPoint3dToDAPoint3d \
    (@DAFUNC_CParamNameToLocalCName{$1},@DAFUNC_CParamNameToDAName{$1})\;

DAFUNC_CopyCToDA:DVec3d \*\W<I>=\n\tConvertCDVec3dToDAVector3d \
    (@DAFUNC_CParamNameToLocalCName{$1},@DAFUNC_CParamNameToDAName{$1})\;

DAFUNC_CopyCToDA:DRange3d \*\W<I>=\n\tConvertCDRange3dToDARange3d \
    (@DAFUNC_CParamNameToLocalCName{$1},@DAFUNC_CParamNameToDAName{$1})\;

DAFUNC_CopyCToDA:DPoint2d \*\W<I>=\n\tConvertCDPoint2dToDAPoint2d \
    (@DAFUNC_CParamNameToLocalCName{$1},@DAFUNC_CParamNameToDAName{$1})\;
DAFUNC_CopyCToDA:RotMatrix \*\W<I>=\n\tConvertCRotMatrixToDAMatrix3d \
    (@DAFUNC_CParamNameToLocalCName{$1},@DAFUNC_CParamNameToDAName{$1})\;
DAFUNC_CopyCToDA:Transform \*\W<I>=\n\tConvertCTransformToDATransform3d \
    (@DAFUNC_CParamNameToLocalCName{$1},@DAFUNC_CParamNameToDAName{$1})\;
DAFUNC_CopyCToDA:?=

DAFUNC_CParamNameToLocalCName:p<K><u>=@DAFUNC_LocalCName{$1$2}
DAFUNC_CParamNameToLocalCName:<I>=@DAFUNC_LocalCName{$1}

DAFUNC_LocalCName:<I>=local$1

DAFUNC_CParamNameToDAName:p<K><u>=$1$2
DAFUNC_CParamNameToDAName:<I>=$1


DAFUNC_ParamListToNativeCallArgs:const=
DAFUNC_ParamListToNativeCallArgs:DPoint3d \*\W<I>=\n\t\t\&@DAFUNC_CParamNameToLocalCName{$1}
DAFUNC_ParamListToNativeCallArgs:DVec3d \*\W<I>=\n\t\t\&@DAFUNC_CParamNameToLocalCName{$1}
DAFUNC_ParamListToNativeCallArgs:DRange3d \*\W<I>=\n\t\t\&@DAFUNC_CParamNameToLocalCName{$1}

DAFUNC_ParamListToNativeCallArgs:DPoint2d \*\W<I>=\n\t\t\&@DAFUNC_CParamNameToLocalCName{$1}
DAFUNC_ParamListToNativeCallArgs:RotMatrix \*\W<I>=\n\t\t\&@DAFUNC_CParamNameToLocalCName{$1}
DAFUNC_ParamListToNativeCallArgs:Transform \*\W<I>=\n\t\t\&@DAFUNC_CParamNameToLocalCName{$1}
DAFUNC_ParamListToNativeCallArgs:,=,
DAFUNC_ParamListToNativeCallArgs:<I> \*\W<I>=\n\t\tp$2
DAFUNC_ParamListToNativeCallArgs:<I>\W<I>=\n\t\t$2
DAFUNC_ParamListToNativeCallArgs:?=


JNI_AssignResult:void=
JNI_AssignResult:<I>=result \=\
JNI_AssignResult:*=\/\* Unknown return type $0 \*\/\n


! DAFUNC_ReturnResult(CResultType)
!    ** No action for void function.
!   ** Copy from local "result" var to output
DAFUNC_ReturnResult:void,*=
DAFUNC_ReturnResult:double,\W,=\n\t\*Result \= result\;
DAFUNC_ReturnResult:BoolInt,\W,=\n\t*Result \= VariantBool (result \!\= 0)\;
! Composite return of function value and parameter needs E_FAIL test...
DAFUNC_ReturnResult:BoolInt,\W<I>\W\*\W<I>\W,*=\
\n\tif (\!result)\
\n\t\t\{\
\n\t\thr \= E_FAIL\;\
\n\t\t\}
DAFUNC_ReturnResult:?=(?)


