\B=@FuncToIMethodB{bsiDPoint3d_crossProduct,crossProduct}
\B=@FuncToIMethodB{bsiDPoint3d_crossProduct3DPoint3d,crossProductToPoints}
\B=@FuncToIMethodB{bsiDPoint3d_crossProduct3DPoint3dXY,crossProductToPointsXY}
\B=@FuncToIMethodB{bsiDPoint3d_crossProductXY,crossProductXY}
\B=@FuncToIMethodB{bsiDPoint3d_dotProduct3DPoint3d,dotProductToPoints}
\B=@FuncToIMethodB{bsiDPoint3d_normalizedCrossProduct,normalizedCrossProduct}
\B=@FuncToIMethodB{bsiDPoint3d_sizedCrossProduct,sizedCrossProduct}
\B=@FuncToIMethodB{bsiDPoint3d_geometricMeanCrossProduct,geometricMeanCrossProduct}
\B=@FuncToIMethodB{bsiDPoint3d_dotProduct,dotProduct}
\B=@FuncToIMethodB{bsiDPoint3d_dotProductXY,dotProductXY}
\B=@FuncToIMethodB{bsiDPoint3d_dotXYZ,dotProduct}
\B=@FuncToIMethodB{bsiDPoint3d_dotDifference,dotDifference}
\B=@FuncToIMethodB{bsiDPoint3d_tripleProduct,tripleProduct}
\B=@FuncToIMethodB{bsiDPoint3d_tripleProduct4Points,tripleProductToPoints}
\B=@FuncToIMethodA{bsiDPoint3d_zero,zero}
\B=@FuncToIMethodA{bsiDPoint3d_one,one}
\B=@FuncToIMethodB{bsiDPoint3d_setXYZ,init}
\B=@FuncToIMethodB{bsiDPoint3d_setXY,init}
\B=@FuncToIMethodB{bsiDPoint3d_getXYZ,xyzOf}
\B=@FuncToIMethodB{bsiDPoint3d_setComponent,setComponent}
\B=@FuncToIMethodB{bsiDPoint3d_getComponent,getComponent}
\B=@FuncToIMethodB{bsiDPoint3d_getTriad,getTriad}
\B=@FuncToIMethodB{bsiDPoint3d_getNormalizedTriad,getNormalizedTriad}
\B=@FuncToIMethodB{bsiDPoint3d_addDPoint3dDPoint3d,sumOf}
\B=@FuncToIMethodB{bsiDPoint3d_addDPoint3dInPlace,add}
\B=@FuncToIMethodB{bsiDPoint3d_subtract,subtract}
\B=@FuncToIMethodB{bsiDPoint3d_addScaledDPoint3d,sumOf}
\B=@FuncToIMethodB{bsiDPoint3d_interpolate,interpolate}
\B=@FuncToIMethodB{bsiDPoint3d_add2ScaledDPoint3d,sumOf}
\B=@FuncToIMethodB{jmdlDPoint3d_linearCombination2,sumOf}
\B=@FuncToIMethodB{jmdlDPoint3d_linearCombination3,sumOf}
\B=@FuncToIMethodB{bsiDPoint3d_add3ScaledDPoint3d,sumOf}
\B=@FuncToIMethodB{bsiDPoint3d_computeNormal,normalizedDifferenceOf}
\B=@FuncToIMethodB{bsiDPoint3d_angleBetweenVectors,angleTo}
\B=@FuncToIMethodB{bsiDPoint3d_smallerAngleBetweenUnorientedVectors,smallerUnorientedAngleTo}
\B=@FuncToIMethodB{bsiDPoint3d_isVectorInSmallerSector,isVectorInSmallerSector}
\B=@FuncToIMethodB{bsiDPoint3d_isPointInSmallerSector,isPointInSmallerSector}
\B=@FuncToIMethodB{bsiDPoint3d_isVectorInCCWSector,isVectorInCCWSector}
\B=@FuncToIMethodB{bsiDPoint3d_isPointInCCWSector,isPointInCCWector}
\B=@FuncToIMethodB{bsiDPoint3d_angleBetweenVectorsXY,angleToXY}
\B=@FuncToIMethodB{bsiDPoint3d_smallerAngleBetweenUnorientedVectorsXY,smallerUnorientedAngleToXY}
\B=@FuncToIMethodB{bsiDPoint3d_rotateXY,rotateXY}
\B=@FuncToIMethodB{bsiDPoint3d_rotateXYInPlace,rotateXY}
\B=@FuncToIMethodB{bsiDPoint3d_signedAngleBetweenVectors,signedAngleTo}
\B=@FuncToIMethodB{bsiDPoint3d_planarAngleBetweenVectors,planarAngleTo}
\B=@FuncToIMethodB{bsiDPoint3d_subtractDPoint3dDPoint3d,differenceOf}
\B=@FuncToIMethodB{bsiDPoint3d_distance,distance}
\B=@FuncToIMethodA{bsiDPoint3d_magnitudeSquared,magnitudeSquared}
\B=@FuncToIMethodB{bsiDPoint3d_distanceSquared,distanceSquared}
\B=@FuncToIMethodB{bsiDPoint3d_distanceSquaredXY,distanceSquaredXY}
\B=@FuncToIMethodB{bsiDPoint3d_distanceXY,distanceXY}
\B=@FuncToIMethodB{bsiDPoint3d_unitPerpendicularXY,unitPerpendicularXY}
\B=@FuncToIMethodA{bsiDPoint3d_magnitude,magnitude}
\B=@FuncToIMethodA{bsiDPoint3d_maxAbs,maxAbs}
\B=@FuncToIMethodB{bsiDPoint3d_pointEqual,isEqual}
\B=@FuncToIMethodB{bsiDPoint3d_pointEqualTolerance,isEqual}
\B=@FuncToIMethodB{bsiDPoint3d_scale,scale}
\B=@FuncToIMethodB{bsiDPoint3d_scaleInPlace,scale}
\B=@FuncToIMethodB{bsiDPoint3d_negate,negate}
\B=@FuncToIMethodA{bsiDPoint3d_negateInPlace,negate}
\B=@FuncToIMethodB{bsiDPoint3d_normalize,normalize}
\B=@FuncToIMethodB{bsiDPoint3d_scaleToLength,scaleToLength}
\B=@FuncToIMethodB{bsiDPoint3d_scaleToLengthInPlace,scaleToLength}
\B=@FuncToIMethodA{bsiDPoint3d_normalizeInPlace,normalize}
\B=@FuncToIMethodB{bsiDPoint3d_areParallel,isParallelTo}
\B=@FuncToIMethodB{bsiDPoint3d_arePerpendicular,isPerpendicularTo}


\B=@FuncToIMethodB{bsiRotMatrix_multiplyDPoint3d,multiply}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyRotMatrixDPoint3d,multiply}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyRotMatrixTransposeDPoint3d,multiply}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyComponents,multiplyComponents}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyTransposeDPoint3d,multiplyTranspose}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyTransposeComponents,multiplyTransposeComponents}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyDPoint3dArray,multiply}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyDPoint4dArray,multiply}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyDPoint2dArray,multiply}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyFPoint3dArray,multiply}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyFPoint2dArray,multiply}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyRotMatrixRotMatrix,productOf}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyRotMatrixRotMatrixRotMatrix,productOf}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyRotMatrixTransform,productOf}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyTransformRotMatrix,productOf}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyRange,multiply}
\B=@FuncToIMethodA{bsiRotMatrix_initIdentity,initIdentity}
\B=@FuncToIMethodA{bsiRotMatrix_zero,zero}
\B=@FuncToIMethodB{bsiRotMatrix_initFromScaleFactors,initFromScaleFactors}
\B=@FuncToIMethodB{bsiRotMatrix_initFromScale,initFromScale}
\B=@FuncToIMethodB{bsiRotMatrix_initFromScaledOuterProduct,initFromScaledOuterProduct}
\B=@FuncToIMethodB{bsiRotMatrix_addScaledOuterProductInPlace,addScaledOuterProductInPlace}
\B=@FuncToIMethodB{bsiRotMatrix_initFromColumnArrays,initFromColumnArrays}
\B=@FuncToIMethodB{bsiRotMatrix_initFromRowValues,initFromRowValues}
\B=@FuncToIMethodB{bsiRotMatrix_initFromColumnVectors,initFromColumnVectors}
\B=@FuncToIMethodB{bsiRotMatrix_initFromRowArrays,initFromRowArrays}
\B=@FuncToIMethodB{bsiRotMatrix_initFromRowVectors,initFromRowVectors}
\B=@FuncToIMethodB{bsiRotMatrix_initFromVectorAndRotationAngle,initFromVectorAndRotationAngle}
\B=@FuncToIMethodB{bsiRotMatrix_initFromDirectionAndScale,initFromDirectionAndScale}
\B=@FuncToIMethodB{bsiRotMatrix_initFromAxisAndRotationAngle,initFromAxisAndRotationAngle}
\B=@FuncToIMethodB{bsiRotMatrix_transpose,transposeOf}
\B=@FuncToIMethodA{bsiRotMatrix_transposeInPlace,transpose}
\B=@FuncToIMethodB{bsiRotMatrix_invertRotMatrix,inverseOf}
\B=@FuncToIMethodB{bsiRotMatrix_solveDPoint3d,solve}
\B=@FuncToIMethodB{bsiRotMatrix_solveDPoint3dTranspose,solveTranspose}
\B=@FuncToIMethodB{bsiRotMatrix_solveDPoint3dArray,solveArray}
\B=@FuncToIMethodA{bsiRotMatrix_invertInPlace,invert}
\B=@FuncToIMethodB{bsiRotMatrix_scaleRows,scaleRows}
\B=@FuncToIMethodB{bsiRotMatrix_scaleColumns,scaleColumns}
\B=@FuncToIMethodB{bsiRotMatrix_multiplyRotMatrixScaleRotMatrix,scale}
\B=@FuncToIMethodB{bsiRotMatrix_rotateByPrincipleAngles,initFromPrincipleAxisRotations}
\B=@FuncToIMethodB{bsiRotMatrix_getColumns,getColumns}
\B=@FuncToIMethodB{bsiRotMatrix_getRows,getRows}
\B=@FuncToIMethodB{bsiRotMatrix_getColumn,getColumn}
\B=@FuncToIMethodB{bsiRotMatrix_getComponentByRowAndColumn,getComponentByRowAndColumn}
\B=@FuncToIMethodB{bsiRotMatrix_setComponentByRowAndColumn,setComponentByRowAndColumn}
\B=@FuncToIMethodB{bsiRotMatrix_getRow,getRow}
\B=@FuncToIMethodB{bsiRotMatrix_getNormalizedRows,normalizeRowsOf}
\B=@FuncToIMethodB{bsiRotMatrix_getNormalizedColumns,normalizeColumnsOf}
\B=@FuncToIMethodA{bsiRotMatrix_determinant,determinant}
\B=@FuncToIMethodA{bsiRotMatrix_conditionNumber,conditionNumber}
\B=@FuncToIMethodA{bsiRotMatrix_isIdentity,isIdentity}
\B=@FuncToIMethodA{bsiRotMatrix_isSignedPermutation,isSignedPermutation}
\B=@FuncToIMethodA{bsiRotMatrix_isRigid,isRigid}
\B=@FuncToIMethodA{bsiRotMatrix_isOrthogonal,isOrthogonal}
\B=@FuncToIMethodB{bsiRotMatrix_areColumnsOrthonormal,isOrthonormal}
\B=@FuncToIMethodB{bsiRotMatrix_isRigidScale,isRigidScale}
\B=@FuncToIMethodB{bsiRotMatrix_isPlanar,isPlanar}
\B=@FuncToIMethodB{bsiRotMatrix_initFrom1Vector,initFrom1Vector}
\B=@FuncToIMethodB{bsiRotMatrix_initFrom2Vectors,initFrom2Vectors}
\B=@FuncToIMethodB{bsiRotMatrix_initRotationFromOriginXY,initRotationFromOriginXY}
\B=@FuncToIMethodB{bsiRotMatrix_squareAndNormalizeColumns,squareAndNormalizeColumns}
\B=@FuncToIMethodB{bsiRotMatrix_squareAndNormalizeColumnsAnyOrder,squareAndNormalizeColumnsAnyOrder}
\B=@FuncToIMethodB{bsiRotMatrix_shuffleColumns,shuffleColumnsOf}
\B=@FuncToIMethodB{bsiRotMatrix_add2ScaledRotMatrix,sumOf}
\B=@FuncToIMethodB{bsiRotMatrix_add,add}
\B=@FuncToIMethodB{bsiRotMatrix_subtract,subtract}
\B=@FuncToIMethodA{bsiRotMatrix_sumSquares,sumSquares}
\B=@FuncToIMethodA{bsiRotMatrix_maxAbs,maxAbs}
\B=@FuncToIMethodB{bsiRotMatrix_maxDiff,maxDiff}
\B=@FuncToIMethodA{bsiRotMatrix_sumDiagonalSquares,sumDiagonalSquares}
\B=@FuncToIMethodA{bsiRotMatrix_sumOffDiagonalSquares,sumOffDiagonalSquares}
\B=@FuncToIMethodB{bsiRotMatrix_fromQuaternion,initFromQuaternion}
\B=@FuncToIMethodB{bsiRotMatrix_toQuaternion,getQuaternion}
\B=@FuncToIMethodB{bsiRotMatrix_toQuaternionAsDoubleArray,getQuaternion}
\B=@FuncToIMethodB{bsiRotMatrix_fromQuaternionAsDoubleArray,initFromQuaternion}
\B=@FuncToIMethodB{bsiRotMatrix_getRotationAngleAndVector,getRotationAngleAndVector}
\B=@FuncToIMethodB{bsiRotMatrix_initFromTransform,initFrom}
\B=@FuncToIMethodB{bsiRotMatrix_copy,copy}
\B=@FuncToIMethodB{bsiRotMatrix_matrixEqual,isEqual}
\B=@FuncToIMethodB{bsiRotMatrix_matrixEqualTolerance,isEqual}
\B=@FuncToIMethodB{bsiRotMatrix_givensRowOp,givensRowOp}
\B=@FuncToIMethodB{bsiRotMatrix_givensColumnOp,givensColumnOp}
\B=@FuncToIMethodB{bsiRotMatrix_hyperbolicRowOp,hyperbolicRowOp}
\B=@FuncToIMethodB{bsiRotMatrix_hyperbolicColumnOp,hyperbolicColumnOp}


\B=@FuncToIMethodB{bsiRotMatrix_getMatrixComponentByRowAndColumn,getMatrixComponentByRowAndColumn}
\B=@FuncToIMethodB{bsiTransform_setMatrixComponentByRowAndColumn,setMatrixComponentByRowAndColumn}
\B=@FuncToIMethodB{bsiRotMatrix_getTranslationComponent,getPointComponent}
\B=@FuncToIMethodB{bsiTransform_setTranslationComponent,setPointComponent}
\B=@FuncToIMethodB{bsiTransform_multiplyDPoint3dInPlace,multiply}
\B=@FuncToIMethodB{bsiTransform_multiplyDPoint3d,multiply}
\B=@FuncToIMethodB{bsiTransform_multiplyWeightedDPoint3dInPlace,multiplyWeighted}
\B=@FuncToIMethodB{bsiTransform_multiplyComponents,multiply}
\B=@FuncToIMethodB{bsiTransform_multiplyComponentsByMatrixPart,multiplyMatrixOnly}
\B=@FuncToIMethodB{bsiTransform_multiplyDPoint3dByMatrixPart,multiplyMatrixOnly}
\B=@FuncToIMethodB{bsiTransform_multiplyDPoint3dByMatrixPartInPlace,multiplyMatrixOnly}
\B=@FuncToIMethodB{bsiTransform_multiplyTransposeComponentsByMatrixPart,multiplyTransposeMatrixOnly}
\B=@FuncToIMethodB{bsiTransform_multiplyTransposePointByMatrixPart,multiplyTransposeMatrixOnly}
\B=@FuncToIMethodB{bsiTransform_multiplyTransposePointByMatrixPartInPlace,multiplyTransposeMatrixOnly}
\B=@FuncToIMethodB{bsiTransform_multiplyTransformTransform,productOf}
\B=@FuncToIMethodB{bsiTransform_multiplyRotMatrixTransform,productOf}
\B=@FuncToIMethodB{bsiTransform_multiplyTransformRotMatrix,productOf}
\B=@FuncToIMethodB{bsiTransform_multiplyRange,multiply}
\B=@FuncToIMethodA{bsiTransform_initIdentity,initIdentity}
\B=@FuncToIMethodB{bsiTransform_initFromMatrix,initFrom}
\B=@FuncToIMethodB{bsiTransform_initFromMatrixAndTranslation,initFrom}
\B=@FuncToIMethodB{bsiTransform_initFromTranslation,initFrom}
\B=@FuncToIMethodB{bsiTransform_initFromTranslationXYZ,initFrom}
\B=@FuncToIMethodB{bsiTransform_initFromRowValues,initFromRowValues}
\B=@FuncToIMethodB{bsiTransform_initFromLineAndRotationAngle,initFromLineAndRotationAngle}
\B=@FuncToIMethodB{bsiTransform_translateInLocalCoordinates,translateInLocalCoordinates}
\B=@FuncToIMethodB{bsiTransform_setMatrix,setMatrix}
\B=@FuncToIMethodB{bsiTransform_setTranslation,setTranslation}
\B=@FuncToIMethodA{bsiTransform_zeroTranslation,zeroTranslation}
\B=@FuncToIMethodB{bsiTransform_setFixedPoint,setFixedPoint}
\B=@FuncToIMethodB{bsiTransform_initFromMatrixAndFixedPoint,initFromMatrixAndFixedPoint}
\B=@FuncToIMethodB{bsiTransform_invertAsRotation,invertRigidBodyTransformation}
\B=@FuncToIMethodB{bsiTransform_invertTransform,inverseOf}
\B=@FuncToIMethodB{bsiTransform_solveDPoint3d,solve}
\B=@FuncToIMethodB{bsiTransform_solveDPoint3dArray,solveArray}
\B=@FuncToIMethodB{bsiTransform_rotateByPrincipleAngles,initFromPrincipleAxisRotations}
\B=@FuncToIMethodB{bsiTransform_scaleMatrixColumns,scaleMatrixColums}
\B=@FuncToIMethodB{bsiTransform_scaleMatrixRows,scaleMatrixRows}
\B=@FuncToIMethodB{bsiTransform_scaleCompleteRows,scaleMatrixRows}
\B=@FuncToIMethodB{bsiTransform_getTranslation,getTranslation}
\B=@FuncToIMethodB{bsiTransform_getMatrixColumn,getMatrixColumn}
\B=@FuncToIMethodB{bsiTransform_getMatrix,getMatrix}
\B=@FuncToIMethodB{bsiTransform_offsetPointByColumn,offsetPointByColumn}
\B=@FuncToIMethodB{bsiTransform_get4Points,get4Points}
\B=@FuncToIMethodB{bsiTransform_get4PointArray,get4Points}
\B=@FuncToIMethodB{bsiTransform_getOriginAndVectors,getOriginAndVectors}
\B=@FuncToIMethodB{bsiTransform_getOriginAndVectorArray,getOriginAndVectors}
\B=@FuncToIMethodA{bsiTransform_isIdentity,isIdentity}
\B=@FuncToIMethodA{bsiTransform_isRigid,isRigid}
\B=@FuncToIMethodB{bsiTransform_isPlanar,isPlanar}
\B=@FuncToIMethodB{bsiTransform_isEqual,isEqual}
\B=@FuncToIMethodB{bsiTransform_isEqualTolerance,isEqual}
\B=@FuncToIMethodB{bsiTransform_initFromOriginAndVectors,initFromOriginAndVectors}
\B=@FuncToIMethodB{bsiTransform_initFrom4Points,initFrom4Points}
\B=@FuncToIMethodB{bsiTransform_initFrom3DPoint3d,initFromPlaneOf3Points}
\B=@FuncToIMethodB{bsiTransform_initFrom2Points,initFromPlaneNormalToLine}
\B=@FuncToIMethodB{bsiTransform_initFromHMatrix,initFrom}
\B=@FuncToIMethodB{bsiTransform_initFromHMap,initFrom}
\B=@FuncToIMethodB{bsiTransform_copy,copy}
\B=@FuncToIMethodB{bsiTransform_initFromDPoint2dOriginAndLengths,initFromOriginAndLengths}
\B=@FuncToIMethodB{bsiTransform_initFromDPoint2dOriginAngleAndLengths,initFromOriginAngleAndLengths}
\B=@FuncToIMethodB{bsiTransform_setDPoint2dFixedPoint,setFixedPoint}
\B=@FuncToIMethodB{bsiTransform_setDPoint2dTranslation,setTranslation}
\B=@FuncToIMethodB{bsiTransform_getDPoint2dTranslation,getTranslation}
\B=@FuncToIMethodB{bsiTransform_initFromDPoint2dOriginAndVectors,initFromOriginAndVectors}
\B=@FuncToIMethodB{bsiTransform_initFrom3DPoint2d,initFrom3Points}
\B=@FuncToIMethodB{bsiTransform_initFromDMatrix4d,initFrom}
\B=@FuncToIMethodB{bsiTransform_initFrom2DPoint2d,initFrom2Points}
\B=@FuncToIMethodB{bsiTransform_getDPoint2dOriginAndVectors,getOriginAndVectors}
\B=@FuncToIMethodB{bsiTransform_getDPoint2dOriginAndVectorArray,getOriginAndVectors}
\B=@FuncToIMethodB{bsiTransform_initFromSquaredColumns,initUniformScaleApproximation}


\B=@FuncToIMethodB{bsiDPlane3d_initFromOriginAndNormalXYZXYZ,initFromOriginAndNormal}
\B=@FuncToIMethodB{bsiDPlane3d_initFromOriginAndNormal,initFromOriginAndNormal}
\B=@FuncToIMethodA{bsiDPlane3d_normalize,normalize}
\B=@FuncToIMethodB{bsiDPlane3d_initFromdDPoint3d,initFrom3Points}
\B=@FuncToIMethodB{bsiDPlane3d_initFromDPoint4d,init}
\B=@FuncToIMethodB{bsiDPlane3d_getDPoint4d,getDPoint4d}
\B=@FuncToIMethodB{bsiDPlane3d_initFromImplicitPlaneCoefficients,init}
\B=@FuncToIMethodB{bsiDPlane3d_getImplicitPlaneCoefficients,getCoefficients}
\B=@FuncToIMethodB{bsiDPlane3d_transform,productOf}
\B=@FuncToIMethodA{bsiDPlane3d_zero,zero}
\B=@FuncToIMethodA{bsiDPlane3d_isZero,isZero}
\B=@FuncToIMethodB{bsiDPlane3d_projectPoint,projectPoint}
\B=@FuncToIMethodB{bsiDPlane3d_evaluate,evaluate}
\B=@FuncToIMethodB{bsiDPlane3d_initFromDPoint3dArray,initFromArray}

ConvertBody:\Isqrt\I=Math.Sqrt
ConvertBody:\Ifabs\I=Math.Abs
ConvertBody:\IbsiTrig_smallAngle\I=Geom.SmallAngle
ConvertBody:\IbsiGeom_cyclic3dAxis\I=Geom.Cyclic3dAxis
ConvertBody:\IbsiTrig_atan2\I=Math.Atan2
ConvertBody:\Isin\W\P\(\I=Math.Sin
ConvertBody:\Icos\W\P\(\I=Math.Cos
ConvertBody:\IbsiTrig_safeDivide\I=Geom.SafeDivide

\B=@FuncToIMethodB{bsiDPoint4d_setComponents,Init}


ConvertBody:if\W(\W\Ip<I>\W)=if (null \!\= p$1)
ConvertBody:if\W(\Wthis\W)=if (null \!\= this)
ConvertBody:\]\[=,

ConvertBody:\ITRUE\I=true
ConvertBody:\IFALSE\I=false
ConvertBody:\IBoolInt\I=bool
ConvertBody:\Iboolean\I=bool

ConvertReturnType:BoolInt=bool
ConvertReturnType:?=?

ConvertMethodName:?<u>=@upcase{$1}$2

!*******************************************
! FuncToIMethodA -- converts single arg function call to void method call
! FuncToIMethodB -- converts multiarg function call to method call
FuncToIMethodA:jmdlRotMatrix<u>=\
    @FuncToIMethodA1{jmdlDMatrix3d$1}\
    @FuncToIMethodA1{$0}

FuncToIMethodA:jmdlTransform<u>=\
    @FuncToIMethodA1{jmdlDTransform3d$1}\
    @FuncToIMethodA1{$0}

FuncToIMethodA:<u>=@FuncToIMethodA1{$0}
!*******************************************
FuncToIMethodB:jmdlRotMatrix<u>=\
    @FuncToIMethodB1{jmdlDMatrix3d$1}\
    @FuncToIMethodB1{$0}

FuncToIMethodB:jmdlTransform<u>=\
    @FuncToIMethodB1{jmdlDTransform3d$1}\
    @FuncToIMethodB1{$0}

FuncToIMethodB:<u>=@FuncToIMethodB1{$0}
!*******************************************

FuncToIMethodB1:<I>,<I>=\
        @define{ConvertBody\:$1\\W(<MethodCallArg>,\\W\=\$1.@ConvertMethodName{$2} (}\
        @define{ConvertBody\:$1\\W(<MethodCallArg>,\\W\=\$1.@ConvertMethodName{$2} (}

FuncToIMethodA1:<I>,<I>=\
        @define{ConvertBody\:$1\\W(<MethodCallArg>)\=\$1.@ConvertMethodName{$2} ()}\
        @define{ConvertBody\:$1\\W(<MethodCallArg>)\=\$1.@ConvertMethodName{$2} ()}

MethodCallArg:\W<I>\W=$1@end
MethodCallArg:\W&<I>\W=$1@end
MethodCallArg:\W&<I>.<I>\W=$1.$2@end
MethodCallArg:\W&<I>\-\><I>\W=$1.$2@end
MethodCallArg:=@fail