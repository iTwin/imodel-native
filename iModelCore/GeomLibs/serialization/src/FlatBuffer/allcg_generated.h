/*---------------------------------------------------------------------------------------------
* Copyright (c) Bentley Systems, Incorporated. All rights reserved.
* See LICENSE.md in the repository root for full copyright notice.
*--------------------------------------------------------------------------------------------*/
// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ALLCG_H_
#define FLATBUFFERS_GENERATED_ALLCG_H_

#include "flatbuffers/flatbuffers.h"

namespace Bentley {
namespace Geometry {
namespace FB {



struct DPoint3d;
struct DRay3d;
struct DPoint2d;
struct DVector3d;
struct Angle;
struct DEllipse3d;
struct DSegment3d;
struct DTransform3d;
struct DgnBoxDetail;
struct DgnSphereDetail;
struct DgnConeDetail;
struct DgnTorusPipeDetail;
struct LineSegment;
struct LineString;
struct PointString;
struct EllipticArc;
struct BsplineCurve;
struct InterpolationCurve;
struct AkimaCurve;
struct CatenaryCurve;
struct PartialCurve;
struct CurvePrimitiveId;
struct CurveVector;
struct VectorOfVariantGeometry;
struct BsplineSurface;
struct DgnBox;
struct DgnSphere;
struct DgnCone;
struct DgnTorusPipe;
struct DgnExtrusion;
struct DgnRotationalSweep;
struct DgnRuledSweep;
struct PolyfaceAuxChannelData;
struct PolyfaceAuxChannel;
struct PolyfaceAuxData;
struct TaggedNumericData;
struct Polyface;
struct TransitionSpiralDetail;
struct DirectSpiralDetail;
struct TransitionSpiral;
struct VariantGeometry;

enum LoopTypeEnum {
  LoopTypeEnum_Parity = 1,
  LoopTypeEnum_InteriorToLeft = 2
};

inline const char **EnumNamesLoopTypeEnum() {
  static const char *names[] = { "Parity", "InteriorToLeft", nullptr };
  return names;
}

inline const char *EnumNameLoopTypeEnum(LoopTypeEnum e) { return EnumNamesLoopTypeEnum()[e - LoopTypeEnum_Parity]; }

enum VariantGeometryUnion {
  VariantGeometryUnion_NONE = 0,
  VariantGeometryUnion_LineSegment = 1,
  VariantGeometryUnion_EllipticArc = 2,
  VariantGeometryUnion_BsplineCurve = 3,
  VariantGeometryUnion_LineString = 4,
  VariantGeometryUnion_CurveVector = 5,
  VariantGeometryUnion_DgnCone = 6,
  VariantGeometryUnion_DgnSphere = 7,
  VariantGeometryUnion_DgnTorusPipe = 8,
  VariantGeometryUnion_DgnBox = 9,
  VariantGeometryUnion_DgnExtrusion = 10,
  VariantGeometryUnion_DgnRotationalSweep = 11,
  VariantGeometryUnion_DgnRuledSweep = 12,
  VariantGeometryUnion_Polyface = 13,
  VariantGeometryUnion_BsplineSurface = 14,
  VariantGeometryUnion_VectorOfVariantGeometry = 15,
  VariantGeometryUnion_InterpolationCurve = 16,
  VariantGeometryUnion_TransitionSpiral = 17,
  VariantGeometryUnion_PointString = 18,
  VariantGeometryUnion_AkimaCurve = 19,
  VariantGeometryUnion_CatenaryCurve = 20,
  VariantGeometryUnion_PartialCurve = 21
};

inline const char **EnumNamesVariantGeometryUnion() {
  static const char *names[] = { "NONE", "LineSegment", "EllipticArc", "BsplineCurve", "LineString", "CurveVector", "DgnCone", "DgnSphere", "DgnTorusPipe", "DgnBox", "DgnExtrusion", "DgnRotationalSweep", "DgnRuledSweep", "Polyface", "BsplineSurface", "VectorOfVariantGeometry", "InterpolationCurve", "TransitionSpiral", "PointString", "AkimaCurve", "CatenaryCurve", "PartialCurve", nullptr };
  return names;
}

inline const char *EnumNameVariantGeometryUnion(VariantGeometryUnion e) { return EnumNamesVariantGeometryUnion()[e]; }

inline bool VerifyVariantGeometryUnion(flatbuffers::Verifier &verifier, const void *union_obj, VariantGeometryUnion type);

MANUALLY_ALIGNED_STRUCT(8) DPoint3d {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DPoint3d(double x, double y, double z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
  double z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(DPoint3d, 24);

MANUALLY_ALIGNED_STRUCT(8) DRay3d {
 private:
  double x_;
  double y_;
  double z_;
  double ux_;
  double uy_;
  double uz_;

 public:
  DRay3d(double x, double y, double z, double ux, double uy, double uz)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)), ux_(flatbuffers::EndianScalar(ux)), uy_(flatbuffers::EndianScalar(uy)), uz_(flatbuffers::EndianScalar(uz)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
  double z() const { return flatbuffers::EndianScalar(z_); }
  double ux() const { return flatbuffers::EndianScalar(ux_); }
  double uy() const { return flatbuffers::EndianScalar(uy_); }
  double uz() const { return flatbuffers::EndianScalar(uz_); }
};
STRUCT_END(DRay3d, 48);

MANUALLY_ALIGNED_STRUCT(8) DPoint2d {
 private:
  double x_;
  double y_;

 public:
  DPoint2d(double x, double y)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(DPoint2d, 16);

MANUALLY_ALIGNED_STRUCT(8) DVector3d {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DVector3d(double x, double y, double z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
  double z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(DVector3d, 24);

MANUALLY_ALIGNED_STRUCT(8) Angle {
 private:
  double degrees_;

 public:
  Angle(double degrees)
    : degrees_(flatbuffers::EndianScalar(degrees)) { }

  double degrees() const { return flatbuffers::EndianScalar(degrees_); }
};
STRUCT_END(Angle, 8);

MANUALLY_ALIGNED_STRUCT(8) DEllipse3d {
 private:
  double centerX_;
  double centerY_;
  double centerZ_;
  double vector0X_;
  double vector0Y_;
  double vector0Z_;
  double vector90X_;
  double vector90Y_;
  double vector90Z_;
  double startRadians_;
  double sweepRadians_;

 public:
  DEllipse3d(double centerX, double centerY, double centerZ, double vector0X, double vector0Y, double vector0Z, double vector90X, double vector90Y, double vector90Z, double startRadians, double sweepRadians)
    : centerX_(flatbuffers::EndianScalar(centerX)), centerY_(flatbuffers::EndianScalar(centerY)), centerZ_(flatbuffers::EndianScalar(centerZ)), vector0X_(flatbuffers::EndianScalar(vector0X)), vector0Y_(flatbuffers::EndianScalar(vector0Y)), vector0Z_(flatbuffers::EndianScalar(vector0Z)), vector90X_(flatbuffers::EndianScalar(vector90X)), vector90Y_(flatbuffers::EndianScalar(vector90Y)), vector90Z_(flatbuffers::EndianScalar(vector90Z)), startRadians_(flatbuffers::EndianScalar(startRadians)), sweepRadians_(flatbuffers::EndianScalar(sweepRadians)) { }

  double centerX() const { return flatbuffers::EndianScalar(centerX_); }
  double centerY() const { return flatbuffers::EndianScalar(centerY_); }
  double centerZ() const { return flatbuffers::EndianScalar(centerZ_); }
  double vector0X() const { return flatbuffers::EndianScalar(vector0X_); }
  double vector0Y() const { return flatbuffers::EndianScalar(vector0Y_); }
  double vector0Z() const { return flatbuffers::EndianScalar(vector0Z_); }
  double vector90X() const { return flatbuffers::EndianScalar(vector90X_); }
  double vector90Y() const { return flatbuffers::EndianScalar(vector90Y_); }
  double vector90Z() const { return flatbuffers::EndianScalar(vector90Z_); }
  double startRadians() const { return flatbuffers::EndianScalar(startRadians_); }
  double sweepRadians() const { return flatbuffers::EndianScalar(sweepRadians_); }
};
STRUCT_END(DEllipse3d, 88);

MANUALLY_ALIGNED_STRUCT(8) DSegment3d {
 private:
  double point0X_;
  double point0Y_;
  double point0Z_;
  double point1X_;
  double point1Y_;
  double point1Z_;

 public:
  DSegment3d(double point0X, double point0Y, double point0Z, double point1X, double point1Y, double point1Z)
    : point0X_(flatbuffers::EndianScalar(point0X)), point0Y_(flatbuffers::EndianScalar(point0Y)), point0Z_(flatbuffers::EndianScalar(point0Z)), point1X_(flatbuffers::EndianScalar(point1X)), point1Y_(flatbuffers::EndianScalar(point1Y)), point1Z_(flatbuffers::EndianScalar(point1Z)) { }

  double point0X() const { return flatbuffers::EndianScalar(point0X_); }
  double point0Y() const { return flatbuffers::EndianScalar(point0Y_); }
  double point0Z() const { return flatbuffers::EndianScalar(point0Z_); }
  double point1X() const { return flatbuffers::EndianScalar(point1X_); }
  double point1Y() const { return flatbuffers::EndianScalar(point1Y_); }
  double point1Z() const { return flatbuffers::EndianScalar(point1Z_); }
};
STRUCT_END(DSegment3d, 48);

MANUALLY_ALIGNED_STRUCT(8) DTransform3d {
 private:
  double axx_;
  double axy_;
  double axz_;
  double axw_;
  double ayx_;
  double ayy_;
  double ayz_;
  double ayw_;
  double azx_;
  double azy_;
  double azz_;
  double azw_;

 public:
  DTransform3d(double axx, double axy, double axz, double axw, double ayx, double ayy, double ayz, double ayw, double azx, double azy, double azz, double azw)
    : axx_(flatbuffers::EndianScalar(axx)), axy_(flatbuffers::EndianScalar(axy)), axz_(flatbuffers::EndianScalar(axz)), axw_(flatbuffers::EndianScalar(axw)), ayx_(flatbuffers::EndianScalar(ayx)), ayy_(flatbuffers::EndianScalar(ayy)), ayz_(flatbuffers::EndianScalar(ayz)), ayw_(flatbuffers::EndianScalar(ayw)), azx_(flatbuffers::EndianScalar(azx)), azy_(flatbuffers::EndianScalar(azy)), azz_(flatbuffers::EndianScalar(azz)), azw_(flatbuffers::EndianScalar(azw)) { }

  double axx() const { return flatbuffers::EndianScalar(axx_); }
  double axy() const { return flatbuffers::EndianScalar(axy_); }
  double axz() const { return flatbuffers::EndianScalar(axz_); }
  double axw() const { return flatbuffers::EndianScalar(axw_); }
  double ayx() const { return flatbuffers::EndianScalar(ayx_); }
  double ayy() const { return flatbuffers::EndianScalar(ayy_); }
  double ayz() const { return flatbuffers::EndianScalar(ayz_); }
  double ayw() const { return flatbuffers::EndianScalar(ayw_); }
  double azx() const { return flatbuffers::EndianScalar(azx_); }
  double azy() const { return flatbuffers::EndianScalar(azy_); }
  double azz() const { return flatbuffers::EndianScalar(azz_); }
  double azw() const { return flatbuffers::EndianScalar(azw_); }
};
STRUCT_END(DTransform3d, 96);

MANUALLY_ALIGNED_STRUCT(8) DgnBoxDetail {
 private:
  double baseOriginX_;
  double baseOriginY_;
  double baseOriginZ_;
  double topOriginX_;
  double topOriginY_;
  double topOriginZ_;
  double vectorXX_;
  double vectorXY_;
  double vectorXZ_;
  double vectorYX_;
  double vectorYY_;
  double vectorYZ_;
  double baseX_;
  double baseY_;
  double topX_;
  double topY_;
  uint8_t capped_;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif
  int8_t __padding0;
  int16_t __padding1;
  int32_t __padding2;
#ifdef __clang__
#pragma clang diagnostic pop
#endif

 public:
  DgnBoxDetail(double baseOriginX, double baseOriginY, double baseOriginZ, double topOriginX, double topOriginY, double topOriginZ, double vectorXX, double vectorXY, double vectorXZ, double vectorYX, double vectorYY, double vectorYZ, double baseX, double baseY, double topX, double topY, uint8_t capped)
    : baseOriginX_(flatbuffers::EndianScalar(baseOriginX)), baseOriginY_(flatbuffers::EndianScalar(baseOriginY)), baseOriginZ_(flatbuffers::EndianScalar(baseOriginZ)), topOriginX_(flatbuffers::EndianScalar(topOriginX)), topOriginY_(flatbuffers::EndianScalar(topOriginY)), topOriginZ_(flatbuffers::EndianScalar(topOriginZ)), vectorXX_(flatbuffers::EndianScalar(vectorXX)), vectorXY_(flatbuffers::EndianScalar(vectorXY)), vectorXZ_(flatbuffers::EndianScalar(vectorXZ)), vectorYX_(flatbuffers::EndianScalar(vectorYX)), vectorYY_(flatbuffers::EndianScalar(vectorYY)), vectorYZ_(flatbuffers::EndianScalar(vectorYZ)), baseX_(flatbuffers::EndianScalar(baseX)), baseY_(flatbuffers::EndianScalar(baseY)), topX_(flatbuffers::EndianScalar(topX)), topY_(flatbuffers::EndianScalar(topY)), capped_(flatbuffers::EndianScalar(capped)), __padding0(0), __padding1(0), __padding2(0) { (void)__padding0; (void)__padding1; (void)__padding2; }

  double baseOriginX() const { return flatbuffers::EndianScalar(baseOriginX_); }
  double baseOriginY() const { return flatbuffers::EndianScalar(baseOriginY_); }
  double baseOriginZ() const { return flatbuffers::EndianScalar(baseOriginZ_); }
  double topOriginX() const { return flatbuffers::EndianScalar(topOriginX_); }
  double topOriginY() const { return flatbuffers::EndianScalar(topOriginY_); }
  double topOriginZ() const { return flatbuffers::EndianScalar(topOriginZ_); }
  double vectorXX() const { return flatbuffers::EndianScalar(vectorXX_); }
  double vectorXY() const { return flatbuffers::EndianScalar(vectorXY_); }
  double vectorXZ() const { return flatbuffers::EndianScalar(vectorXZ_); }
  double vectorYX() const { return flatbuffers::EndianScalar(vectorYX_); }
  double vectorYY() const { return flatbuffers::EndianScalar(vectorYY_); }
  double vectorYZ() const { return flatbuffers::EndianScalar(vectorYZ_); }
  double baseX() const { return flatbuffers::EndianScalar(baseX_); }
  double baseY() const { return flatbuffers::EndianScalar(baseY_); }
  double topX() const { return flatbuffers::EndianScalar(topX_); }
  double topY() const { return flatbuffers::EndianScalar(topY_); }
  uint8_t capped() const { return flatbuffers::EndianScalar(capped_); }
};
STRUCT_END(DgnBoxDetail, 136);

MANUALLY_ALIGNED_STRUCT(8) DgnSphereDetail {
 private:
  DTransform3d localToWorld_;
  double startLatitudeRadians_;
  double latitudeSweepRadians_;
  uint8_t capped_;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif
  int8_t __padding0;
  int16_t __padding1;
  int32_t __padding2;
#ifdef __clang__
#pragma clang diagnostic pop
#endif

 public:
  DgnSphereDetail(const DTransform3d &localToWorld, double startLatitudeRadians, double latitudeSweepRadians, uint8_t capped)
    : localToWorld_(localToWorld), startLatitudeRadians_(flatbuffers::EndianScalar(startLatitudeRadians)), latitudeSweepRadians_(flatbuffers::EndianScalar(latitudeSweepRadians)), capped_(flatbuffers::EndianScalar(capped)), __padding0(0), __padding1(0), __padding2(0) { (void)__padding0; (void)__padding1; (void)__padding2; }

  const DTransform3d &localToWorld() const { return localToWorld_; }
  double startLatitudeRadians() const { return flatbuffers::EndianScalar(startLatitudeRadians_); }
  double latitudeSweepRadians() const { return flatbuffers::EndianScalar(latitudeSweepRadians_); }
  uint8_t capped() const { return flatbuffers::EndianScalar(capped_); }
};
STRUCT_END(DgnSphereDetail, 120);

MANUALLY_ALIGNED_STRUCT(8) DgnConeDetail {
 private:
  double centerAX_;
  double centerAY_;
  double centerAZ_;
  double centerBX_;
  double centerBY_;
  double centerBZ_;
  double vector0X_;
  double vector0Y_;
  double vector0Z_;
  double vector90X_;
  double vector90Y_;
  double vector90Z_;
  double radiusA_;
  double radiusB_;
  uint8_t capped_;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif
  int8_t __padding0;
  int16_t __padding1;
  int32_t __padding2;
#ifdef __clang__
#pragma clang diagnostic pop
#endif

 public:
  DgnConeDetail(double centerAX, double centerAY, double centerAZ, double centerBX, double centerBY, double centerBZ, double vector0X, double vector0Y, double vector0Z, double vector90X, double vector90Y, double vector90Z, double radiusA, double radiusB, uint8_t capped)
    : centerAX_(flatbuffers::EndianScalar(centerAX)), centerAY_(flatbuffers::EndianScalar(centerAY)), centerAZ_(flatbuffers::EndianScalar(centerAZ)), centerBX_(flatbuffers::EndianScalar(centerBX)), centerBY_(flatbuffers::EndianScalar(centerBY)), centerBZ_(flatbuffers::EndianScalar(centerBZ)), vector0X_(flatbuffers::EndianScalar(vector0X)), vector0Y_(flatbuffers::EndianScalar(vector0Y)), vector0Z_(flatbuffers::EndianScalar(vector0Z)), vector90X_(flatbuffers::EndianScalar(vector90X)), vector90Y_(flatbuffers::EndianScalar(vector90Y)), vector90Z_(flatbuffers::EndianScalar(vector90Z)), radiusA_(flatbuffers::EndianScalar(radiusA)), radiusB_(flatbuffers::EndianScalar(radiusB)), capped_(flatbuffers::EndianScalar(capped)), __padding0(0), __padding1(0), __padding2(0) { (void)__padding0; (void)__padding1; (void)__padding2; }

  double centerAX() const { return flatbuffers::EndianScalar(centerAX_); }
  double centerAY() const { return flatbuffers::EndianScalar(centerAY_); }
  double centerAZ() const { return flatbuffers::EndianScalar(centerAZ_); }
  double centerBX() const { return flatbuffers::EndianScalar(centerBX_); }
  double centerBY() const { return flatbuffers::EndianScalar(centerBY_); }
  double centerBZ() const { return flatbuffers::EndianScalar(centerBZ_); }
  double vector0X() const { return flatbuffers::EndianScalar(vector0X_); }
  double vector0Y() const { return flatbuffers::EndianScalar(vector0Y_); }
  double vector0Z() const { return flatbuffers::EndianScalar(vector0Z_); }
  double vector90X() const { return flatbuffers::EndianScalar(vector90X_); }
  double vector90Y() const { return flatbuffers::EndianScalar(vector90Y_); }
  double vector90Z() const { return flatbuffers::EndianScalar(vector90Z_); }
  double radiusA() const { return flatbuffers::EndianScalar(radiusA_); }
  double radiusB() const { return flatbuffers::EndianScalar(radiusB_); }
  uint8_t capped() const { return flatbuffers::EndianScalar(capped_); }
};
STRUCT_END(DgnConeDetail, 120);

MANUALLY_ALIGNED_STRUCT(8) DgnTorusPipeDetail {
 private:
  double centerX_;
  double centerY_;
  double centerZ_;
  double vectorXX_;
  double vectorXY_;
  double vectorXZ_;
  double vectorYX_;
  double vectorYY_;
  double vectorYZ_;
  double majorRadius_;
  double minorRadius_;
  double sweepRadians_;
  uint8_t capped_;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif
  int8_t __padding0;
  int16_t __padding1;
  int32_t __padding2;
#ifdef __clang__
#pragma clang diagnostic pop
#endif

 public:
  DgnTorusPipeDetail(double centerX, double centerY, double centerZ, double vectorXX, double vectorXY, double vectorXZ, double vectorYX, double vectorYY, double vectorYZ, double majorRadius, double minorRadius, double sweepRadians, uint8_t capped)
    : centerX_(flatbuffers::EndianScalar(centerX)), centerY_(flatbuffers::EndianScalar(centerY)), centerZ_(flatbuffers::EndianScalar(centerZ)), vectorXX_(flatbuffers::EndianScalar(vectorXX)), vectorXY_(flatbuffers::EndianScalar(vectorXY)), vectorXZ_(flatbuffers::EndianScalar(vectorXZ)), vectorYX_(flatbuffers::EndianScalar(vectorYX)), vectorYY_(flatbuffers::EndianScalar(vectorYY)), vectorYZ_(flatbuffers::EndianScalar(vectorYZ)), majorRadius_(flatbuffers::EndianScalar(majorRadius)), minorRadius_(flatbuffers::EndianScalar(minorRadius)), sweepRadians_(flatbuffers::EndianScalar(sweepRadians)), capped_(flatbuffers::EndianScalar(capped)), __padding0(0), __padding1(0), __padding2(0) { (void)__padding0; (void)__padding1; (void)__padding2; }

  double centerX() const { return flatbuffers::EndianScalar(centerX_); }
  double centerY() const { return flatbuffers::EndianScalar(centerY_); }
  double centerZ() const { return flatbuffers::EndianScalar(centerZ_); }
  double vectorXX() const { return flatbuffers::EndianScalar(vectorXX_); }
  double vectorXY() const { return flatbuffers::EndianScalar(vectorXY_); }
  double vectorXZ() const { return flatbuffers::EndianScalar(vectorXZ_); }
  double vectorYX() const { return flatbuffers::EndianScalar(vectorYX_); }
  double vectorYY() const { return flatbuffers::EndianScalar(vectorYY_); }
  double vectorYZ() const { return flatbuffers::EndianScalar(vectorYZ_); }
  double majorRadius() const { return flatbuffers::EndianScalar(majorRadius_); }
  double minorRadius() const { return flatbuffers::EndianScalar(minorRadius_); }
  double sweepRadians() const { return flatbuffers::EndianScalar(sweepRadians_); }
  uint8_t capped() const { return flatbuffers::EndianScalar(capped_); }
};
STRUCT_END(DgnTorusPipeDetail, 104);

MANUALLY_ALIGNED_STRUCT(8) TransitionSpiralDetail {
 private:
  DTransform3d transform_;
  double fractionA_;
  double fractionB_;
  double bearing0Radians_;
  double bearing1Radians_;
  double curvature0_;
  double curvature1_;
  int32_t spiralType_;
  int32_t constructionHint_;

 public:
  TransitionSpiralDetail(const DTransform3d &transform, double fractionA, double fractionB, double bearing0Radians, double bearing1Radians, double curvature0, double curvature1, int32_t spiralType, int32_t constructionHint)
    : transform_(transform), fractionA_(flatbuffers::EndianScalar(fractionA)), fractionB_(flatbuffers::EndianScalar(fractionB)), bearing0Radians_(flatbuffers::EndianScalar(bearing0Radians)), bearing1Radians_(flatbuffers::EndianScalar(bearing1Radians)), curvature0_(flatbuffers::EndianScalar(curvature0)), curvature1_(flatbuffers::EndianScalar(curvature1)), spiralType_(flatbuffers::EndianScalar(spiralType)), constructionHint_(flatbuffers::EndianScalar(constructionHint)) { }

  const DTransform3d &transform() const { return transform_; }
  double fractionA() const { return flatbuffers::EndianScalar(fractionA_); }
  double fractionB() const { return flatbuffers::EndianScalar(fractionB_); }
  double bearing0Radians() const { return flatbuffers::EndianScalar(bearing0Radians_); }
  double bearing1Radians() const { return flatbuffers::EndianScalar(bearing1Radians_); }
  double curvature0() const { return flatbuffers::EndianScalar(curvature0_); }
  double curvature1() const { return flatbuffers::EndianScalar(curvature1_); }
  int32_t spiralType() const { return flatbuffers::EndianScalar(spiralType_); }
  int32_t constructionHint() const { return flatbuffers::EndianScalar(constructionHint_); }
};
STRUCT_END(TransitionSpiralDetail, 152);

MANUALLY_ALIGNED_STRUCT(8) DirectSpiralDetail {
 private:
  double nominalLength_;
  double trueLength_;
  double doubleTag0_;
  double doubleTag1_;
  double intTag0_;
  double intTag1_;

 public:
  DirectSpiralDetail(double nominalLength, double trueLength, double doubleTag0, double doubleTag1, double intTag0, double intTag1)
    : nominalLength_(flatbuffers::EndianScalar(nominalLength)), trueLength_(flatbuffers::EndianScalar(trueLength)), doubleTag0_(flatbuffers::EndianScalar(doubleTag0)), doubleTag1_(flatbuffers::EndianScalar(doubleTag1)), intTag0_(flatbuffers::EndianScalar(intTag0)), intTag1_(flatbuffers::EndianScalar(intTag1)) { }

  double nominalLength() const { return flatbuffers::EndianScalar(nominalLength_); }
  double trueLength() const { return flatbuffers::EndianScalar(trueLength_); }
  double doubleTag0() const { return flatbuffers::EndianScalar(doubleTag0_); }
  double doubleTag1() const { return flatbuffers::EndianScalar(doubleTag1_); }
  double intTag0() const { return flatbuffers::EndianScalar(intTag0_); }
  double intTag1() const { return flatbuffers::EndianScalar(intTag1_); }
};
STRUCT_END(DirectSpiralDetail, 48);

struct LineSegment : private flatbuffers::Table {
  const DSegment3d *segment() const { return GetStruct<const DSegment3d *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DSegment3d>(verifier, 4 /* segment */) &&
           verifier.EndTable();
  }
  bool has_segment() const { return CheckField(4); }
};

struct LineSegmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segment(const DSegment3d *segment) { fbb_.AddStruct(4, segment); }
  LineSegmentBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LineSegmentBuilder &operator=(const LineSegmentBuilder &);
  flatbuffers::Offset<LineSegment> Finish() {
    auto o = flatbuffers::Offset<LineSegment>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<LineSegment> CreateLineSegment(flatbuffers::FlatBufferBuilder &_fbb,
   const DSegment3d *segment = 0) {
  LineSegmentBuilder builder_(_fbb);
  builder_.add_segment(segment);
  return builder_.Finish();
}

struct LineString : private flatbuffers::Table {
  const flatbuffers::Vector<double> *points() const { return GetPointer<const flatbuffers::Vector<double> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* points */) &&
           verifier.Verify(points()) &&
           verifier.EndTable();
  }
  bool has_points() const { return CheckField(4); }
};

struct LineStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<double>> points) { fbb_.AddOffset(4, points); }
  LineStringBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LineStringBuilder &operator=(const LineStringBuilder &);
  flatbuffers::Offset<LineString> Finish() {
    auto o = flatbuffers::Offset<LineString>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<LineString> CreateLineString(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<double>> points = 0) {
  LineStringBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

struct PointString : private flatbuffers::Table {
  const flatbuffers::Vector<double> *points() const { return GetPointer<const flatbuffers::Vector<double> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* points */) &&
           verifier.Verify(points()) &&
           verifier.EndTable();
  }
  bool has_points() const { return CheckField(4); }
};

struct PointStringBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<double>> points) { fbb_.AddOffset(4, points); }
  PointStringBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PointStringBuilder &operator=(const PointStringBuilder &);
  flatbuffers::Offset<PointString> Finish() {
    auto o = flatbuffers::Offset<PointString>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<PointString> CreatePointString(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<double>> points = 0) {
  PointStringBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

struct EllipticArc : private flatbuffers::Table {
  const DEllipse3d *arc() const { return GetStruct<const DEllipse3d *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DEllipse3d>(verifier, 4 /* arc */) &&
           verifier.EndTable();
  }
  bool has_arc() const { return CheckField(4); }
};

struct EllipticArcBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arc(const DEllipse3d *arc) { fbb_.AddStruct(4, arc); }
  EllipticArcBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EllipticArcBuilder &operator=(const EllipticArcBuilder &);
  flatbuffers::Offset<EllipticArc> Finish() {
    auto o = flatbuffers::Offset<EllipticArc>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<EllipticArc> CreateEllipticArc(flatbuffers::FlatBufferBuilder &_fbb,
   const DEllipse3d *arc = 0) {
  EllipticArcBuilder builder_(_fbb);
  builder_.add_arc(arc);
  return builder_.Finish();
}

struct BsplineCurve : private flatbuffers::Table {
  int32_t order() const { return GetField<int32_t>(4, 0); }
  uint8_t closed() const { return GetField<uint8_t>(6, 0); }
  const flatbuffers::Vector<double> *poles() const { return GetPointer<const flatbuffers::Vector<double> *>(8); }
  const flatbuffers::Vector<double> *weights() const { return GetPointer<const flatbuffers::Vector<double> *>(10); }
  const flatbuffers::Vector<double> *knots() const { return GetPointer<const flatbuffers::Vector<double> *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* order */) &&
           VerifyField<uint8_t>(verifier, 6 /* closed */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* poles */) &&
           verifier.Verify(poles()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* weights */) &&
           verifier.Verify(weights()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* knots */) &&
           verifier.Verify(knots()) &&
           verifier.EndTable();
  }
  bool has_order() const { return CheckField(4); }
  bool has_closed() const { return CheckField(6); }
  bool has_poles() const { return CheckField(8); }
  bool has_weights() const { return CheckField(10); }
  bool has_knots() const { return CheckField(12); }
};

struct BsplineCurveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_order(int32_t order) { fbb_.AddElement<int32_t>(4, order, 0); }
  void add_closed(uint8_t closed) { fbb_.AddElement<uint8_t>(6, closed, 0); }
  void add_poles(flatbuffers::Offset<flatbuffers::Vector<double>> poles) { fbb_.AddOffset(8, poles); }
  void add_weights(flatbuffers::Offset<flatbuffers::Vector<double>> weights) { fbb_.AddOffset(10, weights); }
  void add_knots(flatbuffers::Offset<flatbuffers::Vector<double>> knots) { fbb_.AddOffset(12, knots); }
  BsplineCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BsplineCurveBuilder &operator=(const BsplineCurveBuilder &);
  flatbuffers::Offset<BsplineCurve> Finish() {
    auto o = flatbuffers::Offset<BsplineCurve>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<BsplineCurve> CreateBsplineCurve(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t order = 0,
   uint8_t closed = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> poles = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> weights = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> knots = 0) {
  BsplineCurveBuilder builder_(_fbb);
  builder_.add_knots(knots);
  builder_.add_weights(weights);
  builder_.add_poles(poles);
  builder_.add_order(order);
  builder_.add_closed(closed);
  return builder_.Finish();
}

struct InterpolationCurve : private flatbuffers::Table {
  int32_t order() const { return GetField<int32_t>(4, 0); }
  uint8_t closed() const { return GetField<uint8_t>(6, 0); }
  int32_t isChordLenKnots() const { return GetField<int32_t>(8, 0); }
  int32_t isColinearTangents() const { return GetField<int32_t>(10, 0); }
  int32_t isChordLenTangents() const { return GetField<int32_t>(12, 0); }
  int32_t isNaturalTangents() const { return GetField<int32_t>(14, 0); }
  const DPoint3d *startTangent() const { return GetStruct<const DPoint3d *>(16); }
  const DVector3d *endTangent() const { return GetStruct<const DVector3d *>(18); }
  const flatbuffers::Vector<double> *fitPoints() const { return GetPointer<const flatbuffers::Vector<double> *>(20); }
  const flatbuffers::Vector<double> *knots() const { return GetPointer<const flatbuffers::Vector<double> *>(22); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* order */) &&
           VerifyField<uint8_t>(verifier, 6 /* closed */) &&
           VerifyField<int32_t>(verifier, 8 /* isChordLenKnots */) &&
           VerifyField<int32_t>(verifier, 10 /* isColinearTangents */) &&
           VerifyField<int32_t>(verifier, 12 /* isChordLenTangents */) &&
           VerifyField<int32_t>(verifier, 14 /* isNaturalTangents */) &&
           VerifyField<DPoint3d>(verifier, 16 /* startTangent */) &&
           VerifyField<DVector3d>(verifier, 18 /* endTangent */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 20 /* fitPoints */) &&
           verifier.Verify(fitPoints()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 22 /* knots */) &&
           verifier.Verify(knots()) &&
           verifier.EndTable();
  }
  bool has_order() const { return CheckField(4); }
  bool has_closed() const { return CheckField(6); }
  bool has_isChordLenKnots() const { return CheckField(8); }
  bool has_isColinearTangents() const { return CheckField(10); }
  bool has_isChordLenTangents() const { return CheckField(12); }
  bool has_isNaturalTangents() const { return CheckField(14); }
  bool has_startTangent() const { return CheckField(16); }
  bool has_endTangent() const { return CheckField(18); }
  bool has_fitPoints() const { return CheckField(20); }
  bool has_knots() const { return CheckField(22); }
};

struct InterpolationCurveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_order(int32_t order) { fbb_.AddElement<int32_t>(4, order, 0); }
  void add_closed(uint8_t closed) { fbb_.AddElement<uint8_t>(6, closed, 0); }
  void add_isChordLenKnots(int32_t isChordLenKnots) { fbb_.AddElement<int32_t>(8, isChordLenKnots, 0); }
  void add_isColinearTangents(int32_t isColinearTangents) { fbb_.AddElement<int32_t>(10, isColinearTangents, 0); }
  void add_isChordLenTangents(int32_t isChordLenTangents) { fbb_.AddElement<int32_t>(12, isChordLenTangents, 0); }
  void add_isNaturalTangents(int32_t isNaturalTangents) { fbb_.AddElement<int32_t>(14, isNaturalTangents, 0); }
  void add_startTangent(const DPoint3d *startTangent) { fbb_.AddStruct(16, startTangent); }
  void add_endTangent(const DVector3d *endTangent) { fbb_.AddStruct(18, endTangent); }
  void add_fitPoints(flatbuffers::Offset<flatbuffers::Vector<double>> fitPoints) { fbb_.AddOffset(20, fitPoints); }
  void add_knots(flatbuffers::Offset<flatbuffers::Vector<double>> knots) { fbb_.AddOffset(22, knots); }
  InterpolationCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  InterpolationCurveBuilder &operator=(const InterpolationCurveBuilder &);
  flatbuffers::Offset<InterpolationCurve> Finish() {
    auto o = flatbuffers::Offset<InterpolationCurve>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<InterpolationCurve> CreateInterpolationCurve(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t order = 0,
   uint8_t closed = 0,
   int32_t isChordLenKnots = 0,
   int32_t isColinearTangents = 0,
   int32_t isChordLenTangents = 0,
   int32_t isNaturalTangents = 0,
   const DPoint3d *startTangent = 0,
   const DVector3d *endTangent = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> fitPoints = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> knots = 0) {
  InterpolationCurveBuilder builder_(_fbb);
  builder_.add_knots(knots);
  builder_.add_fitPoints(fitPoints);
  builder_.add_endTangent(endTangent);
  builder_.add_startTangent(startTangent);
  builder_.add_isNaturalTangents(isNaturalTangents);
  builder_.add_isChordLenTangents(isChordLenTangents);
  builder_.add_isColinearTangents(isColinearTangents);
  builder_.add_isChordLenKnots(isChordLenKnots);
  builder_.add_order(order);
  builder_.add_closed(closed);
  return builder_.Finish();
}

struct AkimaCurve : private flatbuffers::Table {
  const flatbuffers::Vector<double> *points() const { return GetPointer<const flatbuffers::Vector<double> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* points */) &&
           verifier.Verify(points()) &&
           verifier.EndTable();
  }
  bool has_points() const { return CheckField(4); }
};

struct AkimaCurveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<double>> points) { fbb_.AddOffset(4, points); }
  AkimaCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AkimaCurveBuilder &operator=(const AkimaCurveBuilder &);
  flatbuffers::Offset<AkimaCurve> Finish() {
    auto o = flatbuffers::Offset<AkimaCurve>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<AkimaCurve> CreateAkimaCurve(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<double>> points = 0) {
  AkimaCurveBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

struct CatenaryCurve : private flatbuffers::Table {
  double a() const { return GetField<double>(4, 0); }
  const DPoint3d *origin() const { return GetStruct<const DPoint3d *>(6); }
  const DVector3d *vectorU() const { return GetStruct<const DVector3d *>(8); }
  const DVector3d *vectorV() const { return GetStruct<const DVector3d *>(10); }
  double x0() const { return GetField<double>(12, 0); }
  double x1() const { return GetField<double>(14, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, 4 /* a */) &&
           VerifyField<DPoint3d>(verifier, 6 /* origin */) &&
           VerifyField<DVector3d>(verifier, 8 /* vectorU */) &&
           VerifyField<DVector3d>(verifier, 10 /* vectorV */) &&
           VerifyField<double>(verifier, 12 /* x0 */) &&
           VerifyField<double>(verifier, 14 /* x1 */) &&
           verifier.EndTable();
  }
  bool has_a() const { return CheckField(4); }
  bool has_origin() const { return CheckField(6); }
  bool has_vectorU() const { return CheckField(8); }
  bool has_vectorV() const { return CheckField(10); }
  bool has_x0() const { return CheckField(12); }
  bool has_x1() const { return CheckField(14); }
};

struct CatenaryCurveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(double a) { fbb_.AddElement<double>(4, a, 0); }
  void add_origin(const DPoint3d *origin) { fbb_.AddStruct(6, origin); }
  void add_vectorU(const DVector3d *vectorU) { fbb_.AddStruct(8, vectorU); }
  void add_vectorV(const DVector3d *vectorV) { fbb_.AddStruct(10, vectorV); }
  void add_x0(double x0) { fbb_.AddElement<double>(12, x0, 0); }
  void add_x1(double x1) { fbb_.AddElement<double>(14, x1, 0); }
  CatenaryCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CatenaryCurveBuilder &operator=(const CatenaryCurveBuilder &);
  flatbuffers::Offset<CatenaryCurve> Finish() {
    auto o = flatbuffers::Offset<CatenaryCurve>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<CatenaryCurve> CreateCatenaryCurve(flatbuffers::FlatBufferBuilder &_fbb,
   double a = 0,
   const DPoint3d *origin = 0,
   const DVector3d *vectorU = 0,
   const DVector3d *vectorV = 0,
   double x0 = 0,
   double x1 = 0) {
  CatenaryCurveBuilder builder_(_fbb);
  builder_.add_x1(x1);
  builder_.add_x0(x0);
  builder_.add_a(a);
  builder_.add_vectorV(vectorV);
  builder_.add_vectorU(vectorU);
  builder_.add_origin(origin);
  return builder_.Finish();
}

struct PartialCurve : private flatbuffers::Table {
  double fraction0() const { return GetField<double>(4, 0); }
  double fraction1() const { return GetField<double>(6, 0); }
  const VariantGeometry *target() const { return GetPointer<const VariantGeometry *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, 4 /* fraction0 */) &&
           VerifyField<double>(verifier, 6 /* fraction1 */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* target */) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
  bool has_fraction0() const { return CheckField(4); }
  bool has_fraction1() const { return CheckField(6); }
  bool has_target() const { return CheckField(8); }
};

struct PartialCurveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fraction0(double fraction0) { fbb_.AddElement<double>(4, fraction0, 0); }
  void add_fraction1(double fraction1) { fbb_.AddElement<double>(6, fraction1, 0); }
  void add_target(flatbuffers::Offset<VariantGeometry> target) { fbb_.AddOffset(8, target); }
  PartialCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PartialCurveBuilder &operator=(const PartialCurveBuilder &);
  flatbuffers::Offset<PartialCurve> Finish() {
    auto o = flatbuffers::Offset<PartialCurve>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<PartialCurve> CreatePartialCurve(flatbuffers::FlatBufferBuilder &_fbb,
   double fraction0 = 0,
   double fraction1 = 0,
   flatbuffers::Offset<VariantGeometry> target = 0) {
  PartialCurveBuilder builder_(_fbb);
  builder_.add_fraction1(fraction1);
  builder_.add_fraction0(fraction0);
  builder_.add_target(target);
  return builder_.Finish();
}

struct CurvePrimitiveId : private flatbuffers::Table {
  int16_t type() const { return GetField<int16_t>(4, 0); }
  int16_t geomIndex() const { return GetField<int16_t>(6, 0); }
  int16_t partIndex() const { return GetField<int16_t>(8, 0); }
  const flatbuffers::Vector<uint8_t> *bytes() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, 4 /* type */) &&
           VerifyField<int16_t>(verifier, 6 /* geomIndex */) &&
           VerifyField<int16_t>(verifier, 8 /* partIndex */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* bytes */) &&
           verifier.Verify(bytes()) &&
           verifier.EndTable();
  }
  bool has_type() const { return CheckField(4); }
  bool has_geomIndex() const { return CheckField(6); }
  bool has_partIndex() const { return CheckField(8); }
  bool has_bytes() const { return CheckField(10); }
};

struct CurvePrimitiveIdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) { fbb_.AddElement<int16_t>(4, type, 0); }
  void add_geomIndex(int16_t geomIndex) { fbb_.AddElement<int16_t>(6, geomIndex, 0); }
  void add_partIndex(int16_t partIndex) { fbb_.AddElement<int16_t>(8, partIndex, 0); }
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) { fbb_.AddOffset(10, bytes); }
  CurvePrimitiveIdBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CurvePrimitiveIdBuilder &operator=(const CurvePrimitiveIdBuilder &);
  flatbuffers::Offset<CurvePrimitiveId> Finish() {
    auto o = flatbuffers::Offset<CurvePrimitiveId>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<CurvePrimitiveId> CreateCurvePrimitiveId(flatbuffers::FlatBufferBuilder &_fbb,
   int16_t type = 0,
   int16_t geomIndex = 0,
   int16_t partIndex = 0,
   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0) {
  CurvePrimitiveIdBuilder builder_(_fbb);
  builder_.add_bytes(bytes);
  builder_.add_partIndex(partIndex);
  builder_.add_geomIndex(geomIndex);
  builder_.add_type(type);
  return builder_.Finish();
}

struct CurveVector : private flatbuffers::Table {
  int32_t type() const { return GetField<int32_t>(4, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>> *curves() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* curves */) &&
           verifier.Verify(curves()) &&
           verifier.VerifyVectorOfTables(curves()) &&
           verifier.EndTable();
  }
  bool has_type() const { return CheckField(4); }
  bool has_curves() const { return CheckField(6); }
};

struct CurveVectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) { fbb_.AddElement<int32_t>(4, type, 0); }
  void add_curves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>>> curves) { fbb_.AddOffset(6, curves); }
  CurveVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CurveVectorBuilder &operator=(const CurveVectorBuilder &);
  flatbuffers::Offset<CurveVector> Finish() {
    auto o = flatbuffers::Offset<CurveVector>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<CurveVector> CreateCurveVector(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t type = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>>> curves = 0) {
  CurveVectorBuilder builder_(_fbb);
  builder_.add_curves(curves);
  builder_.add_type(type);
  return builder_.Finish();
}

struct VectorOfVariantGeometry : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>> *members() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>> *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* members */) &&
           verifier.Verify(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
  bool has_members() const { return CheckField(4); }
};

struct VectorOfVariantGeometryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>>> members) { fbb_.AddOffset(4, members); }
  VectorOfVariantGeometryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  VectorOfVariantGeometryBuilder &operator=(const VectorOfVariantGeometryBuilder &);
  flatbuffers::Offset<VectorOfVariantGeometry> Finish() {
    auto o = flatbuffers::Offset<VectorOfVariantGeometry>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<VectorOfVariantGeometry> CreateVectorOfVariantGeometry(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>>> members = 0) {
  VectorOfVariantGeometryBuilder builder_(_fbb);
  builder_.add_members(members);
  return builder_.Finish();
}

struct BsplineSurface : private flatbuffers::Table {
  const flatbuffers::Vector<double> *poles() const { return GetPointer<const flatbuffers::Vector<double> *>(4); }
  const flatbuffers::Vector<double> *weights() const { return GetPointer<const flatbuffers::Vector<double> *>(6); }
  const flatbuffers::Vector<double> *knotsU() const { return GetPointer<const flatbuffers::Vector<double> *>(8); }
  const flatbuffers::Vector<double> *knotsV() const { return GetPointer<const flatbuffers::Vector<double> *>(10); }
  int32_t numPolesU() const { return GetField<int32_t>(12, 0); }
  int32_t numPolesV() const { return GetField<int32_t>(14, 0); }
  int32_t orderU() const { return GetField<int32_t>(16, 0); }
  int32_t orderV() const { return GetField<int32_t>(18, 0); }
  int32_t numRulesU() const { return GetField<int32_t>(20, 0); }
  int32_t numRulesV() const { return GetField<int32_t>(22, 0); }
  int32_t holeOrigin() const { return GetField<int32_t>(24, 0); }
  const CurveVector *boundaries() const { return GetPointer<const CurveVector *>(26); }
  uint8_t closedU() const { return GetField<uint8_t>(28, 0); }
  uint8_t closedV() const { return GetField<uint8_t>(30, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* poles */) &&
           verifier.Verify(poles()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* weights */) &&
           verifier.Verify(weights()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* knotsU */) &&
           verifier.Verify(knotsU()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* knotsV */) &&
           verifier.Verify(knotsV()) &&
           VerifyField<int32_t>(verifier, 12 /* numPolesU */) &&
           VerifyField<int32_t>(verifier, 14 /* numPolesV */) &&
           VerifyField<int32_t>(verifier, 16 /* orderU */) &&
           VerifyField<int32_t>(verifier, 18 /* orderV */) &&
           VerifyField<int32_t>(verifier, 20 /* numRulesU */) &&
           VerifyField<int32_t>(verifier, 22 /* numRulesV */) &&
           VerifyField<int32_t>(verifier, 24 /* holeOrigin */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 26 /* boundaries */) &&
           verifier.VerifyTable(boundaries()) &&
           VerifyField<uint8_t>(verifier, 28 /* closedU */) &&
           VerifyField<uint8_t>(verifier, 30 /* closedV */) &&
           verifier.EndTable();
  }
  bool has_poles() const { return CheckField(4); }
  bool has_weights() const { return CheckField(6); }
  bool has_knotsU() const { return CheckField(8); }
  bool has_knotsV() const { return CheckField(10); }
  bool has_numPolesU() const { return CheckField(12); }
  bool has_numPolesV() const { return CheckField(14); }
  bool has_orderU() const { return CheckField(16); }
  bool has_orderV() const { return CheckField(18); }
  bool has_numRulesU() const { return CheckField(20); }
  bool has_numRulesV() const { return CheckField(22); }
  bool has_holeOrigin() const { return CheckField(24); }
  bool has_boundaries() const { return CheckField(26); }
  bool has_closedU() const { return CheckField(28); }
  bool has_closedV() const { return CheckField(30); }
};

struct BsplineSurfaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_poles(flatbuffers::Offset<flatbuffers::Vector<double>> poles) { fbb_.AddOffset(4, poles); }
  void add_weights(flatbuffers::Offset<flatbuffers::Vector<double>> weights) { fbb_.AddOffset(6, weights); }
  void add_knotsU(flatbuffers::Offset<flatbuffers::Vector<double>> knotsU) { fbb_.AddOffset(8, knotsU); }
  void add_knotsV(flatbuffers::Offset<flatbuffers::Vector<double>> knotsV) { fbb_.AddOffset(10, knotsV); }
  void add_numPolesU(int32_t numPolesU) { fbb_.AddElement<int32_t>(12, numPolesU, 0); }
  void add_numPolesV(int32_t numPolesV) { fbb_.AddElement<int32_t>(14, numPolesV, 0); }
  void add_orderU(int32_t orderU) { fbb_.AddElement<int32_t>(16, orderU, 0); }
  void add_orderV(int32_t orderV) { fbb_.AddElement<int32_t>(18, orderV, 0); }
  void add_numRulesU(int32_t numRulesU) { fbb_.AddElement<int32_t>(20, numRulesU, 0); }
  void add_numRulesV(int32_t numRulesV) { fbb_.AddElement<int32_t>(22, numRulesV, 0); }
  void add_holeOrigin(int32_t holeOrigin) { fbb_.AddElement<int32_t>(24, holeOrigin, 0); }
  void add_boundaries(flatbuffers::Offset<CurveVector> boundaries) { fbb_.AddOffset(26, boundaries); }
  void add_closedU(uint8_t closedU) { fbb_.AddElement<uint8_t>(28, closedU, 0); }
  void add_closedV(uint8_t closedV) { fbb_.AddElement<uint8_t>(30, closedV, 0); }
  BsplineSurfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BsplineSurfaceBuilder &operator=(const BsplineSurfaceBuilder &);
  flatbuffers::Offset<BsplineSurface> Finish() {
    auto o = flatbuffers::Offset<BsplineSurface>(fbb_.EndTable(start_, 14));
    return o;
  }
};

inline flatbuffers::Offset<BsplineSurface> CreateBsplineSurface(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<double>> poles = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> weights = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> knotsU = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> knotsV = 0,
   int32_t numPolesU = 0,
   int32_t numPolesV = 0,
   int32_t orderU = 0,
   int32_t orderV = 0,
   int32_t numRulesU = 0,
   int32_t numRulesV = 0,
   int32_t holeOrigin = 0,
   flatbuffers::Offset<CurveVector> boundaries = 0,
   uint8_t closedU = 0,
   uint8_t closedV = 0) {
  BsplineSurfaceBuilder builder_(_fbb);
  builder_.add_boundaries(boundaries);
  builder_.add_holeOrigin(holeOrigin);
  builder_.add_numRulesV(numRulesV);
  builder_.add_numRulesU(numRulesU);
  builder_.add_orderV(orderV);
  builder_.add_orderU(orderU);
  builder_.add_numPolesV(numPolesV);
  builder_.add_numPolesU(numPolesU);
  builder_.add_knotsV(knotsV);
  builder_.add_knotsU(knotsU);
  builder_.add_weights(weights);
  builder_.add_poles(poles);
  builder_.add_closedV(closedV);
  builder_.add_closedU(closedU);
  return builder_.Finish();
}

struct DgnBox : private flatbuffers::Table {
  const DgnBoxDetail *detail() const { return GetStruct<const DgnBoxDetail *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DgnBoxDetail>(verifier, 4 /* detail */) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(4); }
};

struct DgnBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const DgnBoxDetail *detail) { fbb_.AddStruct(4, detail); }
  DgnBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DgnBoxBuilder &operator=(const DgnBoxBuilder &);
  flatbuffers::Offset<DgnBox> Finish() {
    auto o = flatbuffers::Offset<DgnBox>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<DgnBox> CreateDgnBox(flatbuffers::FlatBufferBuilder &_fbb,
   const DgnBoxDetail *detail = 0) {
  DgnBoxBuilder builder_(_fbb);
  builder_.add_detail(detail);
  return builder_.Finish();
}

struct DgnSphere : private flatbuffers::Table {
  const DgnSphereDetail *detail() const { return GetStruct<const DgnSphereDetail *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DgnSphereDetail>(verifier, 4 /* detail */) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(4); }
};

struct DgnSphereBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const DgnSphereDetail *detail) { fbb_.AddStruct(4, detail); }
  DgnSphereBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DgnSphereBuilder &operator=(const DgnSphereBuilder &);
  flatbuffers::Offset<DgnSphere> Finish() {
    auto o = flatbuffers::Offset<DgnSphere>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<DgnSphere> CreateDgnSphere(flatbuffers::FlatBufferBuilder &_fbb,
   const DgnSphereDetail *detail = 0) {
  DgnSphereBuilder builder_(_fbb);
  builder_.add_detail(detail);
  return builder_.Finish();
}

struct DgnCone : private flatbuffers::Table {
  const DgnConeDetail *detail() const { return GetStruct<const DgnConeDetail *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DgnConeDetail>(verifier, 4 /* detail */) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(4); }
};

struct DgnConeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const DgnConeDetail *detail) { fbb_.AddStruct(4, detail); }
  DgnConeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DgnConeBuilder &operator=(const DgnConeBuilder &);
  flatbuffers::Offset<DgnCone> Finish() {
    auto o = flatbuffers::Offset<DgnCone>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<DgnCone> CreateDgnCone(flatbuffers::FlatBufferBuilder &_fbb,
   const DgnConeDetail *detail = 0) {
  DgnConeBuilder builder_(_fbb);
  builder_.add_detail(detail);
  return builder_.Finish();
}

struct DgnTorusPipe : private flatbuffers::Table {
  const DgnTorusPipeDetail *detail() const { return GetStruct<const DgnTorusPipeDetail *>(4); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DgnTorusPipeDetail>(verifier, 4 /* detail */) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(4); }
};

struct DgnTorusPipeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const DgnTorusPipeDetail *detail) { fbb_.AddStruct(4, detail); }
  DgnTorusPipeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DgnTorusPipeBuilder &operator=(const DgnTorusPipeBuilder &);
  flatbuffers::Offset<DgnTorusPipe> Finish() {
    auto o = flatbuffers::Offset<DgnTorusPipe>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<DgnTorusPipe> CreateDgnTorusPipe(flatbuffers::FlatBufferBuilder &_fbb,
   const DgnTorusPipeDetail *detail = 0) {
  DgnTorusPipeBuilder builder_(_fbb);
  builder_.add_detail(detail);
  return builder_.Finish();
}

struct DgnExtrusion : private flatbuffers::Table {
  const CurveVector *baseCurve() const { return GetPointer<const CurveVector *>(4); }
  const DVector3d *extrusionVector() const { return GetStruct<const DVector3d *>(6); }
  uint8_t capped() const { return GetField<uint8_t>(8, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* baseCurve */) &&
           verifier.VerifyTable(baseCurve()) &&
           VerifyField<DVector3d>(verifier, 6 /* extrusionVector */) &&
           VerifyField<uint8_t>(verifier, 8 /* capped */) &&
           verifier.EndTable();
  }
  bool has_baseCurve() const { return CheckField(4); }
  bool has_extrusionVector() const { return CheckField(6); }
  bool has_capped() const { return CheckField(8); }
};

struct DgnExtrusionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_baseCurve(flatbuffers::Offset<CurveVector> baseCurve) { fbb_.AddOffset(4, baseCurve); }
  void add_extrusionVector(const DVector3d *extrusionVector) { fbb_.AddStruct(6, extrusionVector); }
  void add_capped(uint8_t capped) { fbb_.AddElement<uint8_t>(8, capped, 0); }
  DgnExtrusionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DgnExtrusionBuilder &operator=(const DgnExtrusionBuilder &);
  flatbuffers::Offset<DgnExtrusion> Finish() {
    auto o = flatbuffers::Offset<DgnExtrusion>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<DgnExtrusion> CreateDgnExtrusion(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<CurveVector> baseCurve = 0,
   const DVector3d *extrusionVector = 0,
   uint8_t capped = 0) {
  DgnExtrusionBuilder builder_(_fbb);
  builder_.add_extrusionVector(extrusionVector);
  builder_.add_baseCurve(baseCurve);
  builder_.add_capped(capped);
  return builder_.Finish();
}

struct DgnRotationalSweep : private flatbuffers::Table {
  const CurveVector *baseCurve() const { return GetPointer<const CurveVector *>(4); }
  const DRay3d *axis() const { return GetStruct<const DRay3d *>(6); }
  double sweepRadians() const { return GetField<double>(8, 0); }
  int32_t numVRules() const { return GetField<int32_t>(10, 0); }
  uint8_t capped() const { return GetField<uint8_t>(12, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* baseCurve */) &&
           verifier.VerifyTable(baseCurve()) &&
           VerifyField<DRay3d>(verifier, 6 /* axis */) &&
           VerifyField<double>(verifier, 8 /* sweepRadians */) &&
           VerifyField<int32_t>(verifier, 10 /* numVRules */) &&
           VerifyField<uint8_t>(verifier, 12 /* capped */) &&
           verifier.EndTable();
  }
  bool has_baseCurve() const { return CheckField(4); }
  bool has_axis() const { return CheckField(6); }
  bool has_sweepRadians() const { return CheckField(8); }
  bool has_numVRules() const { return CheckField(10); }
  bool has_capped() const { return CheckField(12); }
};

struct DgnRotationalSweepBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_baseCurve(flatbuffers::Offset<CurveVector> baseCurve) { fbb_.AddOffset(4, baseCurve); }
  void add_axis(const DRay3d *axis) { fbb_.AddStruct(6, axis); }
  void add_sweepRadians(double sweepRadians) { fbb_.AddElement<double>(8, sweepRadians, 0); }
  void add_numVRules(int32_t numVRules) { fbb_.AddElement<int32_t>(10, numVRules, 0); }
  void add_capped(uint8_t capped) { fbb_.AddElement<uint8_t>(12, capped, 0); }
  DgnRotationalSweepBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DgnRotationalSweepBuilder &operator=(const DgnRotationalSweepBuilder &);
  flatbuffers::Offset<DgnRotationalSweep> Finish() {
    auto o = flatbuffers::Offset<DgnRotationalSweep>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<DgnRotationalSweep> CreateDgnRotationalSweep(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<CurveVector> baseCurve = 0,
   const DRay3d *axis = 0,
   double sweepRadians = 0,
   int32_t numVRules = 0,
   uint8_t capped = 0) {
  DgnRotationalSweepBuilder builder_(_fbb);
  builder_.add_sweepRadians(sweepRadians);
  builder_.add_numVRules(numVRules);
  builder_.add_axis(axis);
  builder_.add_baseCurve(baseCurve);
  builder_.add_capped(capped);
  return builder_.Finish();
}

struct DgnRuledSweep : private flatbuffers::Table {
  const flatbuffers::Vector<flatbuffers::Offset<CurveVector>> *curves() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CurveVector>> *>(4); }
  uint8_t capped() const { return GetField<uint8_t>(6, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* curves */) &&
           verifier.Verify(curves()) &&
           verifier.VerifyVectorOfTables(curves()) &&
           VerifyField<uint8_t>(verifier, 6 /* capped */) &&
           verifier.EndTable();
  }
  bool has_curves() const { return CheckField(4); }
  bool has_capped() const { return CheckField(6); }
};

struct DgnRuledSweepBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_curves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CurveVector>>> curves) { fbb_.AddOffset(4, curves); }
  void add_capped(uint8_t capped) { fbb_.AddElement<uint8_t>(6, capped, 0); }
  DgnRuledSweepBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DgnRuledSweepBuilder &operator=(const DgnRuledSweepBuilder &);
  flatbuffers::Offset<DgnRuledSweep> Finish() {
    auto o = flatbuffers::Offset<DgnRuledSweep>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<DgnRuledSweep> CreateDgnRuledSweep(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CurveVector>>> curves = 0,
   uint8_t capped = 0) {
  DgnRuledSweepBuilder builder_(_fbb);
  builder_.add_curves(curves);
  builder_.add_capped(capped);
  return builder_.Finish();
}

struct PolyfaceAuxChannelData : private flatbuffers::Table {
  double input() const { return GetField<double>(4, 0); }
  const flatbuffers::Vector<double> *values() const { return GetPointer<const flatbuffers::Vector<double> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, 4 /* input */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* values */) &&
           verifier.Verify(values()) &&
           verifier.EndTable();
  }
  bool has_input() const { return CheckField(4); }
  bool has_values() const { return CheckField(6); }
};

struct PolyfaceAuxChannelDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(double input) { fbb_.AddElement<double>(4, input, 0); }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<double>> values) { fbb_.AddOffset(6, values); }
  PolyfaceAuxChannelDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PolyfaceAuxChannelDataBuilder &operator=(const PolyfaceAuxChannelDataBuilder &);
  flatbuffers::Offset<PolyfaceAuxChannelData> Finish() {
    auto o = flatbuffers::Offset<PolyfaceAuxChannelData>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<PolyfaceAuxChannelData> CreatePolyfaceAuxChannelData(flatbuffers::FlatBufferBuilder &_fbb,
   double input = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> values = 0) {
  PolyfaceAuxChannelDataBuilder builder_(_fbb);
  builder_.add_input(input);
  builder_.add_values(values);
  return builder_.Finish();
}

struct PolyfaceAuxChannel : private flatbuffers::Table {
  int32_t dataType() const { return GetField<int32_t>(4, 0); }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(6); }
  const flatbuffers::String *inputName() const { return GetPointer<const flatbuffers::String *>(8); }
  const flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannelData>> *data() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannelData>> *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* dataType */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* name */) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* inputName */) &&
           verifier.Verify(inputName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* data */) &&
           verifier.Verify(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
  bool has_dataType() const { return CheckField(4); }
  bool has_name() const { return CheckField(6); }
  bool has_inputName() const { return CheckField(8); }
  bool has_data() const { return CheckField(10); }
};

struct PolyfaceAuxChannelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataType(int32_t dataType) { fbb_.AddElement<int32_t>(4, dataType, 0); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(6, name); }
  void add_inputName(flatbuffers::Offset<flatbuffers::String> inputName) { fbb_.AddOffset(8, inputName); }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannelData>>> data) { fbb_.AddOffset(10, data); }
  PolyfaceAuxChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PolyfaceAuxChannelBuilder &operator=(const PolyfaceAuxChannelBuilder &);
  flatbuffers::Offset<PolyfaceAuxChannel> Finish() {
    auto o = flatbuffers::Offset<PolyfaceAuxChannel>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<PolyfaceAuxChannel> CreatePolyfaceAuxChannel(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t dataType = 0,
   flatbuffers::Offset<flatbuffers::String> name = 0,
   flatbuffers::Offset<flatbuffers::String> inputName = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannelData>>> data = 0) {
  PolyfaceAuxChannelBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_inputName(inputName);
  builder_.add_name(name);
  builder_.add_dataType(dataType);
  return builder_.Finish();
}

struct PolyfaceAuxData : private flatbuffers::Table {
  const flatbuffers::Vector<int32_t> *indices() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(4); }
  const flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannel>> *channels() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannel>> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* indices */) &&
           verifier.Verify(indices()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* channels */) &&
           verifier.Verify(channels()) &&
           verifier.VerifyVectorOfTables(channels()) &&
           verifier.EndTable();
  }
  bool has_indices() const { return CheckField(4); }
  bool has_channels() const { return CheckField(6); }
};

struct PolyfaceAuxDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> indices) { fbb_.AddOffset(4, indices); }
  void add_channels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannel>>> channels) { fbb_.AddOffset(6, channels); }
  PolyfaceAuxDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PolyfaceAuxDataBuilder &operator=(const PolyfaceAuxDataBuilder &);
  flatbuffers::Offset<PolyfaceAuxData> Finish() {
    auto o = flatbuffers::Offset<PolyfaceAuxData>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<PolyfaceAuxData> CreatePolyfaceAuxData(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> indices = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannel>>> channels = 0) {
  PolyfaceAuxDataBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_indices(indices);
  return builder_.Finish();
}

struct TaggedNumericData : private flatbuffers::Table {
  int32_t tagA() const { return GetField<int32_t>(4, 0); }
  int32_t tagB() const { return GetField<int32_t>(6, 0); }
  const flatbuffers::Vector<int32_t> *intData() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(8); }
  const flatbuffers::Vector<double> *doubleData() const { return GetPointer<const flatbuffers::Vector<double> *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, 4 /* tagA */) &&
           VerifyField<int32_t>(verifier, 6 /* tagB */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* intData */) &&
           verifier.Verify(intData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* doubleData */) &&
           verifier.Verify(doubleData()) &&
           verifier.EndTable();
  }
  bool has_tagA() const { return CheckField(4); }
  bool has_tagB() const { return CheckField(6); }
  bool has_intData() const { return CheckField(8); }
  bool has_doubleData() const { return CheckField(10); }
};

struct TaggedNumericDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tagA(int32_t tagA) { fbb_.AddElement<int32_t>(4, tagA, 0); }
  void add_tagB(int32_t tagB) { fbb_.AddElement<int32_t>(6, tagB, 0); }
  void add_intData(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intData) { fbb_.AddOffset(8, intData); }
  void add_doubleData(flatbuffers::Offset<flatbuffers::Vector<double>> doubleData) { fbb_.AddOffset(10, doubleData); }
  TaggedNumericDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TaggedNumericDataBuilder &operator=(const TaggedNumericDataBuilder &);
  flatbuffers::Offset<TaggedNumericData> Finish() {
    auto o = flatbuffers::Offset<TaggedNumericData>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<TaggedNumericData> CreateTaggedNumericData(flatbuffers::FlatBufferBuilder &_fbb,
   int32_t tagA = 0,
   int32_t tagB = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> intData = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> doubleData = 0) {
  TaggedNumericDataBuilder builder_(_fbb);
  builder_.add_doubleData(doubleData);
  builder_.add_intData(intData);
  builder_.add_tagB(tagB);
  builder_.add_tagA(tagA);
  return builder_.Finish();
}

struct Polyface : private flatbuffers::Table {
  const flatbuffers::Vector<double> *point() const { return GetPointer<const flatbuffers::Vector<double> *>(4); }
  const flatbuffers::Vector<double> *param() const { return GetPointer<const flatbuffers::Vector<double> *>(6); }
  const flatbuffers::Vector<double> *normal() const { return GetPointer<const flatbuffers::Vector<double> *>(8); }
  const flatbuffers::Vector<double> *doubleColor() const { return GetPointer<const flatbuffers::Vector<double> *>(10); }
  const flatbuffers::Vector<int32_t> *intColor() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(12); }
  const flatbuffers::Vector<int32_t> *pointIndex() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(14); }
  const flatbuffers::Vector<int32_t> *paramIndex() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(16); }
  const flatbuffers::Vector<int32_t> *normalIndex() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(18); }
  const flatbuffers::Vector<int32_t> *colorIndex() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(20); }
  const flatbuffers::Vector<int32_t> *colorTable() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(22); }
  int32_t numPerFace() const { return GetField<int32_t>(24, 0); }
  int32_t numPerRow() const { return GetField<int32_t>(26, 0); }
  int32_t meshStyle() const { return GetField<int32_t>(28, 0); }
  uint8_t twoSided() const { return GetField<uint8_t>(30, 0); }
  const flatbuffers::Vector<int32_t> *faceIndex() const { return GetPointer<const flatbuffers::Vector<int32_t> *>(32); }
  const flatbuffers::Vector<double> *faceData() const { return GetPointer<const flatbuffers::Vector<double> *>(34); }
  const PolyfaceAuxData *auxData() const { return GetPointer<const PolyfaceAuxData *>(36); }
  int32_t expectedClosure() const { return GetField<int32_t>(38, 0); }
  const TaggedNumericData *taggedNumericData() const { return GetPointer<const TaggedNumericData *>(40); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* point */) &&
           verifier.Verify(point()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* param */) &&
           verifier.Verify(param()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* normal */) &&
           verifier.Verify(normal()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* doubleColor */) &&
           verifier.Verify(doubleColor()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* intColor */) &&
           verifier.Verify(intColor()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 14 /* pointIndex */) &&
           verifier.Verify(pointIndex()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 16 /* paramIndex */) &&
           verifier.Verify(paramIndex()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 18 /* normalIndex */) &&
           verifier.Verify(normalIndex()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 20 /* colorIndex */) &&
           verifier.Verify(colorIndex()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 22 /* colorTable */) &&
           verifier.Verify(colorTable()) &&
           VerifyField<int32_t>(verifier, 24 /* numPerFace */) &&
           VerifyField<int32_t>(verifier, 26 /* numPerRow */) &&
           VerifyField<int32_t>(verifier, 28 /* meshStyle */) &&
           VerifyField<uint8_t>(verifier, 30 /* twoSided */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 32 /* faceIndex */) &&
           verifier.Verify(faceIndex()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 34 /* faceData */) &&
           verifier.Verify(faceData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 36 /* auxData */) &&
           verifier.VerifyTable(auxData()) &&
           VerifyField<int32_t>(verifier, 38 /* expectedClosure */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 40 /* taggedNumericData */) &&
           verifier.VerifyTable(taggedNumericData()) &&
           verifier.EndTable();
  }
  bool has_point() const { return CheckField(4); }
  bool has_param() const { return CheckField(6); }
  bool has_normal() const { return CheckField(8); }
  bool has_doubleColor() const { return CheckField(10); }
  bool has_intColor() const { return CheckField(12); }
  bool has_pointIndex() const { return CheckField(14); }
  bool has_paramIndex() const { return CheckField(16); }
  bool has_normalIndex() const { return CheckField(18); }
  bool has_colorIndex() const { return CheckField(20); }
  bool has_colorTable() const { return CheckField(22); }
  bool has_numPerFace() const { return CheckField(24); }
  bool has_numPerRow() const { return CheckField(26); }
  bool has_meshStyle() const { return CheckField(28); }
  bool has_twoSided() const { return CheckField(30); }
  bool has_faceIndex() const { return CheckField(32); }
  bool has_faceData() const { return CheckField(34); }
  bool has_auxData() const { return CheckField(36); }
  bool has_expectedClosure() const { return CheckField(38); }
  bool has_taggedNumericData() const { return CheckField(40); }
};

struct PolyfaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_point(flatbuffers::Offset<flatbuffers::Vector<double>> point) { fbb_.AddOffset(4, point); }
  void add_param(flatbuffers::Offset<flatbuffers::Vector<double>> param) { fbb_.AddOffset(6, param); }
  void add_normal(flatbuffers::Offset<flatbuffers::Vector<double>> normal) { fbb_.AddOffset(8, normal); }
  void add_doubleColor(flatbuffers::Offset<flatbuffers::Vector<double>> doubleColor) { fbb_.AddOffset(10, doubleColor); }
  void add_intColor(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intColor) { fbb_.AddOffset(12, intColor); }
  void add_pointIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pointIndex) { fbb_.AddOffset(14, pointIndex); }
  void add_paramIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paramIndex) { fbb_.AddOffset(16, paramIndex); }
  void add_normalIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> normalIndex) { fbb_.AddOffset(18, normalIndex); }
  void add_colorIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> colorIndex) { fbb_.AddOffset(20, colorIndex); }
  void add_colorTable(flatbuffers::Offset<flatbuffers::Vector<int32_t>> colorTable) { fbb_.AddOffset(22, colorTable); }
  void add_numPerFace(int32_t numPerFace) { fbb_.AddElement<int32_t>(24, numPerFace, 0); }
  void add_numPerRow(int32_t numPerRow) { fbb_.AddElement<int32_t>(26, numPerRow, 0); }
  void add_meshStyle(int32_t meshStyle) { fbb_.AddElement<int32_t>(28, meshStyle, 0); }
  void add_twoSided(uint8_t twoSided) { fbb_.AddElement<uint8_t>(30, twoSided, 0); }
  void add_faceIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> faceIndex) { fbb_.AddOffset(32, faceIndex); }
  void add_faceData(flatbuffers::Offset<flatbuffers::Vector<double>> faceData) { fbb_.AddOffset(34, faceData); }
  void add_auxData(flatbuffers::Offset<PolyfaceAuxData> auxData) { fbb_.AddOffset(36, auxData); }
  void add_expectedClosure(int32_t expectedClosure) { fbb_.AddElement<int32_t>(38, expectedClosure, 0); }
  void add_taggedNumericData(flatbuffers::Offset<TaggedNumericData> taggedNumericData) { fbb_.AddOffset(40, taggedNumericData); }
  PolyfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PolyfaceBuilder &operator=(const PolyfaceBuilder &);
  flatbuffers::Offset<Polyface> Finish() {
    auto o = flatbuffers::Offset<Polyface>(fbb_.EndTable(start_, 19));
    return o;
  }
};

inline flatbuffers::Offset<Polyface> CreatePolyface(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<double>> point = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> param = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> normal = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> doubleColor = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> intColor = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> pointIndex = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> paramIndex = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> normalIndex = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> colorIndex = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> colorTable = 0,
   int32_t numPerFace = 0,
   int32_t numPerRow = 0,
   int32_t meshStyle = 0,
   uint8_t twoSided = 0,
   flatbuffers::Offset<flatbuffers::Vector<int32_t>> faceIndex = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> faceData = 0,
   flatbuffers::Offset<PolyfaceAuxData> auxData = 0,
   int32_t expectedClosure = 0,
   flatbuffers::Offset<TaggedNumericData> taggedNumericData = 0) {
  PolyfaceBuilder builder_(_fbb);
  builder_.add_taggedNumericData(taggedNumericData);
  builder_.add_expectedClosure(expectedClosure);
  builder_.add_auxData(auxData);
  builder_.add_faceData(faceData);
  builder_.add_faceIndex(faceIndex);
  builder_.add_meshStyle(meshStyle);
  builder_.add_numPerRow(numPerRow);
  builder_.add_numPerFace(numPerFace);
  builder_.add_colorTable(colorTable);
  builder_.add_colorIndex(colorIndex);
  builder_.add_normalIndex(normalIndex);
  builder_.add_paramIndex(paramIndex);
  builder_.add_pointIndex(pointIndex);
  builder_.add_intColor(intColor);
  builder_.add_doubleColor(doubleColor);
  builder_.add_normal(normal);
  builder_.add_param(param);
  builder_.add_point(point);
  builder_.add_twoSided(twoSided);
  return builder_.Finish();
}

struct TransitionSpiral : private flatbuffers::Table {
  const TransitionSpiralDetail *detail() const { return GetStruct<const TransitionSpiralDetail *>(4); }
  const flatbuffers::Vector<double> *extraData() const { return GetPointer<const flatbuffers::Vector<double> *>(6); }
  const DirectSpiralDetail *directDetail() const { return GetStruct<const DirectSpiralDetail *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TransitionSpiralDetail>(verifier, 4 /* detail */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* extraData */) &&
           verifier.Verify(extraData()) &&
           VerifyField<DirectSpiralDetail>(verifier, 8 /* directDetail */) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(4); }
  bool has_extraData() const { return CheckField(6); }
  bool has_directDetail() const { return CheckField(8); }
};

struct TransitionSpiralBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const TransitionSpiralDetail *detail) { fbb_.AddStruct(4, detail); }
  void add_extraData(flatbuffers::Offset<flatbuffers::Vector<double>> extraData) { fbb_.AddOffset(6, extraData); }
  void add_directDetail(const DirectSpiralDetail *directDetail) { fbb_.AddStruct(8, directDetail); }
  TransitionSpiralBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TransitionSpiralBuilder &operator=(const TransitionSpiralBuilder &);
  flatbuffers::Offset<TransitionSpiral> Finish() {
    auto o = flatbuffers::Offset<TransitionSpiral>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<TransitionSpiral> CreateTransitionSpiral(flatbuffers::FlatBufferBuilder &_fbb,
   const TransitionSpiralDetail *detail = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> extraData = 0,
   const DirectSpiralDetail *directDetail = 0) {
  TransitionSpiralBuilder builder_(_fbb);
  builder_.add_directDetail(directDetail);
  builder_.add_extraData(extraData);
  builder_.add_detail(detail);
  return builder_.Finish();
}

struct VariantGeometry : private flatbuffers::Table {
  VariantGeometryUnion geometry_type() const { return static_cast<VariantGeometryUnion>(GetField<uint8_t>(4, 0)); }
  const void *geometry() const { return GetPointer<const void *>(6); }
  const CurvePrimitiveId *tag() const { return GetPointer<const CurvePrimitiveId *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* geometry_type */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* geometry */) &&
           VerifyVariantGeometryUnion(verifier, geometry(), geometry_type()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* tag */) &&
           verifier.VerifyTable(tag()) &&
           verifier.EndTable();
  }
  bool has_geometry_type() const { return CheckField(4); }
  bool has_geometry() const { return CheckField(6); }
  bool has_tag() const { return CheckField(8); }
};

struct VariantGeometryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_geometry_type(VariantGeometryUnion geometry_type) { fbb_.AddElement<uint8_t>(4, static_cast<uint8_t>(geometry_type), 0); }
  void add_geometry(flatbuffers::Offset<void> geometry) { fbb_.AddOffset(6, geometry); }
  void add_tag(flatbuffers::Offset<CurvePrimitiveId> tag) { fbb_.AddOffset(8, tag); }
  VariantGeometryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  VariantGeometryBuilder &operator=(const VariantGeometryBuilder &);
  flatbuffers::Offset<VariantGeometry> Finish() {
    auto o = flatbuffers::Offset<VariantGeometry>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<VariantGeometry> CreateVariantGeometry(flatbuffers::FlatBufferBuilder &_fbb,
   VariantGeometryUnion geometry_type = VariantGeometryUnion_NONE,
   flatbuffers::Offset<void> geometry = 0,
   flatbuffers::Offset<CurvePrimitiveId> tag = 0) {
  VariantGeometryBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_geometry(geometry);
  builder_.add_geometry_type(geometry_type);
  return builder_.Finish();
}

inline bool VerifyVariantGeometryUnion(flatbuffers::Verifier &verifier, const void *union_obj, VariantGeometryUnion type) {
  switch (type) {
    case VariantGeometryUnion_NONE: return true;
    case VariantGeometryUnion_LineSegment: return verifier.VerifyTable(reinterpret_cast<const LineSegment *>(union_obj));
    case VariantGeometryUnion_EllipticArc: return verifier.VerifyTable(reinterpret_cast<const EllipticArc *>(union_obj));
    case VariantGeometryUnion_BsplineCurve: return verifier.VerifyTable(reinterpret_cast<const BsplineCurve *>(union_obj));
    case VariantGeometryUnion_LineString: return verifier.VerifyTable(reinterpret_cast<const LineString *>(union_obj));
    case VariantGeometryUnion_CurveVector: return verifier.VerifyTable(reinterpret_cast<const CurveVector *>(union_obj));
    case VariantGeometryUnion_DgnCone: return verifier.VerifyTable(reinterpret_cast<const DgnCone *>(union_obj));
    case VariantGeometryUnion_DgnSphere: return verifier.VerifyTable(reinterpret_cast<const DgnSphere *>(union_obj));
    case VariantGeometryUnion_DgnTorusPipe: return verifier.VerifyTable(reinterpret_cast<const DgnTorusPipe *>(union_obj));
    case VariantGeometryUnion_DgnBox: return verifier.VerifyTable(reinterpret_cast<const DgnBox *>(union_obj));
    case VariantGeometryUnion_DgnExtrusion: return verifier.VerifyTable(reinterpret_cast<const DgnExtrusion *>(union_obj));
    case VariantGeometryUnion_DgnRotationalSweep: return verifier.VerifyTable(reinterpret_cast<const DgnRotationalSweep *>(union_obj));
    case VariantGeometryUnion_DgnRuledSweep: return verifier.VerifyTable(reinterpret_cast<const DgnRuledSweep *>(union_obj));
    case VariantGeometryUnion_Polyface: return verifier.VerifyTable(reinterpret_cast<const Polyface *>(union_obj));
    case VariantGeometryUnion_BsplineSurface: return verifier.VerifyTable(reinterpret_cast<const BsplineSurface *>(union_obj));
    case VariantGeometryUnion_VectorOfVariantGeometry: return verifier.VerifyTable(reinterpret_cast<const VectorOfVariantGeometry *>(union_obj));
    case VariantGeometryUnion_InterpolationCurve: return verifier.VerifyTable(reinterpret_cast<const InterpolationCurve *>(union_obj));
    case VariantGeometryUnion_TransitionSpiral: return verifier.VerifyTable(reinterpret_cast<const TransitionSpiral *>(union_obj));
    case VariantGeometryUnion_PointString: return verifier.VerifyTable(reinterpret_cast<const PointString *>(union_obj));
    case VariantGeometryUnion_AkimaCurve: return verifier.VerifyTable(reinterpret_cast<const AkimaCurve *>(union_obj));
    case VariantGeometryUnion_CatenaryCurve: return verifier.VerifyTable(reinterpret_cast<const CatenaryCurve *>(union_obj));
    case VariantGeometryUnion_PartialCurve: return verifier.VerifyTable(reinterpret_cast<const PartialCurve *>(union_obj));
    default: return false;
  }
}


}}} // End of Bentley::Geometry::FB namespace
#endif // FLATBUFFERS_GENERATED_ALLCG_H_
