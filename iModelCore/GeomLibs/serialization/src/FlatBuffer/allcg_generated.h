/*---------------------------------------------------------------------------------------------
* Copyright (c) Bentley Systems, Incorporated. All rights reserved.
* See LICENSE.md in the repository root for full copyright notice.
*--------------------------------------------------------------------------------------------*/
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ALLCG_H_
#define FLATBUFFERS_GENERATED_ALLCG_H_

#include "flatbuffers/flatbuffers.h"

namespace Bentley {
namespace Geometry {
namespace FB {



struct DPoint3d;

struct DRay3d;

struct DPoint2d;

struct DVector3d;

struct Angle;

struct DEllipse3d;

struct DSegment3d;

struct DTransform3d;

struct DgnBoxDetail;

struct DgnSphereDetail;

struct DgnConeDetail;

struct DgnTorusPipeDetail;

struct LineSegment;
struct LineSegmentBuilder;

struct LineString;
struct LineStringBuilder;

struct PointString;
struct PointStringBuilder;

struct EllipticArc;
struct EllipticArcBuilder;

struct BsplineCurve;
struct BsplineCurveBuilder;

struct InterpolationCurve;
struct InterpolationCurveBuilder;

struct AkimaCurve;
struct AkimaCurveBuilder;

struct CatenaryCurve;
struct CatenaryCurveBuilder;

struct PartialCurve;
struct PartialCurveBuilder;

struct CurvePrimitiveId;
struct CurvePrimitiveIdBuilder;

struct CurveVector;
struct CurveVectorBuilder;

struct VectorOfVariantGeometry;
struct VectorOfVariantGeometryBuilder;

struct BsplineSurface;
struct BsplineSurfaceBuilder;

struct DgnBox;
struct DgnBoxBuilder;

struct DgnSphere;
struct DgnSphereBuilder;

struct DgnCone;
struct DgnConeBuilder;

struct DgnTorusPipe;
struct DgnTorusPipeBuilder;

struct DgnExtrusion;
struct DgnExtrusionBuilder;

struct DgnRotationalSweep;
struct DgnRotationalSweepBuilder;

struct DgnRuledSweep;
struct DgnRuledSweepBuilder;

struct PolyfaceAuxChannelData;
struct PolyfaceAuxChannelDataBuilder;

struct PolyfaceAuxChannel;
struct PolyfaceAuxChannelBuilder;

struct PolyfaceAuxData;
struct PolyfaceAuxDataBuilder;

struct TaggedNumericData;
struct TaggedNumericDataBuilder;

struct Polyface;
struct PolyfaceBuilder;

struct TransitionSpiralDetail;

struct DirectSpiralDetail;

struct TransitionSpiral;
struct TransitionSpiralBuilder;

struct VariantGeometry;
struct VariantGeometryBuilder;

enum LoopTypeEnum {
  LoopTypeEnum_Parity = 1,
  LoopTypeEnum_InteriorToLeft = 2,
  LoopTypeEnum_MIN = LoopTypeEnum_Parity,
  LoopTypeEnum_MAX = LoopTypeEnum_InteriorToLeft
};

inline const LoopTypeEnum (&EnumValuesLoopTypeEnum())[2] {
  static const LoopTypeEnum values[] = {
    LoopTypeEnum_Parity,
    LoopTypeEnum_InteriorToLeft
  };
  return values;
}

inline const char * const *EnumNamesLoopTypeEnum() {
  static const char * const names[3] = {
    "Parity",
    "InteriorToLeft",
    nullptr
  };
  return names;
}

inline const char *EnumNameLoopTypeEnum(LoopTypeEnum e) {
  if (flatbuffers::IsOutRange(e, LoopTypeEnum_Parity, LoopTypeEnum_InteriorToLeft)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(LoopTypeEnum_Parity);
  return EnumNamesLoopTypeEnum()[index];
}

enum VariantGeometryUnion {
  VariantGeometryUnion_NONE = 0,
  VariantGeometryUnion_LineSegment = 1,
  VariantGeometryUnion_EllipticArc = 2,
  VariantGeometryUnion_BsplineCurve = 3,
  VariantGeometryUnion_LineString = 4,
  VariantGeometryUnion_CurveVector = 5,
  VariantGeometryUnion_DgnCone = 6,
  VariantGeometryUnion_DgnSphere = 7,
  VariantGeometryUnion_DgnTorusPipe = 8,
  VariantGeometryUnion_DgnBox = 9,
  VariantGeometryUnion_DgnExtrusion = 10,
  VariantGeometryUnion_DgnRotationalSweep = 11,
  VariantGeometryUnion_DgnRuledSweep = 12,
  VariantGeometryUnion_Polyface = 13,
  VariantGeometryUnion_BsplineSurface = 14,
  VariantGeometryUnion_VectorOfVariantGeometry = 15,
  VariantGeometryUnion_InterpolationCurve = 16,
  VariantGeometryUnion_TransitionSpiral = 17,
  VariantGeometryUnion_PointString = 18,
  VariantGeometryUnion_AkimaCurve = 19,
  VariantGeometryUnion_CatenaryCurve = 20,
  VariantGeometryUnion_PartialCurve = 21,
  VariantGeometryUnion_MIN = VariantGeometryUnion_NONE,
  VariantGeometryUnion_MAX = VariantGeometryUnion_PartialCurve
};

inline const VariantGeometryUnion (&EnumValuesVariantGeometryUnion())[22] {
  static const VariantGeometryUnion values[] = {
    VariantGeometryUnion_NONE,
    VariantGeometryUnion_LineSegment,
    VariantGeometryUnion_EllipticArc,
    VariantGeometryUnion_BsplineCurve,
    VariantGeometryUnion_LineString,
    VariantGeometryUnion_CurveVector,
    VariantGeometryUnion_DgnCone,
    VariantGeometryUnion_DgnSphere,
    VariantGeometryUnion_DgnTorusPipe,
    VariantGeometryUnion_DgnBox,
    VariantGeometryUnion_DgnExtrusion,
    VariantGeometryUnion_DgnRotationalSweep,
    VariantGeometryUnion_DgnRuledSweep,
    VariantGeometryUnion_Polyface,
    VariantGeometryUnion_BsplineSurface,
    VariantGeometryUnion_VectorOfVariantGeometry,
    VariantGeometryUnion_InterpolationCurve,
    VariantGeometryUnion_TransitionSpiral,
    VariantGeometryUnion_PointString,
    VariantGeometryUnion_AkimaCurve,
    VariantGeometryUnion_CatenaryCurve,
    VariantGeometryUnion_PartialCurve
  };
  return values;
}

inline const char * const *EnumNamesVariantGeometryUnion() {
  static const char * const names[23] = {
    "NONE",
    "LineSegment",
    "EllipticArc",
    "BsplineCurve",
    "LineString",
    "CurveVector",
    "DgnCone",
    "DgnSphere",
    "DgnTorusPipe",
    "DgnBox",
    "DgnExtrusion",
    "DgnRotationalSweep",
    "DgnRuledSweep",
    "Polyface",
    "BsplineSurface",
    "VectorOfVariantGeometry",
    "InterpolationCurve",
    "TransitionSpiral",
    "PointString",
    "AkimaCurve",
    "CatenaryCurve",
    "PartialCurve",
    nullptr
  };
  return names;
}

inline const char *EnumNameVariantGeometryUnion(VariantGeometryUnion e) {
  if (flatbuffers::IsOutRange(e, VariantGeometryUnion_NONE, VariantGeometryUnion_PartialCurve)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVariantGeometryUnion()[index];
}

template<typename T> struct VariantGeometryUnionTraits {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_NONE;
};

template<> struct VariantGeometryUnionTraits<LineSegment> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_LineSegment;
};

template<> struct VariantGeometryUnionTraits<EllipticArc> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_EllipticArc;
};

template<> struct VariantGeometryUnionTraits<BsplineCurve> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_BsplineCurve;
};

template<> struct VariantGeometryUnionTraits<LineString> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_LineString;
};

template<> struct VariantGeometryUnionTraits<CurveVector> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_CurveVector;
};

template<> struct VariantGeometryUnionTraits<DgnCone> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_DgnCone;
};

template<> struct VariantGeometryUnionTraits<DgnSphere> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_DgnSphere;
};

template<> struct VariantGeometryUnionTraits<DgnTorusPipe> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_DgnTorusPipe;
};

template<> struct VariantGeometryUnionTraits<DgnBox> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_DgnBox;
};

template<> struct VariantGeometryUnionTraits<DgnExtrusion> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_DgnExtrusion;
};

template<> struct VariantGeometryUnionTraits<DgnRotationalSweep> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_DgnRotationalSweep;
};

template<> struct VariantGeometryUnionTraits<DgnRuledSweep> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_DgnRuledSweep;
};

template<> struct VariantGeometryUnionTraits<Polyface> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_Polyface;
};

template<> struct VariantGeometryUnionTraits<BsplineSurface> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_BsplineSurface;
};

template<> struct VariantGeometryUnionTraits<VectorOfVariantGeometry> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_VectorOfVariantGeometry;
};

template<> struct VariantGeometryUnionTraits<InterpolationCurve> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_InterpolationCurve;
};

template<> struct VariantGeometryUnionTraits<TransitionSpiral> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_TransitionSpiral;
};

template<> struct VariantGeometryUnionTraits<PointString> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_PointString;
};

template<> struct VariantGeometryUnionTraits<AkimaCurve> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_AkimaCurve;
};

template<> struct VariantGeometryUnionTraits<CatenaryCurve> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_CatenaryCurve;
};

template<> struct VariantGeometryUnionTraits<PartialCurve> {
  static const VariantGeometryUnion enum_value = VariantGeometryUnion_PartialCurve;
};

bool VerifyVariantGeometryUnion(flatbuffers::Verifier &verifier, const void *obj, VariantGeometryUnion type);
bool VerifyVariantGeometryUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DPoint3d FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DPoint3d() {
    memset(static_cast<void *>(this), 0, sizeof(DPoint3d));
  }
  DPoint3d(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(DPoint3d, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DRay3d FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;
  double ux_;
  double uy_;
  double uz_;

 public:
  DRay3d() {
    memset(static_cast<void *>(this), 0, sizeof(DRay3d));
  }
  DRay3d(double _x, double _y, double _z, double _ux, double _uy, double _uz)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        ux_(flatbuffers::EndianScalar(_ux)),
        uy_(flatbuffers::EndianScalar(_uy)),
        uz_(flatbuffers::EndianScalar(_uz)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
  double ux() const {
    return flatbuffers::EndianScalar(ux_);
  }
  double uy() const {
    return flatbuffers::EndianScalar(uy_);
  }
  double uz() const {
    return flatbuffers::EndianScalar(uz_);
  }
};
FLATBUFFERS_STRUCT_END(DRay3d, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DPoint2d FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;

 public:
  DPoint2d() {
    memset(static_cast<void *>(this), 0, sizeof(DPoint2d));
  }
  DPoint2d(double _x, double _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(DPoint2d, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DVector3d FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DVector3d() {
    memset(static_cast<void *>(this), 0, sizeof(DVector3d));
  }
  DVector3d(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(DVector3d, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Angle FLATBUFFERS_FINAL_CLASS {
 private:
  double degrees_;

 public:
  Angle() {
    memset(static_cast<void *>(this), 0, sizeof(Angle));
  }
  Angle(double _degrees)
      : degrees_(flatbuffers::EndianScalar(_degrees)) {
  }
  double degrees() const {
    return flatbuffers::EndianScalar(degrees_);
  }
};
FLATBUFFERS_STRUCT_END(Angle, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DEllipse3d FLATBUFFERS_FINAL_CLASS {
 private:
  double centerX_;
  double centerY_;
  double centerZ_;
  double vector0X_;
  double vector0Y_;
  double vector0Z_;
  double vector90X_;
  double vector90Y_;
  double vector90Z_;
  double startRadians_;
  double sweepRadians_;

 public:
  DEllipse3d() {
    memset(static_cast<void *>(this), 0, sizeof(DEllipse3d));
  }
  DEllipse3d(double _centerX, double _centerY, double _centerZ, double _vector0X, double _vector0Y, double _vector0Z, double _vector90X, double _vector90Y, double _vector90Z, double _startRadians, double _sweepRadians)
      : centerX_(flatbuffers::EndianScalar(_centerX)),
        centerY_(flatbuffers::EndianScalar(_centerY)),
        centerZ_(flatbuffers::EndianScalar(_centerZ)),
        vector0X_(flatbuffers::EndianScalar(_vector0X)),
        vector0Y_(flatbuffers::EndianScalar(_vector0Y)),
        vector0Z_(flatbuffers::EndianScalar(_vector0Z)),
        vector90X_(flatbuffers::EndianScalar(_vector90X)),
        vector90Y_(flatbuffers::EndianScalar(_vector90Y)),
        vector90Z_(flatbuffers::EndianScalar(_vector90Z)),
        startRadians_(flatbuffers::EndianScalar(_startRadians)),
        sweepRadians_(flatbuffers::EndianScalar(_sweepRadians)) {
  }
  double centerX() const {
    return flatbuffers::EndianScalar(centerX_);
  }
  double centerY() const {
    return flatbuffers::EndianScalar(centerY_);
  }
  double centerZ() const {
    return flatbuffers::EndianScalar(centerZ_);
  }
  double vector0X() const {
    return flatbuffers::EndianScalar(vector0X_);
  }
  double vector0Y() const {
    return flatbuffers::EndianScalar(vector0Y_);
  }
  double vector0Z() const {
    return flatbuffers::EndianScalar(vector0Z_);
  }
  double vector90X() const {
    return flatbuffers::EndianScalar(vector90X_);
  }
  double vector90Y() const {
    return flatbuffers::EndianScalar(vector90Y_);
  }
  double vector90Z() const {
    return flatbuffers::EndianScalar(vector90Z_);
  }
  double startRadians() const {
    return flatbuffers::EndianScalar(startRadians_);
  }
  double sweepRadians() const {
    return flatbuffers::EndianScalar(sweepRadians_);
  }
};
FLATBUFFERS_STRUCT_END(DEllipse3d, 88);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DSegment3d FLATBUFFERS_FINAL_CLASS {
 private:
  double point0X_;
  double point0Y_;
  double point0Z_;
  double point1X_;
  double point1Y_;
  double point1Z_;

 public:
  DSegment3d() {
    memset(static_cast<void *>(this), 0, sizeof(DSegment3d));
  }
  DSegment3d(double _point0X, double _point0Y, double _point0Z, double _point1X, double _point1Y, double _point1Z)
      : point0X_(flatbuffers::EndianScalar(_point0X)),
        point0Y_(flatbuffers::EndianScalar(_point0Y)),
        point0Z_(flatbuffers::EndianScalar(_point0Z)),
        point1X_(flatbuffers::EndianScalar(_point1X)),
        point1Y_(flatbuffers::EndianScalar(_point1Y)),
        point1Z_(flatbuffers::EndianScalar(_point1Z)) {
  }
  double point0X() const {
    return flatbuffers::EndianScalar(point0X_);
  }
  double point0Y() const {
    return flatbuffers::EndianScalar(point0Y_);
  }
  double point0Z() const {
    return flatbuffers::EndianScalar(point0Z_);
  }
  double point1X() const {
    return flatbuffers::EndianScalar(point1X_);
  }
  double point1Y() const {
    return flatbuffers::EndianScalar(point1Y_);
  }
  double point1Z() const {
    return flatbuffers::EndianScalar(point1Z_);
  }
};
FLATBUFFERS_STRUCT_END(DSegment3d, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DTransform3d FLATBUFFERS_FINAL_CLASS {
 private:
  double axx_;
  double axy_;
  double axz_;
  double axw_;
  double ayx_;
  double ayy_;
  double ayz_;
  double ayw_;
  double azx_;
  double azy_;
  double azz_;
  double azw_;

 public:
  DTransform3d() {
    memset(static_cast<void *>(this), 0, sizeof(DTransform3d));
  }
  DTransform3d(double _axx, double _axy, double _axz, double _axw, double _ayx, double _ayy, double _ayz, double _ayw, double _azx, double _azy, double _azz, double _azw)
      : axx_(flatbuffers::EndianScalar(_axx)),
        axy_(flatbuffers::EndianScalar(_axy)),
        axz_(flatbuffers::EndianScalar(_axz)),
        axw_(flatbuffers::EndianScalar(_axw)),
        ayx_(flatbuffers::EndianScalar(_ayx)),
        ayy_(flatbuffers::EndianScalar(_ayy)),
        ayz_(flatbuffers::EndianScalar(_ayz)),
        ayw_(flatbuffers::EndianScalar(_ayw)),
        azx_(flatbuffers::EndianScalar(_azx)),
        azy_(flatbuffers::EndianScalar(_azy)),
        azz_(flatbuffers::EndianScalar(_azz)),
        azw_(flatbuffers::EndianScalar(_azw)) {
  }
  double axx() const {
    return flatbuffers::EndianScalar(axx_);
  }
  double axy() const {
    return flatbuffers::EndianScalar(axy_);
  }
  double axz() const {
    return flatbuffers::EndianScalar(axz_);
  }
  double axw() const {
    return flatbuffers::EndianScalar(axw_);
  }
  double ayx() const {
    return flatbuffers::EndianScalar(ayx_);
  }
  double ayy() const {
    return flatbuffers::EndianScalar(ayy_);
  }
  double ayz() const {
    return flatbuffers::EndianScalar(ayz_);
  }
  double ayw() const {
    return flatbuffers::EndianScalar(ayw_);
  }
  double azx() const {
    return flatbuffers::EndianScalar(azx_);
  }
  double azy() const {
    return flatbuffers::EndianScalar(azy_);
  }
  double azz() const {
    return flatbuffers::EndianScalar(azz_);
  }
  double azw() const {
    return flatbuffers::EndianScalar(azw_);
  }
};
FLATBUFFERS_STRUCT_END(DTransform3d, 96);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DgnBoxDetail FLATBUFFERS_FINAL_CLASS {
 private:
  double baseOriginX_;
  double baseOriginY_;
  double baseOriginZ_;
  double topOriginX_;
  double topOriginY_;
  double topOriginZ_;
  double vectorXX_;
  double vectorXY_;
  double vectorXZ_;
  double vectorYX_;
  double vectorYY_;
  double vectorYZ_;
  double baseX_;
  double baseY_;
  double topX_;
  double topY_;
  uint8_t capped_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  DgnBoxDetail() {
    memset(static_cast<void *>(this), 0, sizeof(DgnBoxDetail));
  }
  DgnBoxDetail(double _baseOriginX, double _baseOriginY, double _baseOriginZ, double _topOriginX, double _topOriginY, double _topOriginZ, double _vectorXX, double _vectorXY, double _vectorXZ, double _vectorYX, double _vectorYY, double _vectorYZ, double _baseX, double _baseY, double _topX, double _topY, bool _capped)
      : baseOriginX_(flatbuffers::EndianScalar(_baseOriginX)),
        baseOriginY_(flatbuffers::EndianScalar(_baseOriginY)),
        baseOriginZ_(flatbuffers::EndianScalar(_baseOriginZ)),
        topOriginX_(flatbuffers::EndianScalar(_topOriginX)),
        topOriginY_(flatbuffers::EndianScalar(_topOriginY)),
        topOriginZ_(flatbuffers::EndianScalar(_topOriginZ)),
        vectorXX_(flatbuffers::EndianScalar(_vectorXX)),
        vectorXY_(flatbuffers::EndianScalar(_vectorXY)),
        vectorXZ_(flatbuffers::EndianScalar(_vectorXZ)),
        vectorYX_(flatbuffers::EndianScalar(_vectorYX)),
        vectorYY_(flatbuffers::EndianScalar(_vectorYY)),
        vectorYZ_(flatbuffers::EndianScalar(_vectorYZ)),
        baseX_(flatbuffers::EndianScalar(_baseX)),
        baseY_(flatbuffers::EndianScalar(_baseY)),
        topX_(flatbuffers::EndianScalar(_topX)),
        topY_(flatbuffers::EndianScalar(_topY)),
        capped_(flatbuffers::EndianScalar(static_cast<uint8_t>(_capped))),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;    (void)padding1__;    (void)padding2__;
  }
  double baseOriginX() const {
    return flatbuffers::EndianScalar(baseOriginX_);
  }
  double baseOriginY() const {
    return flatbuffers::EndianScalar(baseOriginY_);
  }
  double baseOriginZ() const {
    return flatbuffers::EndianScalar(baseOriginZ_);
  }
  double topOriginX() const {
    return flatbuffers::EndianScalar(topOriginX_);
  }
  double topOriginY() const {
    return flatbuffers::EndianScalar(topOriginY_);
  }
  double topOriginZ() const {
    return flatbuffers::EndianScalar(topOriginZ_);
  }
  double vectorXX() const {
    return flatbuffers::EndianScalar(vectorXX_);
  }
  double vectorXY() const {
    return flatbuffers::EndianScalar(vectorXY_);
  }
  double vectorXZ() const {
    return flatbuffers::EndianScalar(vectorXZ_);
  }
  double vectorYX() const {
    return flatbuffers::EndianScalar(vectorYX_);
  }
  double vectorYY() const {
    return flatbuffers::EndianScalar(vectorYY_);
  }
  double vectorYZ() const {
    return flatbuffers::EndianScalar(vectorYZ_);
  }
  double baseX() const {
    return flatbuffers::EndianScalar(baseX_);
  }
  double baseY() const {
    return flatbuffers::EndianScalar(baseY_);
  }
  double topX() const {
    return flatbuffers::EndianScalar(topX_);
  }
  double topY() const {
    return flatbuffers::EndianScalar(topY_);
  }
  bool capped() const {
    return flatbuffers::EndianScalar(capped_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(DgnBoxDetail, 136);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DgnSphereDetail FLATBUFFERS_FINAL_CLASS {
 private:
  DTransform3d localToWorld_;
  double startLatitudeRadians_;
  double latitudeSweepRadians_;
  uint8_t capped_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  DgnSphereDetail() {
    memset(static_cast<void *>(this), 0, sizeof(DgnSphereDetail));
  }
  DgnSphereDetail(const DTransform3d &_localToWorld, double _startLatitudeRadians, double _latitudeSweepRadians, bool _capped)
      : localToWorld_(_localToWorld),
        startLatitudeRadians_(flatbuffers::EndianScalar(_startLatitudeRadians)),
        latitudeSweepRadians_(flatbuffers::EndianScalar(_latitudeSweepRadians)),
        capped_(flatbuffers::EndianScalar(static_cast<uint8_t>(_capped))),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;    (void)padding1__;    (void)padding2__;
  }
  const DTransform3d &localToWorld() const {
    return localToWorld_;
  }
  double startLatitudeRadians() const {
    return flatbuffers::EndianScalar(startLatitudeRadians_);
  }
  double latitudeSweepRadians() const {
    return flatbuffers::EndianScalar(latitudeSweepRadians_);
  }
  bool capped() const {
    return flatbuffers::EndianScalar(capped_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(DgnSphereDetail, 120);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DgnConeDetail FLATBUFFERS_FINAL_CLASS {
 private:
  double centerAX_;
  double centerAY_;
  double centerAZ_;
  double centerBX_;
  double centerBY_;
  double centerBZ_;
  double vector0X_;
  double vector0Y_;
  double vector0Z_;
  double vector90X_;
  double vector90Y_;
  double vector90Z_;
  double radiusA_;
  double radiusB_;
  uint8_t capped_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  DgnConeDetail() {
    memset(static_cast<void *>(this), 0, sizeof(DgnConeDetail));
  }
  DgnConeDetail(double _centerAX, double _centerAY, double _centerAZ, double _centerBX, double _centerBY, double _centerBZ, double _vector0X, double _vector0Y, double _vector0Z, double _vector90X, double _vector90Y, double _vector90Z, double _radiusA, double _radiusB, bool _capped)
      : centerAX_(flatbuffers::EndianScalar(_centerAX)),
        centerAY_(flatbuffers::EndianScalar(_centerAY)),
        centerAZ_(flatbuffers::EndianScalar(_centerAZ)),
        centerBX_(flatbuffers::EndianScalar(_centerBX)),
        centerBY_(flatbuffers::EndianScalar(_centerBY)),
        centerBZ_(flatbuffers::EndianScalar(_centerBZ)),
        vector0X_(flatbuffers::EndianScalar(_vector0X)),
        vector0Y_(flatbuffers::EndianScalar(_vector0Y)),
        vector0Z_(flatbuffers::EndianScalar(_vector0Z)),
        vector90X_(flatbuffers::EndianScalar(_vector90X)),
        vector90Y_(flatbuffers::EndianScalar(_vector90Y)),
        vector90Z_(flatbuffers::EndianScalar(_vector90Z)),
        radiusA_(flatbuffers::EndianScalar(_radiusA)),
        radiusB_(flatbuffers::EndianScalar(_radiusB)),
        capped_(flatbuffers::EndianScalar(static_cast<uint8_t>(_capped))),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;    (void)padding1__;    (void)padding2__;
  }
  double centerAX() const {
    return flatbuffers::EndianScalar(centerAX_);
  }
  double centerAY() const {
    return flatbuffers::EndianScalar(centerAY_);
  }
  double centerAZ() const {
    return flatbuffers::EndianScalar(centerAZ_);
  }
  double centerBX() const {
    return flatbuffers::EndianScalar(centerBX_);
  }
  double centerBY() const {
    return flatbuffers::EndianScalar(centerBY_);
  }
  double centerBZ() const {
    return flatbuffers::EndianScalar(centerBZ_);
  }
  double vector0X() const {
    return flatbuffers::EndianScalar(vector0X_);
  }
  double vector0Y() const {
    return flatbuffers::EndianScalar(vector0Y_);
  }
  double vector0Z() const {
    return flatbuffers::EndianScalar(vector0Z_);
  }
  double vector90X() const {
    return flatbuffers::EndianScalar(vector90X_);
  }
  double vector90Y() const {
    return flatbuffers::EndianScalar(vector90Y_);
  }
  double vector90Z() const {
    return flatbuffers::EndianScalar(vector90Z_);
  }
  double radiusA() const {
    return flatbuffers::EndianScalar(radiusA_);
  }
  double radiusB() const {
    return flatbuffers::EndianScalar(radiusB_);
  }
  bool capped() const {
    return flatbuffers::EndianScalar(capped_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(DgnConeDetail, 120);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DgnTorusPipeDetail FLATBUFFERS_FINAL_CLASS {
 private:
  double centerX_;
  double centerY_;
  double centerZ_;
  double vectorXX_;
  double vectorXY_;
  double vectorXZ_;
  double vectorYX_;
  double vectorYY_;
  double vectorYZ_;
  double majorRadius_;
  double minorRadius_;
  double sweepRadians_;
  uint8_t capped_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;

 public:
  DgnTorusPipeDetail() {
    memset(static_cast<void *>(this), 0, sizeof(DgnTorusPipeDetail));
  }
  DgnTorusPipeDetail(double _centerX, double _centerY, double _centerZ, double _vectorXX, double _vectorXY, double _vectorXZ, double _vectorYX, double _vectorYY, double _vectorYZ, double _majorRadius, double _minorRadius, double _sweepRadians, bool _capped)
      : centerX_(flatbuffers::EndianScalar(_centerX)),
        centerY_(flatbuffers::EndianScalar(_centerY)),
        centerZ_(flatbuffers::EndianScalar(_centerZ)),
        vectorXX_(flatbuffers::EndianScalar(_vectorXX)),
        vectorXY_(flatbuffers::EndianScalar(_vectorXY)),
        vectorXZ_(flatbuffers::EndianScalar(_vectorXZ)),
        vectorYX_(flatbuffers::EndianScalar(_vectorYX)),
        vectorYY_(flatbuffers::EndianScalar(_vectorYY)),
        vectorYZ_(flatbuffers::EndianScalar(_vectorYZ)),
        majorRadius_(flatbuffers::EndianScalar(_majorRadius)),
        minorRadius_(flatbuffers::EndianScalar(_minorRadius)),
        sweepRadians_(flatbuffers::EndianScalar(_sweepRadians)),
        capped_(flatbuffers::EndianScalar(static_cast<uint8_t>(_capped))),
        padding0__(0),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;    (void)padding1__;    (void)padding2__;
  }
  double centerX() const {
    return flatbuffers::EndianScalar(centerX_);
  }
  double centerY() const {
    return flatbuffers::EndianScalar(centerY_);
  }
  double centerZ() const {
    return flatbuffers::EndianScalar(centerZ_);
  }
  double vectorXX() const {
    return flatbuffers::EndianScalar(vectorXX_);
  }
  double vectorXY() const {
    return flatbuffers::EndianScalar(vectorXY_);
  }
  double vectorXZ() const {
    return flatbuffers::EndianScalar(vectorXZ_);
  }
  double vectorYX() const {
    return flatbuffers::EndianScalar(vectorYX_);
  }
  double vectorYY() const {
    return flatbuffers::EndianScalar(vectorYY_);
  }
  double vectorYZ() const {
    return flatbuffers::EndianScalar(vectorYZ_);
  }
  double majorRadius() const {
    return flatbuffers::EndianScalar(majorRadius_);
  }
  double minorRadius() const {
    return flatbuffers::EndianScalar(minorRadius_);
  }
  double sweepRadians() const {
    return flatbuffers::EndianScalar(sweepRadians_);
  }
  bool capped() const {
    return flatbuffers::EndianScalar(capped_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(DgnTorusPipeDetail, 104);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) TransitionSpiralDetail FLATBUFFERS_FINAL_CLASS {
 private:
  DTransform3d transform_;
  double fractionA_;
  double fractionB_;
  double bearing0Radians_;
  double bearing1Radians_;
  double curvature0_;
  double curvature1_;
  int32_t spiralType_;
  int32_t constructionHint_;

 public:
  TransitionSpiralDetail() {
    memset(static_cast<void *>(this), 0, sizeof(TransitionSpiralDetail));
  }
  TransitionSpiralDetail(const DTransform3d &_transform, double _fractionA, double _fractionB, double _bearing0Radians, double _bearing1Radians, double _curvature0, double _curvature1, int32_t _spiralType, int32_t _constructionHint)
      : transform_(_transform),
        fractionA_(flatbuffers::EndianScalar(_fractionA)),
        fractionB_(flatbuffers::EndianScalar(_fractionB)),
        bearing0Radians_(flatbuffers::EndianScalar(_bearing0Radians)),
        bearing1Radians_(flatbuffers::EndianScalar(_bearing1Radians)),
        curvature0_(flatbuffers::EndianScalar(_curvature0)),
        curvature1_(flatbuffers::EndianScalar(_curvature1)),
        spiralType_(flatbuffers::EndianScalar(_spiralType)),
        constructionHint_(flatbuffers::EndianScalar(_constructionHint)) {
  }
  const DTransform3d &transform() const {
    return transform_;
  }
  double fractionA() const {
    return flatbuffers::EndianScalar(fractionA_);
  }
  double fractionB() const {
    return flatbuffers::EndianScalar(fractionB_);
  }
  double bearing0Radians() const {
    return flatbuffers::EndianScalar(bearing0Radians_);
  }
  double bearing1Radians() const {
    return flatbuffers::EndianScalar(bearing1Radians_);
  }
  double curvature0() const {
    return flatbuffers::EndianScalar(curvature0_);
  }
  double curvature1() const {
    return flatbuffers::EndianScalar(curvature1_);
  }
  int32_t spiralType() const {
    return flatbuffers::EndianScalar(spiralType_);
  }
  int32_t constructionHint() const {
    return flatbuffers::EndianScalar(constructionHint_);
  }
};
FLATBUFFERS_STRUCT_END(TransitionSpiralDetail, 152);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) DirectSpiralDetail FLATBUFFERS_FINAL_CLASS {
 private:
  double nominalLength_;
  double trueLength_;
  double doubleTag0_;
  double doubleTag1_;
  double intTag0_;
  double intTag1_;

 public:
  DirectSpiralDetail() {
    memset(static_cast<void *>(this), 0, sizeof(DirectSpiralDetail));
  }
  DirectSpiralDetail(double _nominalLength, double _trueLength, double _doubleTag0, double _doubleTag1, double _intTag0, double _intTag1)
      : nominalLength_(flatbuffers::EndianScalar(_nominalLength)),
        trueLength_(flatbuffers::EndianScalar(_trueLength)),
        doubleTag0_(flatbuffers::EndianScalar(_doubleTag0)),
        doubleTag1_(flatbuffers::EndianScalar(_doubleTag1)),
        intTag0_(flatbuffers::EndianScalar(_intTag0)),
        intTag1_(flatbuffers::EndianScalar(_intTag1)) {
  }
  double nominalLength() const {
    return flatbuffers::EndianScalar(nominalLength_);
  }
  double trueLength() const {
    return flatbuffers::EndianScalar(trueLength_);
  }
  double doubleTag0() const {
    return flatbuffers::EndianScalar(doubleTag0_);
  }
  double doubleTag1() const {
    return flatbuffers::EndianScalar(doubleTag1_);
  }
  double intTag0() const {
    return flatbuffers::EndianScalar(intTag0_);
  }
  double intTag1() const {
    return flatbuffers::EndianScalar(intTag1_);
  }
};
FLATBUFFERS_STRUCT_END(DirectSpiralDetail, 48);

struct LineSegment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LineSegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEGMENT = 4
  };
  const DSegment3d *segment() const {
    return GetStruct<const DSegment3d *>(VT_SEGMENT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DSegment3d>(verifier, VT_SEGMENT) &&
           verifier.EndTable();
  }
  bool has_segment() const { return CheckField(VT_SEGMENT); }
};

struct LineSegmentBuilder {
  typedef LineSegment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_segment(const DSegment3d *segment) {
    fbb_.AddStruct(LineSegment::VT_SEGMENT, segment);
  }
  explicit LineSegmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LineSegmentBuilder &operator=(const LineSegmentBuilder &);
  flatbuffers::Offset<LineSegment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LineSegment>(end);
    return o;
  }
};

inline flatbuffers::Offset<LineSegment> CreateLineSegment(
    flatbuffers::FlatBufferBuilder &_fbb,
    const DSegment3d *segment = 0) {
  LineSegmentBuilder builder_(_fbb);
  builder_.add_segment(segment);
  return builder_.Finish();
}

struct LineString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LineStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4
  };
  const flatbuffers::Vector<double> *points() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
  bool has_points() const { return CheckField(VT_POINTS); }
};

struct LineStringBuilder {
  typedef LineString Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<double>> points) {
    fbb_.AddOffset(LineString::VT_POINTS, points);
  }
  explicit LineStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LineStringBuilder &operator=(const LineStringBuilder &);
  flatbuffers::Offset<LineString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LineString>(end);
    return o;
  }
};

inline flatbuffers::Offset<LineString> CreateLineString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> points = 0) {
  LineStringBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline flatbuffers::Offset<LineString> CreateLineStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVector<double>(*points) : 0;
  return CreateLineString(
      _fbb,
      points__);
}

struct PointString FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PointStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4
  };
  const flatbuffers::Vector<double> *points() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
  bool has_points() const { return CheckField(VT_POINTS); }
};

struct PointStringBuilder {
  typedef PointString Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<double>> points) {
    fbb_.AddOffset(PointString::VT_POINTS, points);
  }
  explicit PointStringBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PointStringBuilder &operator=(const PointStringBuilder &);
  flatbuffers::Offset<PointString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PointString>(end);
    return o;
  }
};

inline flatbuffers::Offset<PointString> CreatePointString(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> points = 0) {
  PointStringBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline flatbuffers::Offset<PointString> CreatePointStringDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVector<double>(*points) : 0;
  return CreatePointString(
      _fbb,
      points__);
}

struct EllipticArc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EllipticArcBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARC = 4
  };
  const DEllipse3d *arc() const {
    return GetStruct<const DEllipse3d *>(VT_ARC);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DEllipse3d>(verifier, VT_ARC) &&
           verifier.EndTable();
  }
  bool has_arc() const { return CheckField(VT_ARC); }
};

struct EllipticArcBuilder {
  typedef EllipticArc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_arc(const DEllipse3d *arc) {
    fbb_.AddStruct(EllipticArc::VT_ARC, arc);
  }
  explicit EllipticArcBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EllipticArcBuilder &operator=(const EllipticArcBuilder &);
  flatbuffers::Offset<EllipticArc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EllipticArc>(end);
    return o;
  }
};

inline flatbuffers::Offset<EllipticArc> CreateEllipticArc(
    flatbuffers::FlatBufferBuilder &_fbb,
    const DEllipse3d *arc = 0) {
  EllipticArcBuilder builder_(_fbb);
  builder_.add_arc(arc);
  return builder_.Finish();
}

struct BsplineCurve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BsplineCurveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER = 4,
    VT_CLOSED = 6,
    VT_POLES = 8,
    VT_WEIGHTS = 10,
    VT_KNOTS = 12
  };
  int32_t order() const {
    return GetField<int32_t>(VT_ORDER, 0);
  }
  bool closed() const {
    return GetField<uint8_t>(VT_CLOSED, 0) != 0;
  }
  const flatbuffers::Vector<double> *poles() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POLES);
  }
  const flatbuffers::Vector<double> *weights() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_WEIGHTS);
  }
  const flatbuffers::Vector<double> *knots() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_KNOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ORDER) &&
           VerifyField<uint8_t>(verifier, VT_CLOSED) &&
           VerifyOffset(verifier, VT_POLES) &&
           verifier.VerifyVector(poles()) &&
           VerifyOffset(verifier, VT_WEIGHTS) &&
           verifier.VerifyVector(weights()) &&
           VerifyOffset(verifier, VT_KNOTS) &&
           verifier.VerifyVector(knots()) &&
           verifier.EndTable();
  }
  bool has_order() const { return CheckField(VT_ORDER); }
  bool has_closed() const { return CheckField(VT_CLOSED); }
  bool has_poles() const { return CheckField(VT_POLES); }
  bool has_weights() const { return CheckField(VT_WEIGHTS); }
  bool has_knots() const { return CheckField(VT_KNOTS); }
};

struct BsplineCurveBuilder {
  typedef BsplineCurve Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_order(int32_t order) {
    fbb_.AddElement<int32_t>(BsplineCurve::VT_ORDER, order, 0);
  }
  void add_closed(bool closed) {
    fbb_.AddElement<uint8_t>(BsplineCurve::VT_CLOSED, static_cast<uint8_t>(closed), 0);
  }
  void add_poles(flatbuffers::Offset<flatbuffers::Vector<double>> poles) {
    fbb_.AddOffset(BsplineCurve::VT_POLES, poles);
  }
  void add_weights(flatbuffers::Offset<flatbuffers::Vector<double>> weights) {
    fbb_.AddOffset(BsplineCurve::VT_WEIGHTS, weights);
  }
  void add_knots(flatbuffers::Offset<flatbuffers::Vector<double>> knots) {
    fbb_.AddOffset(BsplineCurve::VT_KNOTS, knots);
  }
  explicit BsplineCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BsplineCurveBuilder &operator=(const BsplineCurveBuilder &);
  flatbuffers::Offset<BsplineCurve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BsplineCurve>(end);
    return o;
  }
};

inline flatbuffers::Offset<BsplineCurve> CreateBsplineCurve(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t order = 0,
    bool closed = false,
    flatbuffers::Offset<flatbuffers::Vector<double>> poles = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> weights = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> knots = 0) {
  BsplineCurveBuilder builder_(_fbb);
  builder_.add_knots(knots);
  builder_.add_weights(weights);
  builder_.add_poles(poles);
  builder_.add_order(order);
  builder_.add_closed(closed);
  return builder_.Finish();
}

inline flatbuffers::Offset<BsplineCurve> CreateBsplineCurveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t order = 0,
    bool closed = false,
    const std::vector<double> *poles = nullptr,
    const std::vector<double> *weights = nullptr,
    const std::vector<double> *knots = nullptr) {
  auto poles__ = poles ? _fbb.CreateVector<double>(*poles) : 0;
  auto weights__ = weights ? _fbb.CreateVector<double>(*weights) : 0;
  auto knots__ = knots ? _fbb.CreateVector<double>(*knots) : 0;
  return CreateBsplineCurve(
      _fbb,
      order,
      closed,
      poles__,
      weights__,
      knots__);
}

struct InterpolationCurve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InterpolationCurveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER = 4,
    VT_CLOSED = 6,
    VT_ISCHORDLENKNOTS = 8,
    VT_ISCOLINEARTANGENTS = 10,
    VT_ISCHORDLENTANGENTS = 12,
    VT_ISNATURALTANGENTS = 14,
    VT_STARTTANGENT = 16,
    VT_ENDTANGENT = 18,
    VT_FITPOINTS = 20,
    VT_KNOTS = 22
  };
  int32_t order() const {
    return GetField<int32_t>(VT_ORDER, 0);
  }
  bool closed() const {
    return GetField<uint8_t>(VT_CLOSED, 0) != 0;
  }
  int32_t isChordLenKnots() const {
    return GetField<int32_t>(VT_ISCHORDLENKNOTS, 0);
  }
  int32_t isColinearTangents() const {
    return GetField<int32_t>(VT_ISCOLINEARTANGENTS, 0);
  }
  int32_t isChordLenTangents() const {
    return GetField<int32_t>(VT_ISCHORDLENTANGENTS, 0);
  }
  int32_t isNaturalTangents() const {
    return GetField<int32_t>(VT_ISNATURALTANGENTS, 0);
  }
  const DPoint3d *startTangent() const {
    return GetStruct<const DPoint3d *>(VT_STARTTANGENT);
  }
  const DVector3d *endTangent() const {
    return GetStruct<const DVector3d *>(VT_ENDTANGENT);
  }
  const flatbuffers::Vector<double> *fitPoints() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_FITPOINTS);
  }
  const flatbuffers::Vector<double> *knots() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_KNOTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ORDER) &&
           VerifyField<uint8_t>(verifier, VT_CLOSED) &&
           VerifyField<int32_t>(verifier, VT_ISCHORDLENKNOTS) &&
           VerifyField<int32_t>(verifier, VT_ISCOLINEARTANGENTS) &&
           VerifyField<int32_t>(verifier, VT_ISCHORDLENTANGENTS) &&
           VerifyField<int32_t>(verifier, VT_ISNATURALTANGENTS) &&
           VerifyField<DPoint3d>(verifier, VT_STARTTANGENT) &&
           VerifyField<DVector3d>(verifier, VT_ENDTANGENT) &&
           VerifyOffset(verifier, VT_FITPOINTS) &&
           verifier.VerifyVector(fitPoints()) &&
           VerifyOffset(verifier, VT_KNOTS) &&
           verifier.VerifyVector(knots()) &&
           verifier.EndTable();
  }
  bool has_order() const { return CheckField(VT_ORDER); }
  bool has_closed() const { return CheckField(VT_CLOSED); }
  bool has_isChordLenKnots() const { return CheckField(VT_ISCHORDLENKNOTS); }
  bool has_isColinearTangents() const { return CheckField(VT_ISCOLINEARTANGENTS); }
  bool has_isChordLenTangents() const { return CheckField(VT_ISCHORDLENTANGENTS); }
  bool has_isNaturalTangents() const { return CheckField(VT_ISNATURALTANGENTS); }
  bool has_startTangent() const { return CheckField(VT_STARTTANGENT); }
  bool has_endTangent() const { return CheckField(VT_ENDTANGENT); }
  bool has_fitPoints() const { return CheckField(VT_FITPOINTS); }
  bool has_knots() const { return CheckField(VT_KNOTS); }
};

struct InterpolationCurveBuilder {
  typedef InterpolationCurve Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_order(int32_t order) {
    fbb_.AddElement<int32_t>(InterpolationCurve::VT_ORDER, order, 0);
  }
  void add_closed(bool closed) {
    fbb_.AddElement<uint8_t>(InterpolationCurve::VT_CLOSED, static_cast<uint8_t>(closed), 0);
  }
  void add_isChordLenKnots(int32_t isChordLenKnots) {
    fbb_.AddElement<int32_t>(InterpolationCurve::VT_ISCHORDLENKNOTS, isChordLenKnots, 0);
  }
  void add_isColinearTangents(int32_t isColinearTangents) {
    fbb_.AddElement<int32_t>(InterpolationCurve::VT_ISCOLINEARTANGENTS, isColinearTangents, 0);
  }
  void add_isChordLenTangents(int32_t isChordLenTangents) {
    fbb_.AddElement<int32_t>(InterpolationCurve::VT_ISCHORDLENTANGENTS, isChordLenTangents, 0);
  }
  void add_isNaturalTangents(int32_t isNaturalTangents) {
    fbb_.AddElement<int32_t>(InterpolationCurve::VT_ISNATURALTANGENTS, isNaturalTangents, 0);
  }
  void add_startTangent(const DPoint3d *startTangent) {
    fbb_.AddStruct(InterpolationCurve::VT_STARTTANGENT, startTangent);
  }
  void add_endTangent(const DVector3d *endTangent) {
    fbb_.AddStruct(InterpolationCurve::VT_ENDTANGENT, endTangent);
  }
  void add_fitPoints(flatbuffers::Offset<flatbuffers::Vector<double>> fitPoints) {
    fbb_.AddOffset(InterpolationCurve::VT_FITPOINTS, fitPoints);
  }
  void add_knots(flatbuffers::Offset<flatbuffers::Vector<double>> knots) {
    fbb_.AddOffset(InterpolationCurve::VT_KNOTS, knots);
  }
  explicit InterpolationCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InterpolationCurveBuilder &operator=(const InterpolationCurveBuilder &);
  flatbuffers::Offset<InterpolationCurve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InterpolationCurve>(end);
    return o;
  }
};

inline flatbuffers::Offset<InterpolationCurve> CreateInterpolationCurve(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t order = 0,
    bool closed = false,
    int32_t isChordLenKnots = 0,
    int32_t isColinearTangents = 0,
    int32_t isChordLenTangents = 0,
    int32_t isNaturalTangents = 0,
    const DPoint3d *startTangent = 0,
    const DVector3d *endTangent = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> fitPoints = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> knots = 0) {
  InterpolationCurveBuilder builder_(_fbb);
  builder_.add_knots(knots);
  builder_.add_fitPoints(fitPoints);
  builder_.add_endTangent(endTangent);
  builder_.add_startTangent(startTangent);
  builder_.add_isNaturalTangents(isNaturalTangents);
  builder_.add_isChordLenTangents(isChordLenTangents);
  builder_.add_isColinearTangents(isColinearTangents);
  builder_.add_isChordLenKnots(isChordLenKnots);
  builder_.add_order(order);
  builder_.add_closed(closed);
  return builder_.Finish();
}

inline flatbuffers::Offset<InterpolationCurve> CreateInterpolationCurveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t order = 0,
    bool closed = false,
    int32_t isChordLenKnots = 0,
    int32_t isColinearTangents = 0,
    int32_t isChordLenTangents = 0,
    int32_t isNaturalTangents = 0,
    const DPoint3d *startTangent = 0,
    const DVector3d *endTangent = 0,
    const std::vector<double> *fitPoints = nullptr,
    const std::vector<double> *knots = nullptr) {
  auto fitPoints__ = fitPoints ? _fbb.CreateVector<double>(*fitPoints) : 0;
  auto knots__ = knots ? _fbb.CreateVector<double>(*knots) : 0;
  return CreateInterpolationCurve(
      _fbb,
      order,
      closed,
      isChordLenKnots,
      isColinearTangents,
      isChordLenTangents,
      isNaturalTangents,
      startTangent,
      endTangent,
      fitPoints__,
      knots__);
}

struct AkimaCurve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AkimaCurveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINTS = 4
  };
  const flatbuffers::Vector<double> *points() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINTS) &&
           verifier.VerifyVector(points()) &&
           verifier.EndTable();
  }
  bool has_points() const { return CheckField(VT_POINTS); }
};

struct AkimaCurveBuilder {
  typedef AkimaCurve Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_points(flatbuffers::Offset<flatbuffers::Vector<double>> points) {
    fbb_.AddOffset(AkimaCurve::VT_POINTS, points);
  }
  explicit AkimaCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AkimaCurveBuilder &operator=(const AkimaCurveBuilder &);
  flatbuffers::Offset<AkimaCurve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AkimaCurve>(end);
    return o;
  }
};

inline flatbuffers::Offset<AkimaCurve> CreateAkimaCurve(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> points = 0) {
  AkimaCurveBuilder builder_(_fbb);
  builder_.add_points(points);
  return builder_.Finish();
}

inline flatbuffers::Offset<AkimaCurve> CreateAkimaCurveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *points = nullptr) {
  auto points__ = points ? _fbb.CreateVector<double>(*points) : 0;
  return CreateAkimaCurve(
      _fbb,
      points__);
}

struct CatenaryCurve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CatenaryCurveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_A = 4,
    VT_ORIGIN = 6,
    VT_VECTORU = 8,
    VT_VECTORV = 10,
    VT_X0 = 12,
    VT_X1 = 14
  };
  double a() const {
    return GetField<double>(VT_A, 0.0);
  }
  const DPoint3d *origin() const {
    return GetStruct<const DPoint3d *>(VT_ORIGIN);
  }
  const DVector3d *vectorU() const {
    return GetStruct<const DVector3d *>(VT_VECTORU);
  }
  const DVector3d *vectorV() const {
    return GetStruct<const DVector3d *>(VT_VECTORV);
  }
  double x0() const {
    return GetField<double>(VT_X0, 0.0);
  }
  double x1() const {
    return GetField<double>(VT_X1, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_A) &&
           VerifyField<DPoint3d>(verifier, VT_ORIGIN) &&
           VerifyField<DVector3d>(verifier, VT_VECTORU) &&
           VerifyField<DVector3d>(verifier, VT_VECTORV) &&
           VerifyField<double>(verifier, VT_X0) &&
           VerifyField<double>(verifier, VT_X1) &&
           verifier.EndTable();
  }
  bool has_a() const { return CheckField(VT_A); }
  bool has_origin() const { return CheckField(VT_ORIGIN); }
  bool has_vectorU() const { return CheckField(VT_VECTORU); }
  bool has_vectorV() const { return CheckField(VT_VECTORV); }
  bool has_x0() const { return CheckField(VT_X0); }
  bool has_x1() const { return CheckField(VT_X1); }
};

struct CatenaryCurveBuilder {
  typedef CatenaryCurve Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_a(double a) {
    fbb_.AddElement<double>(CatenaryCurve::VT_A, a, 0.0);
  }
  void add_origin(const DPoint3d *origin) {
    fbb_.AddStruct(CatenaryCurve::VT_ORIGIN, origin);
  }
  void add_vectorU(const DVector3d *vectorU) {
    fbb_.AddStruct(CatenaryCurve::VT_VECTORU, vectorU);
  }
  void add_vectorV(const DVector3d *vectorV) {
    fbb_.AddStruct(CatenaryCurve::VT_VECTORV, vectorV);
  }
  void add_x0(double x0) {
    fbb_.AddElement<double>(CatenaryCurve::VT_X0, x0, 0.0);
  }
  void add_x1(double x1) {
    fbb_.AddElement<double>(CatenaryCurve::VT_X1, x1, 0.0);
  }
  explicit CatenaryCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CatenaryCurveBuilder &operator=(const CatenaryCurveBuilder &);
  flatbuffers::Offset<CatenaryCurve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CatenaryCurve>(end);
    return o;
  }
};

inline flatbuffers::Offset<CatenaryCurve> CreateCatenaryCurve(
    flatbuffers::FlatBufferBuilder &_fbb,
    double a = 0.0,
    const DPoint3d *origin = 0,
    const DVector3d *vectorU = 0,
    const DVector3d *vectorV = 0,
    double x0 = 0.0,
    double x1 = 0.0) {
  CatenaryCurveBuilder builder_(_fbb);
  builder_.add_x1(x1);
  builder_.add_x0(x0);
  builder_.add_a(a);
  builder_.add_vectorV(vectorV);
  builder_.add_vectorU(vectorU);
  builder_.add_origin(origin);
  return builder_.Finish();
}

struct PartialCurve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartialCurveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRACTION0 = 4,
    VT_FRACTION1 = 6,
    VT_TARGET = 8
  };
  double fraction0() const {
    return GetField<double>(VT_FRACTION0, 0.0);
  }
  double fraction1() const {
    return GetField<double>(VT_FRACTION1, 0.0);
  }
  const VariantGeometry *target() const {
    return GetPointer<const VariantGeometry *>(VT_TARGET);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_FRACTION0) &&
           VerifyField<double>(verifier, VT_FRACTION1) &&
           VerifyOffset(verifier, VT_TARGET) &&
           verifier.VerifyTable(target()) &&
           verifier.EndTable();
  }
  bool has_fraction0() const { return CheckField(VT_FRACTION0); }
  bool has_fraction1() const { return CheckField(VT_FRACTION1); }
  bool has_target() const { return CheckField(VT_TARGET); }
};

struct PartialCurveBuilder {
  typedef PartialCurve Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fraction0(double fraction0) {
    fbb_.AddElement<double>(PartialCurve::VT_FRACTION0, fraction0, 0.0);
  }
  void add_fraction1(double fraction1) {
    fbb_.AddElement<double>(PartialCurve::VT_FRACTION1, fraction1, 0.0);
  }
  void add_target(flatbuffers::Offset<VariantGeometry> target) {
    fbb_.AddOffset(PartialCurve::VT_TARGET, target);
  }
  explicit PartialCurveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartialCurveBuilder &operator=(const PartialCurveBuilder &);
  flatbuffers::Offset<PartialCurve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartialCurve>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartialCurve> CreatePartialCurve(
    flatbuffers::FlatBufferBuilder &_fbb,
    double fraction0 = 0.0,
    double fraction1 = 0.0,
    flatbuffers::Offset<VariantGeometry> target = 0) {
  PartialCurveBuilder builder_(_fbb);
  builder_.add_fraction1(fraction1);
  builder_.add_fraction0(fraction0);
  builder_.add_target(target);
  return builder_.Finish();
}

struct CurvePrimitiveId FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurvePrimitiveIdBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_GEOMINDEX = 6,
    VT_PARTINDEX = 8,
    VT_BYTES = 10
  };
  int16_t type() const {
    return GetField<int16_t>(VT_TYPE, 0);
  }
  int16_t geomIndex() const {
    return GetField<int16_t>(VT_GEOMINDEX, 0);
  }
  int16_t partIndex() const {
    return GetField<int16_t>(VT_PARTINDEX, 0);
  }
  const flatbuffers::Vector<uint8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_TYPE) &&
           VerifyField<int16_t>(verifier, VT_GEOMINDEX) &&
           VerifyField<int16_t>(verifier, VT_PARTINDEX) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           verifier.EndTable();
  }
  bool has_type() const { return CheckField(VT_TYPE); }
  bool has_geomIndex() const { return CheckField(VT_GEOMINDEX); }
  bool has_partIndex() const { return CheckField(VT_PARTINDEX); }
  bool has_bytes() const { return CheckField(VT_BYTES); }
};

struct CurvePrimitiveIdBuilder {
  typedef CurvePrimitiveId Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int16_t type) {
    fbb_.AddElement<int16_t>(CurvePrimitiveId::VT_TYPE, type, 0);
  }
  void add_geomIndex(int16_t geomIndex) {
    fbb_.AddElement<int16_t>(CurvePrimitiveId::VT_GEOMINDEX, geomIndex, 0);
  }
  void add_partIndex(int16_t partIndex) {
    fbb_.AddElement<int16_t>(CurvePrimitiveId::VT_PARTINDEX, partIndex, 0);
  }
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) {
    fbb_.AddOffset(CurvePrimitiveId::VT_BYTES, bytes);
  }
  explicit CurvePrimitiveIdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurvePrimitiveIdBuilder &operator=(const CurvePrimitiveIdBuilder &);
  flatbuffers::Offset<CurvePrimitiveId> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CurvePrimitiveId>(end);
    return o;
  }
};

inline flatbuffers::Offset<CurvePrimitiveId> CreateCurvePrimitiveId(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int16_t geomIndex = 0,
    int16_t partIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0) {
  CurvePrimitiveIdBuilder builder_(_fbb);
  builder_.add_bytes(bytes);
  builder_.add_partIndex(partIndex);
  builder_.add_geomIndex(geomIndex);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CurvePrimitiveId> CreateCurvePrimitiveIdDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int16_t type = 0,
    int16_t geomIndex = 0,
    int16_t partIndex = 0,
    const std::vector<uint8_t> *bytes = nullptr) {
  auto bytes__ = bytes ? _fbb.CreateVector<uint8_t>(*bytes) : 0;
  return CreateCurvePrimitiveId(
      _fbb,
      type,
      geomIndex,
      partIndex,
      bytes__);
}

struct CurveVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CurveVectorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_CURVES = 6
  };
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>> *curves() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>> *>(VT_CURVES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_CURVES) &&
           verifier.VerifyVector(curves()) &&
           verifier.VerifyVectorOfTables(curves()) &&
           verifier.EndTable();
  }
  bool has_type() const { return CheckField(VT_TYPE); }
  bool has_curves() const { return CheckField(VT_CURVES); }
};

struct CurveVectorBuilder {
  typedef CurveVector Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(CurveVector::VT_TYPE, type, 0);
  }
  void add_curves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>>> curves) {
    fbb_.AddOffset(CurveVector::VT_CURVES, curves);
  }
  explicit CurveVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CurveVectorBuilder &operator=(const CurveVectorBuilder &);
  flatbuffers::Offset<CurveVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CurveVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<CurveVector> CreateCurveVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>>> curves = 0) {
  CurveVectorBuilder builder_(_fbb);
  builder_.add_curves(curves);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<CurveVector> CreateCurveVectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t type = 0,
    const std::vector<flatbuffers::Offset<VariantGeometry>> *curves = nullptr) {
  auto curves__ = curves ? _fbb.CreateVector<flatbuffers::Offset<VariantGeometry>>(*curves) : 0;
  return CreateCurveVector(
      _fbb,
      type,
      curves__);
}

struct VectorOfVariantGeometry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VectorOfVariantGeometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MEMBERS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>> *members() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>> *>(VT_MEMBERS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEMBERS) &&
           verifier.VerifyVector(members()) &&
           verifier.VerifyVectorOfTables(members()) &&
           verifier.EndTable();
  }
  bool has_members() const { return CheckField(VT_MEMBERS); }
};

struct VectorOfVariantGeometryBuilder {
  typedef VectorOfVariantGeometry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_members(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>>> members) {
    fbb_.AddOffset(VectorOfVariantGeometry::VT_MEMBERS, members);
  }
  explicit VectorOfVariantGeometryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorOfVariantGeometryBuilder &operator=(const VectorOfVariantGeometryBuilder &);
  flatbuffers::Offset<VectorOfVariantGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorOfVariantGeometry>(end);
    return o;
  }
};

inline flatbuffers::Offset<VectorOfVariantGeometry> CreateVectorOfVariantGeometry(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VariantGeometry>>> members = 0) {
  VectorOfVariantGeometryBuilder builder_(_fbb);
  builder_.add_members(members);
  return builder_.Finish();
}

inline flatbuffers::Offset<VectorOfVariantGeometry> CreateVectorOfVariantGeometryDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<VariantGeometry>> *members = nullptr) {
  auto members__ = members ? _fbb.CreateVector<flatbuffers::Offset<VariantGeometry>>(*members) : 0;
  return CreateVectorOfVariantGeometry(
      _fbb,
      members__);
}

struct BsplineSurface FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BsplineSurfaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POLES = 4,
    VT_WEIGHTS = 6,
    VT_KNOTSU = 8,
    VT_KNOTSV = 10,
    VT_NUMPOLESU = 12,
    VT_NUMPOLESV = 14,
    VT_ORDERU = 16,
    VT_ORDERV = 18,
    VT_NUMRULESU = 20,
    VT_NUMRULESV = 22,
    VT_HOLEORIGIN = 24,
    VT_BOUNDARIES = 26,
    VT_CLOSEDU = 28,
    VT_CLOSEDV = 30
  };
  const flatbuffers::Vector<double> *poles() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POLES);
  }
  const flatbuffers::Vector<double> *weights() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_WEIGHTS);
  }
  const flatbuffers::Vector<double> *knotsU() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_KNOTSU);
  }
  const flatbuffers::Vector<double> *knotsV() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_KNOTSV);
  }
  int32_t numPolesU() const {
    return GetField<int32_t>(VT_NUMPOLESU, 0);
  }
  int32_t numPolesV() const {
    return GetField<int32_t>(VT_NUMPOLESV, 0);
  }
  int32_t orderU() const {
    return GetField<int32_t>(VT_ORDERU, 0);
  }
  int32_t orderV() const {
    return GetField<int32_t>(VT_ORDERV, 0);
  }
  int32_t numRulesU() const {
    return GetField<int32_t>(VT_NUMRULESU, 0);
  }
  int32_t numRulesV() const {
    return GetField<int32_t>(VT_NUMRULESV, 0);
  }
  int32_t holeOrigin() const {
    return GetField<int32_t>(VT_HOLEORIGIN, 0);
  }
  const CurveVector *boundaries() const {
    return GetPointer<const CurveVector *>(VT_BOUNDARIES);
  }
  bool closedU() const {
    return GetField<uint8_t>(VT_CLOSEDU, 0) != 0;
  }
  bool closedV() const {
    return GetField<uint8_t>(VT_CLOSEDV, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POLES) &&
           verifier.VerifyVector(poles()) &&
           VerifyOffset(verifier, VT_WEIGHTS) &&
           verifier.VerifyVector(weights()) &&
           VerifyOffset(verifier, VT_KNOTSU) &&
           verifier.VerifyVector(knotsU()) &&
           VerifyOffset(verifier, VT_KNOTSV) &&
           verifier.VerifyVector(knotsV()) &&
           VerifyField<int32_t>(verifier, VT_NUMPOLESU) &&
           VerifyField<int32_t>(verifier, VT_NUMPOLESV) &&
           VerifyField<int32_t>(verifier, VT_ORDERU) &&
           VerifyField<int32_t>(verifier, VT_ORDERV) &&
           VerifyField<int32_t>(verifier, VT_NUMRULESU) &&
           VerifyField<int32_t>(verifier, VT_NUMRULESV) &&
           VerifyField<int32_t>(verifier, VT_HOLEORIGIN) &&
           VerifyOffset(verifier, VT_BOUNDARIES) &&
           verifier.VerifyTable(boundaries()) &&
           VerifyField<uint8_t>(verifier, VT_CLOSEDU) &&
           VerifyField<uint8_t>(verifier, VT_CLOSEDV) &&
           verifier.EndTable();
  }
  bool has_poles() const { return CheckField(VT_POLES); }
  bool has_weights() const { return CheckField(VT_WEIGHTS); }
  bool has_knotsU() const { return CheckField(VT_KNOTSU); }
  bool has_knotsV() const { return CheckField(VT_KNOTSV); }
  bool has_numPolesU() const { return CheckField(VT_NUMPOLESU); }
  bool has_numPolesV() const { return CheckField(VT_NUMPOLESV); }
  bool has_orderU() const { return CheckField(VT_ORDERU); }
  bool has_orderV() const { return CheckField(VT_ORDERV); }
  bool has_numRulesU() const { return CheckField(VT_NUMRULESU); }
  bool has_numRulesV() const { return CheckField(VT_NUMRULESV); }
  bool has_holeOrigin() const { return CheckField(VT_HOLEORIGIN); }
  bool has_boundaries() const { return CheckField(VT_BOUNDARIES); }
  bool has_closedU() const { return CheckField(VT_CLOSEDU); }
  bool has_closedV() const { return CheckField(VT_CLOSEDV); }
};

struct BsplineSurfaceBuilder {
  typedef BsplineSurface Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_poles(flatbuffers::Offset<flatbuffers::Vector<double>> poles) {
    fbb_.AddOffset(BsplineSurface::VT_POLES, poles);
  }
  void add_weights(flatbuffers::Offset<flatbuffers::Vector<double>> weights) {
    fbb_.AddOffset(BsplineSurface::VT_WEIGHTS, weights);
  }
  void add_knotsU(flatbuffers::Offset<flatbuffers::Vector<double>> knotsU) {
    fbb_.AddOffset(BsplineSurface::VT_KNOTSU, knotsU);
  }
  void add_knotsV(flatbuffers::Offset<flatbuffers::Vector<double>> knotsV) {
    fbb_.AddOffset(BsplineSurface::VT_KNOTSV, knotsV);
  }
  void add_numPolesU(int32_t numPolesU) {
    fbb_.AddElement<int32_t>(BsplineSurface::VT_NUMPOLESU, numPolesU, 0);
  }
  void add_numPolesV(int32_t numPolesV) {
    fbb_.AddElement<int32_t>(BsplineSurface::VT_NUMPOLESV, numPolesV, 0);
  }
  void add_orderU(int32_t orderU) {
    fbb_.AddElement<int32_t>(BsplineSurface::VT_ORDERU, orderU, 0);
  }
  void add_orderV(int32_t orderV) {
    fbb_.AddElement<int32_t>(BsplineSurface::VT_ORDERV, orderV, 0);
  }
  void add_numRulesU(int32_t numRulesU) {
    fbb_.AddElement<int32_t>(BsplineSurface::VT_NUMRULESU, numRulesU, 0);
  }
  void add_numRulesV(int32_t numRulesV) {
    fbb_.AddElement<int32_t>(BsplineSurface::VT_NUMRULESV, numRulesV, 0);
  }
  void add_holeOrigin(int32_t holeOrigin) {
    fbb_.AddElement<int32_t>(BsplineSurface::VT_HOLEORIGIN, holeOrigin, 0);
  }
  void add_boundaries(flatbuffers::Offset<CurveVector> boundaries) {
    fbb_.AddOffset(BsplineSurface::VT_BOUNDARIES, boundaries);
  }
  void add_closedU(bool closedU) {
    fbb_.AddElement<uint8_t>(BsplineSurface::VT_CLOSEDU, static_cast<uint8_t>(closedU), 0);
  }
  void add_closedV(bool closedV) {
    fbb_.AddElement<uint8_t>(BsplineSurface::VT_CLOSEDV, static_cast<uint8_t>(closedV), 0);
  }
  explicit BsplineSurfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BsplineSurfaceBuilder &operator=(const BsplineSurfaceBuilder &);
  flatbuffers::Offset<BsplineSurface> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BsplineSurface>(end);
    return o;
  }
};

inline flatbuffers::Offset<BsplineSurface> CreateBsplineSurface(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> poles = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> weights = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> knotsU = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> knotsV = 0,
    int32_t numPolesU = 0,
    int32_t numPolesV = 0,
    int32_t orderU = 0,
    int32_t orderV = 0,
    int32_t numRulesU = 0,
    int32_t numRulesV = 0,
    int32_t holeOrigin = 0,
    flatbuffers::Offset<CurveVector> boundaries = 0,
    bool closedU = false,
    bool closedV = false) {
  BsplineSurfaceBuilder builder_(_fbb);
  builder_.add_boundaries(boundaries);
  builder_.add_holeOrigin(holeOrigin);
  builder_.add_numRulesV(numRulesV);
  builder_.add_numRulesU(numRulesU);
  builder_.add_orderV(orderV);
  builder_.add_orderU(orderU);
  builder_.add_numPolesV(numPolesV);
  builder_.add_numPolesU(numPolesU);
  builder_.add_knotsV(knotsV);
  builder_.add_knotsU(knotsU);
  builder_.add_weights(weights);
  builder_.add_poles(poles);
  builder_.add_closedV(closedV);
  builder_.add_closedU(closedU);
  return builder_.Finish();
}

inline flatbuffers::Offset<BsplineSurface> CreateBsplineSurfaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *poles = nullptr,
    const std::vector<double> *weights = nullptr,
    const std::vector<double> *knotsU = nullptr,
    const std::vector<double> *knotsV = nullptr,
    int32_t numPolesU = 0,
    int32_t numPolesV = 0,
    int32_t orderU = 0,
    int32_t orderV = 0,
    int32_t numRulesU = 0,
    int32_t numRulesV = 0,
    int32_t holeOrigin = 0,
    flatbuffers::Offset<CurveVector> boundaries = 0,
    bool closedU = false,
    bool closedV = false) {
  auto poles__ = poles ? _fbb.CreateVector<double>(*poles) : 0;
  auto weights__ = weights ? _fbb.CreateVector<double>(*weights) : 0;
  auto knotsU__ = knotsU ? _fbb.CreateVector<double>(*knotsU) : 0;
  auto knotsV__ = knotsV ? _fbb.CreateVector<double>(*knotsV) : 0;
  return CreateBsplineSurface(
      _fbb,
      poles__,
      weights__,
      knotsU__,
      knotsV__,
      numPolesU,
      numPolesV,
      orderU,
      orderV,
      numRulesU,
      numRulesV,
      holeOrigin,
      boundaries,
      closedU,
      closedV);
}

struct DgnBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DgnBoxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DETAIL = 4
  };
  const DgnBoxDetail *detail() const {
    return GetStruct<const DgnBoxDetail *>(VT_DETAIL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DgnBoxDetail>(verifier, VT_DETAIL) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(VT_DETAIL); }
};

struct DgnBoxBuilder {
  typedef DgnBox Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const DgnBoxDetail *detail) {
    fbb_.AddStruct(DgnBox::VT_DETAIL, detail);
  }
  explicit DgnBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DgnBoxBuilder &operator=(const DgnBoxBuilder &);
  flatbuffers::Offset<DgnBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DgnBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<DgnBox> CreateDgnBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    const DgnBoxDetail *detail = 0) {
  DgnBoxBuilder builder_(_fbb);
  builder_.add_detail(detail);
  return builder_.Finish();
}

struct DgnSphere FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DgnSphereBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DETAIL = 4
  };
  const DgnSphereDetail *detail() const {
    return GetStruct<const DgnSphereDetail *>(VT_DETAIL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DgnSphereDetail>(verifier, VT_DETAIL) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(VT_DETAIL); }
};

struct DgnSphereBuilder {
  typedef DgnSphere Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const DgnSphereDetail *detail) {
    fbb_.AddStruct(DgnSphere::VT_DETAIL, detail);
  }
  explicit DgnSphereBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DgnSphereBuilder &operator=(const DgnSphereBuilder &);
  flatbuffers::Offset<DgnSphere> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DgnSphere>(end);
    return o;
  }
};

inline flatbuffers::Offset<DgnSphere> CreateDgnSphere(
    flatbuffers::FlatBufferBuilder &_fbb,
    const DgnSphereDetail *detail = 0) {
  DgnSphereBuilder builder_(_fbb);
  builder_.add_detail(detail);
  return builder_.Finish();
}

struct DgnCone FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DgnConeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DETAIL = 4
  };
  const DgnConeDetail *detail() const {
    return GetStruct<const DgnConeDetail *>(VT_DETAIL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DgnConeDetail>(verifier, VT_DETAIL) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(VT_DETAIL); }
};

struct DgnConeBuilder {
  typedef DgnCone Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const DgnConeDetail *detail) {
    fbb_.AddStruct(DgnCone::VT_DETAIL, detail);
  }
  explicit DgnConeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DgnConeBuilder &operator=(const DgnConeBuilder &);
  flatbuffers::Offset<DgnCone> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DgnCone>(end);
    return o;
  }
};

inline flatbuffers::Offset<DgnCone> CreateDgnCone(
    flatbuffers::FlatBufferBuilder &_fbb,
    const DgnConeDetail *detail = 0) {
  DgnConeBuilder builder_(_fbb);
  builder_.add_detail(detail);
  return builder_.Finish();
}

struct DgnTorusPipe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DgnTorusPipeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DETAIL = 4
  };
  const DgnTorusPipeDetail *detail() const {
    return GetStruct<const DgnTorusPipeDetail *>(VT_DETAIL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DgnTorusPipeDetail>(verifier, VT_DETAIL) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(VT_DETAIL); }
};

struct DgnTorusPipeBuilder {
  typedef DgnTorusPipe Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const DgnTorusPipeDetail *detail) {
    fbb_.AddStruct(DgnTorusPipe::VT_DETAIL, detail);
  }
  explicit DgnTorusPipeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DgnTorusPipeBuilder &operator=(const DgnTorusPipeBuilder &);
  flatbuffers::Offset<DgnTorusPipe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DgnTorusPipe>(end);
    return o;
  }
};

inline flatbuffers::Offset<DgnTorusPipe> CreateDgnTorusPipe(
    flatbuffers::FlatBufferBuilder &_fbb,
    const DgnTorusPipeDetail *detail = 0) {
  DgnTorusPipeBuilder builder_(_fbb);
  builder_.add_detail(detail);
  return builder_.Finish();
}

struct DgnExtrusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DgnExtrusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASECURVE = 4,
    VT_EXTRUSIONVECTOR = 6,
    VT_CAPPED = 8
  };
  const CurveVector *baseCurve() const {
    return GetPointer<const CurveVector *>(VT_BASECURVE);
  }
  const DVector3d *extrusionVector() const {
    return GetStruct<const DVector3d *>(VT_EXTRUSIONVECTOR);
  }
  bool capped() const {
    return GetField<uint8_t>(VT_CAPPED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASECURVE) &&
           verifier.VerifyTable(baseCurve()) &&
           VerifyField<DVector3d>(verifier, VT_EXTRUSIONVECTOR) &&
           VerifyField<uint8_t>(verifier, VT_CAPPED) &&
           verifier.EndTable();
  }
  bool has_baseCurve() const { return CheckField(VT_BASECURVE); }
  bool has_extrusionVector() const { return CheckField(VT_EXTRUSIONVECTOR); }
  bool has_capped() const { return CheckField(VT_CAPPED); }
};

struct DgnExtrusionBuilder {
  typedef DgnExtrusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_baseCurve(flatbuffers::Offset<CurveVector> baseCurve) {
    fbb_.AddOffset(DgnExtrusion::VT_BASECURVE, baseCurve);
  }
  void add_extrusionVector(const DVector3d *extrusionVector) {
    fbb_.AddStruct(DgnExtrusion::VT_EXTRUSIONVECTOR, extrusionVector);
  }
  void add_capped(bool capped) {
    fbb_.AddElement<uint8_t>(DgnExtrusion::VT_CAPPED, static_cast<uint8_t>(capped), 0);
  }
  explicit DgnExtrusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DgnExtrusionBuilder &operator=(const DgnExtrusionBuilder &);
  flatbuffers::Offset<DgnExtrusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DgnExtrusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<DgnExtrusion> CreateDgnExtrusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<CurveVector> baseCurve = 0,
    const DVector3d *extrusionVector = 0,
    bool capped = false) {
  DgnExtrusionBuilder builder_(_fbb);
  builder_.add_extrusionVector(extrusionVector);
  builder_.add_baseCurve(baseCurve);
  builder_.add_capped(capped);
  return builder_.Finish();
}

struct DgnRotationalSweep FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DgnRotationalSweepBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASECURVE = 4,
    VT_AXIS = 6,
    VT_SWEEPRADIANS = 8,
    VT_NUMVRULES = 10,
    VT_CAPPED = 12
  };
  const CurveVector *baseCurve() const {
    return GetPointer<const CurveVector *>(VT_BASECURVE);
  }
  const DRay3d *axis() const {
    return GetStruct<const DRay3d *>(VT_AXIS);
  }
  double sweepRadians() const {
    return GetField<double>(VT_SWEEPRADIANS, 0.0);
  }
  int32_t numVRules() const {
    return GetField<int32_t>(VT_NUMVRULES, 0);
  }
  bool capped() const {
    return GetField<uint8_t>(VT_CAPPED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BASECURVE) &&
           verifier.VerifyTable(baseCurve()) &&
           VerifyField<DRay3d>(verifier, VT_AXIS) &&
           VerifyField<double>(verifier, VT_SWEEPRADIANS) &&
           VerifyField<int32_t>(verifier, VT_NUMVRULES) &&
           VerifyField<uint8_t>(verifier, VT_CAPPED) &&
           verifier.EndTable();
  }
  bool has_baseCurve() const { return CheckField(VT_BASECURVE); }
  bool has_axis() const { return CheckField(VT_AXIS); }
  bool has_sweepRadians() const { return CheckField(VT_SWEEPRADIANS); }
  bool has_numVRules() const { return CheckField(VT_NUMVRULES); }
  bool has_capped() const { return CheckField(VT_CAPPED); }
};

struct DgnRotationalSweepBuilder {
  typedef DgnRotationalSweep Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_baseCurve(flatbuffers::Offset<CurveVector> baseCurve) {
    fbb_.AddOffset(DgnRotationalSweep::VT_BASECURVE, baseCurve);
  }
  void add_axis(const DRay3d *axis) {
    fbb_.AddStruct(DgnRotationalSweep::VT_AXIS, axis);
  }
  void add_sweepRadians(double sweepRadians) {
    fbb_.AddElement<double>(DgnRotationalSweep::VT_SWEEPRADIANS, sweepRadians, 0.0);
  }
  void add_numVRules(int32_t numVRules) {
    fbb_.AddElement<int32_t>(DgnRotationalSweep::VT_NUMVRULES, numVRules, 0);
  }
  void add_capped(bool capped) {
    fbb_.AddElement<uint8_t>(DgnRotationalSweep::VT_CAPPED, static_cast<uint8_t>(capped), 0);
  }
  explicit DgnRotationalSweepBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DgnRotationalSweepBuilder &operator=(const DgnRotationalSweepBuilder &);
  flatbuffers::Offset<DgnRotationalSweep> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DgnRotationalSweep>(end);
    return o;
  }
};

inline flatbuffers::Offset<DgnRotationalSweep> CreateDgnRotationalSweep(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<CurveVector> baseCurve = 0,
    const DRay3d *axis = 0,
    double sweepRadians = 0.0,
    int32_t numVRules = 0,
    bool capped = false) {
  DgnRotationalSweepBuilder builder_(_fbb);
  builder_.add_sweepRadians(sweepRadians);
  builder_.add_numVRules(numVRules);
  builder_.add_axis(axis);
  builder_.add_baseCurve(baseCurve);
  builder_.add_capped(capped);
  return builder_.Finish();
}

struct DgnRuledSweep FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DgnRuledSweepBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CURVES = 4,
    VT_CAPPED = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<CurveVector>> *curves() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CurveVector>> *>(VT_CURVES);
  }
  bool capped() const {
    return GetField<uint8_t>(VT_CAPPED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURVES) &&
           verifier.VerifyVector(curves()) &&
           verifier.VerifyVectorOfTables(curves()) &&
           VerifyField<uint8_t>(verifier, VT_CAPPED) &&
           verifier.EndTable();
  }
  bool has_curves() const { return CheckField(VT_CURVES); }
  bool has_capped() const { return CheckField(VT_CAPPED); }
};

struct DgnRuledSweepBuilder {
  typedef DgnRuledSweep Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_curves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CurveVector>>> curves) {
    fbb_.AddOffset(DgnRuledSweep::VT_CURVES, curves);
  }
  void add_capped(bool capped) {
    fbb_.AddElement<uint8_t>(DgnRuledSweep::VT_CAPPED, static_cast<uint8_t>(capped), 0);
  }
  explicit DgnRuledSweepBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DgnRuledSweepBuilder &operator=(const DgnRuledSweepBuilder &);
  flatbuffers::Offset<DgnRuledSweep> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DgnRuledSweep>(end);
    return o;
  }
};

inline flatbuffers::Offset<DgnRuledSweep> CreateDgnRuledSweep(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CurveVector>>> curves = 0,
    bool capped = false) {
  DgnRuledSweepBuilder builder_(_fbb);
  builder_.add_curves(curves);
  builder_.add_capped(capped);
  return builder_.Finish();
}

inline flatbuffers::Offset<DgnRuledSweep> CreateDgnRuledSweepDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<CurveVector>> *curves = nullptr,
    bool capped = false) {
  auto curves__ = curves ? _fbb.CreateVector<flatbuffers::Offset<CurveVector>>(*curves) : 0;
  return CreateDgnRuledSweep(
      _fbb,
      curves__,
      capped);
}

struct PolyfaceAuxChannelData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolyfaceAuxChannelDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT = 4,
    VT_VALUES = 6
  };
  double input() const {
    return GetField<double>(VT_INPUT, 0.0);
  }
  const flatbuffers::Vector<double> *values() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_INPUT) &&
           VerifyOffset(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
  bool has_input() const { return CheckField(VT_INPUT); }
  bool has_values() const { return CheckField(VT_VALUES); }
};

struct PolyfaceAuxChannelDataBuilder {
  typedef PolyfaceAuxChannelData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input(double input) {
    fbb_.AddElement<double>(PolyfaceAuxChannelData::VT_INPUT, input, 0.0);
  }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<double>> values) {
    fbb_.AddOffset(PolyfaceAuxChannelData::VT_VALUES, values);
  }
  explicit PolyfaceAuxChannelDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PolyfaceAuxChannelDataBuilder &operator=(const PolyfaceAuxChannelDataBuilder &);
  flatbuffers::Offset<PolyfaceAuxChannelData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PolyfaceAuxChannelData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PolyfaceAuxChannelData> CreatePolyfaceAuxChannelData(
    flatbuffers::FlatBufferBuilder &_fbb,
    double input = 0.0,
    flatbuffers::Offset<flatbuffers::Vector<double>> values = 0) {
  PolyfaceAuxChannelDataBuilder builder_(_fbb);
  builder_.add_input(input);
  builder_.add_values(values);
  return builder_.Finish();
}

inline flatbuffers::Offset<PolyfaceAuxChannelData> CreatePolyfaceAuxChannelDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    double input = 0.0,
    const std::vector<double> *values = nullptr) {
  auto values__ = values ? _fbb.CreateVector<double>(*values) : 0;
  return CreatePolyfaceAuxChannelData(
      _fbb,
      input,
      values__);
}

struct PolyfaceAuxChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolyfaceAuxChannelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATATYPE = 4,
    VT_NAME = 6,
    VT_INPUTNAME = 8,
    VT_DATA = 10
  };
  int32_t dataType() const {
    return GetField<int32_t>(VT_DATATYPE, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *inputName() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUTNAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannelData>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannelData>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTNAME) &&
           verifier.VerifyString(inputName()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
  bool has_dataType() const { return CheckField(VT_DATATYPE); }
  bool has_name() const { return CheckField(VT_NAME); }
  bool has_inputName() const { return CheckField(VT_INPUTNAME); }
  bool has_data() const { return CheckField(VT_DATA); }
};

struct PolyfaceAuxChannelBuilder {
  typedef PolyfaceAuxChannel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataType(int32_t dataType) {
    fbb_.AddElement<int32_t>(PolyfaceAuxChannel::VT_DATATYPE, dataType, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(PolyfaceAuxChannel::VT_NAME, name);
  }
  void add_inputName(flatbuffers::Offset<flatbuffers::String> inputName) {
    fbb_.AddOffset(PolyfaceAuxChannel::VT_INPUTNAME, inputName);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannelData>>> data) {
    fbb_.AddOffset(PolyfaceAuxChannel::VT_DATA, data);
  }
  explicit PolyfaceAuxChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PolyfaceAuxChannelBuilder &operator=(const PolyfaceAuxChannelBuilder &);
  flatbuffers::Offset<PolyfaceAuxChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PolyfaceAuxChannel>(end);
    return o;
  }
};

inline flatbuffers::Offset<PolyfaceAuxChannel> CreatePolyfaceAuxChannel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dataType = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> inputName = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannelData>>> data = 0) {
  PolyfaceAuxChannelBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_inputName(inputName);
  builder_.add_name(name);
  builder_.add_dataType(dataType);
  return builder_.Finish();
}

inline flatbuffers::Offset<PolyfaceAuxChannel> CreatePolyfaceAuxChannelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dataType = 0,
    const char *name = nullptr,
    const char *inputName = nullptr,
    const std::vector<flatbuffers::Offset<PolyfaceAuxChannelData>> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputName__ = inputName ? _fbb.CreateString(inputName) : 0;
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<PolyfaceAuxChannelData>>(*data) : 0;
  return CreatePolyfaceAuxChannel(
      _fbb,
      dataType,
      name__,
      inputName__,
      data__);
}

struct PolyfaceAuxData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolyfaceAuxDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDICES = 4,
    VT_CHANNELS = 6
  };
  const flatbuffers::Vector<int32_t> *indices() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INDICES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannel>> *channels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannel>> *>(VT_CHANNELS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.VerifyVector(indices()) &&
           VerifyOffset(verifier, VT_CHANNELS) &&
           verifier.VerifyVector(channels()) &&
           verifier.VerifyVectorOfTables(channels()) &&
           verifier.EndTable();
  }
  bool has_indices() const { return CheckField(VT_INDICES); }
  bool has_channels() const { return CheckField(VT_CHANNELS); }
};

struct PolyfaceAuxDataBuilder {
  typedef PolyfaceAuxData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<int32_t>> indices) {
    fbb_.AddOffset(PolyfaceAuxData::VT_INDICES, indices);
  }
  void add_channels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannel>>> channels) {
    fbb_.AddOffset(PolyfaceAuxData::VT_CHANNELS, channels);
  }
  explicit PolyfaceAuxDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PolyfaceAuxDataBuilder &operator=(const PolyfaceAuxDataBuilder &);
  flatbuffers::Offset<PolyfaceAuxData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PolyfaceAuxData>(end);
    return o;
  }
};

inline flatbuffers::Offset<PolyfaceAuxData> CreatePolyfaceAuxData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> indices = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PolyfaceAuxChannel>>> channels = 0) {
  PolyfaceAuxDataBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_indices(indices);
  return builder_.Finish();
}

inline flatbuffers::Offset<PolyfaceAuxData> CreatePolyfaceAuxDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *indices = nullptr,
    const std::vector<flatbuffers::Offset<PolyfaceAuxChannel>> *channels = nullptr) {
  auto indices__ = indices ? _fbb.CreateVector<int32_t>(*indices) : 0;
  auto channels__ = channels ? _fbb.CreateVector<flatbuffers::Offset<PolyfaceAuxChannel>>(*channels) : 0;
  return CreatePolyfaceAuxData(
      _fbb,
      indices__,
      channels__);
}

struct TaggedNumericData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TaggedNumericDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TAGA = 4,
    VT_TAGB = 6,
    VT_INTDATA = 8,
    VT_DOUBLEDATA = 10
  };
  int32_t tagA() const {
    return GetField<int32_t>(VT_TAGA, 0);
  }
  int32_t tagB() const {
    return GetField<int32_t>(VT_TAGB, 0);
  }
  const flatbuffers::Vector<int32_t> *intData() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTDATA);
  }
  const flatbuffers::Vector<double> *doubleData() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DOUBLEDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TAGA) &&
           VerifyField<int32_t>(verifier, VT_TAGB) &&
           VerifyOffset(verifier, VT_INTDATA) &&
           verifier.VerifyVector(intData()) &&
           VerifyOffset(verifier, VT_DOUBLEDATA) &&
           verifier.VerifyVector(doubleData()) &&
           verifier.EndTable();
  }
  bool has_tagA() const { return CheckField(VT_TAGA); }
  bool has_tagB() const { return CheckField(VT_TAGB); }
  bool has_intData() const { return CheckField(VT_INTDATA); }
  bool has_doubleData() const { return CheckField(VT_DOUBLEDATA); }
};

struct TaggedNumericDataBuilder {
  typedef TaggedNumericData Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tagA(int32_t tagA) {
    fbb_.AddElement<int32_t>(TaggedNumericData::VT_TAGA, tagA, 0);
  }
  void add_tagB(int32_t tagB) {
    fbb_.AddElement<int32_t>(TaggedNumericData::VT_TAGB, tagB, 0);
  }
  void add_intData(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intData) {
    fbb_.AddOffset(TaggedNumericData::VT_INTDATA, intData);
  }
  void add_doubleData(flatbuffers::Offset<flatbuffers::Vector<double>> doubleData) {
    fbb_.AddOffset(TaggedNumericData::VT_DOUBLEDATA, doubleData);
  }
  explicit TaggedNumericDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TaggedNumericDataBuilder &operator=(const TaggedNumericDataBuilder &);
  flatbuffers::Offset<TaggedNumericData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaggedNumericData>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaggedNumericData> CreateTaggedNumericData(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tagA = 0,
    int32_t tagB = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> intData = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> doubleData = 0) {
  TaggedNumericDataBuilder builder_(_fbb);
  builder_.add_doubleData(doubleData);
  builder_.add_intData(intData);
  builder_.add_tagB(tagB);
  builder_.add_tagA(tagA);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaggedNumericData> CreateTaggedNumericDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tagA = 0,
    int32_t tagB = 0,
    const std::vector<int32_t> *intData = nullptr,
    const std::vector<double> *doubleData = nullptr) {
  auto intData__ = intData ? _fbb.CreateVector<int32_t>(*intData) : 0;
  auto doubleData__ = doubleData ? _fbb.CreateVector<double>(*doubleData) : 0;
  return CreateTaggedNumericData(
      _fbb,
      tagA,
      tagB,
      intData__,
      doubleData__);
}

struct Polyface FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PolyfaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POINT = 4,
    VT_PARAM = 6,
    VT_NORMAL = 8,
    VT_DOUBLECOLOR = 10,
    VT_INTCOLOR = 12,
    VT_POINTINDEX = 14,
    VT_PARAMINDEX = 16,
    VT_NORMALINDEX = 18,
    VT_COLORINDEX = 20,
    VT_COLORTABLE = 22,
    VT_NUMPERFACE = 24,
    VT_NUMPERROW = 26,
    VT_MESHSTYLE = 28,
    VT_TWOSIDED = 30,
    VT_FACEINDEX = 32,
    VT_FACEDATA = 34,
    VT_AUXDATA = 36,
    VT_EXPECTEDCLOSURE = 38,
    VT_TAGGEDNUMERICDATA = 40
  };
  const flatbuffers::Vector<double> *point() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_POINT);
  }
  const flatbuffers::Vector<double> *param() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_PARAM);
  }
  const flatbuffers::Vector<double> *normal() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_NORMAL);
  }
  const flatbuffers::Vector<double> *doubleColor() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DOUBLECOLOR);
  }
  const flatbuffers::Vector<int32_t> *intColor() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INTCOLOR);
  }
  const flatbuffers::Vector<int32_t> *pointIndex() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_POINTINDEX);
  }
  const flatbuffers::Vector<int32_t> *paramIndex() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PARAMINDEX);
  }
  const flatbuffers::Vector<int32_t> *normalIndex() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NORMALINDEX);
  }
  const flatbuffers::Vector<int32_t> *colorIndex() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_COLORINDEX);
  }
  const flatbuffers::Vector<int32_t> *colorTable() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_COLORTABLE);
  }
  int32_t numPerFace() const {
    return GetField<int32_t>(VT_NUMPERFACE, 0);
  }
  int32_t numPerRow() const {
    return GetField<int32_t>(VT_NUMPERROW, 0);
  }
  int32_t meshStyle() const {
    return GetField<int32_t>(VT_MESHSTYLE, 0);
  }
  bool twoSided() const {
    return GetField<uint8_t>(VT_TWOSIDED, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *faceIndex() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FACEINDEX);
  }
  const flatbuffers::Vector<double> *faceData() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_FACEDATA);
  }
  const PolyfaceAuxData *auxData() const {
    return GetPointer<const PolyfaceAuxData *>(VT_AUXDATA);
  }
  int32_t expectedClosure() const {
    return GetField<int32_t>(VT_EXPECTEDCLOSURE, 0);
  }
  const TaggedNumericData *taggedNumericData() const {
    return GetPointer<const TaggedNumericData *>(VT_TAGGEDNUMERICDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_POINT) &&
           verifier.VerifyVector(point()) &&
           VerifyOffset(verifier, VT_PARAM) &&
           verifier.VerifyVector(param()) &&
           VerifyOffset(verifier, VT_NORMAL) &&
           verifier.VerifyVector(normal()) &&
           VerifyOffset(verifier, VT_DOUBLECOLOR) &&
           verifier.VerifyVector(doubleColor()) &&
           VerifyOffset(verifier, VT_INTCOLOR) &&
           verifier.VerifyVector(intColor()) &&
           VerifyOffset(verifier, VT_POINTINDEX) &&
           verifier.VerifyVector(pointIndex()) &&
           VerifyOffset(verifier, VT_PARAMINDEX) &&
           verifier.VerifyVector(paramIndex()) &&
           VerifyOffset(verifier, VT_NORMALINDEX) &&
           verifier.VerifyVector(normalIndex()) &&
           VerifyOffset(verifier, VT_COLORINDEX) &&
           verifier.VerifyVector(colorIndex()) &&
           VerifyOffset(verifier, VT_COLORTABLE) &&
           verifier.VerifyVector(colorTable()) &&
           VerifyField<int32_t>(verifier, VT_NUMPERFACE) &&
           VerifyField<int32_t>(verifier, VT_NUMPERROW) &&
           VerifyField<int32_t>(verifier, VT_MESHSTYLE) &&
           VerifyField<uint8_t>(verifier, VT_TWOSIDED) &&
           VerifyOffset(verifier, VT_FACEINDEX) &&
           verifier.VerifyVector(faceIndex()) &&
           VerifyOffset(verifier, VT_FACEDATA) &&
           verifier.VerifyVector(faceData()) &&
           VerifyOffset(verifier, VT_AUXDATA) &&
           verifier.VerifyTable(auxData()) &&
           VerifyField<int32_t>(verifier, VT_EXPECTEDCLOSURE) &&
           VerifyOffset(verifier, VT_TAGGEDNUMERICDATA) &&
           verifier.VerifyTable(taggedNumericData()) &&
           verifier.EndTable();
  }
  bool has_point() const { return CheckField(VT_POINT); }
  bool has_param() const { return CheckField(VT_PARAM); }
  bool has_normal() const { return CheckField(VT_NORMAL); }
  bool has_doubleColor() const { return CheckField(VT_DOUBLECOLOR); }
  bool has_intColor() const { return CheckField(VT_INTCOLOR); }
  bool has_pointIndex() const { return CheckField(VT_POINTINDEX); }
  bool has_paramIndex() const { return CheckField(VT_PARAMINDEX); }
  bool has_normalIndex() const { return CheckField(VT_NORMALINDEX); }
  bool has_colorIndex() const { return CheckField(VT_COLORINDEX); }
  bool has_colorTable() const { return CheckField(VT_COLORTABLE); }
  bool has_numPerFace() const { return CheckField(VT_NUMPERFACE); }
  bool has_numPerRow() const { return CheckField(VT_NUMPERROW); }
  bool has_meshStyle() const { return CheckField(VT_MESHSTYLE); }
  bool has_twoSided() const { return CheckField(VT_TWOSIDED); }
  bool has_faceIndex() const { return CheckField(VT_FACEINDEX); }
  bool has_faceData() const { return CheckField(VT_FACEDATA); }
  bool has_auxData() const { return CheckField(VT_AUXDATA); }
  bool has_expectedClosure() const { return CheckField(VT_EXPECTEDCLOSURE); }
  bool has_taggedNumericData() const { return CheckField(VT_TAGGEDNUMERICDATA); }
};

struct PolyfaceBuilder {
  typedef Polyface Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_point(flatbuffers::Offset<flatbuffers::Vector<double>> point) {
    fbb_.AddOffset(Polyface::VT_POINT, point);
  }
  void add_param(flatbuffers::Offset<flatbuffers::Vector<double>> param) {
    fbb_.AddOffset(Polyface::VT_PARAM, param);
  }
  void add_normal(flatbuffers::Offset<flatbuffers::Vector<double>> normal) {
    fbb_.AddOffset(Polyface::VT_NORMAL, normal);
  }
  void add_doubleColor(flatbuffers::Offset<flatbuffers::Vector<double>> doubleColor) {
    fbb_.AddOffset(Polyface::VT_DOUBLECOLOR, doubleColor);
  }
  void add_intColor(flatbuffers::Offset<flatbuffers::Vector<int32_t>> intColor) {
    fbb_.AddOffset(Polyface::VT_INTCOLOR, intColor);
  }
  void add_pointIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> pointIndex) {
    fbb_.AddOffset(Polyface::VT_POINTINDEX, pointIndex);
  }
  void add_paramIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paramIndex) {
    fbb_.AddOffset(Polyface::VT_PARAMINDEX, paramIndex);
  }
  void add_normalIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> normalIndex) {
    fbb_.AddOffset(Polyface::VT_NORMALINDEX, normalIndex);
  }
  void add_colorIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> colorIndex) {
    fbb_.AddOffset(Polyface::VT_COLORINDEX, colorIndex);
  }
  void add_colorTable(flatbuffers::Offset<flatbuffers::Vector<int32_t>> colorTable) {
    fbb_.AddOffset(Polyface::VT_COLORTABLE, colorTable);
  }
  void add_numPerFace(int32_t numPerFace) {
    fbb_.AddElement<int32_t>(Polyface::VT_NUMPERFACE, numPerFace, 0);
  }
  void add_numPerRow(int32_t numPerRow) {
    fbb_.AddElement<int32_t>(Polyface::VT_NUMPERROW, numPerRow, 0);
  }
  void add_meshStyle(int32_t meshStyle) {
    fbb_.AddElement<int32_t>(Polyface::VT_MESHSTYLE, meshStyle, 0);
  }
  void add_twoSided(bool twoSided) {
    fbb_.AddElement<uint8_t>(Polyface::VT_TWOSIDED, static_cast<uint8_t>(twoSided), 0);
  }
  void add_faceIndex(flatbuffers::Offset<flatbuffers::Vector<int32_t>> faceIndex) {
    fbb_.AddOffset(Polyface::VT_FACEINDEX, faceIndex);
  }
  void add_faceData(flatbuffers::Offset<flatbuffers::Vector<double>> faceData) {
    fbb_.AddOffset(Polyface::VT_FACEDATA, faceData);
  }
  void add_auxData(flatbuffers::Offset<PolyfaceAuxData> auxData) {
    fbb_.AddOffset(Polyface::VT_AUXDATA, auxData);
  }
  void add_expectedClosure(int32_t expectedClosure) {
    fbb_.AddElement<int32_t>(Polyface::VT_EXPECTEDCLOSURE, expectedClosure, 0);
  }
  void add_taggedNumericData(flatbuffers::Offset<TaggedNumericData> taggedNumericData) {
    fbb_.AddOffset(Polyface::VT_TAGGEDNUMERICDATA, taggedNumericData);
  }
  explicit PolyfaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PolyfaceBuilder &operator=(const PolyfaceBuilder &);
  flatbuffers::Offset<Polyface> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Polyface>(end);
    return o;
  }
};

inline flatbuffers::Offset<Polyface> CreatePolyface(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> point = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> param = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> normal = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> doubleColor = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> intColor = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> pointIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paramIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> normalIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> colorIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> colorTable = 0,
    int32_t numPerFace = 0,
    int32_t numPerRow = 0,
    int32_t meshStyle = 0,
    bool twoSided = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> faceIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> faceData = 0,
    flatbuffers::Offset<PolyfaceAuxData> auxData = 0,
    int32_t expectedClosure = 0,
    flatbuffers::Offset<TaggedNumericData> taggedNumericData = 0) {
  PolyfaceBuilder builder_(_fbb);
  builder_.add_taggedNumericData(taggedNumericData);
  builder_.add_expectedClosure(expectedClosure);
  builder_.add_auxData(auxData);
  builder_.add_faceData(faceData);
  builder_.add_faceIndex(faceIndex);
  builder_.add_meshStyle(meshStyle);
  builder_.add_numPerRow(numPerRow);
  builder_.add_numPerFace(numPerFace);
  builder_.add_colorTable(colorTable);
  builder_.add_colorIndex(colorIndex);
  builder_.add_normalIndex(normalIndex);
  builder_.add_paramIndex(paramIndex);
  builder_.add_pointIndex(pointIndex);
  builder_.add_intColor(intColor);
  builder_.add_doubleColor(doubleColor);
  builder_.add_normal(normal);
  builder_.add_param(param);
  builder_.add_point(point);
  builder_.add_twoSided(twoSided);
  return builder_.Finish();
}

inline flatbuffers::Offset<Polyface> CreatePolyfaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *point = nullptr,
    const std::vector<double> *param = nullptr,
    const std::vector<double> *normal = nullptr,
    const std::vector<double> *doubleColor = nullptr,
    const std::vector<int32_t> *intColor = nullptr,
    const std::vector<int32_t> *pointIndex = nullptr,
    const std::vector<int32_t> *paramIndex = nullptr,
    const std::vector<int32_t> *normalIndex = nullptr,
    const std::vector<int32_t> *colorIndex = nullptr,
    const std::vector<int32_t> *colorTable = nullptr,
    int32_t numPerFace = 0,
    int32_t numPerRow = 0,
    int32_t meshStyle = 0,
    bool twoSided = false,
    const std::vector<int32_t> *faceIndex = nullptr,
    const std::vector<double> *faceData = nullptr,
    flatbuffers::Offset<PolyfaceAuxData> auxData = 0,
    int32_t expectedClosure = 0,
    flatbuffers::Offset<TaggedNumericData> taggedNumericData = 0) {
  auto point__ = point ? _fbb.CreateVector<double>(*point) : 0;
  auto param__ = param ? _fbb.CreateVector<double>(*param) : 0;
  auto normal__ = normal ? _fbb.CreateVector<double>(*normal) : 0;
  auto doubleColor__ = doubleColor ? _fbb.CreateVector<double>(*doubleColor) : 0;
  auto intColor__ = intColor ? _fbb.CreateVector<int32_t>(*intColor) : 0;
  auto pointIndex__ = pointIndex ? _fbb.CreateVector<int32_t>(*pointIndex) : 0;
  auto paramIndex__ = paramIndex ? _fbb.CreateVector<int32_t>(*paramIndex) : 0;
  auto normalIndex__ = normalIndex ? _fbb.CreateVector<int32_t>(*normalIndex) : 0;
  auto colorIndex__ = colorIndex ? _fbb.CreateVector<int32_t>(*colorIndex) : 0;
  auto colorTable__ = colorTable ? _fbb.CreateVector<int32_t>(*colorTable) : 0;
  auto faceIndex__ = faceIndex ? _fbb.CreateVector<int32_t>(*faceIndex) : 0;
  auto faceData__ = faceData ? _fbb.CreateVector<double>(*faceData) : 0;
  return CreatePolyface(
      _fbb,
      point__,
      param__,
      normal__,
      doubleColor__,
      intColor__,
      pointIndex__,
      paramIndex__,
      normalIndex__,
      colorIndex__,
      colorTable__,
      numPerFace,
      numPerRow,
      meshStyle,
      twoSided,
      faceIndex__,
      faceData__,
      auxData,
      expectedClosure,
      taggedNumericData);
}

struct TransitionSpiral FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransitionSpiralBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DETAIL = 4,
    VT_EXTRADATA = 6,
    VT_DIRECTDETAIL = 8
  };
  const TransitionSpiralDetail *detail() const {
    return GetStruct<const TransitionSpiralDetail *>(VT_DETAIL);
  }
  const flatbuffers::Vector<double> *extraData() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_EXTRADATA);
  }
  const DirectSpiralDetail *directDetail() const {
    return GetStruct<const DirectSpiralDetail *>(VT_DIRECTDETAIL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TransitionSpiralDetail>(verifier, VT_DETAIL) &&
           VerifyOffset(verifier, VT_EXTRADATA) &&
           verifier.VerifyVector(extraData()) &&
           VerifyField<DirectSpiralDetail>(verifier, VT_DIRECTDETAIL) &&
           verifier.EndTable();
  }
  bool has_detail() const { return CheckField(VT_DETAIL); }
  bool has_extraData() const { return CheckField(VT_EXTRADATA); }
  bool has_directDetail() const { return CheckField(VT_DIRECTDETAIL); }
};

struct TransitionSpiralBuilder {
  typedef TransitionSpiral Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_detail(const TransitionSpiralDetail *detail) {
    fbb_.AddStruct(TransitionSpiral::VT_DETAIL, detail);
  }
  void add_extraData(flatbuffers::Offset<flatbuffers::Vector<double>> extraData) {
    fbb_.AddOffset(TransitionSpiral::VT_EXTRADATA, extraData);
  }
  void add_directDetail(const DirectSpiralDetail *directDetail) {
    fbb_.AddStruct(TransitionSpiral::VT_DIRECTDETAIL, directDetail);
  }
  explicit TransitionSpiralBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransitionSpiralBuilder &operator=(const TransitionSpiralBuilder &);
  flatbuffers::Offset<TransitionSpiral> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransitionSpiral>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransitionSpiral> CreateTransitionSpiral(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TransitionSpiralDetail *detail = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> extraData = 0,
    const DirectSpiralDetail *directDetail = 0) {
  TransitionSpiralBuilder builder_(_fbb);
  builder_.add_directDetail(directDetail);
  builder_.add_extraData(extraData);
  builder_.add_detail(detail);
  return builder_.Finish();
}

inline flatbuffers::Offset<TransitionSpiral> CreateTransitionSpiralDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TransitionSpiralDetail *detail = 0,
    const std::vector<double> *extraData = nullptr,
    const DirectSpiralDetail *directDetail = 0) {
  auto extraData__ = extraData ? _fbb.CreateVector<double>(*extraData) : 0;
  return CreateTransitionSpiral(
      _fbb,
      detail,
      extraData__,
      directDetail);
}

struct VariantGeometry FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VariantGeometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GEOMETRY_TYPE = 4,
    VT_GEOMETRY = 6,
    VT_TAG = 8
  };
  VariantGeometryUnion geometry_type() const {
    return static_cast<VariantGeometryUnion>(GetField<uint8_t>(VT_GEOMETRY_TYPE, 0));
  }
  const void *geometry() const {
    return GetPointer<const void *>(VT_GEOMETRY);
  }
  template<typename T> const T *geometry_as() const;
  const LineSegment *geometry_as_LineSegment() const {
    return geometry_type() == VariantGeometryUnion_LineSegment ? static_cast<const LineSegment *>(geometry()) : nullptr;
  }
  const EllipticArc *geometry_as_EllipticArc() const {
    return geometry_type() == VariantGeometryUnion_EllipticArc ? static_cast<const EllipticArc *>(geometry()) : nullptr;
  }
  const BsplineCurve *geometry_as_BsplineCurve() const {
    return geometry_type() == VariantGeometryUnion_BsplineCurve ? static_cast<const BsplineCurve *>(geometry()) : nullptr;
  }
  const LineString *geometry_as_LineString() const {
    return geometry_type() == VariantGeometryUnion_LineString ? static_cast<const LineString *>(geometry()) : nullptr;
  }
  const CurveVector *geometry_as_CurveVector() const {
    return geometry_type() == VariantGeometryUnion_CurveVector ? static_cast<const CurveVector *>(geometry()) : nullptr;
  }
  const DgnCone *geometry_as_DgnCone() const {
    return geometry_type() == VariantGeometryUnion_DgnCone ? static_cast<const DgnCone *>(geometry()) : nullptr;
  }
  const DgnSphere *geometry_as_DgnSphere() const {
    return geometry_type() == VariantGeometryUnion_DgnSphere ? static_cast<const DgnSphere *>(geometry()) : nullptr;
  }
  const DgnTorusPipe *geometry_as_DgnTorusPipe() const {
    return geometry_type() == VariantGeometryUnion_DgnTorusPipe ? static_cast<const DgnTorusPipe *>(geometry()) : nullptr;
  }
  const DgnBox *geometry_as_DgnBox() const {
    return geometry_type() == VariantGeometryUnion_DgnBox ? static_cast<const DgnBox *>(geometry()) : nullptr;
  }
  const DgnExtrusion *geometry_as_DgnExtrusion() const {
    return geometry_type() == VariantGeometryUnion_DgnExtrusion ? static_cast<const DgnExtrusion *>(geometry()) : nullptr;
  }
  const DgnRotationalSweep *geometry_as_DgnRotationalSweep() const {
    return geometry_type() == VariantGeometryUnion_DgnRotationalSweep ? static_cast<const DgnRotationalSweep *>(geometry()) : nullptr;
  }
  const DgnRuledSweep *geometry_as_DgnRuledSweep() const {
    return geometry_type() == VariantGeometryUnion_DgnRuledSweep ? static_cast<const DgnRuledSweep *>(geometry()) : nullptr;
  }
  const Polyface *geometry_as_Polyface() const {
    return geometry_type() == VariantGeometryUnion_Polyface ? static_cast<const Polyface *>(geometry()) : nullptr;
  }
  const BsplineSurface *geometry_as_BsplineSurface() const {
    return geometry_type() == VariantGeometryUnion_BsplineSurface ? static_cast<const BsplineSurface *>(geometry()) : nullptr;
  }
  const VectorOfVariantGeometry *geometry_as_VectorOfVariantGeometry() const {
    return geometry_type() == VariantGeometryUnion_VectorOfVariantGeometry ? static_cast<const VectorOfVariantGeometry *>(geometry()) : nullptr;
  }
  const InterpolationCurve *geometry_as_InterpolationCurve() const {
    return geometry_type() == VariantGeometryUnion_InterpolationCurve ? static_cast<const InterpolationCurve *>(geometry()) : nullptr;
  }
  const TransitionSpiral *geometry_as_TransitionSpiral() const {
    return geometry_type() == VariantGeometryUnion_TransitionSpiral ? static_cast<const TransitionSpiral *>(geometry()) : nullptr;
  }
  const PointString *geometry_as_PointString() const {
    return geometry_type() == VariantGeometryUnion_PointString ? static_cast<const PointString *>(geometry()) : nullptr;
  }
  const AkimaCurve *geometry_as_AkimaCurve() const {
    return geometry_type() == VariantGeometryUnion_AkimaCurve ? static_cast<const AkimaCurve *>(geometry()) : nullptr;
  }
  const CatenaryCurve *geometry_as_CatenaryCurve() const {
    return geometry_type() == VariantGeometryUnion_CatenaryCurve ? static_cast<const CatenaryCurve *>(geometry()) : nullptr;
  }
  const PartialCurve *geometry_as_PartialCurve() const {
    return geometry_type() == VariantGeometryUnion_PartialCurve ? static_cast<const PartialCurve *>(geometry()) : nullptr;
  }
  const CurvePrimitiveId *tag() const {
    return GetPointer<const CurvePrimitiveId *>(VT_TAG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GEOMETRY_TYPE) &&
           VerifyOffset(verifier, VT_GEOMETRY) &&
           VerifyVariantGeometryUnion(verifier, geometry(), geometry_type()) &&
           VerifyOffset(verifier, VT_TAG) &&
           verifier.VerifyTable(tag()) &&
           verifier.EndTable();
  }
  bool has_geometry_type() const { return CheckField(VT_GEOMETRY_TYPE); }
  bool has_geometry() const { return CheckField(VT_GEOMETRY); }
  bool has_tag() const { return CheckField(VT_TAG); }
};

template<> inline const LineSegment *VariantGeometry::geometry_as<LineSegment>() const {
  return geometry_as_LineSegment();
}

template<> inline const EllipticArc *VariantGeometry::geometry_as<EllipticArc>() const {
  return geometry_as_EllipticArc();
}

template<> inline const BsplineCurve *VariantGeometry::geometry_as<BsplineCurve>() const {
  return geometry_as_BsplineCurve();
}

template<> inline const LineString *VariantGeometry::geometry_as<LineString>() const {
  return geometry_as_LineString();
}

template<> inline const CurveVector *VariantGeometry::geometry_as<CurveVector>() const {
  return geometry_as_CurveVector();
}

template<> inline const DgnCone *VariantGeometry::geometry_as<DgnCone>() const {
  return geometry_as_DgnCone();
}

template<> inline const DgnSphere *VariantGeometry::geometry_as<DgnSphere>() const {
  return geometry_as_DgnSphere();
}

template<> inline const DgnTorusPipe *VariantGeometry::geometry_as<DgnTorusPipe>() const {
  return geometry_as_DgnTorusPipe();
}

template<> inline const DgnBox *VariantGeometry::geometry_as<DgnBox>() const {
  return geometry_as_DgnBox();
}

template<> inline const DgnExtrusion *VariantGeometry::geometry_as<DgnExtrusion>() const {
  return geometry_as_DgnExtrusion();
}

template<> inline const DgnRotationalSweep *VariantGeometry::geometry_as<DgnRotationalSweep>() const {
  return geometry_as_DgnRotationalSweep();
}

template<> inline const DgnRuledSweep *VariantGeometry::geometry_as<DgnRuledSweep>() const {
  return geometry_as_DgnRuledSweep();
}

template<> inline const Polyface *VariantGeometry::geometry_as<Polyface>() const {
  return geometry_as_Polyface();
}

template<> inline const BsplineSurface *VariantGeometry::geometry_as<BsplineSurface>() const {
  return geometry_as_BsplineSurface();
}

template<> inline const VectorOfVariantGeometry *VariantGeometry::geometry_as<VectorOfVariantGeometry>() const {
  return geometry_as_VectorOfVariantGeometry();
}

template<> inline const InterpolationCurve *VariantGeometry::geometry_as<InterpolationCurve>() const {
  return geometry_as_InterpolationCurve();
}

template<> inline const TransitionSpiral *VariantGeometry::geometry_as<TransitionSpiral>() const {
  return geometry_as_TransitionSpiral();
}

template<> inline const PointString *VariantGeometry::geometry_as<PointString>() const {
  return geometry_as_PointString();
}

template<> inline const AkimaCurve *VariantGeometry::geometry_as<AkimaCurve>() const {
  return geometry_as_AkimaCurve();
}

template<> inline const CatenaryCurve *VariantGeometry::geometry_as<CatenaryCurve>() const {
  return geometry_as_CatenaryCurve();
}

template<> inline const PartialCurve *VariantGeometry::geometry_as<PartialCurve>() const {
  return geometry_as_PartialCurve();
}

struct VariantGeometryBuilder {
  typedef VariantGeometry Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_geometry_type(VariantGeometryUnion geometry_type) {
    fbb_.AddElement<uint8_t>(VariantGeometry::VT_GEOMETRY_TYPE, static_cast<uint8_t>(geometry_type), 0);
  }
  void add_geometry(flatbuffers::Offset<void> geometry) {
    fbb_.AddOffset(VariantGeometry::VT_GEOMETRY, geometry);
  }
  void add_tag(flatbuffers::Offset<CurvePrimitiveId> tag) {
    fbb_.AddOffset(VariantGeometry::VT_TAG, tag);
  }
  explicit VariantGeometryBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VariantGeometryBuilder &operator=(const VariantGeometryBuilder &);
  flatbuffers::Offset<VariantGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VariantGeometry>(end);
    return o;
  }
};

inline flatbuffers::Offset<VariantGeometry> CreateVariantGeometry(
    flatbuffers::FlatBufferBuilder &_fbb,
    VariantGeometryUnion geometry_type = VariantGeometryUnion_NONE,
    flatbuffers::Offset<void> geometry = 0,
    flatbuffers::Offset<CurvePrimitiveId> tag = 0) {
  VariantGeometryBuilder builder_(_fbb);
  builder_.add_tag(tag);
  builder_.add_geometry(geometry);
  builder_.add_geometry_type(geometry_type);
  return builder_.Finish();
}

inline bool VerifyVariantGeometryUnion(flatbuffers::Verifier &verifier, const void *obj, VariantGeometryUnion type) {
  switch (type) {
    case VariantGeometryUnion_NONE: {
      return true;
    }
    case VariantGeometryUnion_LineSegment: {
      auto ptr = reinterpret_cast<const LineSegment *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_EllipticArc: {
      auto ptr = reinterpret_cast<const EllipticArc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_BsplineCurve: {
      auto ptr = reinterpret_cast<const BsplineCurve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_LineString: {
      auto ptr = reinterpret_cast<const LineString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_CurveVector: {
      auto ptr = reinterpret_cast<const CurveVector *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_DgnCone: {
      auto ptr = reinterpret_cast<const DgnCone *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_DgnSphere: {
      auto ptr = reinterpret_cast<const DgnSphere *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_DgnTorusPipe: {
      auto ptr = reinterpret_cast<const DgnTorusPipe *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_DgnBox: {
      auto ptr = reinterpret_cast<const DgnBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_DgnExtrusion: {
      auto ptr = reinterpret_cast<const DgnExtrusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_DgnRotationalSweep: {
      auto ptr = reinterpret_cast<const DgnRotationalSweep *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_DgnRuledSweep: {
      auto ptr = reinterpret_cast<const DgnRuledSweep *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_Polyface: {
      auto ptr = reinterpret_cast<const Polyface *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_BsplineSurface: {
      auto ptr = reinterpret_cast<const BsplineSurface *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_VectorOfVariantGeometry: {
      auto ptr = reinterpret_cast<const VectorOfVariantGeometry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_InterpolationCurve: {
      auto ptr = reinterpret_cast<const InterpolationCurve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_TransitionSpiral: {
      auto ptr = reinterpret_cast<const TransitionSpiral *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_PointString: {
      auto ptr = reinterpret_cast<const PointString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_AkimaCurve: {
      auto ptr = reinterpret_cast<const AkimaCurve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_CatenaryCurve: {
      auto ptr = reinterpret_cast<const CatenaryCurve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VariantGeometryUnion_PartialCurve: {
      auto ptr = reinterpret_cast<const PartialCurve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyVariantGeometryUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVariantGeometryUnion(
        verifier,  values->Get(i), types->GetEnum<VariantGeometryUnion>(i))) {
      return false;
    }
  }
  return true;
}

}}} // End of Bentley::Geometry::FB namespace
#endif  // FLATBUFFERS_GENERATED_ALLCG_H_
