/*--------------------------------------------------------------------------------------+
|
|     $Source: vu/src/vumod.cpp $
|
|  $Copyright: (c) 2014 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#include <bsibasegeomPCH.h>
BEGIN_BENTLEY_GEOMETRY_NAMESPACE
#include <math.h>
/*
   Typical 'meshing' operations on a vu graph -- horizontal line slicing,
   triangulation of monotone face.

   These algorithms assume that all vu nodes have the same coordinate space,
   hence coordinates can be copied blindly to opposite sides of edges
   (no seams!!!).

   The cautious numerical coder will notice many exact floating point equality
   tests!!!  These are quite intentional.  The theory is that these numbers are
   generated by COPYING, and from a strictly topological standpoint the ordering
   imposed by the floating point space is just as good as integers. Yes, that is
   frightening to think about.  However, it works remarkably well.  A LONG discussion
   is needed to clarify that!!
*/

/*----------------------------------------------------------------------+
|                                                                       |
| name          vu_splitEdgeAtV                                         |
|                                                                       |
| author        earlinLutz                                      10/94   |
|                                                                       |
+----------------------------------------------------------------------*/
static void     vu_splitEdgeAtV (
VuSetP          graphP,         /* Parent set where the new nodes are added */
VuP             startP,         /* Starting vu of edge to split */
double          v,              /* v coordinate for new point. */
VuP            *leftP,          /* <= new vu on left of edge */
VuP            *rightP          /* <= new vu on right of edge */
)
    {
    double          t, u, v0;
    VuP             endP = VU_FSUCC (startP);
    v0 = VU_V (startP);
    t = (v - v0) / (VU_V (VU_FSUCC (startP)) - v0);
    u = VU_U (startP) + t * (VU_U (endP) - VU_U (startP));
    vu_splitEdge (graphP, startP, leftP, rightP);
    VU_SET_UV (*leftP, u, v);
    VU_SET_UV (*rightP, u, v);
    }

/*----------------------------------------------------------------------+
|                                                                       |
| name          searchSortedArrayAbove                                  |
|                                                                       |
| author        earlinLutz                                      10/94   |
|                                                                       |
+----------------------------------------------------------------------*/
static int      searchSortedArrayAbove (       /* <= the index of the least entry strictly larger than a
                                                   This value is nv if all entries are a or less */
double          a,              /* => test key */
double         *v,              /* => array of keys */
int             nv              /* => number of keys */
)
    {
    int             i;
    for (i = 0; i < nv && v[i] <= a; i++)
        {
        }
    return i;
    }


/*----------------------------------------------------------------------+
|                                                                       |
| name          searchSortedArrayBelow                                  |
|                                                                       |
| author        earlinLutz                                      10/94   |
|                                                                       |
+----------------------------------------------------------------------*/
static int      searchSortedArrayBelow (       /* <= the index of the last entry strictly smaller than a
                                                   This value is -1 if all entries are a or more */
double          a,              /* => test key */
double         *v,              /* => array of keys */
int             nv              /* => number of keys */
)
    {
    int             i;
    for (i = nv; --i >= 0 && v[i] >= a;)
        {
        }
    return i;
    }

/*----------------------------------------------------------------------+
|                                                                       |
| name          searchSortedArrayExact                                  |
|                                                                       |
| author        earlinLutz                                      10/94   |
|                                                                       |
+----------------------------------------------------------------------*/
static int      searchSortedArrayExact (       /* <= the index any entry that exactly matches a.
                                                   If there are no matches, returned value is -1 */
double          a,              /* => test key */
double         *v,              /* => array of keys */
int             nv              /* => number of keys */
)
    {
    int             i;
    for (i = nv; --i >= 0 && v[i] > a;)
        {
        }
    if (i >= 0 && v[i] != a)
        i = -1;
    return i;
    }

/*---------------------------------------------------------------------------------**//**
* @param P0 IN face predecessor of node where an exact hit occurs
* @return 0, 1, or 2 == # sides (left, right) of the horizontal line through the
*   exact hit that are strictly interior to the face
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
static int      classifyExactHit
(
VuP P0
)
    {
    VuP             P1 = VU_FSUCC (P0);
    double          du1 = VU_U (P1) - VU_U (P0);
    double          dv1 = VU_V (P1) - VU_V (P0);
    VuP             P2 = VU_FSUCC (P1);
    double          du2 = VU_U (P2) - VU_U (P1);
    double          dv2 = VU_V (P2) - VU_V (P1);
    double          crossProduct;
    int             count = 0;
    double          vProduct = dv1 * dv2;
    if (vProduct > 0)
        {
        count = 1;
        }
    else if (vProduct < 0)
        {
        crossProduct = VU_CROSS_PRODUCT_FROM_COMPONENTS (du1, dv1, du2, dv2);
        if (crossProduct < 0)
            count = 2;
        }
    else
        {
        /*      At least one dv is zero.
           If both are zero the following cross product is also 0!!!
           If one is nonzero, the cross product sorts out all the combinations.
           If you are concerned about an accidental zero in the cross product:
           we assume:  1) du1*0-du2*0 will produce a true zero
           2) du1*0-du2*dv1, where dv1 is nonzero, will NOT, and
           vice versa */
        crossProduct = VU_CROSS_PRODUCT_FROM_COMPONENTS (du1, dv1, du2, dv2);
        if (crossProduct < 0)
            count = 1;
        }
    return count;
    }


/*======================================================================+
|                                                                       |
|   Major Public Code Section                                           |
|                                                                       |
+======================================================================*/

/*---------------------------------------------------------------------------------**//**
* @description Split edges in the given faces wherever they cross the given horizontal lines.
* @remarks The mask is set on a node for which the intersecting altitude is strictly interior to the face on both sides of the node;
*       otherwise, the mask is cleared.  More specifically:
*   <ul>
*   <li>When a face loop touches an altitude line at a single point "from below" such that neighborhoods of both sides of the line are
*       strictly interior to the face, then the touch node is entered as a rightArrayP node, and marked by mPointUp.</li>
*   <li>When a face loop touches an altitude line at a single point "from above" such that neighborhoods of both sides of the line are
*       strictly interior to the face, then the touch node is entered as a rightArrayP node, and marked by mPointDn.</li>
*   <li>When a face loop touches an altitude line at a single point from either above or below, but neighborhoods of both sides of the line
*       are never strictly interior to the face, <em>no</em> entry is made.</li>
*   </ul>
* @remarks The following logic generates the proper number of start-stop points for interval management:
*   <ul>
*   <li>Every leftArrayP entry generates one interval parameter, and it will always be a left value.</li>
*   <li>Every rightArrayP entry generates one interval parameter that will be a right value.</li>
*   <li>A rightArrayP entry with either mPointUp or mPointDn mask set also generates a left parameter.</li>
*   </ul>
* @param graphP         IN OUT  graph header
* @param loopArrayP     IN      array of nodes, one per face loop to split
* @param leftArrayP     OUT     array to collect added/existing nodes that lie on the given altitudes and whose edge is to their left, e.g.,
*                               nodes that can be the left end of segments of the horizontal line split by the face.
* @param rightArrayP    OUT     array to collect added/existing nodes that lie on the given altitudes and whose edge is to their right, e.g.,
*                               nodes that can be the right end of segments of the horizontal line split by the face.
* @param v              IN      ascending array of altitudes (y-coordinates of horizontal split lines)
* @param nv             IN      number of altitudes
* @param mPointUp       IN      mask set for a VU at a face corner that points up and touches an altitude line
* @param mPointDn       IN      mask set for a VU at a face corner that points down and touches an altitude line
* @group "VU Meshing"
* @see vu_joinSortedPairs, vu_splitOnSortedHorizontalLines
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void            vu_horizontalSplit
(
VuSetP          graphP,
VuArrayP        loopArrayP,

VuArrayP        leftArrayP,
VuArrayP        rightArrayP,
double         *v,
int             nv,
VuMask          mPointUp,
VuMask          mPointDn
)
    {
    VuP             Pface, Q, A, B;
    int             i;
    double          v0, v1, vNew;
    double          tNew, uNew;
    VuMask          mBothPoints = mPointUp | mPointDn;

    vu_arrayClear (leftArrayP);
    vu_arrayClear (rightArrayP);

    /*    For each loop .. */
    for (vu_arrayOpen (loopArrayP);
         vu_arrayRead (loopArrayP, &Pface);)
        {
        /*      For each edge within the loop ... */
        VU_FACE_LOOP (P, Pface)
            {
            Q = VU_FSUCC (P);
            v0 = VU_V (P);
            v1 = VU_V (Q);
            if (v1 > v0)
                {
                /*      Walk upward in both the edge and array */
                i = searchSortedArrayAbove (v0, v, nv);
                while (i < nv && v[i] < v1)
                    {
                    /*              split .. */
                    vNew = v[i];
                    tNew = (vNew - v0) / (v1 - v0);
                    uNew = VU_U (P) + tNew * (VU_U (Q) - VU_U (P));
                    vu_splitEdge (graphP, P, &A, &B);
                    v0 = vNew;
                    P = A;
                    VU_SET_UV (A, uNew, vNew);
                    VU_SET_UV (B, uNew, vNew);      /* Hmm. this should be done separately?? */
                    vu_arrayAdd (rightArrayP, A);
                    VU_CLRMASK (A, mBothPoints);
                    /*              advance over matched v values */
                    for (; i++ < nv && v[i] == vNew;)
                        {
                        }
                    }
                /*      Handle exact hits at the end node */
                if (i < nv && v[i] == v1)
                    {
                    int             crossingOrder = classifyExactHit (P);
                    if (crossingOrder > 0)
                        {
                        vu_arrayAdd (rightArrayP, Q);
                        VU_CLRMASK (Q, mBothPoints);
                        if (crossingOrder == 2)
                            {
                            VU_SETMASK (Q, mPointUp);
                            }
                        }
                    }
                }
            else if (v1 < v0)
                {
                /*      Walk downard in both the edge and array */
                i = searchSortedArrayBelow (v0, v, nv);
                while (i >= 0 && v[i] > v1)
                    {
                    /*              split .. */
                    vNew = v[i];
                    tNew = (vNew - v0) / (v1 - v0);
                    uNew = VU_U (P) + tNew * (VU_U (Q) - VU_U (P));
                    vu_splitEdge (graphP, P, &A, &B);
                    v0 = vNew;
                    P = A;
                    vu_arrayAdd (leftArrayP, A);
                    VU_SET_UV (A, uNew, vNew);
                    VU_SET_UV (B, uNew, vNew);      /* Hmm. this should be done separately?? */
                    VU_CLRMASK (A, mBothPoints);
                    /*              advance over matched v values */
                    for (; --i >= 0 && v[i] == vNew;)
                        {
                        }
                    }
                /*      Handle exact hits at the end node */
                if (i >= 0 && v[i] == v1)
                    {
                    int             crossingOrder = classifyExactHit (P);
                    if (crossingOrder > 0)
                        {
                        VU_CLRMASK (Q, mBothPoints);
                        if (crossingOrder == 1)
                            {
                            vu_arrayAdd (leftArrayP, Q);
                            }
                        else
                            {
                            vu_arrayAdd (rightArrayP, Q);
                            VU_SETMASK (Q, mPointDn);
                            }
                        }
                    }
                }
            else
                {
                /*      Horizontal line. */
                i = searchSortedArrayExact (v0, v, nv);
                if (i >= 0 && i < nv)
                    {
                    /*              Exact hit at both P and Q. Check the
                       departure direction of the edge after Q
                       to see if there is any 'in' neighborhood */
                    double          du = VU_dU (P);
                    double          cross = du * VU_dV (Q);
                    if (cross < 0)
                        {
                        VU_CLRMASK (Q, mBothPoints);        /* This is always a single case */
                        if (du > 0)
                            {
                            vu_arrayAdd (leftArrayP, Q);
                            }
                        else
                            {
                            vu_arrayAdd (rightArrayP, Q);
                            }
                        }
                    }
                }
            }
        END_VU_FACE_LOOP (P, Pface)
        }
    }

/*----------------------------------------------------------------------+
|                                                                       |
| name          lineCoordinates                                         |
|                                                                       |
| author        earlinLutz                                      10/94   |
|                                                                       |
| Return tangential and transverse coordinates of nodeP relative        |
| to a (directed, infinite) line.                                       |
+----------------------------------------------------------------------*/
static void lineCoordinates
(
double      *uP,            /* <= tangential coordinate */
double      *vP,            /* <= transverse coordinate */
VuP         nodeP,          /* => node to map */
DPoint2d    *startP,        /* => reference point on line */
DPoint2d    *dirP           /* => direction vector on line */
)
    {
    double dx = VU_U(nodeP) - startP->x;
    double dy = VU_V(nodeP) - startP->y;
    *uP = dx * dirP->x + dy * dirP->y;
    *vP = dx * dirP->y - dy * dirP->x;
    }

/*----------------------------------------------------------------------+
|                                                                       |
| name          classifyExactLineHit                                    |
|                                                                       |
| author        earlinLutz                                      10/94   |
|                                                                       |
+----------------------------------------------------------------------*/
static int      classifyExactLineHit ( /* <= 0,1, or 2 == number of sides (left and right) that are 'in */
VuP             P0,             /* => Face predecessor of node where an exact hit occurs. */
DPoint2d        *startP,        /* => line reference point */
DPoint2d        *dirP           /* => line direction vector */
)
    {
    VuP             P1 = VU_FSUCC (P0);
    VuP             P2 = VU_FSUCC (P1);
    double          u0, u1, u2, v0, v1, v2;
    double          du1, du2, dv1, dv2;
    double          crossProduct;
    int             count = 0;
    double          vProduct;

    lineCoordinates (&u0, &v0, P0, startP, dirP);
    lineCoordinates (&u1, &v1, P1, startP, dirP);
    lineCoordinates (&u2, &v2, P2, startP, dirP);

    du1 = u1 - u0;
    du2 = u2 - u1;
    dv1 = v1 - v0;
    dv2 = v2 - v1;

    vProduct = dv1 * dv2;
    if (vProduct > 0)
        {
        count = 1;
        }
    else if (vProduct < 0)
        {
        crossProduct = VU_CROSS_PRODUCT_FROM_COMPONENTS (du1, dv1, du2, dv2);
        if (crossProduct < 0)
            count = 2;
        }
    else
        {
        /*      At least one dv is zero.
           If both are zero the following cross product is also 0!!!
           If one is nonzero, the cross product sorts out all the combinations.
           If you are concerned about an accidental zero in the cross product:
           we assume:  1) du1*0-du2*0 will produce a true zero
           2) du1*0-du2*dv1, where dv1 is nonzero, will NOT, and
           vice versa */
        crossProduct = VU_CROSS_PRODUCT_FROM_COMPONENTS (du1, dv1, du2, dv2);
        if (crossProduct < 0)
            count = 1;
        }
    return count;
    }

static DPoint2d s_sortDirectionVector;
/*----------------------------------------------------------------------+
|                                                                       |
| name          lineSpaceSortFunction                                   |
|                                                                       |
| author        earlinLutz                                      10/94   |
|                                                                       |
| Standard qsort comparison function (returns -1, 0, 1) to compare      |
| positions based on a sort direction vector.  This is a pure           |
| one dimensional sort -- no resolution of equal coordinates            |
+----------------------------------------------------------------------*/
static int lineSpaceSortFunction
(
const VuP       *nodeAVoidPP,
const VuP       *nodeBVoidPP
)
    {
    int     retCode;
    VuP     nodeAP = (VuP)*nodeAVoidPP;
    VuP     nodeBP = (VuP)*nodeBVoidPP;

    double sA = VU_U(nodeAP) * s_sortDirectionVector.x + VU_V(nodeAP) * s_sortDirectionVector.y;
    double sB = VU_U(nodeBP) * s_sortDirectionVector.x + VU_V(nodeBP) * s_sortDirectionVector.y;
    double delta = sB - sA;

    if (delta > 0.0)
        {
        retCode = -1;
        }
    else if (delta < 0.0)
        {
        retCode = 1;
        }
    else
        {
        retCode = 0;
        }

    return retCode;
    }

/*---------------------------------------------------------------------------------**//**
* @description Add edges between pairs of nodes in the split lists returned by ~mvu_splitFacesOnLine.
* @remarks Assumptions:
*   <ul>
*   <li>Double points are present only in both lists with identical pointers.</li>
*   <li>The slicing began with a list of double-sided face loops.  That is, the intersection line coming in from the left first strikes a
*       "right" node, then starts a left-right node pair.  Similarly, at the end of that line there is a dangling edge from a "left" node.</li>
*   </ul>
* @param graphP             IN OUT  graph header
* @param newEdgeArrayP      OUT     array to collect the (start) nodes of new edges
* @param leftArrayP         IN OUT  array of nodes that intersect the line and whose edge is to their left, e.g.,
*                                   nodes that can be the left end of segments of the line.  Sorted lexically on return.
* @param rightArrayP        IN OUT  array of nodes that intersect the line and whose edge is to their right, e.g.,
*                                   nodes that can be the right end of segments of the line.  Sorted lexically on return.
* @param startPointP        IN      start point of section line (unused)
* @param directionVectorP   IN      direction vector of section line
* @param mPointUp           IN      mask set for a VU at a face corner that points up and touches the line
* @param mPointDn           IN      mask set for a VU at a face corner that points down and touches the line
* @param mLeft              IN      mask to set on left end of new edges
* @param mRight             IN      mask to set on right end of new edges
* @group "VU Meshing"
* @see vu_splitInteriorFacesOnLine, vu_splitFacesOnLine
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void            vu_joinLineSplitPoints
(
VuSetP          graphP,
VuArrayP        newEdgeArrayP,
VuArrayP        leftArrayP,
VuArrayP        rightArrayP,
DPoint2d        *startPointP,
DPoint2d        *directionVectorP,
VuMask          mPointUp,
VuMask          mPointDn,
VuMask          mLeft,
VuMask          mRight
)
    {
    VuP leftP;
    VuP rightP;
    VuP newLeftNodeP, newRightNodeP;

    s_sortDirectionVector = *directionVectorP;

    vu_arraySort0 (leftArrayP, lineSpaceSortFunction);
    vu_arraySort0 (rightArrayP, lineSpaceSortFunction);

    vu_arrayClear (newEdgeArrayP);

    vu_arrayOpen (leftArrayP);
    vu_arrayOpen (rightArrayP);

    vu_arrayRead (leftArrayP, &leftP);
    vu_arrayRead (rightArrayP, &rightP);

    while (leftP && rightP)
        {
        if (lineSpaceSortFunction (&leftP, &rightP) == -1)
            {
            vu_join (graphP, leftP, rightP, &newLeftNodeP, &newRightNodeP);
            VU_SETMASK (newLeftNodeP, mLeft);
            VU_SETMASK (newRightNodeP, mRight);

            if (newEdgeArrayP)
                vu_arrayAdd (newEdgeArrayP, newLeftNodeP);

            if (VU_GETMASK (rightP, mPointUp))
                {
                leftP = rightP;
                vu_arrayRead (rightArrayP, &rightP);
                }
            else if (VU_GETMASK (rightP, mPointDn))
                {
                leftP = newRightNodeP;
                vu_arrayRead (rightArrayP, &rightP);
                }
            else
                {
                vu_arrayRead (rightArrayP, &rightP);
                vu_arrayRead (leftArrayP, &leftP);
                }
            }
        else
            {
            vu_arrayRead (rightArrayP, &rightP);
            }
        }
    }

/*---------------------------------------------------------------------------------**//**
* @description Split edges in the given faces wherever they cross the given line.
* @remarks The mask is set on a node for which the line is strictly interior to the face on both sides of the node;
*       otherwise, the mask is cleared.  More specifically:
*   <ul>
*   <li>When a face loop touches the line at a single point "from below" such that neighborhoods of both sides of the line are
*       strictly interior to the face, then the touch node is entered as a rightArrayP node, and marked by mPointUp.</li>
*   <li>When a face loop touches the line at a single point "from above" such that neighborhoods of both sides of the line are
*       strictly interior to the face, then the touch node is entered as a rightArrayP node, and marked by mPointDn.</li>
*   <li>When a face loop touches the line at a single point from either above or below, but neighborhoods of both sides of the line
*       are never strictly interior to the face, <em>no</em> entry is made.</li>
*   </ul>
* @remarks The following logic generates the proper number of start-stop points for interval management:
*   <ul>
*   <li>Every leftArrayP entry generates one interval parameter, and it will always be a left value.</li>
*   <li>Every rightArrayP entry generates one interval parameter that will be a right value.</li>
*   <li>A rightArrayP entry with either mPointUp or mPointDn mask set also generates a left parameter.</li>
*   </ul>
* @param graphP             IN OUT  graph header
* @param leftArrayP         OUT     array to collect added/existing nodes that intersect the line and whose edge is to their left, e.g.,
*                                   nodes that can be the left end of segments of the line.
* @param rightArrayP        OUT     array to collect added/existing nodes that intersect the line and whose edge is to their right, e.g.,
*                                   nodes that can be the right end of segments of the line.
* @param loopArrayP         IN      array of nodes, one per face loop to split
* @param startPointP        IN      start point of section line
* @param directionVectorP   IN      direction vector of section line
* @param mPointUp           IN      mask set for a VU at a face corner that points up and touches the line
* @param mPointDn           IN      mask set for a VU at a face corner that points down and touches the line
* @group "VU Meshing"
* @see vu_splitInteriorFacesOnLine, vu_joinLineSplitPoints
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void            vu_splitFacesOnLine
(
VuSetP          graphP,
VuArrayP        leftArrayP,
VuArrayP        rightArrayP,
VuArrayP        loopArrayP,
DPoint2d        *startPointP,
DPoint2d        *directionVectorP,
VuMask          mPointUp,
VuMask          mPointDn
)
    {
    VuP             Pface, Q, A, B;
    double          v0, v1, u0, u1;
    double          uCut, vCut, wCut, tCut;
    double          product;
    VuMask          mBothPoints = mPointUp | mPointDn;

    vu_arrayClear (leftArrayP);
    vu_arrayClear (rightArrayP);

    /*    For each loop .. */
    for (vu_arrayOpen (loopArrayP);
         vu_arrayRead (loopArrayP, &Pface);)
        {
        /*      For each edge within the loop ... */
        VU_FACE_LOOP (P, Pface)
            {
            Q = VU_FSUCC (P);
            lineCoordinates(&u0, &v0, P, startPointP, directionVectorP);
            lineCoordinates (&u1, &v1, Q, startPointP, directionVectorP);
            product = v0 * v1;
            vCut = 0.0;
            if (product < 0.0)
                {
                vu_splitEdge (graphP, P, &A, &B);
                tCut = v0 / ( v0 - v1 );
                uCut = VU_U (P) + tCut * (VU_U (Q) - VU_U (P));
                vCut = VU_V (P) + tCut * (VU_V (Q) - VU_V (P));
                wCut = VU_W (P) + tCut * (VU_W (Q) - VU_W (P));
                VU_SET_UVW (A, uCut, vCut, wCut);
                VU_SET_UVW (B, uCut, vCut, wCut);
                if (v0 < 0.0)
                    vu_arrayAdd (rightArrayP, A);
                else
                    vu_arrayAdd (leftArrayP, A);

                VU_CLRMASK (A, mBothPoints);
                }
            else if (product > 0.0)
                {
                /* No contact */
                }
            else /* one or both ends are ON the line */
                {
                if (v0 != 0.0)  /* v1 must be zero to get product = 0 */
                    {
                    int crossingOrder = classifyExactLineHit (P, startPointP, directionVectorP);
                    if (crossingOrder > 0)
                        {
                        if (v1 > v0)
                            {
                            vu_arrayAdd (rightArrayP, Q);
                            VU_CLRMASK (Q, mBothPoints);
                            if (crossingOrder == 2)
                                {
                                VU_SETMASK (Q, mPointUp);
                                }
                            }
                        else /* v0 > v1 */
                            {
                            VU_CLRMASK (Q, mBothPoints);

                            if (crossingOrder == 1)
                                {
                                vu_arrayAdd (leftArrayP, Q);
                                }
                            else
                                {
                                vu_arrayAdd (rightArrayP, Q);
                                VU_SETMASK (Q, mPointDn);
                                }
                            }
                        }
                    }
                else
                    {
                    /* "on" edge */
                    if (v0 == 0.0 && v1 == 0.0)
                        {
                        /*              Exact hit at both P and Q. Check the
                           departure direction of the edge after Q
                           to see if there is any 'in' neighborhood */
                        double          du = u1 - u0;
                        double u2, v2;
                        double cross;
                        lineCoordinates (&u2, &v2, VU_FSUCC(Q), startPointP, directionVectorP);
                        cross = du * (v2 - v1);
                        if (cross < 0)
                            {
                            VU_CLRMASK (Q, mBothPoints);        /* This is always a single case */
                            if (du > 0)
                                {
                                vu_arrayAdd (leftArrayP, Q);
                                }
                            else
                                {
                                vu_arrayAdd (rightArrayP, Q);
                                }
                            }
                        }
                    }
                }
            }
        END_VU_FACE_LOOP (P, Pface)
        }
    }

/*---------------------------------------------------------------------------------**//**
* @description Split the interior faces of the graph at their intersection(s) with the given line.
* @param graphP             IN OUT  graph header
* @param newEdgeArrayP      OUT     array to collect the (start) nodes of new edges
* @param pStartPoint        IN      start point of section line
* @param pDirectionVector   IN      direction vector of section line
* @param mLeft              IN      mask to set on left end of new edges
* @param mRight             IN      mask to set on right end of new edges
* @group "VU Meshing"
* @see vu_splitFacesOnLine, vu_joinLineSplitPoints
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void vu_splitInteriorFacesOnLine
(
VuSetP          graphP,
VuArrayP        newEdgeArrayP,
DPoint2d        *pStartPoint,
DPoint2d        *pDirectionVector,
VuMask          mLeft,
VuMask          mRight
)
    {
    VuArrayP leftArrayP  = vu_grabArray (graphP);
    VuArrayP rightArrayP = vu_grabArray (graphP);
    VuArrayP interiorFaceArrayP = vu_grabArray (graphP);
    VuMask  mPointsUp    = vu_grabMask  (graphP);
    VuMask  mPointsDn    = vu_grabMask  (graphP);

    vu_collectInteriorFaceLoops (interiorFaceArrayP, graphP);

    vu_splitFacesOnLine (graphP,
                leftArrayP, rightArrayP,
                interiorFaceArrayP,
                pStartPoint, pDirectionVector,
                mPointsUp, mPointsDn
                );
    vu_joinLineSplitPoints (graphP, newEdgeArrayP,
                leftArrayP, rightArrayP,
                pStartPoint, pDirectionVector,
                mPointsUp, mPointsDn,
                mLeft, mRight
                );

    vu_returnArray (graphP, interiorFaceArrayP);
    vu_returnArray (graphP, leftArrayP);
    vu_returnArray (graphP, rightArrayP);
    vu_returnMask  (graphP, mPointsUp);
    vu_returnMask  (graphP, mPointsDn);
    }

/*---------------------------------------------------------------------------------**//**
* @description Add horizontal edges between pairs of nodes in the split lists returned by ~mvu_horizontalSplit.
* @remarks Assumptions:
*   <ul>
*   <li>Both node lists are lexically sorted into horizontal sweeps, e.g., with ~mvu_compareLexicalUV0.</li>
*   <li>Double points are present only in both lists with identical pointers.</li>
*   <li>The slicing began with a list of double-sided face loops.  That is, the intersection line coming in from the left first strikes a
*       "right" node, then starts a left-right node pair.  Similarly, at the end of that line there is a dangling edge from a "left" node.</li>
*   </ul>
* @param graphP             IN OUT  graph header
* @param leftArrayP         IN      array of nodes that intersect the line and whose edge is to their left, e.g.,
*                                   nodes that can be the left end of segments of the line.
* @param rightArrayP        IN      array of nodes that intersect the line and whose edge is to their right, e.g.,
*                                   nodes that can be the right end of segments of the line.
* @param doubleMaxMask      IN      mask set for a VU at a face corner that points up and touches the line
* @param doubleMinMask      IN      mask set for a VU at a face corner that points down and touches the line
* @group "VU Meshing"
* @see vu_horizontalSplit, vu_splitOnSortedHorizontalLines
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void            vu_joinSortedPairs
(
VuSetP          graphP,
VuArrayP        leftArrayP,
VuArrayP        rightArrayP,
VuMask          doubleMaxMask,
VuMask          doubleMinMask
)
    {
    VuP             leftVuP, rightVuP, newLeftVuP, newRightVuP;
    int counter;
    /*    The simple situation is that we advance through the arrays
       pulling one VuP from each array and joining them with a
       new edge at each step.
       When there are double hit points, the double point appears
       only in the rightArrayP, and the subsequent edge uses a
       newly created node from that new edge as its left
     */

    vu_arrayOpen(leftArrayP);
    vu_arrayOpen(rightArrayP);
    if ( ! vu_arrayRead ( rightArrayP , &rightVuP ) )
        return;

    counter = 0;
    leftVuP = ( VU_GETMASK ( rightVuP, doubleMinMask ) ? rightVuP : NULL );

    for ( ;     ( vu_arrayRead( rightArrayP , &rightVuP ) )
            &&  ( leftVuP ||  vu_arrayRead( leftArrayP, &leftVuP ) )
          ; )
        {

        if ( VU_V( rightVuP ) > VU_V(leftVuP) )
            {
            /* This pair jumps up to the next level. */
            counter = 0;
            if ( VU_GETMASK ( rightVuP , doubleMinMask ) )
                {
                leftVuP = rightVuP;
                }
            else if ( VU_GETMASK ( rightVuP , doubleMaxMask ) )
                {
                leftVuP = rightVuP;
                }
            else
                {
                leftVuP = NULL;
                }
            }
        else if ( VU_U( rightVuP ) > VU_U( leftVuP ) )
            {
            /* Normal joining pair */
            vu_join (graphP, leftVuP, rightVuP, &newLeftVuP, &newRightVuP);
            if (VU_GETMASK (rightVuP, doubleMaxMask))
                {
                leftVuP = rightVuP;
                }
            else if (VU_GETMASK (rightVuP, doubleMinMask))
                {
                leftVuP = newRightVuP;
                }
            else
                {
                leftVuP = VU_NULL;
                }
            }
        }
    }

/*---------------------------------------------------------------------------------**//**
* @description Split the interior faces of the graph at their intersection(s) with the given horizontal lines.
* @param graphP         IN OUT  graph header
* @param faces          IN      array of nodes, one per face loop to split
* @param v              IN      ascending array of altitudes (y-coordinates of horizontal split lines)
* @param nv             IN      number of altitudes
* @param leftNodes      IN      working array
* @param rightNodes     IN      working array
* @group "VU Meshing"
* @see vu_horizontalSplit, vu_joinSortedPairs
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void            vu_splitOnSortedHorizontalLines
(
VuSetP          graphP,
VuArrayP        faces,
double         *v,
int             nv,
VuArrayP        leftNodes,
VuArrayP        rightNodes
)
    {
    int mask1 = vu_grabMask (graphP);
    int mask2 = vu_grabMask (graphP);
    vu_horizontalSplit (graphP, faces, leftNodes, rightNodes, v, nv, mask1, mask2);

    vu_arraySort0 (leftNodes, vu_compareLexicalUV0);
    vu_arraySort0 (rightNodes, vu_compareLexicalUV0);

    vu_joinSortedPairs (graphP, leftNodes, rightNodes, mask1, mask2);
    vu_returnMask (graphP, mask2);
    vu_returnMask (graphP, mask1);
    }

/*---------------------------------------------------------------------------------**//**
* @description Insert horizontal edges across a face that is known to be monotone in the v-coordinate.
* @param graphP         IN OUT  graph header
* @param sliceArrayP    OUT     array to receive the sliced faces, one node per new face
* @param startP         IN      any starter node in the face
* @param v              IN      ascending array of altitudes (v-coordinates of horizontal split lines)
* @param maskP          IN      array of masks to install on new edges
* @param nv             IN      number of altitudes/masks
* @param fixedMask      IN      additional mask to apply to new edges
* @group "VU Meshing"
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void            vu_splitMonotoneFaceOnSortedHorizontalLines
(
VuSetP          graphP,
VuArrayP        sliceArrayP,
VuP             startP,
double          *v,
VuMask          *maskP,
int             nv,
VuMask          fixedMask
)
    {
    VuP             nextP, leftP, rightP;
    VuP             insideP, outsideP;
    VuP             newLeftP, newRightP;
    double          v0, v1, vLine;
    int             i;
    VuMask          mask;

    /*    Look for a local min (which should also be a global min) */
    nextP = VU_FSUCC (startP);
    if (VU_BELOW (nextP, startP))
        {
        do
            {
            startP = nextP;
            nextP = VU_FSUCC (nextP);
            }
        while (VU_BELOW (nextP, startP));
        }
    else
        {
        for (nextP = VU_FPRED (startP);
             VU_BELOW (nextP, startP);
             startP = nextP, nextP = VU_FPRED (nextP))
            {
            }
        ;
        }


    i = searchSortedArrayAbove (VU_V (startP), v, nv);
    /*    Walk upwards on both sides, inserting and joining
       cross lines at each v value  */
    leftP = rightP = startP;
    vu_arrayAdd (sliceArrayP, leftP);

    while (i < nv)
        {

        mask = maskP[i] | fixedMask;
        vLine = v[i++];

        /*      Search and subdivide on the left */
        v1 = VU_V (leftP);
        nextP = leftP;
        do
            {
            leftP = nextP;
            nextP = VU_FPRED (leftP);
            v0 = v1;
            v1 = VU_V (nextP);
            }
        while (v1 < vLine && VU_BELOW (leftP, nextP));

        if (v1 > vLine)
            {
            /*      subdivide the left edge */
            vu_splitEdgeAtV (graphP, nextP, vLine, &insideP, &outsideP);
            leftP = insideP;
            }
        else
            {
            /*      Continue moving as long as the edge moves
               strictly to the right */
            do
                {
                leftP = nextP;
                nextP = VU_FPRED (nextP);
                }
            while (VU_V (nextP) == v1 && VU_U (nextP) > VU_U (leftP));
            }

        /*      Search and subdivide on the right */
        v1 = VU_V (rightP);
        nextP = rightP;
        do
            {
            rightP = nextP;
            nextP = VU_FSUCC (rightP);
            v0 = v1;
            v1 = VU_V (nextP);
            }
        while (v1 < vLine && VU_BELOW (rightP, nextP));

        if (v1 > vLine)
            {
            /*      subdivide the left edge */
            vu_splitEdgeAtV (graphP, rightP, vLine, &insideP, &outsideP);
            rightP = insideP;
            }
        else
            {
            rightP = nextP;
            }

        if (leftP != rightP
            && VU_V (leftP) == vLine
            && VU_V (rightP) == vLine)
            {
            vu_join (graphP, leftP, rightP, &newLeftP, &newRightP);
            VU_SETMASK(newLeftP,mask);
            VU_SETMASK(newRightP,mask);
            leftP = newLeftP;
            vu_arrayAdd (sliceArrayP, newLeftP);
            }
        else
            {
            i = nv;             /* forces loop exit */
            }
        }
    }

/*---------------------------------------------------------------------------------**//**
* @description If the computed area of the face is positive, apply positiveSideMask to each edge and negativeSideMask to mates;
*       if negative area, apply masks in reverse.
* @param pSeed IN OUT seed node for face loop
* @param positiveSideMask IN mask to apply to positive side of face
* @param negativeSideMask IN mask to apply to negative side of face
* @group "VU Node Masks"
* @see vu_markFaceAndComputeArea, vu_markExteriorFacesByArea
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void vu_setMaskByArea
(
VuP pSeed,
VuMask positiveSideMask,
VuMask negativeSideMask
)
    {
    double area;
    VuMask mask0;
    VuMask mask1;
    if (pSeed)
        {
        area = vu_area (pSeed);
        if (area >= 0.0)
            {
            mask0 = positiveSideMask;
            mask1 = negativeSideMask;
            }
        else
            {
            mask0 = negativeSideMask;
            mask1 = positiveSideMask;
            }

        VU_FACE_LOOP(pCurr, pSeed)
            {
            vu_setMask (pCurr, mask0);
            vu_setMask (vu_edgeMate (pCurr), mask1);
            }
        END_VU_FACE_LOOP(pCurr, pSeed)
        }
    }

/*---------------------------------------------------------------------------------**//**
* @description Set all the v-coordinates around a face to a constant value.
* @param startP IN OUT  start node on the face
* @param v      IN      v-coordinate to set
* @group "VU Coordinates"
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void vu_setVAroundFace
(
VuP startP,
double v
)
    {
    VU_FACE_LOOP( currP, startP )
        {
        VU_SET_V( currP, v);
        }
    END_VU_FACE_LOOP( currP, startP )
    }

/*---------------------------------------------------------------------------------**//**
* @description Make an isolated chain of edges in the graph, with coordinates taken from the given array of 2D points.
* @remarks Also set inside and outside masks.
* @param graphP         IN OUT  graph header in which a loop is to be constructed
* @param firstNodePP    OUT     first node in chain
* @param lastNodePP     OUT     last node in chain
* @param uvP            IN      xy-coordinates to install
* @param id0            IN      index for first node
* @param id1            IN      index for last node
* @param closed         IN      whether the loop is closed
* @param leftMask       IN      mask to apply to the left of the chain
* @param rightMask      IN      mask to apply to the right of the chain
* @group "VU Edges"
* @see vu_joinIndexedChains
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void vu_makeIndexedChain
(
VuSetP graphP,
VuP *firstNodePP,
VuP *lastNodePP,
DPoint2d *uvP,
int id0,
int id1,
bool    closed,
VuMask leftMask,
VuMask rightMask
)
    {
    VuP startP, endP;   /* Nodes on current edge */
    VuP tailP = NULL;          /* Node at tail of chain */
    int id;
    if ( id0 >= id1 )
        {
        *firstNodePP = NULL;
        *lastNodePP  = NULL;
        }
    else
        {
        for ( id = id0; id < id1 ; id++ )
            {
            vu_makePair ( graphP, &startP, &endP );
            VU_SET_LABEL ( startP, id );
            VU_SET_LABEL (   endP, id+1 );
            VU_SET_UV( startP, uvP[id].x, uvP[id].y );
            VU_SET_UV(   endP, uvP[id+1].x, uvP[id+1].y );
            VU_SETMASK ( startP, leftMask );
            VU_SETMASK ( endP, rightMask );
            if ( id == id0 )
                {
                *firstNodePP = startP;
                }
            else
                {
                vu_vertexTwist (graphP, tailP, startP);
                }
            tailP = endP;
            }
        *lastNodePP = tailP;
        }
        if ( closed )
            {
            vu_vertexTwist (graphP, *firstNodePP, *lastNodePP );
            VU_COPY_LABEL ( *lastNodePP , *firstNodePP );
            }
    }

/*---------------------------------------------------------------------------------**//**
* @description Join the endpoints of two chains by a seam edge if they are both closed.
* @remarks First and last nodes of chains are as returned from prior calls to ~mvu_makeIndexedChain
*       and ~mvu_joinIndexedChains.
* @param graphP             IN OUT  graph header
* @param firstBottomNodeP   IN OUT  first node on bottom chain, advanced to top on output
* @param lastBottomNodeP    IN OUT  last node on bottom chain, advanced to top on output
* @param bottomClosed       IN      whether bottom chain is closed
* @param firstTopNodeP      IN      first node on top chain
* @param lastTopNodeP       IN      last node on top chain
* @param topClosed          IN      whether top chain is closed
* @group "VU Edges"
* @see vu_makeIndexedChain
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void vu_joinIndexedChains
(
VuSetP graphP,
VuP *firstBottomNodeP,
VuP *lastBottomNodeP,
bool    bottomClosed,
VuP *firstTopNodeP,
VuP *lastTopNodeP,
bool    topClosed
)
    {
    VuP AP, BP;
    if  (   ! *firstBottomNodeP || ! *lastBottomNodeP
        ||  ! *firstTopNodeP    || ! *lastTopNodeP
        )
        {
        /* A dummy call on the first level */
        }
    else if ( topClosed && bottomClosed )
        {
        /* Single edge A..B from bottom to top */
        /* At each vertex, the ids are identical, but coordinates
                are taken from first/last to maintain seam */
        vu_makePair(graphP, &AP, &BP );

        vu_vertexTwist (graphP, AP, *firstBottomNodeP );
        VU_COPY_LABEL( AP, *lastBottomNodeP );
        VU_COPY_UV( AP, *lastBottomNodeP );
        VU_SETMASK( AP, VU_SEAM_EDGE );

        vu_vertexTwist (graphP, BP, *lastTopNodeP );
        VU_COPY_LABEL( BP, *firstTopNodeP );
        VU_COPY_UV( BP, *firstTopNodeP );
        VU_SETMASK( BP, VU_SEAM_EDGE );

        }
    *firstBottomNodeP = *firstTopNodeP ;
    *lastBottomNodeP  = *lastTopNodeP ;
    }

/*---------------------------------------------------------------------------------**//**
* @description Apply an affine mapping to the 2D coordinates of every node.
* @param graphP IN OUT  graph header
* @param uMin0  IN      old minimum u-coordinate
* @param uMax0  IN      old maximum u-coordinate
* @param uMin1  IN      new minimum u-coordinate
* @param uMax1  IN      new maximum u-coordinate
* @param vMin0  IN      old minimum v-coordinate
* @param vMax0  IN      old maximum v-coordinate
* @param vMin1  IN      new minimum v-coordinate
* @param vMax1  IN      new maximum v-coordinate
* @group "VU Coordinates"
* @bsimethod                                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void vu_mapCoordinates
(
VuSetP graphP,
double uMin0,
double uMax0,
double uMin1,
double uMax1,
double vMin0,
double vMax0,
double vMin1,
double vMax1
)
    {
    double u0, v0, du, dv, u, v;
    if ( uMax0 != uMin0 && uMax1 != uMin1 )
        {
        du = ( uMax1 - uMin1 ) / ( uMax0 - uMin0 );
        u0 = uMin1 - uMin0 * du;
        }
    else
        {
        u0 = 0.0;
        du = 1.0;
        }

    if ( vMax0 != vMin0 && vMax1 != vMin1 )
        {
        dv = ( vMax1 - vMin1 ) / ( vMax0 - vMin0 );
        v0 = vMin1 - vMin0 * dv;
        }
    else
        {
        v0 = 0.0;
        dv = 1.0;
        }

    VU_SET_LOOP ( currP, graphP )
        {
        u = VU_U(currP);
        v = VU_V(currP);
        VU_U(currP) = u0 + u*du;
        VU_V(currP) = v0 + v*dv;
        }
    END_VU_SET_LOOP ( currP, graphP )
    }

/*---------------------------------------------------------------------------------**//**
* @description Remove all edges in a graph, except those with the given mask on exactly one side.
* @param graphP IN OUT  graph header
* @param mask   IN      mask to query
* @group "VU Edges"
* @bsimethod                                                    EarlinLutz      8/96
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP void vu_removeAllButSingleMarkedEdges
(
VuSetP  graphP,
VuMask  mask
)
    {
    int mateFlag;

    VuP mateP;
    VuMask myMask = vu_grabMask (graphP);
    vu_clearMaskInSet (graphP, myMask);

    VU_SET_LOOP(currP, graphP)
        {
        mateP = vu_edgeMate (currP);
        mateFlag = vu_getMask (mateP, mask);
        if (vu_getMask (currP, mask))
            {
            if (mateFlag)
                {
                // doubly-marked edge
                vu_setMask (currP, myMask);
                vu_setMask (mateP, myMask);
                }
            }
        else
            {
            if (!mateFlag)
                {
                // unmarked edge
                vu_setMask (currP, myMask);
                vu_setMask (mateP, myMask);
                }
            }
        }
    END_VU_SET_LOOP (currP, graphP)

    vu_freeMarkedEdges (graphP, myMask);
    vu_returnMask (graphP, myMask);
    }

END_BENTLEY_GEOMETRY_NAMESPACE
