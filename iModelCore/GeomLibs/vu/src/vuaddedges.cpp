/*--------------------------------------------------------------------------------------+
|
|  Copyright (c) Bentley Systems, Incorporated. All rights reserved.
|
+--------------------------------------------------------------------------------------*/
#include <bsibasegeomPCH.h>
BEGIN_BENTLEY_GEOMETRY_NAMESPACE
#include <math.h>
/*
   Typical 'meshing' operations on a vu graph -- horizontal line slicing,
   triangulation of monotone face.

   These algorithms assume that all vu nodes have the same coordinate space,
   hence coordinates can be copied blindly to opposite sides of edges
   (no seams!!!).

   The cautious numerical coder will notice many exact floating point equality
   tests!!!  These are quite intentional.  The theory is that these numbers are
   generated by COPYING, and from a strictly topological standpoint the ordering
   imposed by the floating point space is just as good as integers. Yes, that is
   frightening to think about.  However, it works remarkably well.  A LONG discussion
   is needed to clarify that!!
*/

// _alloca is your friend struct, but not if you ask for meg-ish chunks.
// Example: with 72000 points, the stack request is about 1.5 meg.
// this function handles allocation by _alloca or BSIBaseGeom::Malloc
// as appropriate.
#define MAX_ALLOCA_POINTS 10000

/*--------------------------------------------------------------------*//**
* @return xy distance, as max of absolute values.
+----------------------------------------------------------------------*/
static double distanceXY
(
DPoint3d    *pPoint0,
DPoint3d    *pPoint1
)
    {
    double dx = fabs (pPoint1->x - pPoint0->x);
    double dy = fabs (pPoint1->y - pPoint0->y);
    return dx > dy ? dx : dy;
    }

/*--------------------------------------------------------------------*//**
* Extract edge start, end points applying wraparound logic to base index in array.
+----------------------------------------------------------------------*/
static double edgeCoordinates
(
DPoint3d    *pPoint0,
DPoint3d    *pPoint1,
DPoint3d    *pPointBuffer,
int         numPoint,
int         i0
)
    {
    int i1;
    while (i0 < 0)
        i0 += numPoint;
    while (i0 >= numPoint)
        i0 -= numPoint;

    i1 = i0 + 1;
    if (i1 == numPoint)
        i1 = 0;

    if (pPoint0)
        *pPoint0 = pPointBuffer[i0];
    if (pPoint1)
        *pPoint1 = pPointBuffer[i1];

    return distanceXY (pPoint0, pPoint1);
    }

/*--------------------------------------------------------------------*//**
* Compute a replacement endpoint for the common point between two edges
*   with near-coincident endpoints.
+----------------------------------------------------------------------*/
static void adjustEndPoint
(
DPoint3d*   pCorrectedPoint,
DPoint3d*   pPoint0,
DPoint3d*   pPoint1,
DPoint3d*   pPoint2,
DPoint3d*   pPoint3,
double      xyTol
)
    {
    double dx01 = pPoint1->x - pPoint0->x;
    double dy01 = pPoint1->y - pPoint0->y;
    double dx23 = pPoint3->x - pPoint2->x;
    double dy23 = pPoint3->y - pPoint2->y;
    double d1X, d2X;
    double param01, param02;
    DPoint3d resultPoint = *pPoint1;
    DPoint3d testPoint;
    if (bsiSVD_solve2x2(
                        &param01, &param02,
                        dx01, -dx23,
                        dy01, -dy23,
                        pPoint2->x - pPoint1->x,
                        pPoint2->y - pPoint1->y
                        ))
        {
        testPoint.x = pPoint1->x + param01 * dx01;
        testPoint.y = pPoint1->y + param01 * dy01;
        testPoint.z = pPoint1->z;

        d1X = distanceXY (pPoint1, &testPoint);
        d2X = distanceXY (pPoint2, &testPoint);
        if (d1X < xyTol && d2X < xyTol)
            resultPoint = testPoint;
        else
            resultPoint = *pPoint1;
        }
    *pCorrectedPoint = resultPoint;
    }

static VuP insertVertexInLoop
(
VuSetP    pGraph,
VuP         pBaseNode,
DPoint3d    *pPoint
)
    {
    VuP pInside, pOutside;
    vu_splitEdge (pGraph, pBaseNode, &pInside, &pOutside);
    VU_SET_UVW( pInside, pPoint->x, pPoint->y, pPoint->z);
    VU_SET_UVW(pOutside, pPoint->x, pPoint->y, pPoint->z);
    return pInside;
    }

/*--------------------------------------------------------------------*//**
* Create a new loop from an array of points.  Nearby points are adjusted
*   to avoid short edges.
* @param graphP IN OUT graph
* @param pWorkBuffer IN OUT points in loop.  Contents are modified (compressed)
                        in place.
* @param pEdgeIndex IN OUT caller-allocated work buffer of size numPoints ints
* @param numPoints IN number of points.
* @param abstol IN smallest allowed absolute tolerance.
* @param reltol IN relative tolerance.  An internal minimum is applied (1e-8)
* @return pointer to some vu around the loop.
+----------------------------------------------------------------------*/
static VuP     vu_loopFromDPoint3dArrayXYTol_goNoDisconnects
(
VuSetP          graphP,
DPoint3d        *pWorkPoints,
int             *pEdgeIndex,
int             numPoints,
double          abstol,
double          reltol
)
    {
    DPoint3d    point0, point1, point2, point3, point4;
    double      dCurr;
    double      dTotal;
    int         i, j, k;
    VuP         baseP;
    static double s_defaultReltol = 1.0e-8;
    static double s_minReltol = 1.0e-14;
    double      maxCoord = DPoint3dOps::LargestCoordinate (pWorkPoints, numPoints);
    double      xyTol;
    int         numGoodEdge;

    if (abstol < 0.0)
        abstol = 0.0;

    if (reltol <= 0.0)
        reltol = s_defaultReltol;
    else if (reltol < s_minReltol)
        reltol = s_minReltol;

    xyTol = abstol + reltol * maxCoord;

    baseP = VU_NULL;    /* During construction, baseP is the last created VU (if any) */
    if (numPoints < 2)
        return NULL;

    numGoodEdge = 0;

    // Look for short edges anywhere, including between first/last points.
    // In work array, overwrite coordinates of short edge ends with single replacement point.
    for (i = 0; i < numPoints;)
        {
        if (edgeCoordinates (&point0, &point1, pWorkPoints, numPoints, i) > xyTol)
            {
            /* This edge is long. Look for "next" long edge and use it to generate
                a replacement coordinate for the endpoint. */
            pEdgeIndex[numGoodEdge++] = i;
            dTotal = xyTol;
            for (j = 1;
                    j < numPoints
                 && (dCurr = edgeCoordinates
                                (&point2, &point3, pWorkPoints, numPoints, i + j))
                        < xyTol;
                 j++
                 )
                {
                dTotal += dCurr;
                }
            // j == 1 + number of short edges to consolidate.
            if (j == 1)
                {
                // No short edges.  Endpoint is ok.
                }
            else if (j < numPoints)
                {
                /* There are one or more short edges between two long edges at i and i+j.
                   Get a replacemet point and consolidate all.
                */
                adjustEndPoint (&point4,
                        &point0, &point1, &point2, &point3,
                        dTotal
                        );

                for (k = 1; k <= j; k++)
                    {
                    int m = i + k;
                    if (m >= numPoints)
                        m -= numPoints;
                    pWorkPoints[m] = point4;
                    }
                }
            else
                {
                // Really strange -- didn't find another long edge anywhere.
                return NULL;
                }
            i += j;
            }
        else
            {
            i += 1;
            }
        }

    if (numGoodEdge <= 1)
        return NULL;

    baseP = NULL;
    for (i = 0; i < numGoodEdge; i++)
        {
        baseP = insertVertexInLoop (graphP, baseP, &pWorkPoints[pEdgeIndex[i]]);
        }

    return baseP;
    }

static VuP     vu_loopFromDPoint3dArrayXYTol_goWithDisconnects
(
VuSetP          graphP,
TransformCP     worldToLocal,
DPoint3d        *pWorkPoints,
int             *pEdgeIndex,
int             numPoints,
double          abstol,
double          reltol
)
    {
    VuP lastLoop = NULL;
    for (int i0 = 0, i1 = 0; i1 < numPoints; i1++)
        {
        int numPointsThisLoop = 0;
        if (i1 + 1 >= numPoints)
            numPointsThisLoop = i1 - i0 + 1;
        else if (pWorkPoints[i1].IsDisconnect ())
            numPointsThisLoop = i1 - i0;

        if (numPointsThisLoop > 0)
            {
            if (numPointsThisLoop > 0)
                {
                if (NULL != worldToLocal)
                    worldToLocal->Multiply (pWorkPoints, numPoints);
                lastLoop = vu_loopFromDPoint3dArrayXYTol_goNoDisconnects (graphP, pWorkPoints + i0, pEdgeIndex, numPointsThisLoop, abstol, reltol);
                }
            i0 = i1;
            }
        }
    return lastLoop;
    }


Public GEOMDLLIMPEXP VuP      vu_loopFromDPoint3dArrayXYTol
(
VuSetP          graphP,
DPoint3dCP      pPointBuffer,
int             numPoints,
double          abstol,
double          reltol
)
    {
    return vu_loopFromDPoint3dArrayXYTol (graphP, NULL, pPointBuffer, numPoints, abstol, reltol);
    }

/*--------------------------------------------------------------------*//**
* @description Create a new (isolated) loop in the graph from an array of 3D points.
* @remarks short edges are culled by removing duplicate points within tol = abstol + reltol * max,
        where max is the largest xy-coordinate of the input points.
* @param graphP IN OUT graph to receive loop
* @param pPointBuffer IN coordinates around loop
* @param numPoints IN number of points
* @param abstol IN smallest allowed tolerance
* @param reltol IN relative tolerance (or nonpositive for default)
* @return pointer to some node around the new loop
* @group "VU Edges"
* @bsimethod                                    EarlinLutz      10/94
+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP VuP      vu_loopFromDPoint3dArrayXYTol
(
VuSetP          graphP,
TransformCP     worldToLocal,
DPoint3dCP      pPointBuffer,
int             numPoints,
double          abstol,
double          reltol
)
    {
    DPoint3d        *pWorkPoints = NULL;
    int             *pEdgeIndex = NULL;
    VuP             pBase = NULL;
    if (numPoints < 2)
        {
        pBase = NULL;
        }
    else if (numPoints <= MAX_ALLOCA_POINTS)
        {
        pWorkPoints = (DPoint3d *)_alloca (numPoints * sizeof (DPoint3d));
        memcpy (pWorkPoints, pPointBuffer, numPoints * sizeof (DPoint3d));
            pEdgeIndex = (int *)_alloca (numPoints * sizeof (int));
        pBase = vu_loopFromDPoint3dArrayXYTol_goWithDisconnects (graphP, worldToLocal, pWorkPoints, pEdgeIndex, numPoints, abstol, reltol);
        }
    else
        {
        pWorkPoints = (DPoint3d *)BSIBaseGeom::Malloc(numPoints * sizeof (DPoint3d));
        pEdgeIndex = (int *)BSIBaseGeom::Malloc (numPoints * sizeof (int));
        if (pPointBuffer != NULL && pEdgeIndex != NULL)
            {
            memcpy (pWorkPoints, pPointBuffer, numPoints * sizeof (DPoint3d));
            pBase = vu_loopFromDPoint3dArrayXYTol_goWithDisconnects (graphP, worldToLocal, pWorkPoints, pEdgeIndex, numPoints, abstol, reltol);
            }
        if (pWorkPoints)
            BSIBaseGeom::Free (pWorkPoints);
        if (pEdgeIndex)
            BSIBaseGeom::Free (pEdgeIndex);
        }
    return pBase;
    }


#define SMALL_DISTANCE 1e-7
/*PF*/
/*----------------------------------------------------------------------+
|                                                                       |
| name          vu_makeLoopFromArray                                    |
|                                                                       |
| author        earlinLutz                                      10/94   |
|                                                                       |
| Make an (isolated) loop in a vu graph, with coordinates taken from    |
| the given array of xy points.   Optionally set the VU_EXTERIOR_EDGE   |
| flag on the 'outside' of the loop.                                    |
| Duplicate points are eliminated (within a fixed tolerance)            |
+----------------------------------------------------------------------*/
static VuP vu_makeLoopFromArray_go /* <= pointer to an arbitrary vu on the loop */
(
VuSetP graphP,          /* <=> VU set in which a loop is to be constructed */
DPoint2d *xyP,          /* => array of uv coordinates of the points, */
DPoint3d *pWorkArray,  /* Work array -- one DPoint3d per input point */
int *pEdgeIndex,        /* Work array -- one int per point */
int nxy,                /* => number of points */
int markExterior,       /* => true to mark the right side of the path EXTERIOR */
int testArea            /* => true to do a signed area test to determine if the
                                exterior is to the right or left.  If false, the
                                RIGHT side is marked. */
)
    {
    VuP baseP;
    VuP insideP, startP;
    int i;
    for (i = 0; i < nxy; i++)
        {
        pWorkArray[i].Init ( xyP[i].x, xyP[i].y, 0.0);
        }

    baseP = vu_loopFromDPoint3dArrayXYTol_goWithDisconnects (graphP, NULL, pWorkArray, pEdgeIndex, nxy, SMALL_DISTANCE, 0.0);

    if(baseP && markExterior)
        {
        insideP = baseP;
        if(testArea && vu_area( insideP ) < 0.0)
            {
            baseP = insideP = VU_EDGE_MATE( insideP );
            }
        startP = VU_EDGE_MATE( insideP );
        VU_FACE_LOOP(currP,startP)
           VU_SETMASK(currP,VU_EXTERIOR_EDGE);
        END_VU_FACE_LOOP(currP,startP)
        }
    return baseP;
    }

/*---------------------------------------------------------------------------------**//**
* @description Create a new (isolated) loop in the graph from an array of points.
* @remarks Duplicate points are eliminated within a fixed tolerance.
* @param graphP         IN OUT  graph to receive loop
* @param xyP            IN      uv-coordinates around loop
* @param nxy            IN      number of points
* @param markExterior   IN      whether to mark the right side of the path EXTERIOR
* @param testArea       IN      (if markExterior is true) whether to do a signed area test to determine
*                               if the exterior is to the right or left.  If false, the right side is marked.
* @return pointer to some node around the new loop
* @group "VU Edges"
* @bsimethod                                                    EarlinLutz      10/04
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP VuP vu_makeLoopFromArray
(
VuSetP graphP,
DPoint2d *xyP,
int nxy,
bool    markExterior,
bool    testArea
)
    {
    DPoint3d        *pWorkPoints = NULL;
    int             *pEdgeIndex = NULL;
    VuP             pBase = NULL;
    if (nxy < 2)
        {
        pBase = NULL;
        }
    else if (nxy <= MAX_ALLOCA_POINTS)
        {
        pWorkPoints = (DPoint3d *)_alloca (nxy * sizeof (DPoint3d));
        pEdgeIndex = (int *)_alloca (nxy * sizeof (int));
        pBase = vu_makeLoopFromArray_go (graphP, xyP, pWorkPoints, pEdgeIndex, nxy, markExterior, testArea);
        }
    else
        {
        pWorkPoints = (DPoint3d *)BSIBaseGeom::Malloc(nxy * sizeof (DPoint3d));
        pEdgeIndex = (int *)BSIBaseGeom::Malloc (nxy * sizeof (int));
        if (pWorkPoints != NULL && pEdgeIndex != NULL)
            pBase = vu_makeLoopFromArray_go (graphP, xyP, pWorkPoints, pEdgeIndex, nxy, markExterior, testArea);
        if (pWorkPoints)
            BSIBaseGeom::Free (pWorkPoints);
        if (pEdgeIndex)
            BSIBaseGeom::Free (pEdgeIndex);
        }
    return pBase;
    }

/*---------------------------------------------------------------------------------**//**
* @description Create a new (isolated) loop in the graph from an array of 3D points.
* @remarks Duplicate points are eliminated if all three coordinates fall within a tolerance based on a fixed fraction of the xy-range.
* @param graphP         IN OUT  graph to receive loop
* @param pointP         IN      uv-coordinates around loop
* @param nPoints        IN      number of points
* @param markExterior   IN      whether to mark the right side of the path EXTERIOR
* @param testArea       IN      (if markExterior is true) whether to do a signed area test to determine
*                               if the exterior is to the right or left.  If false, the right side is marked.
* @return pointer to some node around the new loop
* @group "VU Edges"
* @bsimethod                                                    BrianPeters     05/95
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP VuP      vu_makeLoopFromArray3d
(
VuSetP          graphP,
DPoint3d        *pointP,
int             nPoints,
int             markExterior,
int             testArea
)
    {
    double      dx, dy, dz;
    DPoint3d    *ptP, *endP, lastPoint;
    VuP         baseP, insideP, outsideP, startP;
    static double s_relTol = 1.0e-8;
    double      tol = s_relTol * DPoint3dOps::LargestCoordinate (pointP, nPoints);

    baseP = VU_NULL;    /* During construction, baseP is the last created VU (if any) */
    if (nPoints < 2)
        return NULL;
    lastPoint = pointP[nPoints - 1];

    for (ptP = endP = pointP, endP += nPoints; ptP < endP; ptP++)
        {
        dx = fabs (ptP->x - lastPoint.x);
        dy = fabs (ptP->y - lastPoint.y);
        dz = fabs (ptP->z - lastPoint.z);
        if (dx > tol || dy > tol || dz > tol)
            {
            vu_splitEdge (graphP, baseP, &insideP, &outsideP);
            baseP = insideP;
            VU_SET_UVW( insideP, ptP->x, ptP->y, ptP->z);
            VU_SET_UVW(outsideP, ptP->x, ptP->y, ptP->z);
            lastPoint = *ptP;
            }
        }

    if (baseP && markExterior)
        {
        insideP = baseP;
        if (testArea && vu_area (insideP) < 0.0)
            {
            baseP = insideP = VU_EDGE_MATE (insideP);
            }
        if (-1 == markExterior)
            startP = insideP;
        else
            startP = VU_EDGE_MATE (insideP);
        VU_FACE_LOOP (currP, startP)
            VU_SETMASK (currP, VU_EXTERIOR_EDGE);
        END_VU_FACE_LOOP (currP, startP)
        }
    return baseP;
    }

/*---------------------------------------------------------------------------------**//**
* @description Create a chain of VU edges in the graph from an array of points.
* @remarks Optionally skips short edges using xy and/or xyz length as tolerance.
* @param graphP             IN OUT  graph to receive chain
* @param pointP             IN      coordinates around loop
* @param nPoints            IN      number of points
* @param leftMask           IN      mask bits to apply to the left of each edge (typically VU_BOUNDARY_EDGE)
* @param rightMask          IN      mask bits to apply to the right of each edge (typically VU_EXTERIOR_EDGE and/or VU_BOUNDARY_EDGE)
* @param minXYEdgeLength    IN      absolute tolerance for testing minimum 2D edge length (if negative, no test is done)
* @param minXYZEdgeLength   IN      absolute tolerance for testing minimum 3D edge length (if negative, no test is done)
* @return pointer to first node in the new chain
* @group "VU Edges"
* @bsimethod                                                    BrianPeters     05/95
+---------------+---------------+---------------+---------------+---------------+------*/
Public GEOMDLLIMPEXP VuP      vu_makeEdgesFromArray3d
(
VuSetP          graphP,
DPoint3d        *pointP,
int             nPoints,
int             leftMask,
int             rightMask,
double          minXYEdgeLength,
double          minXYZEdgeLength
)
    {
    double      tol2XY, tol2XYZ;
    int         testXY, testXYZ;
    int         i;
    VuP         baseP, startP, endP, tailP;
    DPoint3d    startPoint, endPoint;
    int         iLast;

    int         acceptEdge;

    tol2XY      = minXYEdgeLength * minXYEdgeLength;
    tol2XYZ     = minXYZEdgeLength * minXYZEdgeLength;

    testXY = minXYEdgeLength >= 0.0;
    testXYZ = minXYZEdgeLength >= 0.0;

    tailP = VU_NULL;    /* last created VU */
    baseP = VU_NULL;    /* First created vu */
    iLast = 0;

    for (i = 1; i < nPoints; i++)
        {
        startPoint = pointP[iLast];
        endPoint   = pointP[i];

        acceptEdge = true;
        if (testXY && startPoint.DistanceSquaredXY (endPoint) < tol2XY)
            acceptEdge = false;
        if (testXYZ && startPoint.DistanceSquared (endPoint) < tol2XYZ)
            acceptEdge = false;

        if (acceptEdge)
            {
            vu_makePair (graphP, &startP, &endP);
            vu_setMask (startP, leftMask);
            vu_setMask (endP,  rightMask);
            vu_setDPoint3d (startP, &startPoint);
            vu_setDPoint3d (endP, &endPoint);

            if (baseP)
                {
                /* link up to the prior chain */
                vu_vertexTwist (graphP, tailP, startP);
                }
            else
                {
                /* record the start point */
                baseP = startP;
                }
            iLast = i;
            tailP = endP;
            }
        }
    return baseP;
    }


static DPoint3d GetTransformed (bvector<DPoint3d> const &data, size_t i, TransformCP worldToLocal)
    {
    if (i >= data.size ())
        return DPoint3d::From (0,0,0);
    if (worldToLocal == nullptr)
        return data[i];
    return (*worldToLocal) * data[i];
    }

Public VuP vu_addEdgeXYTol (
VuSetP          graph,
DPoint3dCR xyz0,
DPoint3dCR xyz1,
double abstol,
VuMask leftMask,
VuMask rightMask
)
    {
    if (xyz0.DistanceSquared (xyz1) < abstol * abstol)
        return nullptr;
    VuP node0, node1;
    vu_makePair (graph, &node0, &node1);
    node0->SetMask (leftMask);
    node1->SetMask (rightMask);
    node0->SetXYZ (xyz0);
    node1->SetXYZ (xyz1);
    return node0;
    }

Public void vu_addEdgesXYTol
(
VuSetP          graph,
TransformCP     worldToLocal,
bvector<DPoint3d> const &data,
bool closed,
double          abstol,
VuMask leftMask,
VuMask rightMask
)
    {
    size_t n = data.size ();
    if (n < 2)
        return;

    DPoint3d xyz0 = GetTransformed (data, 0, worldToLocal);
    DPoint3d xyz00 = xyz0;  // save to reuse for closure
    for (size_t i = 1; i < n; i++)
        {
        DPoint3d xyz1 = GetTransformed (data, i, worldToLocal);
        vu_addEdgeXYTol (graph, xyz0, xyz1, abstol, leftMask, rightMask);
        xyz0 = xyz1;
        }
    if (closed)
        vu_addEdgeXYTol (graph, xyz0, xyz00, abstol, leftMask, rightMask);
    }

Public void vu_addEdgesXYTol
(
VuSetP          graph,
TransformCP     worldToLocal,
bvector<bvector<DPoint3d>> const &data,
bool closed,
double          abstol,     // applied in LOCAL !!!!
VuMask leftMask,
VuMask rightMask
)
    {
    for (auto &path : data)
        vu_addEdgesXYTol (graph, worldToLocal, path, closed, abstol, leftMask, rightMask);
    }

END_BENTLEY_GEOMETRY_NAMESPACE
