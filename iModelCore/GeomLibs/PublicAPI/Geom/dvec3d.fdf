/*--------------------------------------------------------------------------------------+
|
|     $Source: PublicAPI/Geom/dvec3d.fdf $
|
|  $Copyright: (c) 2015 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#pragma once

/*__BENTLEY_INTERNAL_ONLY__*/

BEGIN_BENTLEY_NAMESPACE

//!
//! @description Returns the (vector) cross product of two vectors.
//! @param pCrossProduct OUT     cross product of vector1 and vector2
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//!
Public GEOMDLLIMPEXP void bsiDVec3d_crossProduct
(
DVec3dP pCrossProduct,
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Returns the (vector) cross product of two vectors.
//! @param pCrossProduct OUT     cross product of vector1 and vector2
//! @param pVector1 IN      The first vector
//! @param pPoint2 IN      The second vector, given as a point.
//!        The point's xyz are understood to be a vector from the origin.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_crossProductDVec3dDPoint3d
(
DVec3dP pCrossProduct,
DVec3dCP pVector1,
DPoint3dCP pPoint2
);

//!
//! @description Returns the (vector) cross product of two vectors.
//! @param pCrossProduct OUT     cross product of vector1 and vector2
//! @param pPoint1 IN      The first vector, givenn as a point.
//!        The point's xyz are understood to be a vector from the origin.
//! @param pVector2 IN      The second vector.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_crossProductDPoint3dDVec3d
(
DVec3dP pCrossProduct,
DPoint3dCP pPoint1,
DVec3dCP pVector2
);

//!
//! @description Returns the (scalar) dot product of two vectors.
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector, given as point.
//!        The point's xyz are understood to be a vector from the origin.
//! @return dot product of the two vectors.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_dotProductDVec3dDPoint3d
(
DVec3dCP pVector1,
DPoint3dCP pPoint2
);

//!
//! @description Returns the (vector) cross product of two vectors.
//!   The vectors are computed from the Origin to Target1 and Target2.
//! @param pCrossProduct OUT     product
//! @param pOrigin IN      The base point for computing vectors.
//! @param pTarget1 IN      The target point for the first vector.
//! @param pTarget2 IN      The target point for the second vector.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_crossProduct3DPoint3d
(
DVec3dP pCrossProduct,
DPoint3dCP pOrigin,
DPoint3dCP pTarget1,
DPoint3dCP pTarget2
);

//!
//! @description Return the (scalar) cross product of the xy parts of two vectors.
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The 2d cross product.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_crossProductXY
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Compute the normalized cross product of two vectors
//! and return the length of the unnormalized cross product.
//!
//! @param pCrossProduct OUT     normalized (unit) vector in the direction of the
//!           cross product of vector1 and vector2
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The length of the original (prenormalization) cross product vector
//!
Public GEOMDLLIMPEXP double bsiDVec3d_normalizedCrossProduct
(
DVec3dP pCrossProduct,
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Computes the cross product of the two parameter vectors and scales it to a given
//! length.  The scaled vector is stored as the product vector, and the length of the original
//! cross product vector is returned.
//!
//! @param pProduct OUT     vector of given length in direction of the cross product of 2 vectors.
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @param productLength IN      The Desired length
//! @return The length of original vector.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_sizedCrossProduct
(
DVec3dP pProduct,
DVec3dCP pVector1,
DVec3dCP pVector2,
double      productLength
);

//!
//! @description Computes the cross product of two vectors and scales it to the
//! geometric mean of the lengths of the two vectors.  This is useful
//! because it has the direction of the cross product (i.e. normal to the plane
//! of the two vectors) and a size in between the two vectors.
//!
//! @param pProduct OUT     cross product vector
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The length of original vector.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_geometricMeanCrossProduct
(
DVec3dP pProduct,
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Computes the triple product of three vectors.
//! The following are equivalent definitions of the triple product of three
//! vectors V1, V2, and V3:
//!
//! <UL>
//! <LI> (V1 cross V2) dot V3
//! <LI> V1 dot (V2 cross V3)
//! <LI>The determinant of the 3x3 matrix with the three vectors as its
//!               columns.
//! <LI>The determinant of the 3x3 matrix with the three vectors as its
//!               rows.
//! <LI>The (signed)volume of the parallelepiped whose 4 vertices are at the
//!               origin and at the ends of the 3 vectors placed at the
//!               origin.
//! </UL>
//!
//! @param pVector1 IN      The first vector.
//! @param pVector2 IN      The second vector.
//! @param pVector3 IN      The third vector.
//! @return The triple product
//!
Public GEOMDLLIMPEXP double bsiDVec3d_tripleProduct
(
DVec3dCP pVector1,
DVec3dCP pVector2,
DVec3dCP pVector3
);

//!
//! @description Returns the (scalar) dot product of two vectors.
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The dot product of the two vectors
//!
Public GEOMDLLIMPEXP double bsiDVec3d_dotProduct
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Returns the (scalar) dot product of xy parts of two vectors.
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The dot product of the xy parts of the two vectors
//!
Public GEOMDLLIMPEXP double bsiDVec3d_dotProductXY
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Computes the dot product of one vector given as a vector structure and another given as
//! xyz components.
//! @param pVector IN      The first vector.
//! @param ax IN      The x component of second vector.
//! @param ay IN      The y component of second vector.
//! @param az IN      The z component of second vector.
//! @return The dot product of the vector with a vector with the given components
//!
Public GEOMDLLIMPEXP double bsiDVec3d_dotXYZ
(
DVec3dCP pVector,
double    ax,
double    ay,
double    az
);

//!
//! @description Sets three vectors so that they are mutually
//! perpendicular, the third (Z) vector is identical to the
//! given axis vector, and all have the same length.
//! If the given axis vector contains only zeros, a (0,0,1) vector
//!   is used instead.
//!
//! @param pGivenAxis IN      input z direction vector
//! @param pXAxis OUT     x direction of the coordinate system
//! @param pYAxis OUT     y direction of the coordinate system
//! @param pZAxis OUT     z direction of the coordinate system
//! @return true unless given vector is z zero vector.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_getTriad
(
DVec3dCP pGivenAxis,
DVec3dP pXAxis,
DVec3dP pYAxis,
DVec3dP pZAxis
);

//!
//! @description Sets three vectors so that they are mutually
//! perpendicular unit vectors with the  third (Z) vector in the
//! direction of the given axis vector.
//! If the given axis vector contains only zeros, a (0,0,1) vector
//!   is used instead.
//!
//! @param pGivenAxis   IN      input z direction vector
//! @param    pXAxis      OUT     unit x direction vector
//! @param    pYAxis      OUT     unit y direction vector
//! @param    pZAxis      OUT     unit z direction vector
//! @return true unless given vector has zero length.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_getNormalizedTriad
(
DVec3dCP pGivenAxis,
DVec3dP pXAxis,
DVec3dP pYAxis,
DVec3dP pZAxis
);

//!
//! @description Apply a Givens to the two vectors, as if they are columns of a matrix to be postmultiplied
//! by the Givens matrx.
//! The Givens matrix is
//!       R(0,0)=R(1,1)=c
//!       R(0,1)=-s
//!       R(1,0)=s
//!
//! @param    pOut0   OUT     rotation of pIn0
//! @param    pOut1   OUT     rotation of pIn1
//! @param    pIn0    IN      first vector
//! @param    pIn1    IN      second vector
//! @param    c   IN      cosine of givens rotation.
//! @param    s   IN      sine of givens rotation.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_applyGivensRotation
(
DVec3dP pOut0,
DVec3dP pOut1,
DVec3dCP pIn0,
DVec3dCP pIn1,
double          c,
double          s
);

//!
//! @description Apply a hyperbolic rotation to the two vectors, as if they are columns of a matrix to be postmultiplied
//! by the hyperbolic matrix
//! The hyperbolic matrix is
//!       R(0,0)=R(1,1)=secant
//!       R(0,1)=R(1,0)= tangent
//!
//! @param    pOut0   OUT     rotation of pIn0
//! @param    pOut1   OUT     rotation of pIn1
//! @param    pIn0    IN      first vector
//! @param    pIn1    IN      second vector
//! @param    secant  IN      secant (diagonal) part of the hyperbolic transformation
//! @param    tangent IN      tangent (offdiagonal) part of the hyperbolic transformation
//!
Public GEOMDLLIMPEXP void bsiDVec3d_applyHyperbolicReflection
(
DVec3dP pOut0,
DVec3dP pOut1,
DVec3dCP pIn0,
DVec3dCP pIn1,
double          secant,
double          tangent
);

//!
//! @description Computes a unit vector  in the direction of the difference of the vectors
//! or vectors (Second parameter vector is subtracted from the first parameter vector,
//! exactly as in the subtract function.)
//!
//! @param pVector OUT     The normalized vector in direction (pTarget - pOrigin)
//! @param pTarget IN      The target point.
//! @param pOrigin IN      The origin point.
//! @return The length of original difference vector.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_computeNormal
(
DVec3dP pVector,
DPoint3dCP pTarget,
DPoint3dCP pOrigin
);

//!
//! @description Returns the angle between two vectors.  This angle is between 0 and
//! pi.  Rotating the first vector by this angle around the cross product
//! between the vectors aligns it with the second vector.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The angle between the vectors.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_angleBetweenVectors
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Returns the angle between two vectors, choosing the smaller
//!   of the two possible angles when both the vectors and their negations are considered.
//!    This angle is between 0 and pi/2.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The angle between the vectors.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_smallerAngleBetweenUnorientedVectors
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Test a vector is "between" vector0 and vector1.
//! If the vectors are coplanar and vector0 is neither parallel nor antiparallel
//! to vector1, betweenness has the expected meaning: there are two angles between
//! vector0 and vector1; one is less than 180; the test vector is tested to
//! see if it is in the smaller angle.
//! If the vectors are not coplanar, the test is based on the projection of
//! the test vector into the plane of the other two vectors.
//!
//! Zero testing is untoleranced, and is biased to all parallel conditions "false".
//! That is, if any pair of the input vectors is parallel or antiparallel,
//! the mathematical answer is false.  Floating point tolerances
//! will cause "nearby" cases to be unpredictable.  It is assumed that if
//! the caller considers the "parallel" cases important they will be
//! checked explicitly.
//!
//! @param pTestVector IN      The vector to test
//! @param pVector0 IN      The first boundary vector.
//! @param pVector1 IN      The second boundary vector.
//! @return true if the test vector is within the angle.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_isVectorInSmallerSector
(
DVec3dCP pTestVector,
DVec3dCP pVector0,
DVec3dCP pVector1
);

//!
//! @description Test if the test vector vector is "between" vector0 and vector1, with CCW direction resolved by an up vector.
//! @remarks The cross product of vector0 and vector1 is considered the positive plane normal if its dot product with the up vector is positive.
//! @remarks The containment test is strict in the sense that if the test vector equals a boundary vector, this function returns false.
//! @param pTestVector IN      The vector to test
//! @param pVector0 IN      The boundary vector
//! @param pVector1 IN      The boundary vector
//! @param pUpVector IN      The out of plane vector.  If null, the z-axis vector (001) is used.
//! @return true if test vector is within the angle.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_isVectorInCCWSector
(
DVec3dCP pTestVector,
DVec3dCP pVector0,
DVec3dCP pVector1,
DVec3dCP pUpVector
);

//!
//! @description Test if the test vector vector is "between" vector0 and vector1, in CCW sense using only xy-components of the 3 vectors.
//! @remarks The containment test is strict in the sense that if the xy-components of the test vector equal those of a boundary vector, this function returns false.
//! @param pTestVector IN      The vector to test
//! @param pVector0 IN      The boundary vector
//! @param pVector1 IN      The boundary vector
//! @return true if test vector is within the angle.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_isVectorInCCWXYSector
(
DVec3dCP pTestVector,
DVec3dCP pVector0,
DVec3dCP pVector1
);

//!
//! @description Returns the angle from Vector1 to Vector2 using only xy parts.
//!  This angle is between -pi and +pi.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The angle between vectors.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_angleBetweenVectorsXY
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Returns the angle between two vectors, considering both
//!   the vectors and their negations and choosing the smaller.
//!   This angle is between 0 and pi/2.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The angle between vectors.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_smallerAngleBetweenUnorientedVectorsXY
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Rotate a vector around the z axis.
//! @param pRotatedVector OUT     rotated vector
//! @param theta   IN      The rotation angle.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_rotateXY
(
DVec3dP pRotatedVector,
DVec3dCP pVector,
double      theta
);

//!
//! @description Rotate a vector around the z axis.
//! @param pVector IN OUT  rotated vector
//! @param theta   IN      The rotation angle.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_rotateXYInPlace
(
DVec3dP pVector,
double      theta
);

//!
//! @description Computes the signed angle from one vector to another, in the plane
//!       of the two vectors.   Initial computation using only the two vectors
//!       yields two possible angles depending on which side of the plane of the
//!       vectors is viewed.  To choose which side to view, go on the side whose
//!       normal has a positive dot product with the orientation vector.
//! This angle can be between -pi and +pi.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @param pOrientationVector IN      The vector used to determine orientation.
//! @return The signed angle
//!
Public GEOMDLLIMPEXP double bsiDVec3d_signedAngleBetweenVectors
(
DVec3dCP pVector1,
DVec3dCP pVector2,
DVec3dCP pOrientationVector
);

//!
//! @description Computes the signed angle between the projection of two vectors
//!       onto a plane with given normal.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @param pPlaneNormal IN      The plane normal vector
//! @return The angle in plane
//!
Public GEOMDLLIMPEXP double bsiDVec3d_planarAngleBetweenVectors
(
DVec3dCP pVector1,
DVec3dCP pVector2,
DVec3dCP pPlaneNormal
);

//!
//! @description Scale each (homogeneous) point by the other's weight and subtract, i.e. form
//! (point1 * point2.w - point2 * point1.w).  The weight term
//! vanishes.   Copy the xyz parts back as a vector.
//!
//! @param pDifference OUT     The difference vector
//! @param pHPoint1 IN      The first homogeneous point
//! @param pHPoint2 IN      The second homogeneous point.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_weightedDifference
(
DVec3dP pDifference,
DPoint4dCP pHPoint1,
DPoint4dCP pHPoint2
);

//!
//! @description Form the cross product of the weighted differences from base poitn
//!    to two targets
//!
//! @param pProduct OUT     cross product result
//! @param pBasePoint IN      The common base point (second point for differences)
//! @param pTarget1 IN      The first target point.
//! @param pTarget2 IN      The second target point.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_weightedDifferenceCrossProduct
(
DVec3dP pProduct,
DPoint4dCP pBasePoint,
DPoint4dCP pTarget1,
DPoint4dCP pTarget2
);

//!
//! @description Computes the squared magnitude of a vector.
//!
//! @param pVector IN      The vector whose magnitude is computed.
//! @return The squared magnitude of the vector.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_magnitudeSquared (DVec3dCP pVector);

//!
//! @description Computes the magnitude of the xy part of a vector.
//! @param pVector IN      The vector
//! @return The magnitude of the xy parts of the given vector.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_magnitudeXY (DVec3dCP pVector);

//!
//! @description Computes the squared magnitude of the xy part of a vector.
//! @param pVector IN      The vector
//! @return The squared magnitude of the xy parts of the given vector.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_magnitudeSquaredXY (DVec3dCP pVector);

//!
//! @description Compute a unit vector perpendicular to the xy parts of given vector.
//!
//! @remarks Input may equal output.
//!
//! @param pRotatedVector OUT     The rotated and scaled vector.  Z-coordinate is zero.
//! @param pVector        IN      The source vector
//! @return true if the input vector has nonzero length
//!
Public GEOMDLLIMPEXP bool     bsiDVec3d_unitPerpendicularXY
(
DVec3dP      pRotatedVector,
DVec3dCP      pVector
);

//!
//! @description Compute the unit vector perpendicular to the xy parts of the given vector with the given handedness.
//!
//! @remarks Input may equal output.
//!
//! @param pRotatedVector OUT     The rotated and scaled vector.  Z-coordinate is zero.
//! @param pVector        IN      The source vector
//! @param bRightHanded   IN      Whether the returned vector points to the right of the projection of the given vector in the xy-plane.
//! @return true if the input vector has nonzero length
//!
Public GEOMDLLIMPEXP bool     bsiDVec3d_unitPerpendicularXYWithHandedness
(
DVec3dP      pRotatedVector,
DVec3dCP      pVector,
bool        bRightHanded
);

//!
//! @description Computes the magnitude of a vector.
//! @param pVector IN      The vector
//! @return The length of the vector
//!
Public GEOMDLLIMPEXP double bsiDVec3d_magnitude (DVec3dCP pVector);

//!
//! Determines within angular tolerance if normals are parallel and pointing
//! in same direction.  Input -1 for dot0, dot1 to compute them in this function.
//!
//! @param pNormal0   IN      first normal
//! @param dot0       IN      squared magnitude of first normal (or -1)
//! @param pNormal1   IN      second normal
//! @param dot1       IN      squared magnitude of second normal (or -1)
//! @param eps2       IN      max sin^2(angle) for parallel normals
//! @return true if normals are same within tolerance
//!
Public GEOMDLLIMPEXP bool     bsiDVec3d_normalEqualTolerance
(
DVec3dCP pNormal0,
double          dot0,
DVec3dCP pNormal1,
double          dot1,
double          eps2
);

//!
//! @description Multiplies a vector by a scale factor.
//! @param pScaledVector OUT     The scaled vector.
//! @param pVector IN      The vector to be scaled.
//! @param scale IN      The scale factor.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_scale
(
DVec3dP pScaledVector,
DVec3dCP pVector,
double       scale
);

//!
//! @description Multiplies a vector (in place) by a scale factor.
//! @param pVector IN OUT  scaled vector
//! @param scale IN      The scale
//!
Public GEOMDLLIMPEXP void bsiDVec3d_scaleInPlace
(
DVec3dP pVector,
double       scale
);

//!
//! @description Computes a negated (opposite) vector.
//!
//! @param pNegated OUT     The negated vector.
//! @param pVector IN      The vector to be negated.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_negate
(
DVec3dP pNegatedVector,
DVec3dCP pVector
);

//!
//! @description Negate a vector in place.
//!
//! @param pVector IN OUT  negated vector
//!
Public GEOMDLLIMPEXP void bsiDVec3d_negateInPlace (DVec3dP pVector);

//!
//! @description Normalizes (scales) a vector to length 1.
//! If the input vector length is 0, the output vector is a zero vector
//! and the returned length is 0.
//!
//! @param pUnitVector OUT     The normalized vector.
//! @param pVector IN      The vector to be normalized.
//! @return The length prior to normalization
//!
Public GEOMDLLIMPEXP double bsiDVec3d_normalize
(
DVec3dP pUnitVector,
DVec3dCP pVector
);

//!
//! @description Scales a vector to specified length.
//! If the input vector length is 0, the output vector is a zero vector
//! and the returned length is 0.
//!
//! @param pScaledVector OUT     The scaled vector.
//! @param    pVector IN      The original vector.
//! @param    length IN      The requested length.
//! @return The length prior to scaling.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_scaleToLength
(
DVec3dP pScaledVector,
DVec3dCP pVector,
double    length
);

//!
//! @description Scales a vector to a specified length, and returns
//! the prior length.
//! If the input vector length is 0, the output vector is a zero vector
//! and the returned length is 0.
//!
//! @param pScaledVector OUT     scaled
//! @param    length IN      The requested length
//! @return The length prior to scaling.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_scaleToLengthInPlace
(
DVec3dP pScaledVector,
double    length
);

//!
//! @description Replaces a vector by a unit vector in the same direction, and returns
//! the original length.
//! If the input vector length is 0, the output vector is a zero vector
//! and the returned length is 0.
//!
//! @param pVector IN OUT  vector to be normalized
//! @return The length prior to normalization
//!
Public GEOMDLLIMPEXP double bsiDVec3d_normalizeInPlace (DVec3dP pVector);

//!
//! @description Computes a unit vector in the direction of a given vector.
//! If the input vector length is 0, the output vector is a zero vector.
//!
//! @param pUnitVector OUT     The normalized vector.
//! @param pVector IN      The vector to normalize.
//!
Public GEOMDLLIMPEXP void     bsiDVec3d_unitVector
(
DVec3dP pUnitVector,
DVec3dCP pVector
);

//!
//! @description Tests if two vectors are parallel.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return true if the vectors are parallel within tolerance
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_areParallel
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Tests if two vectors are perpendicular.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return true if vectors are perpendicular within tolerance
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_arePerpendicular
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Tests if two vectors are parallel.
//! @remarks Use bsiTrig_smallAngle() for tolerance corresponding to bsiDVec3d_areParallel.
//!
//! @param pVector1   IN      the first vector
//! @param pVector2   IN      the second vector
//! @param tolerance  IN      radian tolerance for angle between vectors
//! @return true if the vectors are parallel within tolerance
//!
Public GEOMDLLIMPEXP bool     bsiDVec3d_areParallelTolerance
(
DVec3dCP    pVector1,
DVec3dCP    pVector2,
double          tolerance
);

//!
//! @description Tests if two vectors are perpendicular.
//! @remarks Use bsiTrig_smallAngle() for tolerance corresponding to bsiDVec3d_arePerpendicular.
//!
//! @param pVector1   IN      the first vector
//! @param pVector2   IN      the second vector
//! @param tolerance  IN      radian tolerance for angle between vectors
//! @return true if the vectors are perpendicular within tolerance
//!
Public GEOMDLLIMPEXP bool     bsiDVec3d_arePerpendicularTolerance
(
DVec3dCP    pVector1,
DVec3dCP    pVector2,
double          tolerance
);

//!
//! @description Try to divide each component of a vector by a scalar.  If the denominator
//! near zero compared to any numerator component, return the original
//! vector.
//! @param pScaledVector OUT     The vector after scaling.
//! @param pVector IN      The initial vector.
//! @param denominator IN      The divisor.
//! @return true if division is numerically safe.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_safeDivide
(
DVec3dP pScaledVector,
DVec3dCP pVector,
double  denominator
);

//!
//! @description Return the angle component of the polar coordinates
//!           form of a vector.  Z part of the vector is ignored.
//! @param pVector IN      vector in xyz form.
//! @return angle from x axis to this vector, using only xy parts.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_polarAngle (DVec3dCP pVector);

//!
//! @description Sets all components of a vector to zero.
//! @param pVector OUT     The zeroed vector.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_zero (DVec3dP pVector);

//!
//! @description Returns a vector with all components 1.0.
//! @param pVector OUT     The initialized vector.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_one (DVec3dP pVector);

//!
//! @description Copies doubles from a 3 component array to the x,y, and z components
//! of a DVec3d
//!
//! @param pVector OUT     vector whose components are set
//! @param pXyz IN      x, y, z components
//!
Public GEOMDLLIMPEXP void bsiDVec3d_fromArray
(
DVec3dP pVector,
const   double      *pXyz
);

//!
//! @description Sets the x,y, and z components of a vector
//!
//! @param pVector OUT     vector whose componts are set.
//! @param ax IN      The x component.
//! @param ay IN      The y component.
//! @param az IN      The z component.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_setXYZ
(
DVec3dP pVector,
double       ax,
double       ay,
double       az
);

//!
//! @description Initialize a vector from a point (treating the point
//!            as a vector from its origin).
//! @param pVector OUT     vector whose componts are set.
//! @param pPoint IN      the point.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_fromDPoint3d
(
DVec3dP pVector,
DPoint3dCP pPoint
);

//!
//! @description Sets the x, and y components of a vector. Sets z to zero.
//!
//! @param pVector OUT     vector whose componts are set.
//! @param ax IN      The x component.
//! @param ax IN      The x component.
//! @param ay IN      The y component
//!
Public GEOMDLLIMPEXP void bsiDVec3d_setXY
(
DVec3dP pVector,
double       ax,
double       ay
);

//!
//! @description Sets a vector from given angle and distance in xy plane.
//!       Z part is set to zero.
//!
//! @param pVector OUT     vector whose componts are set.
//! @param theta IN      Angle from X axis to the vector, in the xy plane.
//! @param magnitude IN      Vector magitude
//!
Public GEOMDLLIMPEXP void bsiDVec3d_fromXYAngleAndMagnitude
(
DVec3dP pVector,
double       theta,
double       magnitude
);

//!
//! @description Sets the x,y, and z components of a DVec3d structure from the
//! corresponding parts of a DPoint4d.  Weight part of DPoint4d is not used.
//!
//! @param pVector OUT     vector whose components are set
//! @param pHPoint IN      The homogeneous point
//!
Public GEOMDLLIMPEXP void bsiDVec3d_getXYZ
(
DVec3dP pVector,
DPoint4dCP pHPoint
);

//!
//! @description Set one of three components (x,y,z) of the vector.
//!
//! @param pVector OUT     vector whose component is set.
//! @param a IN      The component value.
//! @param index IN      Selects the the axis: 0=x, 1=y, 2=z, others cyclic.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_setComponent
(
DVec3dP pVector,
double       a,
int         index
);

//!
//! @description Gets a single component of a vector.  If the index is out of
//! range 0,1,2, it is interpreted cyclically.
//!
//! @param pVector IN      vector whose component is accessed.
//! @param index IN      Indicates which component is accessed.  The values
//!                       are 0=x, 1=y, 2=z.  Other values are treated cyclically.
//! @return The specified component of the vector.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_getComponent
(
DVec3dCP pVector,
int         index
);

//!
//! @description Copies x,y,z components from a vector to individual variables.
//!
//! @param pVector IN      source vector
//! @param pXCoord OUT     x component
//! @param pYCoord OUT     y component
//! @param pZCoord OUT     z component
//!
Public GEOMDLLIMPEXP void bsiDVec3d_getComponents
(
DVec3dCP pVector,
double      *pXCoord,
double      *pYCoord,
double      *pZCoord
);

//!
//! @description Compute the sum of two vectors or vectors.
//!
//! @param pSum OUT     The computed sum.
//! @param pVector1 IN      The the first vector
//! @param pVector2 IN      The second vector
//!
Public GEOMDLLIMPEXP void bsiDVec3d_add
(
DVec3dP pSum,
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Adds a vector to a pointer or vector, returns the result in place.
//!
//! @param pSum IN OUT  The vector to be modified.
//! @param pVector IN      The vector to add.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_addInPlace
(
DVec3dP pSum,
DVec3dCP pVector
);

//!
//! @description Subtract two vectors, and return the result in
//!           place of the first.
//!
//! @param pVector2 IN OUT  The vector to be modified.
//! @param pVector2 IN      The vector to subtract.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_subtractInPlace
(
DVec3dP pVector1,
DVec3dCP pVector2
);

//!
//! @description Adds an origin and a scaled vector.
//!
//! @param pSum OUT     The sum
//! @param pOrigin IN      Origin for the sum.
//! @param pVector IN      The vector to be added.
//! @param scale IN      The scale factor.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_addScaled
(
DVec3dP pSum,
DVec3dCP pOrigin,
DVec3dCP pVector,
double           scale
);

//!
//! @description Computes a vector whose position is given by a fractional
//! argument and two vectors.
//!
//! @param pSum OUT     The interpolated vector.
//! @param pVector0 IN      The vector corresponding to fractionParameter of 0.
//! @param fractionParameter IN      The fractional parametric coordinate.
//!               0.0 is the start of the segment, 1.0 is the end, 0.5 is middle
//! @param pVector1 IN      The vector corresponding to fractionParameter of 1.
//!
Public GEOMDLLIMPEXP void bsiDVec3d_interpolate
(
DVec3dP pSum,
DVec3dCP pVector0,
double       fractionParameter,
DVec3dCP pVector1
);

//!
//! @description Adds an origin and two scaled vectors.
//!
//! @param pSum OUT     sum
//! @param pOrigin IN      The origin.  May be null.
//! @param pVector1 IN      The first direction vector
//! @param scale1 IN      The first scale factor
//! @param pVector2 IN      The second direction vector
//! @param scale2 IN      The second scale factor
//!
Public GEOMDLLIMPEXP void bsiDVec3d_add2ScaledDVec3d
(
DVec3dP pSum,
DVec3dCP pOrigin,
DVec3dCP pVector1,
double           scale1,
DVec3dCP pVector2,
double           scale2
);

//!
//! @description Adds an origin and three scaled vectors.
//!
//! @param pSum OUT     The sum.
//! @param pOrigin IN      The origin. May be null
//! @param pVector1 IN      The first direction vector
//! @param scale1 IN      The first scale factor
//! @param pVector2 IN      The second direction vector
//! @param scale2 IN      The second scale factor
//! @param pVector3 IN      The third direction vector
//! @param scale3 IN      The third scale factor
//!
Public GEOMDLLIMPEXP void bsiDVec3d_add3ScaledDVec3d
(
DVec3dP pSum,
DVec3dCP pOrigin,
DVec3dCP pVector1,
double          scale1,
DVec3dCP pVector2,
double          scale2,
DVec3dCP pVector3,
double          scale3
);

//!
//! @description Subtract coordinates of two vectors. (Compute Vector1 - Vector2)
//!
//! @param pVector OUT     The difference vector
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second (subtracted) vector
//!
Public GEOMDLLIMPEXP void bsiDVec3d_subtract
(
DVec3dP pVector,
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Subtract coordinates of two points. (Compute Point1 - Point2)
//!
//! @param pVector OUT     The difference vector
//! @param pTarget IN      The target point
//! @param pBase IN      The base point
//!
Public GEOMDLLIMPEXP void bsiDVec3d_subtractDPoint3dDPoint3d
(
DVec3dP pVector,
DPoint3dCP pTarget,
DPoint3dCP pBase
);

//!
//! @description Computes the (cartesian) distance between two vectors
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The distance between vector.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_distance
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Computes the squared distance between two vectors.
//!
//! @param pVector1 IN      The first vector.
//! @param pVector2 IN      The second vector.
//! @return The squared distance between the vectors.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_distanceSquared
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Computes the squared distance between two vectors, using only the
//!       xy parts.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The squared distance between the XY projections of the two vectors.
//!               (i.e. any z difference is ignored)
//!
Public GEOMDLLIMPEXP double bsiDVec3d_distanceSquaredXY
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Computes the distance between two vectors, using
//!   only x and y components.
//!
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The distance between the XY projections of the two vectors.
//!               (i.e. any z difference is ignored)
//!
Public GEOMDLLIMPEXP double bsiDVec3d_distanceXY
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Finds the largest absolute value among the components of a vector.
//! @param pVector IN      The vector
//! @return The largest absolute value among vector coordinates.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_maxAbs (DVec3dCP pVector);

//!
//! @description Finds the largest absolute value among the components of a
//! difference of vectors.
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return The largest absolute value among vector coordinates.
//!
Public GEOMDLLIMPEXP double bsiDVec3d_maxAbsDifference
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Test for exact equality between all components of two vectors.
//! @param pVector1 IN      The first vector
//! @param pVector2 IN      The second vector
//! @return true if the vectors are identical.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_equal
(
DVec3dCP pVector1,
DVec3dCP pVector2
);

//!
//! @description Test if the x, y, and z components of two vectors are
//!   equal within tolerance.
//! Tests are done independently using the absolute value of each component differences
//! (i.e. not the magnitude or sum of squared differences)
//!
//! @param pVector1 IN      The first vector.
//! @param pVector2 IN      The second vector.
//! @param tolerance IN      The tolerance.
//! @return true if all components are within given tolerance of each other.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_equalTolerance
(
DVec3dCP pVector1,
DVec3dCP pVector2,
double                  tolerance
);

//!
//! @description Decompose a vector into two perpendicular parts.  One part is
//!   parallel to a reference vector, the other is perpendicular.
//! @param pVector IN vector to decompose.
//! @param pParallelPart OUT part parallel to reference vector
//! @param pPerpendicularPart OUT part perpendicular to reference vector
//! @param pFraction IN size of the parallel part as a fraction of the reference vector.
//! @param pRefVector IN reference vector.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_perpendicularParts
(
DVec3dCP pVector,
DVec3dP  pParallelPart,
DVec3dP  pPerpendicularPart,
double*  pFraction,
DVec3dCP pRefVector
);

//!
//! @description Sweep the vector along a specified direction until it is perependicular to a plane normal.
//! @param pVectorIN known vector
//! @param pResult OUT initialized vector
//! @param pSweepMultiplier OUT muliplier of sweep vector.
//! @param pSweepDirection IN direction to project.  If NULL, the plane normal is used.
//! @param pPlane IN the target plane.
//! @return false if projection direction is parallel to the plane.  The result
//!    is then a copy of the source.
//!
Public GEOMDLLIMPEXP bool    bsiDVec3d_sweepToPlane
(
DVec3dCP    pVector,
DVec3dP     pResult,
double *    pSweepMultiplier,
DVec3dCP    pSweepDirection,
DPlane3dCP  pPlane
);

//!
//! @description Compute a normalized vector that lies between the given vectors at a fraction of the (smaller) angle spanned by the vectors.
//! @remarks In general, the vector returned by this function differs from the vector returned by ~mbsiDVec3d_interpolate.
//! @remarks Input vectors do not have to be normalized.
//! @remarks If the given parameter is <=0 (>=1), the interpolant is bit-copied from pVector0 (pVector1).
//! @remarks If the vectors are not diametrically opposed, their cross product is the rotation axis; otherwise, the rotation axis is the cross
//!       product of the first with the third vector.
//!
//! @param pSum                       OUT     the interpolated, normalized vector
//! @param pVector0                   IN      vector corresponding to parameter 0.0
//! @param angularFractionParameter   IN      the angular fraction in [0,1] at which to construct the interpolant
//! @param pVector1                   IN      vector corresponding to parameter 1.0
//! @param pDefaultPlaneVector        IN      vector in default rotation plane (used only if given vectors are antiparallel)
//! @return false iff a given vector is zero.
//!
Public GEOMDLLIMPEXP bool     bsiDVec3d_interpolateNormals
(
DVec3dP  pSum,
DVec3dCP  pVector0,
double  angularFractionParameter,
DVec3dCP  pVector1,
DVec3dCP  pDefaultPlaneVector
);

END_BENTLEY_NAMESPACE

