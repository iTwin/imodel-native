<#
.SYNOPSIS
    Script to compare native and managed roundtrip implimentations.
.DESCRIPTION
    Roundtrips ECSchema(s) through native and managed and checks the output of
    each to ensure both roundtrips produce the same ECSchema.
.PARAMETER Schema
    Path of the target ECSchema to roundrip.
.PARAMETER SchemaDirs
    Array of directories containing ECShemas XML files to roundtrip.
.PARAMETER RefDirs
    Array of reference directories.
.PARAMETER NativeSchemaRoundtrip
    Path of the native SchemaRoundtrip executable.
.PARAMETER NativeSchemaComparison
    Path of the native SchemaComparison executable.
.PARAMETER ManagedECSchemaUtility
    Path of the managed ECShemaUtility executable.
.PARAMETER OutputLogsOnError
    Write out log statements generated by the failing executable if an error
    occurs.
.PARAMETER ContinueOnError
    Continue processing the current and remaining schemas on error.
.PARAMETER EnableWriteDebug
    Write out Powershell debug statements.
.NOTES
    Author: Victor Cushman
    Date  : 10/2017
#>

Param(
    [Parameter(Mandatory=$True, ParameterSetName="SchemaSingle")] [string]   $Schema,
    [Parameter(Mandatory=$True, ParameterSetName="SchemaDir")]    [string[]] $SchemaDirs,
    [Parameter(Mandatory=$False)] [string[]] $RefDirs,
    [Parameter(Mandatory=$True)]  [string]   $NativeSchemaRoundtrip,
    [Parameter(Mandatory=$True)]  [string]   $NativeSchemaComparison,
    [Parameter(Mandatory=$True)]  [string]   $ManagedECSchemaUtility,
    [Parameter(Mandatory=$False)] [switch]   $OutputLogsOnError,
    [Parameter(Mandatory=$False)] [switch]   $ContinueOnError,
    [Parameter(Mandatory=$False)] [switch]   $EnableWriteDebug
)
$ParamSet = $PsCmdlet.ParameterSetName

### Constants
# Parameter annotations are essentially named comments, so there's no way to
# use constants for them. The best that can be done is write them as literals
# and duplicate those literals below (thanks Microsoft). If the parameter
# annoations are ever changed, be sure to change both the annotation string
# literals and these constants.
[string] $PARAM_SET_SCHEMA_SINGLE = "SchemaSingle"
[string] $PARAM_SET_SCHEMA_DIR    = "SchemaDir"

$EXIT_SUCCESS = 0
$EXIT_FAILURE = 1
$NATIVE_ROUNDTRIP_EXIT_SUCCESS  = $EXIT_SUCCESS
$NATIVE_SCHEMAS_EQ_EXIT_STATUS  = $EXIT_SUCCESS
$MANAGED_ROUNDTRIP_EXIT_SUCCESS = $EXIT_SUCCESS
$MANAGED_SCHEMAS_EQ_EXIT_STATUS = $EXIT_SUCCESS

[string] $STRING_COULD_NOT_FIND_SCHEMA     = "Could not find schema"
[string] $STRING_COULD_NOT_FIND_EXECUTABLE = "Could not find executable"
[string] $STRING_COULD_NOT_FIND_DIR        = "Could not find directory"
[string] $STRING_SCHEMAS_EQ                = "The schemas are equal"
[string] $STRING_HR                        = "========================================================================================================================"
### !Constants

### Functions
function ArrayToString
    {
    Param([Parameter(Mandatory=$True)] [Object[]] $Arr)
    $OutStr = ""
    Foreach ($s in $Output)
        {
        $OutStr += $s + "`n"
        }
    return $OutStr
    }

function MatchSchema
    {
    Param(
        [Parameter(Mandatory=$True)] [string] $SchemaBaseName,
        [Parameter(Mandatory=$True)] [string] $Dir
    )
    $SchemaNoExtension = $SchemaBaseName
    $Ext = [System.IO.Path]::GetExtension($SchemaNoExtension)
    While ($Ext -ne [System.String]::Empty)
        {
        $SchemaNoExtension = [System.IO.Path]::GetFileNameWithoutExtension($SchemaNoExtension)
        $Ext = [System.IO.Path]::GetExtension($SchemaNoExtension)
        }
    [string] $MatchedSchemaFullPath = Get-ChildItem -Path "$Dir`\$SchemaNoExtension.*ecschema.xml"
    return $MatchedSchemaFullPath
    }

function RemoveDir
    {
    Param([Parameter(Mandatory=$True)] [string] $Dir)
    If (Test-Path $Dir -PathType Container)
        {
        # Remove-Item doesn't always work properly with -Recurse (thanks Microsoft), so cmd rmdir is used instead.
        &cmd.exe /c rmdir /S /Q "$Dir"
        }
    }

function WriteValidateSchemaErrorToOutput
    {
    Param(
        [Parameter(Mandatory=$True)] [string]   $Stage,
        [Parameter(Mandatory=$True)] [string[]] $ExeOutput,
        [Parameter(Mandatory=$True)] [int]      $ExitCode
    )
    Write-Output "ERROR DURING STAGE: $Stage (EXIT STATUS $ExitCode)"
    If ($OutputLogsOnError.IsPresent)
        {
        Write-Output $ExeOutput
        }
    }

function ValidateSchema
    {
    Param(
        [Parameter(Mandatory=$True)]  [string]   $Schema,
        [Parameter(Mandatory=$False)] [string[]] $RefDirs,
        [Parameter(Mandatory=$True)]  [string]   $OutputDirNative,
        [Parameter(Mandatory=$True)]  [string]   $OutputDirManaged
    )

    [string] $SchemaBaseName = [System.IO.Path]::GetFileName($Schema)

    # -r|--ref formatting for reference directories.
    [string[]] $RefFmt = @()
    ForEach ($Dir in $RefDirs)
        {
        $RefFmt += "-r"
        $RefFmt += $Dir
        }

    Write-Output "TESTING SCHEMA: $Schema"

    ## Roundtrip schemas through native.
    Write-Debug "(1) Roundtrip though Native."
    # Check if current schema has a version in the filename
    [string] $NoVersion = ""
    if (-not ($Schema -imatch "\D*?\.\d{1,2}\.\d{1,2}\.(\d{1,2}\.)?ecschema\.xml"))
        {
        [string] $NoVersion = "--noversion"
        }
    Write-Debug "$NativeSchemaRoundtrip -i $Schema -o $OutputDirNative $RefFmt $NoVersion"
    $Output   = &$NativeSchemaRoundtrip -i $Schema -o $OutputDirNative $RefFmt $NoVersion
    $NativeRoundTripExitCode = $lastExitCode
    if ($NativeRoundTripExitCode -ne $NATIVE_ROUNDTRIP_EXIT_SUCCESS)
        {
        $OutputStr = ArrayToString $Output
        WriteValidateSchemaErrorToOutput -Stage "Native roundtrip" -ExeOutput $OutputStr -ExitCode $NativeRoundTripExitCode
        If (-not $ContinueOnError.IsPresent)
            {
            exit $EXIT_FAILURE
            }
        $MatchedSchema = MatchSchema -SchemaBaseName $SchemaBaseName -Dir $OutputDirNative
        }

    ## Compare original vs round-tripped schemas in managed.
    If (($NativeRoundTripExitCode -eq $NATIVE_ROUNDTRIP_EXIT_SUCCESS) -and (-not ([string]::IsNullOrEmpty($MatchedSchema))))
        {
        Write-Debug "(1) Compare in Managed."
        Write-Debug "$ManagedECSchemaUtility compare $Schema $MatchedSchema $RefFmt"
        $Output   = &$ManagedECSchemaUtility compare $Schema $MatchedSchema $RefFmt
        if ($lastExitCode -ne $MANAGED_SCHEMAS_EQ_EXIT_STATUS)
            {
            $OutputStr = ArrayToString $Output
            WriteValidateSchemaErrorToOutput -Stage "Compare Native roundtrip in Managed" -ExeOutput $OutputStr -ExitCode $lastExitCode
            If (-not $ContinueOnError.IsPresent)
                {
                exit $EXIT_FAILURE
                }
            }
        else
            {
            Write-Debug $STRING_SCHEMAS_EQ
            }
        }

    ## Roundtrip schemas through managed.
    Write-Debug "(2) Roundtrip though Managed."
    Write-Debug "$ManagedECSchemaUtility roundtrip $Schema $OutputDirManaged $RefFmt"
    $Output   = &$ManagedECSchemaUtility roundtrip $Schema $OutputDirManaged $RefFmt
    $ManagedRoundTripExitCode = $lastExitCode
    if ($ManagedRoundTripExitCode -ne $MANAGED_ROUNDTRIP_EXIT_SUCCESS)
        {
        $OutputStr = ArrayToString $Output
        WriteValidateSchemaErrorToOutput -Stage "Managed roundtrip" -ExeOutput $OutputStr -ExitCode $NativeRoundTripExitCode
        If (-not $ContinueOnError.IsPresent)
            {
            exit $EXIT_FAILURE
            }
        $MatchedSchema = MatchSchema -SchemaBaseName $SchemaBaseName -Dir $OutputDirManaged
        }

    ## Compare original vs round-tripped schemas in native.
    if (($ManagedRoundTripExitCode -eq $MANAGED_ROUNDTRIP_EXIT_SUCCESS) -and (-not ([string]::IsNullOrEmpty($MatchedSchema))))
        {
        Write-Debug "(2) Compare in Native."
        Write-Debug "$NativeSchemaComparison -i $Schema -i $MatchedSchema $RefFmt"
        $Output   = &$NativeSchemaComparison -i $Schema -i $MatchedSchema $RefFmt
        if ($lastExitCode -ne $NATIVE_SCHEMAS_EQ_EXIT_STATUS)
            {
            $OutputStr = ArrayToString $Output
            WriteValidateSchemaErrorToOutput -Stage "Compare Managed roundtrip in Native" -ExeOutput $OutputStr -ExitCode $lastExitCode
            If (-not $ContinueOnError.IsPresent)
                {
                exit $EXIT_FAILURE
                }
            }
        else
            {
            Write-Debug $STRING_SCHEMAS_EQ
            }
        }
    }
### !Functions

Try
    {
    If ($EnableWriteDebug.IsPresent)
        {
        $DebugPreference = "Continue"
        }

    ## Check all files exist
    If (-not (Test-Path $NativeSchemaRoundtrip -PathType Leaf))
        {
        throw [System.IO.FileNotFoundException]::New($STRING_COULD_NOT_FIND_EXECUTABLE, $NativeSchemaRoundtrip)
        }
    If (-not (Test-Path $NativeSchemaComparison -PathType Leaf))
        {
        throw [System.IO.FileNotFoundException]::New($STRING_COULD_NOT_FIND_EXECUTABLE, $NativeSchemaComparison)
        }
    If (-not (Test-Path $ManagedECSchemaUtility -PathType Leaf))
        {
        throw [System.IO.FileNotFoundException]::New($STRING_COULD_NOT_FIND_EXECUTABLE, $ManagedECSchemaUtility)
        }

    If ($ParamSet -eq $PARAM_SET_SCHEMA_DIR)
        {
        If ($SchemaDirs.Length -eq 0)
            {
            throw [System.Exception]::New([string]"List of schema directories is empty")
            }
        Write-Output "SCHEMA DIRECTORIES:"
        ForEach ($Dir in $SchemaDirs)
            {
            Write-Output "`t$Dir"
            If (-not (Test-Path $Dir -PathType Container))
                {
                throw [System.IO.FileNotFoundException]::New($STRING_COULD_NOT_FIND_DIR, $Dir)
                }
            }
        }
    ElseIf ($ParamSet -eq $PARAM_SET_SCHEMA_SINGLE)
        {
        If (-not (Test-Path $Schema -PathType Leaf))
            {
            throw [System.IO.FileNotFoundException]::New($STRING_COULD_NOT_FIND_SCHEMA, $Schema)
            }
        Write-Output "SCHEMA:" "`t$Schema"
        }

    Write-Output "REFERENCE DIRECTORIES:"
    ForEach ($Dir in $RefDirs)
        {
        Write-Output "`t$Dir"
        If (-not (Test-Path $Dir -PathType Container))
            {
            throw [System.IO.FileNotFoundException]::New($STRING_COULD_NOT_FIND_DIR, $Dir)
            }
        }

    ## Set up temporary directory for storing roundtrip output files.
    # [string] $TmpDir = $env:TMP + "\" + ([System.IO.FileInfo]$MyInvocation.MyCommand.Name).BaseName
    [string] $TmpDir = $env:OutRoot + "Winx64\Product\SchemaRoundtripValidation\OutSchemas"
    Write-Debug "Output schemas will be written to $TmpDir"
    [string] $NativeOutDir  = "$TmpDir`\native_roundtrip`\"
    [string] $ManagedOutDir = "$TmpDir`\managed_roundtrip`\"
    RemoveDir -Dir $TmpDir # Clean from pevious script runs.
    New-Item -ItemType Directory -Force -Path $TmpDir >$null 2>&1 # See TMP%\<this script's name> for roundtripped schemas
    New-Item -ItemType Directory -Force -Path $NativeOutDir  >$null 2>&1
    New-Item -ItemType Directory -Force -Path $ManagedOutDir >$null 2>&1

    If ($ParamSet -eq $PARAM_SET_SCHEMA_DIR)
        {
        ForEach ($Dir in $SchemaDirs)
            {
            $SchemaFiles = Get-ChildItem -Path "$Dir\*.ecschema.xml" -Recurse -Force
            ForEach ($s in $SchemaFiles)
                {
                ValidateSchema -Schema $s -RefDirs $RefDirs -OutputDirNative $NativeOutDir -OutputDirManaged $ManagedOutDir
                If ($OutputLogsOnError.IsPresent -or $ContinueOnError.IsPresent -or $EnableWriteDebug.IsPresent)
                    {
                     # Use HRs to make output more readable in the case of dense output settings
                    Write-Output $STRING_HR
                    }
                }
            }
        }
    ElseIf ($ParamSet -eq $PARAM_SET_SCHEMA_SINGLE)
        {
        ValidateSchema -Schema $Schema -RefDirs $RefDirs -OutputDirNative $NativeOutDir -OutputDirManaged $ManagedOutDir
        }
    }
Catch [System.IO.FileNotFoundException]
    {
    Write-Error -Message ($PSItem.Exception.Message + " " + $PSItem.Exception.FileName)
    exit $EXIT_FAILURE
    }
Catch
    {
    Write-Error -Message $_.Exception.Message
    exit $EXIT_FAILURE
    }

exit $EXIT_SUCCESS
