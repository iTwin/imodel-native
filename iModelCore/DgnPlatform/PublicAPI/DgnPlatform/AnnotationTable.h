/*--------------------------------------------------------------------------------------+
|
|     $Source: PublicAPI/DgnPlatform/AnnotationTable.h $
|
|  $Copyright: (c) 2016 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#pragma once
//__PUBLISH_SECTION_START__

#include <Bentley/RefCounted.h>
#include <Bentley/WString.h>
#include <ECDb/ECSqlStatement.h>
#include <DgnPlatform/Annotations/AnnotationTextBlockLayout.h>
#include <Bentley/stdcxx/bstdmap.h>

DGNPLATFORM_TYPEDEFS (AnnotationTableCellIndex);
DGNPLATFORM_TYPEDEFS (AnnotationTableSymbologyValues);
DGNPLATFORM_TYPEDEFS (AnnotationTable);
DGNPLATFORM_TYPEDEFS (AnnotationTableAspect);
DGNPLATFORM_TYPEDEFS (AnnotationTableCell);
DGNPLATFORM_TYPEDEFS (AnnotationTableRow);
DGNPLATFORM_TYPEDEFS (AnnotationTableColumn);
DGNPLATFORM_TYPEDEFS (TableCellMarginValues);
DGNPLATFORM_TYPEDEFS (PropertyNames);

DGNPLATFORM_TYPEDEFS (CellContentHolder);
DGNPLATFORM_TYPEDEFS (SymbologyEntry);
DGNPLATFORM_TYPEDEFS (MergeEntry);
DGNPLATFORM_TYPEDEFS (AnnotationTableEdgeRun);
DGNPLATFORM_TYPEDEFS (EdgeRuns);
DGNPLATFORM_TYPEDEFS (AnnotationTableFillRun);
DGNPLATFORM_TYPEDEFS (FillRuns);

//__PUBLISH_SECTION_END__
DGNPLATFORM_TYPEDEFS (TextBlockHolder);
//__PUBLISH_SECTION_START__

DGNPLATFORM_REF_COUNTED_PTR(AnnotationTable);

#define BIS_CLASS_AnnotationTable           "AnnotationTable"
#define BIS_CLASS_AnnotationTableHeader     "AnnotationTableHeader"
#define BIS_CLASS_AnnotationTableRow        "AnnotationTableRow"
#define BIS_CLASS_AnnotationTableColumn     "AnnotationTableColumn"
#define BIS_CLASS_AnnotationTableCell       "AnnotationTableCell"
#define BIS_CLASS_AnnotationTableMerge      "AnnotationTableMerge"
#define BIS_CLASS_AnnotationTableSymbology  "AnnotationTableSymbology"
#define BIS_CLASS_AnnotationTableEdgeRun    "AnnotationTableEdgeRun"

BEGIN_BENTLEY_DGN_NAMESPACE

typedef std::shared_ptr<CellContentHolder>  CellContentHolderPtr;

//=======================================================================================
//! Specifies a <row, col> position within a table.
//! @ingroup GROUP_Annotation
//=======================================================================================
struct AnnotationTableCellIndex
{
private:
    static int const    _LT_ = -1;
    static int const    _EQ_ =  0;
    static int const    _GT_ =  1;

    inline int compare (AnnotationTableCellIndex const& other) const
        {
        if (row < other.row)                        return _LT_;
        if (row > other.row)                        return _GT_;
        if (col < other.col)                        return _LT_;
        if (col > other.col)                        return _GT_;

        return  _EQ_;
        }

//__PUBLISH_SECTION_END__
public:
    static AnnotationTableCellIndex     GetCellIndex (BeSQLite::EC::ECSqlStatement&, uint32_t colIndex);
    static void                         BindCellIndex (BeSQLite::EC::ECSqlStatement&, Utf8CP paramName, AnnotationTableCellIndexCR);

//__PUBLISH_SECTION_START__
public:
    uint32_t    row;
    uint32_t    col;

    //! Construct an index for cell 0,0.
    AnnotationTableCellIndex () : row(0), col(0) {}

    //! Construct an index for a specified cell.
    AnnotationTableCellIndex (uint32_t r, uint32_t c) : row(r), col(c) {}

    //! Test two indices for relative value.
    bool operator>  (AnnotationTableCellIndex const& other) const {return      compare (other) >  _EQ_;}
    //! Test two indices for relative value.
    bool operator<  (AnnotationTableCellIndex const& other) const {return      compare (other) <  _EQ_;}
    //! Test two indices for relative value.
    bool operator>= (AnnotationTableCellIndex const& other) const {return      compare (other) >= _EQ_;}
    //! Test two indices for relative value.
    bool operator<= (AnnotationTableCellIndex const& other) const {return      compare (other) <= _EQ_;}
    //! Test two indices for equality.
    bool operator== (AnnotationTableCellIndex const& other) const {return      compare (other) == _EQ_;}
    //! Test two indices for equality.
    bool operator!= (AnnotationTableCellIndex const& other) const {return      compare (other) != _EQ_;}

    //! Create a string representation of the index.
    DGNPLATFORM_EXPORT          Utf8String     ToString() const;

    //! Initialize an index from a string in the format generated by ToString.
    DGNPLATFORM_EXPORT static   BentleyStatus  FromString (AnnotationTableCellIndexR, Utf8CP);

    //! Create a string representation for a row index.
    DGNPLATFORM_EXPORT static   Utf8String StringFromRowIndex      (uint32_t);
    //! Create a string representation for a column index.
    DGNPLATFORM_EXPORT static   Utf8String StringFromColumnIndex   (uint32_t);

    //! Get the row index value from a string.
    DGNPLATFORM_EXPORT static   BentleyStatus  RowIndexFromString      (uint32_t&, Utf8CP);
    //! Get the cell index value from a string.
    DGNPLATFORM_EXPORT static   BentleyStatus  ColumnIndexFromString   (uint32_t&, Utf8CP);
};

//=======================================================================================
//! This enum represents the distinct regions within a TextTable.  A table can hold
//! a unique TextStyle for each region that will be used when adding text to an empty cell.
//! @ingroup GROUP_Annotation
//=======================================================================================
enum class AnnotationTableRegion
    {
    Body            = 0,
    TitleRow        = 1,
    HeaderRow       = 2,
    FooterRow       = 3,
    HeaderColumn    = 4,
    FooterColumn    = 5,
    };

//=======================================================================================
//! Used by TextTable::InsertRow and TextTable::InsertColumn.
//! @ingroup GROUP_Annotation
//=======================================================================================
enum class TableInsertDirection
    {
    Before          = 0,
    After           = 1,
    };

//=======================================================================================
//! Describes how a table is broken up to be displayed as sub tables.
//! @ingroup GROUP_Annotation
//=======================================================================================
enum class TableBreakType
    {
    None            = 0,
    Horizontal      = 1,
    Vertical        = 2,
    };

//=======================================================================================
//! Describes how each sub table is positioned relative to the previous sub table.
//! @ingroup GROUP_Annotation
//=======================================================================================
enum class TableBreakPosition
    {
    Right           = 0,
    Left            = 1,
    Above           = 2,
    Below           = 3,
    Manual          = 4,
    };

//=======================================================================================
//! Describes how text will be positioned within a table cell.
//! @ingroup GROUP_Annotation
//=======================================================================================
enum class TableCellAlignment
    {
    LeftTop         = 0,
    LeftMiddle      = 1,
    LeftBottom      = 2,
    CenterTop       = 3,
    CenterMiddle    = 4,
    CenterBottom    = 5,
    RightTop        = 6,
    RightMiddle     = 7,
    RightBottom     = 8,
    };

//=======================================================================================
//! Describes how text within a cell will be rotated relative to the table.
//! @ingroup GROUP_Annotation
//=======================================================================================
enum class TableCellOrientation
    {
    Horizontal      = 0,
    Rotate90        = 1,
    Rotate270       = 2,
    Vertical        = 3,
    };

//=======================================================================================
//! Describes the type of a table row or column.
//! @ingroup GROUP_Annotation
//=======================================================================================
enum class TableHeaderFooterType
    {
    Title           = 0,
    Header          = 1,
    Body            = 2,
    Footer          = 3,
    };

//=======================================================================================
//! Describes the various edge lines that surround a group of one or more table cells.
//! @ingroup GROUP_Annotation
//=======================================================================================
enum TableCellListEdges
    {
    Top                   = 0,
    Bottom                = 1,
    Left                  = 2,
    Right                 = 3,
    Interior              = 4,
    Exterior              = 5,
    InteriorHorizontal    = 6,
    InteriorVertical      = 7,
    All                   = 50,
    };

//=======================================================================================
//! Used to specify the default fill of a table row.
//! @ingroup GROUP_Annotation
//=======================================================================================
enum class TableRows
    {
    Odd             = 0,
    Even            = 1,
    All             = 50,
    };

//=======================================================================================
//! Used to specify the minimum gap between a cell's contents and its edges.
//! @ingroup GROUP_Annotation
//=======================================================================================
struct TableCellMarginValues
{
double  m_top;      ///<    Minimum distance between the top edge of a cell and its contents.
double  m_bottom;   ///<    Minimum distance between the bottom edge of a cell and its contents.
double  m_left;     ///<    Minimum distance between the left edge of a cell and its contents.
double  m_right;    ///<    Minimum distance between the right edge of a cell and its contents.
};

//=======================================================================================
//! Used to query and modify the color, style and weight of table edge lines and fills.
//! TableSymbologyValues objects optionally hold the following values.
//! - bool     line visible
//! - UInt32   line color
//! - Int32    line style
//! - UInt32   line weight
//! - bool     fill visible
//! - UInt32   fill color
//!
//! For each value you can a) query if the value exists and b) get the value and c).add or change the value.
//! @ingroup GROUP_Annotation
//=======================================================================================
struct AnnotationTableSymbologyValues
{
private:
    bool            m_lineVisibleFlag;
    bool            m_colorFlag;
    bool            m_weightFlag;
    bool            m_styleFlag;
    bool            m_fillVisibleFlag;
    bool            m_fillColorFlag;

    bool            m_lineVisibleVal;
    ColorDef        m_colorVal;
    uint32_t        m_weightVal;
    DgnStyleId      m_styleIdVal;
    double          m_styleScaleVal;
    bool            m_fillVisibleVal;
    ColorDef        m_fillColorVal;

public:
    DGNPLATFORM_EXPORT  /*ctor*/    AnnotationTableSymbologyValues ();  //!< Construct a new blank values object that specifies no values.

    //! @private
    DGNPLATFORM_EXPORT  bool        IsEquivalent (AnnotationTableSymbologyValuesCR other) const;

    DGNPLATFORM_EXPORT  bool        HasLineVisible    () const;         //!< Test if this object specifies a line visibility flag.
    DGNPLATFORM_EXPORT  bool        HasLineColor      () const;         //!< Test if this object specifies a line color value.
    DGNPLATFORM_EXPORT  bool        HasLineWeight     () const;         //!< Test if this object specifies a line weight value.
    DGNPLATFORM_EXPORT  bool        HasLineStyle      () const;         //!< Test if this object specifies a line style value.
    DGNPLATFORM_EXPORT  bool        HasFillVisible    () const;         //!< Test if this object specifies a fill visibility flag.
    DGNPLATFORM_EXPORT  bool        HasFillColor      () const;         //!< Test if this object specifies a fill color value.

    DGNPLATFORM_EXPORT  bool        GetLineVisible    () const;         //!< Get the value of the line visibility flag.
    DGNPLATFORM_EXPORT  ColorDef    GetLineColor      () const;         //!< Get the line color value.
    DGNPLATFORM_EXPORT  DgnStyleId  GetLineStyleId    () const;         //!< Get the line style id value.
    DGNPLATFORM_EXPORT  double      GetLineStyleScale () const;         //!< Get the line style scale value.
    DGNPLATFORM_EXPORT  uint32_t    GetLineWeight     () const;         //!< Get the line weight value.
    DGNPLATFORM_EXPORT  bool        GetFillVisible    () const;         //!< Get the value of the fill visibility flag.
    DGNPLATFORM_EXPORT  ColorDef    GetFillColor      () const;         //!< Get the fill color value.

    DGNPLATFORM_EXPORT  void        SetLineVisible    (bool       val); //!< Set the value of the line visibility flag.
    DGNPLATFORM_EXPORT  void        SetLineColor      (ColorDef   val); //!< Set the color value.
    DGNPLATFORM_EXPORT  void        SetLineStyle      (DgnStyleId id, double value);     //!< Set the line style value.
    DGNPLATFORM_EXPORT  void        SetLineWeight     (uint32_t   val); //!< Set the weight value.
    DGNPLATFORM_EXPORT  void        SetFillVisible    (bool       val); //!< Set the value of the fill visibility flag.
    DGNPLATFORM_EXPORT  void        SetFillColor      (ColorDef   val); //!< Set the fill color value.

    DGNPLATFORM_EXPORT  void        Clear             ();               //!< Reset this object so that it specifies no values.
};

//=======================================================================================
//! @private
//=======================================================================================
enum class SizeLockAction
    {
    TurnOn      = 1,
    TurnOff     = 2,
    NoChange    = 3,
    };

//=======================================================================================
//! @private
//=======================================================================================
struct          AnnotationTableSerializer
    {
private:
    AnnotationTableR             m_table;
    bset<uint32_t>                      m_usedSymbologyKeys;
#if defined (NEEDSWORK)
    bset<uint32_t>                      m_usedFillKeys;
    bool                                m_cacheXAttributes;
    bool                                m_updateRange;
    bool                                m_cleanedElement;
    bool                                m_deferStandalones;
    bvector<TextTableInstanceHolderP>   m_deferredHolders;
#endif
    BentleyStatus   SerializeAspectChanges (AnnotationTableAspectR);
    bool            SerializeEdgeRuns (EdgeRunsR edgeRuns);
#if defined (NEEDSWORK)
    void            DeleteAllPrivateInstances ();
    BentleyStatus   ScheduleDeferredInstances ();
#endif
public:
    AnnotationTableSerializer (AnnotationTableR table/*, bool isDynamics, bool updateRange*/) : m_table(table) {};

    AnnotationTableR  GetElement () { return m_table; }

    DgnDbStatus       SerializeTableToDb ();
    };

//=======================================================================================
//! @private
//=======================================================================================
template<class T_Primitive> class TableValue
{
private:
    bool            m_isValid;
    T_Primitive     m_value;

protected:
    void    SetValid () { m_isValid = true; }

public:
    TableValue () { m_isValid = false; }
    TableValue (T_Primitive v) { m_isValid = true; m_value = v; }
    TableValue (TableValue& rhs) { m_isValid = rhs.m_isValid; m_value = rhs.m_value; } 

    void        Clear () { m_isValid = false; }
    bool        IsValid () const { return m_isValid; }
    bool        IsNull () const { return ! m_isValid; }
    void        SetValue (T_Primitive v) { m_value = v; SetValid(); }
    T_Primitive GetValue () const { return IsValid() ? m_value : 0; }
};

typedef TableValue<int>         TableIntValue;      //!< @private
typedef TableValue<uint32_t>    TableUIntValue;     //!< @private
typedef TableValue<uint64_t>    TableUInt64Value;   //!< @private
typedef TableValue<double>      TableDoubleValue;   //!< @private
typedef TableValue<bool>        TableBoolValue;     //!< @private

//=======================================================================================
//! @private
//=======================================================================================
enum class AnnotationTableAspectType
    {
    Header      = 0,
    Row         = 1,
    Column      = 2,
    Cell        = 3,
    Merge       = 4,
    Symbology   = 5,
    EdgeRun     = 6,
    Fill        = 7,
    };

//=======================================================================================
//! @private
//=======================================================================================
struct AnnotationTableAspectDescr
{
AnnotationTableAspectType   m_type;
uint64_t                    m_aspectId;

/*ctor*/    AnnotationTableAspectDescr (AnnotationTableAspectType t, uint64_t id) : m_type(t), m_aspectId(id) {}
};

//=======================================================================================
//! @private
//=======================================================================================
struct PropertyDescr
    {
    int     m_propIndex;
    Utf8CP  m_propName;
    };

//=======================================================================================
//! @private
//=======================================================================================
struct PropertyNames : bvector <Utf8String>
{
    // This serves to ensure that the property name strings are correlated
    // to the PropIndex values.  In the SELECT statement, PropIndices are 
    // directly correlated to column indices.  So it's important that the
    // first name is propIdex=0, etc. and that no gaps exist.
    /* ctor */ PropertyNames (std::initializer_list<PropertyDescr> iList)
        {
        for (PropertyDescr const& item : iList)
            {
            BeAssert (item.m_propIndex == size());
            push_back (item.m_propName);
            }
        }
};

//=======================================================================================
//! @private
//=======================================================================================
struct AspectTypeData
    {
    AnnotationTableAspectType   m_type;
    bool                        m_isUniqueAspect;
    Utf8CP                      m_ecClassName;
    PropertyNames               m_propertyNames;

    Utf8String                  m_ecSqlInsertString;
    Utf8String                  m_ecSqlUpdateString;
    Utf8String                  m_ecSqlDeleteString;
    Utf8String                  m_ecSqlSelectString;
    Utf8String                  m_ecSqlSelectDupeString;

    /*ctor*/ AspectTypeData (AnnotationTableAspectType t, PropertyNamesCR p, bool u, Utf8CP c) : m_type(t), m_propertyNames(p), m_isUniqueAspect(u), m_ecClassName(c) {}
    };

//=======================================================================================
//! @ingroup GROUP_Annotation
//=======================================================================================
struct AnnotationTableAspect
{
private:
    bool                        m_hasChanges;
    TableUInt64Value            m_aspectId;
    AnnotationTableR     m_table;

    static AspectTypeData const& GetAspectTypeData(AnnotationTableAspectType);
    void                CopyDataFrom (AnnotationTableAspectCR, bool isNew);

protected:
    /*ctor*/                AnnotationTableAspect (AnnotationTableR t) : m_table (t), m_hasChanges(false) {}
    /*ctor*/                AnnotationTableAspect (AnnotationTableAspectCR rhs, bool isNew);
    virtual ~AnnotationTableAspect() {/* required because this has virtual functions*/}

    AnnotationTableAspectR  operator= (AnnotationTableAspectCR rhs);

    bool BindIfNull  (BeSQLite::EC::ECSqlStatement&, Utf8CP paramName, bool isNull);

    void BindInt     (BeSQLite::EC::ECSqlStatement&, Utf8CP paramName, TableIntValue const&);
    void BindUInt    (BeSQLite::EC::ECSqlStatement&, Utf8CP paramName, TableUIntValue const&);
    void BindInt64   (BeSQLite::EC::ECSqlStatement&, Utf8CP paramName, TableUInt64Value const&);
    void BindBool    (BeSQLite::EC::ECSqlStatement&, Utf8CP paramName, TableBoolValue const&);
    void BindDouble  (BeSQLite::EC::ECSqlStatement&, Utf8CP paramName, TableDoubleValue const&);

    void BindProperties (BeSQLite::EC::ECSqlStatement&, bool isUpdate);

    void    SetHasChanges ()    { m_hasChanges = true;  }
    void    ClearHasChanges ()  { m_hasChanges = false; }

    // To support insert, update, delete.
    virtual void                        _BindProperties (BeSQLite::EC::ECSqlStatement&) = 0;
    virtual void                        _AssignValue (int index, BeSQLite::EC::IECSqlValue const&) = 0;

//__PUBLISH_SECTION_END__
public:
    void                AssignProperties (BeSQLite::EC::ECSqlStatement const& statement);
    void                SetAspectId (uint64_t id) { m_aspectId = id; }

    static BentleyStatus   DeleteAspectFromDb (AnnotationTableAspectType, uint64_t aspectId, AnnotationTableR table);
    static BeSQLite::EC::CachedECSqlStatementPtr  GetPreparedSelectStatement (AnnotationTableAspectType, AnnotationTableCR);
    static bool  DbContainsDuplicateRows (AnnotationTableAspectType, AnnotationTableCR);

    BentleyStatus       InsertInDb();
    BentleyStatus       UpdateInDb();
    BentleyStatus       DeleteFromDb();
//__PUBLISH_SECTION_START__

public:
    bool        HasChanges () const         { return m_hasChanges; }                        //!< @private
    bool        HasValidAspectId () const   { return m_aspectId.IsValid(); }                //!< @private
    uint64_t    GetAspectId () const        { return m_aspectId.GetValue(); }               //!< @private

    virtual AnnotationTableAspectType   _GetAspectType() const = 0;                         //!< @private
    virtual bool                        _IsUniqueAspect () const { return false; }          //!< @private
    virtual bool                        _IsRequiredOnElement () const { return false; }     //!< @private
    virtual bool                        _ShouldBePersisted (AnnotationTableSerializer&) const { return true; }      //!< @private
    virtual void                        _FlushChangesToProperties() {}                      //!< @private
    virtual void                        _DiscloseSymbologyKeys (bset<uint32_t>&) {}         //!< @private

    AnnotationTableR     GetTable ()       { return m_table; }
    AnnotationTableCR    GetTable () const { return m_table; }

};

//=======================================================================================
//! @private
//=======================================================================================
struct MergeEntry : AnnotationTableAspect
{
private:
    AnnotationTableCellIndex    m_rootCell;
    TableUIntValue              m_rowSpan;
    TableUIntValue              m_columnSpan;

    enum class PropIndex
        {
        RootCell        = 0,    // no gaps allowed
        RowSpan         = 1,
        ColumnSpan      = 2,
        };

    void                                CopyDataFrom (MergeEntryCR);

protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Merge; }
    virtual void                        _BindProperties(BeSQLite::EC::ECSqlStatement&) override;
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&) override;
    virtual bool                        _ShouldBePersisted (AnnotationTableSerializer&) const override;

public:
    static PropertyNames            GetPropertyNames();
    void                            SetRootCell (AnnotationTableCellIndexCR val);
    Utf8String                      ToString() const;

public:
    /*ctor*/                        MergeEntry (AnnotationTableR, AnnotationTableCellIndex rootCell);
    /*ctor*/                        MergeEntry (MergeEntryCR);

    MergeEntryR                     operator= (MergeEntryCR rhs);

    AnnotationTableCellIndexCR      GetRootIndex    ()  const;
    uint32_t                        GetRowSpan      ()  const;
    uint32_t                        GetColumnSpan   ()  const;

    void                            SetRootIndex (AnnotationTableCellIndexCR);
    void                            SetRowSpan      (uint32_t);
    void                            SetColumnSpan   (uint32_t);
};

//! @private
typedef Bstdcxx::bstdmap<AnnotationTableCellIndex, MergeEntry>    MergeMap;

//=======================================================================================
//! @private
//=======================================================================================
struct MergeDictionary : MergeMap
{
public:
    /*ctor*/                        MergeDictionary () {}

    Utf8String                      ToString() const;

    MergeEntryCP                    GetMerge (AnnotationTableCellIndexCR) const;
    MergeEntryP                     GetMerge (AnnotationTableCellIndexCR);
    BentleyStatus                   DeleteMerge (AnnotationTableCellIndexCR, AnnotationTableR table);
    BentleyStatus                   AddMerge (MergeEntryCR);

    void                            AdjustMergesAfterIndex (uint32_t rowIndex, bool isRow, bool increment);

};

//=======================================================================================
//! @ingroup GROUP_Annotation
//=======================================================================================
struct AnnotationTableFillRun
{
private:
    uint32_t        m_hostIndex;
    uint32_t        m_startIndex;
    uint32_t        m_span;
    uint32_t        m_fillKey;
    uint32_t        m_verticalSpan;

public:
    /*ctor*/        AnnotationTableFillRun ();
    /*ctor*/        AnnotationTableFillRun (AnnotationTableFillRunCR other, bool unused = false);

    AnnotationTableFillRunR operator= (AnnotationTableFillRunCR other);

    void            From (AnnotationTableFillRunCR other);
    void            Initialize (AnnotationTableCR table, uint32_t hostIndex);
    void            Initialize (AnnotationTableFillRunCR other, bool unused);

    bool            CanMergeWith (AnnotationTableFillRunCR other) const;
    void            OnRemoved (AnnotationTableR) {}

    uint32_t        GetHostIndex    ()   const;
    uint32_t        GetStartIndex   ()   const;
    uint32_t        GetSpan         ()   const;
    uint32_t        GetFillKey      ()   const;
    uint32_t        GetVerticalSpan ()   const;

    uint32_t        GetEndIndex     ()   const; // convenience method, not stored.

    void            SetHostIndex        (uint32_t);
    void            SetStartIndex       (uint32_t);
    void            SetSpan             (uint32_t);
    void            SetFillKey          (uint32_t);
    void            SetVerticalSpan     (uint32_t);
};

//=======================================================================================
//! @ingroup GROUP_Annotation
//=======================================================================================
struct IFillRunInitializer
    {
    virtual AnnotationTableFillRun CreateNewRun (AnnotationTableFillRunCP seed) const = 0;
    };

//=======================================================================================
//! @ingroup GROUP_Annotation
//=======================================================================================
struct FillRuns : bvector<AnnotationTableFillRun>
{
FillRuns::iterator  CreateGap (FillRunsP removedRuns, uint32_t gapStartIndex, uint32_t gapSpan);

void                InsertSpan (uint32_t startIndex, uint32_t span, IFillRunInitializer const&);

void                MergeRedundantRuns (AnnotationTableP);
void                ApplyRun (uint32_t fillKey, uint32_t verticalSpan, uint32_t startIndex, uint32_t span);
};

//=======================================================================================
//! @private
//=======================================================================================
struct SymbologyEntry : AnnotationTableAspect
{
private:
    uint32_t                        m_key;
    TableBoolValue                  m_visible;
    TableUIntValue                  m_color;
    TableUIntValue                  m_weight;
    TableUInt64Value                m_lineStyleId;
    TableDoubleValue                m_lineStyleScale;
    TableUIntValue                  m_fillColor;

    enum class PropIndex
        {
        Key             = 0,    // no gaps allowed
        Visible         = 1,
        Color           = 2,
        Weight          = 3,
        LineStyleId     = 4,
        LineStyleScale  = 5,
        FillColor       = 6,
        };

    void                                CopyDataFrom (SymbologyEntryCR);

protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Symbology; }
    virtual void                        _BindProperties(BeSQLite::EC::ECSqlStatement&) override;
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&) override;
    virtual bool                        _ShouldBePersisted (AnnotationTableSerializer&) const override;

public:
    static PropertyNames            GetPropertyNames();
    void                            SetKey (uint32_t);
    Utf8String                      ToString() const;

public:
    /*ctor*/                        SymbologyEntry (AnnotationTableR, uint32_t key);
    /*ctor*/                        SymbologyEntry (SymbologyEntryCR other);
    /*ctor*/                        SymbologyEntry (SymbologyEntryCR other, bool isNew);

    SymbologyEntryR                 operator= (SymbologyEntryCR other);

    bool                            IsEquivalent (SymbologyEntryCR) const;

    uint32_t                        GetKey            ()  const;
    bool                            HasVisible        ()  const;
    bool                            HasColor          ()  const;
    bool                            HasWeight         ()  const;
    bool                            HasLineStyle      ()  const;
    bool                            HasFillColor      ()  const;

    bool                            GetVisible        ()  const;
    ColorDef                        GetColor          ()  const;
    uint32_t                        GetWeight         ()  const;
    DgnStyleId                      GetLineStyleId    ()  const;
    double                          GetLineStyleScale ()  const;
    ColorDef                        GetFillColor      ()  const;
    void                            ClearVisible      ();
    void                            ClearColor        ();
    void                            ClearWeight       ();
    void                            ClearLineStyle    ();
    void                            ClearFillColor    ();

    void                            SetVisible        (bool);
    void                            SetColor          (ColorDef);
    void                            SetWeight         (uint32_t);
    void                            SetLineStyle      (DgnStyleId, double);
    void                            SetFillColor      (ColorDef);

};

//! @private
typedef Bstdcxx::bstdmap<uint32_t, SymbologyEntry>    SymbologyMap;

//=======================================================================================
//! @private
//=======================================================================================
struct SymbologyDictionary : SymbologyMap
{
public:
    /*ctor*/                        SymbologyDictionary ();

    Utf8String                      ToString() const;

    SymbologyEntryCP                GetSymbology (uint32_t key) const;
    SymbologyEntryP                 GetSymbology (uint32_t key);
    BentleyStatus                   AddSymbology (SymbologyEntryCR);
    uint32_t                        FindOrAddSymbology (SymbologyEntryR entry);
};

//=======================================================================================
//! @private
//=======================================================================================
enum class EdgeRunHostType
    {
    Top       = 0,
    Left      = 1,
    Row       = 2,
    Column    = 3,
    };

//=======================================================================================
//! @private
//=======================================================================================
struct AnnotationTableEdgeRun : AnnotationTableAspect
{
private:
    EdgeRunHostType         m_hostType;
    uint32_t                m_host;
    uint32_t                m_start;
    uint32_t                m_span;
    uint32_t                m_symbologyKey;

    enum class PropIndex
        {
        HostType        = 0,    // no gaps allowed
        Host            = 1,
        Start           = 2,
        Span            = 3,
        SymbologyKey    = 4,
        };

protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::EdgeRun; }
    virtual void                        _BindProperties(BeSQLite::EC::ECSqlStatement&) override;
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&) override;
    virtual bool                        _ShouldBePersisted (AnnotationTableSerializer&) const override;

//__PUBLISH_SECTION_END__
public:
    static PropertyNames            GetPropertyNames();
    void                            SetKey (uint32_t);
    Utf8String                      ToString() const;

    EdgeRunsP                       GetHostEdgeRuns (AnnotationTableR) const;
    uint32_t                        GetHostMaxIndex (AnnotationTableCR table) const;

    bool                            CanMergeWith (AnnotationTableEdgeRunCR other) const;
    void                            OnRemoved (AnnotationTableR table);

    void                            CopyDataFrom (AnnotationTableEdgeRunCR);

//__PUBLISH_SECTION_START__
public:
    /*ctor*/                        AnnotationTableEdgeRun (AnnotationTableR);
    /*ctor*/                        AnnotationTableEdgeRun (AnnotationTableEdgeRunCR other);
    /*ctor*/                        AnnotationTableEdgeRun (AnnotationTableEdgeRunCR other, bool isNew);
    virtual                         ~AnnotationTableEdgeRun() {}
    void                            Initialize (EdgeRunHostType, uint32_t hostIndex);

    AnnotationTableEdgeRunR         operator= (AnnotationTableEdgeRunCR other);

    //! @private
    virtual void                    _DiscloseSymbologyKeys (bset<uint32_t>& keys) override;

    EdgeRunHostType      GetHostType     ()   const { return m_hostType;     };
    uint32_t             GetHostIndex    ()   const { return m_host;         };
    uint32_t             GetStartIndex   ()   const { return m_start;        };
    uint32_t             GetSpan         ()   const { return m_span;         };
    uint32_t             GetSymbologyKey ()   const { return m_symbologyKey; };

    DGNPLATFORM_EXPORT uint32_t             GetEndIndex     ()   const; // convenience method, not stored.

    void                 SetHostType         (EdgeRunHostType v)  { m_hostType     = v; SetHasChanges(); }
    void                 SetHostIndex        (uint32_t v)         { m_host         = v; SetHasChanges(); }
    void                 SetStartIndex       (uint32_t v)         { m_start        = v; SetHasChanges(); }
    void                 SetSpan             (uint32_t v)         { m_span         = v; SetHasChanges(); }
    void                 SetSymbologyKey     (uint32_t v)         { m_symbologyKey = v; SetHasChanges(); }
};

//=======================================================================================
//! @private
//=======================================================================================
struct IEdgeRunInitializer
    {
    virtual AnnotationTableEdgeRun CreateNewRun (AnnotationTableEdgeRun const* seed) const = 0;
    };

//=======================================================================================
//! @private
//=======================================================================================
struct EdgeRuns : bvector<AnnotationTableEdgeRun>
{
DGNPLATFORM_EXPORT Utf8String   ToString() const;

void                            CopyFrom (EdgeRunsCR source, AnnotationTableR element);

DGNPLATFORM_EXPORT iterator     CreateGap (EdgeRunsP removedRuns, uint32_t startIndex, uint32_t span);
DGNPLATFORM_EXPORT void         CloseSpan (EdgeRunsP removedRuns, uint32_t startIndex, uint32_t span);
DGNPLATFORM_EXPORT void         Insert (AnnotationTableEdgeRunCR newEdgeRun);
DGNPLATFORM_EXPORT void         InsertSpan (uint32_t startIndex, uint32_t span, IEdgeRunInitializer const&);
DGNPLATFORM_EXPORT void         DeleteSpan (AnnotationTableR, uint32_t startIndex, uint32_t span);
DGNPLATFORM_EXPORT void         FillGap (uint32_t startIndex, uint32_t span);
DGNPLATFORM_EXPORT void         MergeRedundantRuns (AnnotationTableP);

bool                            IsGapEnd   (uint32_t index) const;
bool                            IsGapStart (uint32_t index, uint32_t maxIndex) const;
AnnotationTableEdgeRunCP        GetSpanningRun (uint32_t index) const;
void                            ApplySeed (EdgeRunsCR seed);
void                            ApplySeedAtIndex (uint32_t newRunIndex, uint32_t newRunSpan, uint32_t seedRunIndex);
void                            ApplySeedKeyAtIndex (uint32_t newRunIndex, uint32_t newRunSpan, uint32_t symbologyKey);

DGNPLATFORM_EXPORT void         SetSymbology (AnnotationTableSymbologyValuesCR symb, uint32_t startIndex, uint32_t span, SymbologyDictionary&);
};

//__PUBLISH_SECTION_END__
/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          CellContentHolder
{
protected:
    AnnotationTableCellP            m_tableCell;

    /* ctor */                      CellContentHolder (AnnotationTableCellR c) { Initialize (c); }

public:
    void                            Initialize (AnnotationTableCellR c) { m_tableCell = &c; }

    virtual bool                    _IsEmpty () const = 0;
    virtual DVec2d                  _GetSize () const = 0;                  // The current size of the content
    virtual double                  _GetFullyCompressedHeight () const = 0; // Minimum height supported by the content
    virtual double                  _GetFullyExpandedHeight () const = 0;   // Natural height of the content
    virtual double                  _GetFullyCompressedWidth () const = 0;  // Minimum width supported by the content
    virtual double                  _GetFullyExpandedWidth () const = 0;    // Natural width of the content
    virtual void                    _AppendGeometry (DPoint2dCR origin, DVec2dCR, TableCellAlignment, GeometryBuilderR) const {}

    virtual void                    _SetAlignment (TableCellAlignment) {};
    virtual void                    _SetOrientation (TableCellOrientation) {};
    virtual void                    _FitContentToHeight (double height) = 0;
    virtual void                    _FitContentToWidth (double width) = 0;
    virtual void                    _FlushChangesToProperties () = 0;

    virtual TextBlockHolderP        _AsTextBlockHolder () = 0;
};

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          TextBlockHolder : CellContentHolder
{
private:

enum TextBlockState
    {
    TEXTBLOCK_STATE_Uninitialized   = 0,
    TEXTBLOCK_STATE_Initialized     = 1,
    TEXTBLOCK_STATE_Changed         = 2,
    };

mutable AnnotationTextBlockPtr          m_textBlock;
mutable AnnotationTextBlockLayoutPtr    m_textBlockLayout;
mutable TextBlockState                  m_textBlockState;

    void            ReconcileCellPropertiesFromNewTextBlock();
    void            ReconcileJustificationForNewTextBlock();
    void            SetWordWrapLength (double length);
    double          GetMinimumWordWrapLength () const;
    double          GetNonWrappedLength () const;
    void            GetPaddedSizeAlignedWithTextBlock (double& width, double& height) const;
    void            SetTextBlockDirect (AnnotationTextBlockP textBlock) const;

public:
    /* ctor */                  TextBlockHolder (AnnotationTableCellR cell);
    TextBlockHolderR            operator= (TextBlockHolderCR other);

    AnnotationTextBlockCP       GetTextBlock () const;
    AnnotationTextBlockP        GetTextBlockForFieldProcessing();
    void                        SetTextBlock (AnnotationTextBlockCR textBlock);
    AnnotationTextBlockLayoutCP GetTextBlockLayout () const;

    // CellContentHolder
    virtual bool                    _IsEmpty () const override;
    virtual DVec2d                  _GetSize () const override;
    virtual double                  _GetFullyCompressedWidth () const override;
    virtual double                  _GetFullyExpandedWidth () const override;
    virtual double                  _GetFullyCompressedHeight () const override;
    virtual double                  _GetFullyExpandedHeight () const override;
    virtual void                    _AppendGeometry (DPoint2dCR origin, DVec2dCR, TableCellAlignment, GeometryBuilderR) const;

    virtual void                    _SetAlignment (TableCellAlignment) override;
    virtual void                    _SetOrientation (TableCellOrientation) override;
    virtual void                    _FitContentToHeight (double height) override;
    virtual void                    _FitContentToWidth (double width) override;
    virtual TextBlockHolder*        _AsTextBlockHolder () override { return this; }
    virtual void                    _FlushChangesToProperties () override;

static  double          ComputeDescenderAdjustment (AnnotationTextStyleCR);
static  double          ComputeDescenderAdjustment (AnnotationTextBlockLayoutCR);

}; // TextBlockHolder

//__PUBLISH_SECTION_START__
//=======================================================================================
//! @ingroup GROUP_Annotation
//=======================================================================================
struct AnnotationTableCell : AnnotationTableAspect
{
friend AnnotationTable;

private:
    AnnotationTableCellIndex    m_index;
    Byte const*                 m_rawTextBlock;
    size_t                      m_rawTextBlockBytes;
    TableUIntValue              m_fillKey;
    TableUIntValue              m_alignment;
    TableUIntValue              m_orientation;
    TableDoubleValue            m_marginTop;
    TableDoubleValue            m_marginBottom;
    TableDoubleValue            m_marginLeft;
    TableDoubleValue            m_marginRight;

    CellContentHolderPtr        m_contentHolder;

//__PUBLISH_SECTION_END__
    enum class PropIndex
        {
        CellIndex       = 0,    // must be first
        TextBlock       = 1,    // no gaps allowed
        FillKey         = 2,
        Alignment       = 3,
        Orientation     = 4,
        MarginTop       = 5,
        MarginBottom    = 6,
        MarginLeft      = 7,
        MarginRight     = 8,
        };

    void                                CopyDataFrom (AnnotationTableCellCR);
    void                                InitContentsToEmptyTextBlock ();

//__PUBLISH_SECTION_START__
protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Cell; }
    virtual void                        _BindProperties(BeSQLite::EC::ECSqlStatement&) override;
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&) override;
    virtual void                        _FlushChangesToProperties() override;
    virtual bool                        _ShouldBePersisted (AnnotationTableSerializer&) const override;
    virtual void                        _DiscloseSymbologyKeys (bset<uint32_t>&);

//__PUBLISH_SECTION_END__
public:
    static PropertyNames                GetPropertyNames();

    void                                SetIndex (AnnotationTableCellIndexCR val);

    DVec2d                              GetContentDirection () const;
    DPoint2d                            GetContentOrigin (DPoint2dCR cellOrigin, DVec2dCR xVec, DVec2dCR yVec) const;
    DVec2d                              GetContentSize () const;
    void                                AppendContentsGeometry (DPoint2dCR origin, DVec2dCR xVec, DVec2dCR yVec, GeometryBuilderR builder) const;
    double                              GetFullyCompressedContentHeight () const;
    double                              GetFullyExpandedContentHeight () const;
    double                              GetFullyCompressedContentWidth () const;
    double                              GetFullyExpandedContentWidth () const;
    DVec2d                              GetAvailableContentSize() const;
    DVec2d                              GetEmptyMinimumSizeWithoutMargins() const;
    void                                FitContentToHeight (double height);
    void                                FitContentToWidth (double width);
    void                                SetSizeFromContents (DVec2dCP oldContentSize);
    DVec2d                              GetTextSize () const;

    void                                ApplyTextStyleByRegion ();
    void                                HeightChanged ();
    void                                WidthChanged ();

    bool                                IndexIsInSpan (AnnotationTableCellIndexCR) const;
    void                                SetAsMergedCellRoot (uint32_t rowSpan, uint32_t colSpan);
    void                                SetAsMergedCellInterior (bool isMerged);
    bool                                IsMergedCellInterior () const;
    void                                DeleteMergeCellInteriorRow();
    void                                DeleteMergeCellInteriorColumn();

    void                                ClearFillKey ();
    void                                SetFillKey (uint32_t fillKey);
    bool                                HasFillKey () const;
    uint32_t                            GetFillKey () const;

    void                                SetAlignmentDirect (TableCellAlignment);
    void                                SetOrientationDirect (TableCellOrientation);
    void                                SetTextBlockDirect (AnnotationTextBlockCR);
    DGNPLATFORM_EXPORT void             SetMarginsDirect (TableCellMarginValuesCR);
    void const*                         GetBinaryTextBlock (size_t* numBytes);
    void                                AssignBinaryTextBlock (void const* data, size_t numBytes);
    void                                ClearBinaryTextBlock ();

    static AnnotationTextBlock::HorizontalJustification ToTextBlockJustification (TableCellAlignment);

    enum class HorizontalAlignment
        {
        Left    = 0,
        Center  = 1,
        Right   = 2,
        };

    enum class VerticalAlignment
        {
        Top     = 0,
        Middle  = 1,
        Bottom  = 2,
        };

    static HorizontalAlignment  ToHorizontalAlignment (TableCellAlignment);
    static VerticalAlignment    ToVerticalAlignment   (TableCellAlignment);
    static TableCellAlignment   ToTableCellAlignment  (HorizontalAlignment, VerticalAlignment);

//__PUBLISH_SECTION_START__

public:
    /*ctor*/        AnnotationTableCell (AnnotationTableR, AnnotationTableCellIndex index);
    /*ctor*/        AnnotationTableCell (AnnotationTableCellCR);

    AnnotationTableCellR operator= (AnnotationTableCellCR rhs);

//! Get the unique index that represents this cell.
DGNPLATFORM_EXPORT  AnnotationTableCellIndex    GetIndex         () const { return m_index; }
//! Get the TextTableRegion that hosts this cell.  The region is determined by the TableHeaderFooterType of the cell's row and column.  It cannot be controlled for individual cells.
DGNPLATFORM_EXPORT  AnnotationTableRegion       GetTableRegion   () const;
//! Get the TextBlock stored in this cell.  May be NULL.  Do not modify this TextBlock.  To change it, call TextBlock::Clone and then AnnotationTableCell::SetTextBlock.
DGNPLATFORM_EXPORT  AnnotationTextBlockCP       GetTextBlock     () const;
//! Returns true if the cell has no contents.
DGNPLATFORM_EXPORT  bool                        IsEmpty          () const;

//! Get the alignment stored in this cell.  The alignment controls the position of the contents within the cell.
DGNPLATFORM_EXPORT  TableCellAlignment          GetAlignment()      const;
//! Get the orientation stored in this cell.  The orientation controls the rotation of the contents within the cell.
DGNPLATFORM_EXPORT  TableCellOrientation        GetOrientation()    const;
//! Get the margins stored in this cell.  The margins control the minimum gap between a cell's contents and its edges.
DGNPLATFORM_EXPORT  TableCellMarginValues       GetMargins()        const;

//! Change the alignment stored in this cell.  The alignment controls the position of the contents within the cell.
DGNPLATFORM_EXPORT  void                        SetAlignment (TableCellAlignment);
//! Change the orientation stored in this cell.  The orientation controls the rotation of the contents within the cell.
DGNPLATFORM_EXPORT  void                        SetOrientation (TableCellOrientation);
//! Change the margins stored in this cell.  The margins control the minimum gap between a cell's contents and its edges.
DGNPLATFORM_EXPORT  void                        SetMargins (TableCellMarginValuesCR);

//! Get the size of this cell in UORs.  The x,y coordinates of the returned value represent the horizontal and vertical sizes of the cell in the table's coordinate system.
//! The size is determined by the hosting rows and columns and cannot be controlled for individual cells.
DGNPLATFORM_EXPORT  DVec2d                      GetSize () const;

//! Set or remove a uniform color fill for this cell.  The options set by this method will override the default fill behavior dictated by the table.  See TextTable::GetDefaultFill.
//! To set a particular color call symb.SetFillColor before calling SetFill.  To turn off fill for this cell call symb.SetFillVisible(false) before calling SetFill.
DGNPLATFORM_EXPORT  void                        SetFillSymbology (AnnotationTableSymbologyValuesCR symb);

//! Delete the contents of this cell.
DGNPLATFORM_EXPORT  void                        ClearContents ();
//! Specify text to be displayed in this cell.  It can be useful to call AnnotationTableCell::CreateEmptyTextBlock to start building the text based on the default formatting options.
//! Will replace the existing contents of this cell.
DGNPLATFORM_EXPORT  void                        SetTextBlock (AnnotationTextBlockCR);
//! Specify a text string to be displayed in this cell using the default formatting options for this cell.  Will replace the existing contents of this cell.
DGNPLATFORM_EXPORT  void                        SetTextString (Utf8CP);
//! Returns an empty TextBlock that is set up with the default formatting options for this cell.
DGNPLATFORM_EXPORT  AnnotationTextBlockPtr      CreateEmptyTextBlock    () const;

//! Get the number of rows spanned by this cell.  Typically each cell only spans a single row but the cell merging feature allows a cell to span multiple.  See TextTable::MergeCells.
DGNPLATFORM_EXPORT  uint32_t                    GetRowSpan () const;
//! Get the number of columns spanned by this cell.  Typically each cell only spans a single column but the cell merging feature allows a cell to span multiple.  See TextTable::MergeCells.
DGNPLATFORM_EXPORT  uint32_t                    GetColumnSpan () const;

//! Get the fill override property stored on this cell.  If the cell doesn't store an override its displayed fill will be based on the default behavior of its row.  See TextTable::GetDefaultFill.
//! @param symb OUT if (false == symb.HasFillVisible) this cell uses its row's default fill.  Otherwise use symb.GetFillVisible and symb.GetFillColor to get the cell's fill override.
DGNPLATFORM_EXPORT  void                        GetFillSymbology (AnnotationTableSymbologyValuesR symb) const;
//! Get a list of symbologies used to display the edges of this cell.  Note that for a merged cell it is possible for even a single edge to return multiple symbologies.  For
//! example, consider a cell that spans two columns.  That cell's Top edge may have two different symbologies.  This method is similiar to TextTable::GetEdgeSymbology except
//! that it only works on one cell.
//! @param symb  OUT List of unique symbologies on the requested edges of this cell.
//! @param edges IN  Edges from which to report.  Interior, InteriorHorizontal and InteriorVertical are ignored.
DGNPLATFORM_EXPORT  void                        GetEdgeSymbology (bvector<AnnotationTableSymbologyValues>& symb, TableCellListEdges edges) const;

//! Change this cell to span only a single row and a single column.
DGNPLATFORM_EXPORT  void                        Unmerge ();

};

//=======================================================================================
//! @ingroup GROUP_Annotation
//=======================================================================================
struct AnnotationTableRow : AnnotationTableAspect
{
friend AnnotationTable;

private:
    uint32_t                        m_index;
    TableBoolValue                  m_heightLock;
    TableDoubleValue                m_height;
    bvector<AnnotationTableCell>    m_cells;
    EdgeRuns                        m_edgeRuns;

//__PUBLISH_SECTION_END__
    enum class PropIndex
        {
        RowIndex    = 0,    // must be first
        HeightLock  = 1,    // no gaps allowed
        Height      = 2,
        };

    void                            CopyDataFrom (AnnotationTableRowCR);
    void                            InitializeInternalCollections();

//__PUBLISH_SECTION_START__
protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Row; }
    virtual void                        _BindProperties(BeSQLite::EC::ECSqlStatement&) override;
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&) override;
    virtual void                        _FlushChangesToProperties() override;
    virtual bool                        _ShouldBePersisted (AnnotationTableSerializer&) const override;

public:
//__PUBLISH_SECTION_END__
    static PropertyNames                GetPropertyNames();

    void                                SetIndex (uint32_t);
    bvector<AnnotationTableCell>&       GetCellVectorR()          { return m_cells; }

    void                                ApplyHeaderFooterType ();

    // Finds all cells that intersect this row
    bvector<AnnotationTableCellP>       FindCells() const;

    EdgeRunsR                           GetEdgeRuns()       { return m_edgeRuns; }
    EdgeRunsCR                          GetEdgeRuns() const { return m_edgeRuns; }
    EdgeRunsR                           GetEdgeRuns(bool top);

    double                              GetLength () const  { return GetHeight(); }
    void                                FindMergedLength (double& mergedLength, uint32_t& mergedCount) const;

    DGNPLATFORM_EXPORT void             SetHeightLock (bool);
    DGNPLATFORM_EXPORT void             SetHeightDirect (double);
    void                                SetHeight (double newHeight, SizeLockAction);
    void                                ShrinkHeightToContents ();
    void                                SetHeightFromContents (bool allowedToChangeContentLayout);
    double                              GetAlternateMinimumHeight () const;
    double                              GetMinimumHeight (bool allowedToChangeContentLayout) const;
    Utf8String                          ToString() const;

//__PUBLISH_SECTION_START__

public:
    /*ctor*/        AnnotationTableRow (AnnotationTableR, int index);
    /*ctor*/        AnnotationTableRow (AnnotationTableRowCR);

    AnnotationTableRowR operator= (AnnotationTableRowCR rhs);

//! Get the unique index that represents this row.
DGNPLATFORM_EXPORT  uint32_t                    GetIndex         () const { return m_index; }
//! Get the value of this row's height lock.  This setting controls how the row will react when contents of the table cells change size.
//! When the lock is false, the row's height will grow or shrink based on the content.  When the lock is true, the row's height will never
//! shrink as the content shrinks although it may grow but only if the content grows too large to fit.
DGNPLATFORM_EXPORT  bool                        GetHeightLock    () const;
//! Get the height of this row.
DGNPLATFORM_EXPORT  double                      GetHeight        () const;
//! Compute the minimum height possible for this row given the content of its cells.
DGNPLATFORM_EXPORT  double                      ComputeMinimumHeight () const;

//! Change the height of this row.  The row height cannot be made smaller than the height of the largest content including margins.
//! The height lock will be set to true for this row.  See AnnotationTableRow::GetHeightLock.
DGNPLATFORM_EXPORT  void                        SetHeight        (double);
//! Shrink the height of this row to fit the current contents of the cells.
//! The height lock will be set to false for this row.  See TextTableRow::GetHeightLock.
DGNPLATFORM_EXPORT  void                        SetHeightFromContents ();

//! Get the type of this row.  The row's type controls the default TextStyle for the row's cells.
DGNPLATFORM_EXPORT  TableHeaderFooterType       GetHeaderFooterType () const;
//! Set the type of this row.  The row's type controls the default TextStyle for the row's cells.
//! The type cannot by set to an arbitrary value.  The following rules apply:
//! - All title rows must occur before all rows of any other type.
//! - All header rows must occur after all title rows but before all rows of any other type.
//! - All body rows must occur after all title and header rows but before all footer rows.
//! - All footer rows must occur after all rows of any other type.
//! @param type IN new type
//! @returns ERROR if the type could not be set.  See the rules above.
DGNPLATFORM_EXPORT  BentleyStatus               SetHeaderFooterType (TableHeaderFooterType type);
};

//=======================================================================================
//! @ingroup GROUP_Annotation
//=======================================================================================
struct AnnotationTableColumn : AnnotationTableAspect
{
friend AnnotationTable;

private:
    uint32_t                m_index;
    TableBoolValue          m_widthLock;
    TableDoubleValue        m_width;
    EdgeRuns                m_edgeRuns;

//__PUBLISH_SECTION_END__
    enum class PropIndex
        {
        ColumnIndex = 0,    // must be first
        WidthLock   = 1,    // no gaps allowed
        Width       = 2,
        };

    void                                CopyDataFrom (AnnotationTableColumnCR);

//__PUBLISH_SECTION_START__
protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Column; }
    virtual void                        _BindProperties(BeSQLite::EC::ECSqlStatement&);
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&);
    virtual void                        _FlushChangesToProperties() override;
    virtual bool                        _ShouldBePersisted (AnnotationTableSerializer&) const override;

//__PUBLISH_SECTION_END__
public:
    static PropertyNames                GetPropertyNames();
    void                                SetIndex (uint32_t);

    void                                ApplyHeaderFooterType ();

    // Finds all cells that intersect this column
    bvector<AnnotationTableCellP>       FindCells() const;

    EdgeRunsR                           GetEdgeRuns()       { return m_edgeRuns; }
    EdgeRunsCR                          GetEdgeRuns() const { return m_edgeRuns; }
    EdgeRunsR                           GetEdgeRuns(bool left);

    double                              GetLength () const  { return GetWidth(); }
    void                                FindMergedLength (double& mergedLength, uint32_t& mergedCount) const;

    DGNPLATFORM_EXPORT void             SetWidthLock    (bool);
    DGNPLATFORM_EXPORT void             SetWidthDirect (double);
    void                                SetWidth (double newWidth, SizeLockAction);
    void                                ShrinkWidthToContents ();
    double                              GetMinimumWidth (bool allowedToChangeContentLayout) const;
    void                                SetWidthFromContents (bool allowedToChangeContentLayout);
    double                              GetAlternateMinimumWidth () const;
    Utf8String                          ToString() const;

//__PUBLISH_SECTION_START__

public:
    /*ctor*/        AnnotationTableColumn (AnnotationTableR, int index);
    /*ctor*/        AnnotationTableColumn (AnnotationTableColumnCR);

    AnnotationTableColumnR operator= (AnnotationTableColumnCR rhs);

//! Get the unique index that represents this column.
DGNPLATFORM_EXPORT  uint32_t                    GetIndex         () const { return m_index; }
//! Get the value of this column's width lock.  This setting controls how the column will react when contents of the table cells change size.
//! When the lock is false, the column's width will grow or shrink based on the content.  When the lock is true, the column's width will never
//! shrink as the content shrinks although it may grow but only if the content grows too large to fit.
DGNPLATFORM_EXPORT  bool                        GetWidthLock    () const;
//! Get the width of this column.
DGNPLATFORM_EXPORT  double                      GetWidth        () const;
//! Compute the minimum width possible for this column given the content of its cells.
DGNPLATFORM_EXPORT  double                      ComputeMinimumWidth () const;

//! Change the width of this column.  The column width cannot be made smaller than the width of the largest content including margins.
//! The width lock will be set to true for this column.  See AnnotationTableColumn::GetWidthLock.
DGNPLATFORM_EXPORT  void                        SetWidth        (double);
//! Shrink the width of this column to fit the current contents of the cells.
//! The width lock will be set to false for this column.  See TextTableColumn::GetWidthLock.
DGNPLATFORM_EXPORT  void                        SetWidthFromContents ();

//! Get the type of this column.  The column's type controls the default TextStyle for the column's cells.
//! TableHeaderFooterType::Title is not supported for columns.
DGNPLATFORM_EXPORT  TableHeaderFooterType       GetHeaderFooterType () const;
//! Set the type of this column.  The column's type controls the default TextStyle for the column's cells.
//! TableHeaderFooterType::Title is not supported for columns.
//! The type cannot by set to an arbitrary value.  The following rules apply:
//! - All header columns must occur before all columns of any other type.
//! - All body columns must occur after all header columns but before all footer columns.
//! - All footer columns must occur after all columns of any other type.
//! @param type IN new type
//! @returns ERROR if the type could not be set.  See the rules above.
DGNPLATFORM_EXPORT  BentleyStatus               SetHeaderFooterType (TableHeaderFooterType type);

};

//=======================================================================================
//! @private
//=======================================================================================
struct TableHeaderAspect : AnnotationTableAspect
{
friend AnnotationTable;

private:
    TableUIntValue          m_rowCount;
    TableUIntValue          m_columnCount;
    TableUInt64Value        m_textStyleId;
    TableUIntValue          m_titleRowCount;
    TableUIntValue          m_headerRowCount;
    TableUIntValue          m_footerRowCount;
    TableUIntValue          m_headerColumnCount;
    TableUIntValue          m_footerColumnCount;
    TableUIntValue          m_breakType;
    TableUIntValue          m_breakPosition;
    TableDoubleValue        m_breakLength;
    TableDoubleValue        m_breakGap;
    TableBoolValue          m_repeatHeaders;
    TableBoolValue          m_repeatFooters;
    TableDoubleValue        m_defaultColumnWidth;
    TableDoubleValue        m_defaultRowHeight;
    TableDoubleValue        m_defaultMarginTop;
    TableDoubleValue        m_defaultMarginBottom;
    TableDoubleValue        m_defaultMarginLeft;
    TableDoubleValue        m_defaultMarginRight;
    TableUIntValue          m_defaultCellAlignment;
    TableUIntValue          m_defaultCellOrientation;
    TableUIntValue          m_fillSymbologyKeyOddRow;
    TableUIntValue          m_fillSymbologyKeyEvenRow;
    TableUInt64Value        m_titleRowTextStyle;
    TableUInt64Value        m_headerRowTextStyle;
    TableUInt64Value        m_footerRowTextStyle;
    TableUInt64Value        m_headerColumnTextStyle;
    TableUInt64Value        m_footerColumnTextStyle;
    double                  m_backupTextHeight;
    int                     m_dataSourceProviderId;
    TableDoubleValue        m_bodyTextHeight;
    TableDoubleValue        m_titleRowTextHeight;
    TableDoubleValue        m_headerRowTextHeight;
    TableDoubleValue        m_footerRowTextHeight;
    TableDoubleValue        m_headerColumnTextHeight;
    TableDoubleValue        m_footerColumnTextHeight;
    TableUIntValue          m_defaultTextSymbKey;

//__PUBLISH_SECTION_END__
    enum class PropIndex
        {
        RowCount                = 0,        // no gaps allowed
        ColumnCount             = 1, 
        TextStyleId             = 2,
        TitleRowCount           = 3,
        HeaderRowCount          = 4,
        FooterRowCount          = 5,
        HeaderColumnCount       = 6,
        FooterColumnCount       = 7,
        BreakType               = 8,
        BreakPosition           = 9,
        BreakLength             = 10,
        BreakGap                = 11,
        RepeatHeaders           = 12,
        RepeatFooters           = 13,
        DefaultColumnWidth      = 14,
        DefaultRowHeight        = 15,
        DefaultMarginTop        = 16,
        DefaultMarginBottom     = 17,
        DefaultMarginLeft       = 18,
        DefaultMarginRight      = 19,
        DefaultCellAlignment    = 20,
        DefaultCellOrientation  = 21,
        FillSymbologyKeyOddRow  = 22,
        FillSymbologyKeyEvenRow = 23,
        TitleRowTextStyle       = 24,
        HeaderRowTextStyle      = 25,
        FooterRowTextStyle      = 26,
        HeaderColumnTextStyle   = 27,
        FooterColumnTextStyle   = 28,
        BackupTextHeight        = 29,
        DataSourceProviderId    = 30,
        BodyTextHeight          = 31,
        TitleRowTextHeight      = 32,
        HeaderRowTextHeight     = 33,
        FooterRowTextHeight     = 34,
        HeaderColumnTextHeight  = 35,
        FooterColumnTextHeight  = 36,
        DefaultTextSymbKey      = 37,
        };

    TableHeaderAspect (AnnotationTableR);
    void        CopyDataFrom (TableHeaderAspect const& rhs);

    void        Invalidate ();

    TableUIntValue const*     GetUIntValue   (PropIndex) const;
    TableUInt64Value const*   GetUInt64Value (PropIndex) const;
    TableBoolValue const*     GetBoolValue   (PropIndex) const;
    TableDoubleValue const*   GetDoubleValue (PropIndex) const;

    int                 GetUInteger (PropIndex) const;
    bool                GetBoolean  (PropIndex, bool defVal) const;
    double              GetDouble   (PropIndex) const;
    DgnElementId        GetStyleId (PropIndex) const;

    void                SetUInteger (int, PropIndex);
    void                SetBoolean  (bool, PropIndex);
    void                SetDouble   (double, PropIndex);
    void                SetStyleId (DgnElementId, PropIndex);

//__PUBLISH_SECTION_START__
protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Header; }
    virtual void                        _BindProperties(BeSQLite::EC::ECSqlStatement&);
    virtual void                        _AssignValue (int propIndex, BeSQLite::EC::IECSqlValue const&) override;
    virtual bool                        _IsUniqueAspect () const override { return true; }
    virtual void                        _FlushChangesToProperties();
    virtual bool                        _IsRequiredOnElement () const override { return true; }
    virtual void                        _DiscloseSymbologyKeys (bset<uint32_t>& keys) override;

//__PUBLISH_SECTION_END__
public:
    static PropertyNames                GetPropertyNames();
//__PUBLISH_SECTION_START__

public:
};

struct AnnotationTableCellCollection;

//=======================================================================================
//! An iterator that can step through the set of cells in a table.
//! @see AnnotationTable::GetCellCollection
//! @ingroup GROUP_Annotation
//=======================================================================================
struct      AnnotationTableCellIterator : RefCountedBase, std::iterator<std::forward_iterator_tag, AnnotationTableCell>
{
private:
    friend struct   AnnotationTableCellCollection;

    AnnotationTableCellP      m_cell;

    AnnotationTableCellCollection const*  m_parentCollection;
    AnnotationTableCellIterator (AnnotationTableCellCollection const& collection, bool begin);

public:

    DGNPLATFORM_EXPORT bool                 IsDifferent(AnnotationTableCellIterator const& rhs) const;  //!< Compare this with another iterator
    DGNPLATFORM_EXPORT void                 MoveToNext ();                                              //!< Advance the iterator to the next item
    DGNPLATFORM_EXPORT AnnotationTableCellR GetCurrent () const;                                        //!< Get the current item
};

//=======================================================================================
//! A collection that can iterate through the set of cells in a table.
//! See AnnotationTable::GetCellCollection
//! @ingroup GROUP_Annotation
//=======================================================================================
struct      AnnotationTableCellCollection
{
private:
    friend struct   AnnotationTable;
    friend struct   AnnotationTableCellIterator;

    AnnotationTablePtr    m_table;

    AnnotationTableCellCollection (AnnotationTableCR table);

public:
    typedef ECN::VirtualCollectionIterator<AnnotationTableCellIterator> const_iterator;
    typedef const_iterator iterator;    //!< only const iteration is possible

public:
    DGNPLATFORM_EXPORT const_iterator begin () const;           //!< Returns an iterator to the first element in the collection.
    DGNPLATFORM_EXPORT const_iterator end ()   const;           //!< Returns an iterator that points to the end of the collection.
};

//=======================================================================================
//! @ingroup GROUP_Annotation
//=======================================================================================
struct EXPORT_VTABLE_ATTRIBUTE AnnotationTable : AnnotationElement2d
{
//__PUBLISH_SECTION_END__
friend struct AnnotationTableSerializer;
friend struct ConvertV8TextTableToDgnDbExtension;
friend struct V8TextTableToDgnDbConverter;
//__PUBLISH_SECTION_START__

private:
    DGNELEMENT_DECLARE_MEMBERS(BIS_CLASS_AnnotationTable, AnnotationElement2d) 

    TableHeaderAspect                       m_tableHeader;
    SymbologyDictionary                     m_symbologyDictionary;
    MergeDictionary                         m_mergeDictionary;
    bvector<AnnotationTableRow>             m_rows;
    bvector<AnnotationTableColumn>          m_columns;
    EdgeRuns                                m_topEdgeRuns;
    EdgeRuns                                m_leftEdgeRuns;
    bvector<AnnotationTableAspectDescr>     m_aspectsPendingDelete;

    mutable bmap<AnnotationTableRegion, AnnotationTextStyleCPtr> m_textStyles;

    void                            UpdateGeometryRepresentation();
    DgnDbStatus                     SaveChanges();

    void                            Initialize (bool isNewTable);
    TableHeaderAspect&              GetHeaderAspect() { return m_tableHeader; }
    BentleyStatus                   ValidateAllAspectTablePointers();

    void                            Clear();
    void                            LoadCells();

    void        MarkAsMergedCellInteriors (AnnotationTableCellIndexCR, uint32_t rowSpan, uint32_t colSpan, bool loading);
    void        BumpRowHeaderFooterCount (AnnotationTableRowCR row, bool add);
    void        BumpColumnHeaderFooterCount (AnnotationTableColumnCR row, bool add);

    void        CopyPropsForNewRow    (uint32_t indexOfNewRow, uint32_t indexOfSeedRow);
    void        CopyPropsForNewColumn (uint32_t indexOfNewCol, uint32_t indexOfSeedCol);

    bool        HasOverlappingMerges (bvector<AnnotationTableCellP>& consumedRoots, AnnotationTableCellIndexCR rootIndex, uint32_t numRows, uint32_t numCols);

    enum class  TextSymb { Color, Weight };
    enum class  TextSymbAction { Store, Clear };
    void        ChangeDefaultTextSymbology (TextSymb, TextSymbAction, uint32_t value);

protected:
    DGNPLATFORM_EXPORT  void                                BootStrap(uint32_t rowCount, uint32_t columnCount, DgnElementId textStyleId, double backupTextHeight);

    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _OnInsert() override;
    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _OnUpdate(DgnElementCR original) override;

    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _InsertInDb() override;
    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _UpdateInDb() override;
    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _LoadFromDb() override;
    DGNPLATFORM_EXPORT  virtual void                        _CopyFrom(DgnElementCR) override;

//__PUBLISH_SECTION_END__
public:
    bvector<AnnotationTableRow>&            GetRowVectorR()             { return m_rows; }
    bvector<AnnotationTableRow> const&      GetRowVector() const        { return m_rows; }
    bvector<AnnotationTableColumn>&         GetColumnVectorR()          { return m_columns; }
    bvector<AnnotationTableColumn> const&   GetColumnVector() const     { return m_columns; }
    bvector<AnnotationTableAspectDescr>&    GetAspectsPendingDelete()   { return m_aspectsPendingDelete; }
    AnnotationTextStyleCP                   GetTextStyle (AnnotationTableRegion) const;
    void                                    SetTextStyleIdDirect (DgnElementId val, AnnotationTableRegion region);
    void                                    DeleteAspect (AnnotationTableAspectCR);
    void                                    ConsiderRegionForAlternateMinimumSize (double& min, AnnotationTableRegion region, bool isHeight) const;

    DGNPLATFORM_EXPORT void         SetTitleRowCount     (uint32_t);
    DGNPLATFORM_EXPORT void         SetHeaderRowCount    (uint32_t);
    DGNPLATFORM_EXPORT void         SetFooterRowCount    (uint32_t);
    DGNPLATFORM_EXPORT void         SetHeaderColumnCount (uint32_t);
    DGNPLATFORM_EXPORT void         SetFooterColumnCount (uint32_t);

    MergeDictionary&                GetMergeDictionary()            { return m_mergeDictionary; }
    MergeDictionary const&          GetMergeDictionary() const      { return m_mergeDictionary; }

    SymbologyDictionary&            GetSymbologyDictionary()        { return m_symbologyDictionary; }
    SymbologyDictionary const&      GetSymbologyDictionary() const  { return m_symbologyDictionary; }

    AnnotationTableCellP            GetCell (AnnotationTableCellIndexCR cellIndex, bool allowMergedInteriors) const;

    EdgeRunsR                       GetTopEdgeRuns ()          { return m_topEdgeRuns; }
    EdgeRunsCR                      GetTopEdgeRuns () const    { return m_topEdgeRuns; }
    EdgeRunsR                       GetLeftEdgeRuns ()         { return m_leftEdgeRuns; }
    EdgeRunsCR                      GetLeftEdgeRuns () const   { return m_leftEdgeRuns; }
    EdgeRunsP                       GetEdgeRuns (EdgeRunHostType, uint32_t hostIndex);
    EdgeRunsCP                      GetEdgeRuns (EdgeRunHostType, uint32_t hostIndex) const;

    uint32_t                        GetFillSymbologyForRow (uint32_t) const;
    uint32_t                        GetFillSymbologyForOddRow()     const;
    uint32_t                        GetFillSymbologyForEvenRow()    const;
    uint32_t                        GetDefaultTextSymbology()       const;
    void                            SetFillSymbologyForOddRow   (uint32_t);
    void                            SetFillSymbologyForEvenRow  (uint32_t);
    void                            SetDefaultTextSymbology     (uint32_t);

    void                            CopyPropsForNewCell (AnnotationTableCellR newCell, AnnotationTableCellCR seedCell);

    void                            SetRowCount     (uint32_t v);
    void                            SetColumnCount  (uint32_t v);

    AnnotationTableRegion           GetTableRegion (AnnotationTableCellIndexCR cellIndex) const;
    TableHeaderFooterType           GetRowHeaderFooterType (uint32_t rowIndex) const;
    bool                            CanChangeRowHeaderFooterType (uint32_t rowIndex, TableHeaderFooterType newType) const;
    BentleyStatus                   ChangeRowHeaderFooterType (uint32_t rowIndex, TableHeaderFooterType newType);
    TableHeaderFooterType           GetColumnHeaderFooterType (uint32_t columnIndex) const;
    bool                            CanChangeColumnHeaderFooterType (uint32_t colIndex, TableHeaderFooterType newType) const;
    BentleyStatus                   ChangeColumnHeaderFooterType (uint32_t colIndex, TableHeaderFooterType newType);

    void                            HasInteriorEdges (bool* hasAny, bool* hasHorizontal, bool* hasVertical, bvector<AnnotationTableCellIndex> const&) const;

    static  AnnotationTableRegion   GetTableRegionFromRowType    (TableHeaderFooterType);
    static  AnnotationTableRegion   GetTableRegionFromColumnType (TableHeaderFooterType);
    static  void                    ClassifyTableRegion (TableHeaderFooterType& type, bool& isRow, AnnotationTableRegion);

    DVec2d                          GetEmptyMinimumSizeWithoutMargins (AnnotationTableRegion) const;

    double                          GetDefaultBreakGap () const;
//__PUBLISH_SECTION_START__
public:
                    explicit                        AnnotationTable(CreateParams const& params);
DGNPLATFORM_EXPORT  static AnnotationTablePtr       Create(CreateParams const& params);

                    static DgnClassId               QueryClassId(DgnDbR db) { return DgnClassId(db.Schemas().GetECClassId(BIS_ECSCHEMA_NAME, BIS_CLASS_AnnotationTable)); }

                    static AnnotationTableCPtr      Get(DgnDbR db, DgnElementId id) { return db.Elements().Get<AnnotationTable>(id); }
                    static AnnotationTablePtr       GetForEdit(DgnDbR db, DgnElementId id) { return db.Elements().GetForEdit<AnnotationTable>(id); }
                    AnnotationTableCPtr             Insert() { return GetDgnDb().Elements().Insert<AnnotationTable>(*this); }
                    AnnotationTableCPtr             Update() { return GetDgnDb().Elements().Update<AnnotationTable>(*this); }
                    DgnDbStatus                     Delete() const { return GetDgnDb().Elements().Delete(*this); }

                    bool                            IsValid () const;


DGNPLATFORM_EXPORT  uint32_t                        GetRowCount      ()                     const;  //!<    Get the number of rows in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetColumnCount   ()                     const;  //!<    Get the number of columns in this table.
#if defined (NEEDSWORK)
DGNPLATFORM_EXPORT  DPoint3d                        GetOrigin   ()                          const;  //!<    Get the origin which is the upper left corner of cell 0,0.
DGNPLATFORM_EXPORT  RotMatrix                       GetRotation ()                          const;  //!<    Get the rotation which defines the orientation of this table.
#endif
DGNPLATFORM_EXPORT  uint32_t                        GetTitleRowCount ()                     const;  //!<    Get the number of title rows in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetHeaderRowCount ()                    const;  //!<    Get the number of header rows in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetFooterRowCount ()                    const;  //!<    Get the number of footer rows in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetHeaderColumnCount ()                 const;  //!<    Get the number of header columns in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetFooterColumnCount ()                 const;  //!<    Get the number of footer columns in this table.
DGNPLATFORM_EXPORT  TableBreakType                  GetBreakType ()                         const;  //!<    Get the break type of this table.
DGNPLATFORM_EXPORT  TableBreakPosition              GetBreakPosition ()                     const;  //!<    Get the break position for this table.
DGNPLATFORM_EXPORT  double                          GetBreakLength ()                       const;  //!<    Get the break length in UORs for this table.  Any cells that don't fit within this length will flow into a new subtable.
DGNPLATFORM_EXPORT  double                          GetBreakGap ()                          const;  //!<    Get the break gap in UORs for this table.  This controlls the spacing between subtables.
DGNPLATFORM_EXPORT  bool                            GetRepeatHeaders ()                     const;  //!<    Get the flag defining if header rows will be repeated in sub tables created by breaking.
DGNPLATFORM_EXPORT  bool                            GetRepeatFooters ()                     const;  //!<    Get the flag defining if footer rows will be repeated in sub tables created by breaking.
DGNPLATFORM_EXPORT  double                          GetDefaultColumnWidth ()                const;  //!<    Get the default column width in UORs which will be used by columns that don't have a specific width set.
DGNPLATFORM_EXPORT  double                          GetDefaultRowHeight ()                  const;  //!<    Get the default row height in UORs which will be used by rows that don't have a specific height set.
DGNPLATFORM_EXPORT  TableCellMarginValues           GetDefaultMargins ()                    const;  //!<    Get the default cell margins in UORs which will be used by cells that don't have specific margins set.
DGNPLATFORM_EXPORT  ColorDef                        GetDefaultLineColor ()                  const;  //!<    Get the default line color which will be used by edge lines that don't have a specific color set.
DGNPLATFORM_EXPORT  DgnStyleId                      GetDefaultLineStyleId ()                const;  //!<    Get the default line style which will be used by edge lines that don't have a specific style set.
DGNPLATFORM_EXPORT  double                          GetDefaultLineStyleScale ()             const;  //!<    Get the default line style which will be used by edge lines that don't have a specific style set.
DGNPLATFORM_EXPORT  uint32_t                        GetDefaultLineWeight()                  const;  //!<    Get the default line weight which will be used by edge lines that don't have a specific weight set.
DGNPLATFORM_EXPORT  ColorDef                        GetDefaultTextColor ()                  const;  //!<    Get the default color which will be used for text that doesn't have a specific color set.
DGNPLATFORM_EXPORT  uint32_t                        GetDefaultTextWeight ()                 const;  //!<    Get the default weight which will be used for text that doesn't have a specific weight set.
DGNPLATFORM_EXPORT  TableCellAlignment              GetDefaultCellAlignment()               const;  //!<    Get the default alignment which will be used by cells that don't have a specific alignment set.
DGNPLATFORM_EXPORT  TableCellOrientation            GetDefaultCellOrientation()             const;  //!<    Get the default orientation which will be used by cells that don't have a specific orientation set.
DGNPLATFORM_EXPORT  DgnElementId                    GetTextStyleId (AnnotationTableRegion)  const;  //!<    Get the default text style which will be used to create text for empty cells.

DGNPLATFORM_EXPORT  void                            GetDefaultFill (AnnotationTableSymbologyValuesR symb, TableRows rows) const;  //!<    Get the default fill parameters which will be used by cells that don't have a specific fill set.

DGNPLATFORM_EXPORT  bool                            HasDefaultTextColor ()                  const;  //!<    Test if a default text color is stored.  Use GetDefaultTextColor to get the value.
DGNPLATFORM_EXPORT  bool                            HasDefaultTextWeight ()                 const;  //!<    Test if a default text weight is stored.  Use GetDefaultTextWeight to get the value.

DGNPLATFORM_EXPORT void        SetTextStyleId           (DgnElementId, AnnotationTableRegion);          //!<    Change the default text style which will be used to create text for empty cells.
DGNPLATFORM_EXPORT void        SetBreakType             (TableBreakType);                               //!<    Change the break type of this table.
DGNPLATFORM_EXPORT void        SetBreakPosition         (TableBreakPosition);                           //!<    Change the break position for this table.
DGNPLATFORM_EXPORT void        SetBreakLength           (double);                                       //!<    Change the break length in UORs for this table.  Any cells that don't fit within this length will flow into a new subtable.
DGNPLATFORM_EXPORT void        SetBreakGap              (double);                                       //!<    Change the break gap in UORs for this table.  This controlls the spacing between subtables.
DGNPLATFORM_EXPORT void        SetRepeatHeaders         (bool);                                         //!<    Change the flag defining if header rows will be repeated in sub tables created by breaking.
DGNPLATFORM_EXPORT void        SetRepeatFooters         (bool);                                         //!<    Change the flag defining if footer rows will be repeated in sub tables created by breaking.
DGNPLATFORM_EXPORT void        SetDefaultColumnWidth    (double);                                       //!<    Change the default column width in UORs which will be used by columns that don't have a specific width set.
DGNPLATFORM_EXPORT void        SetDefaultRowHeight      (double);                                       //!<    Change the default row height in UORs which will be used by rows that don't have a specific height set.
DGNPLATFORM_EXPORT void        SetDefaultMargins        (TableCellMarginValuesCR);                      //!<    Change the default cell margins in UORs which will be used by cells that don't have specific margins set.
DGNPLATFORM_EXPORT void        SetDefaultLineColor      (ColorDef);                                     //!<    Change the default line color which will be used by edge lines that don't have a specific color set.
DGNPLATFORM_EXPORT void        SetDefaultLineStyle      (DgnStyleId id, double scale);                  //!<    Change the default line style which will be used by edge lines that don't have a specific style set.
DGNPLATFORM_EXPORT void        SetDefaultLineWeight     (uint32_t);                                     //!<    Change the default line weight which will be used by edge lines that don't have a specific weight set.
DGNPLATFORM_EXPORT void        SetDefaultFill           (AnnotationTableSymbologyValuesCR, TableRows rows);  //!<    Change the default fill parameters which will be used by cells that don't have a specific fill set.
DGNPLATFORM_EXPORT void        SetDefaultTextColor      (ColorDef value);                               //!<    Change the default color which will be used for text that doesn't have a specific color set.  Use ClearDefaultTextColor to remove this value.
DGNPLATFORM_EXPORT void        SetDefaultTextWeight     (uint32_t value);                               //!<    Change the default weight which will be used for text that doesn't have a specific weight set.  Use ClearDefaultTextWeight to remove this value.
DGNPLATFORM_EXPORT void        SetDefaultCellOrientation(TableCellOrientation);                         //!<    Change the default orientation which will be used by cells that don't have a specific orientation set.
DGNPLATFORM_EXPORT void        SetDefaultCellAlignment  (TableCellAlignment);                           //!<    Change the default alignment which will be used by cells that don't have a specific alignment set.

DGNPLATFORM_EXPORT  void       ClearDefaultTextColor ();                                                //!<    Remove the default text color.  This is the opposite of SetDefaultTextColor.
DGNPLATFORM_EXPORT  void       ClearDefaultTextWeight ();                                               //!<    Remove the default text weight.  This is the opposite of SetDefaultTextWeight.

DGNPLATFORM_EXPORT  AnnotationTableRowCP        GetRow (uint32_t rowIndex) const;                       //!<    Get an object representing a row by its index.  Will return NULL if the index is out of range.
DGNPLATFORM_EXPORT  AnnotationTableRowP         GetRow (uint32_t rowIndex);                             //!<    Get an object representing a row by its index.  Will return NULL if the index is out of range.

DGNPLATFORM_EXPORT  AnnotationTableColumnCP     GetColumn (uint32_t colIndex) const;                    //!<    Get an object representing a column by its index.  Will return NULL if the index is out of range.
DGNPLATFORM_EXPORT  AnnotationTableColumnP      GetColumn (uint32_t colIndex);                          //!<    Get an object representing a column by its index.  Will return NULL if the index is out of range.

//! Get an object representing a cell by its index.  For merged cells (those with row and or column span greater than 1) only the upper left TableCellIndex represents the cell.
//! Consider a cell at index 2,2 with a column span of 2.  Index 2,2 represents the cell.  The index 2,3 represents a cell that was consumed and GetCell will return NULL when asked for cell 2,3.
//! @param cellIndex IN    The index of the desired cell.
//! @return NULL if the index is out of range or if the index refers to a position consumed by a merged cell.
DGNPLATFORM_EXPORT  AnnotationTableCellP                  GetCell (AnnotationTableCellIndexCR cellIndex) const;

//! Insert a new row into the table.  It is only possible to insert directly before (above) or after (below) the seed row.
//! @param indexOfSeedRow IN    The seed row's properties but not its contents will be copied to form the new row.
//! @param dir            IN    The location of the new row either before or after the seed row.
DGNPLATFORM_EXPORT  BentleyStatus                   InsertRow (uint32_t indexOfSeedRow, TableInsertDirection dir);
//! Delete an existing row from the table.
DGNPLATFORM_EXPORT  BentleyStatus                   DeleteRow (uint32_t indexOfOldRow);

//! Insert a new column into the table.  It is only possible to insert directly before (to the left of) or after (to the right of) the seed column.
//! @param indexOfSeedColumn IN     The seed columns's properties but not its contents will be copied to form the new column.
//! @param dir               IN     The location of the new column either before or after the seed column.
DGNPLATFORM_EXPORT  BentleyStatus                   InsertColumn (uint32_t indexOfSeedColumn, TableInsertDirection dir);
//! Delete an existing column from the table.
DGNPLATFORM_EXPORT  BentleyStatus                   DeleteColumn (uint32_t indexOfOldColumn);

//! Get a collection that can be used to iterate all the cells in the table.  This method is more convenient than calling GetCell in a nested for loop.
//! \code
//! for (AnnotationTableCellCR cell : table.GetCellCollection())
//!     // do something with cell
//! \endcode
DGNPLATFORM_EXPORT  AnnotationTableCellCollection         GetCellCollection () const;

//! Change the row and/or column span of a cell.  This will fail if it would consume a part of another merged cell.
//! @param root    IN The upper left cell index of the merged cell.
//! @param numRows IN the number of rows that will be spanned by the merged cell.
//! @param numCols IN the number of columns that will be spanned by the merged cell.
//! @return ERROR if the merging could not be done.
DGNPLATFORM_EXPORT  BentleyStatus                   MergeCells (AnnotationTableCellIndexCR root, uint32_t numRows, uint32_t numCols);


//! Get the edge line symbologies used to draw the edges of a collection of cells.
//! @param symb  OUT A list of unique symbologies from the requested edges.
//! @param edges IN  Specifies which edges to query.
//! @param cells IN  Specifies which cells to query.
DGNPLATFORM_EXPORT  void                            GetEdgeSymbology (bvector<AnnotationTableSymbologyValues>& symb, TableCellListEdges edges, bvector<AnnotationTableCellIndex> const& cells) const;
//! Change the edge line symbology used to draw the edges of a collection of cells.
//! @param symb  IN  The symbology to apply to the specified edges.
//! @param edges IN  Specifies which edges to change.
//! @param cells IN  Specifies which cells to change.
DGNPLATFORM_EXPORT  void                            SetEdgeSymbology (AnnotationTableSymbologyValuesCR symb, TableCellListEdges edges, bvector<AnnotationTableCellIndex> const& cells);

//! Get the overall width of this table.  This is equivalent to summing all the column widths.  This method ignores the effects of table breaking.
DGNPLATFORM_EXPORT  double                          GetWidth  ()  const;
//! Get the overrall height of this table.  This is equivalent to summing all the row heights.  This method ignores the effects of table breaking.
DGNPLATFORM_EXPORT  double                          GetHeight () const;

//! Get the overall width of this table.  Each column will be resized proportionally to its original size in the table.  Will fail if the input value is less than
//! the sum of the minimum widths for all the columns.
DGNPLATFORM_EXPORT  void                            SetWidth  (double val);
//! Get the overrall height of this table.  Each row will be resized proportionally to its original size in the table.  Will fail if the input value is less than
//! the sum of the minimum heights for all the rows.
DGNPLATFORM_EXPORT  void                            SetHeight (double val);

//! Create a new table from scratch.  All table properties will be initialized to safe default values.
//! @param rowCount         IN  The number of rows in the table.
//! @param columnCount      IN  The number of columns in the table.
//! @param textStyleId      IN  The default TextStyle.
//! @param backupTextHeight IN  Used when textStyleId refers to a style with zero text height.
//! @param params           IN  General element parameters
DGNPLATFORM_EXPORT  static  AnnotationTablePtr            Create(uint32_t rowCount, uint32_t columnCount, DgnElementId textStyleId, double backupTextHeight, CreateParams const& params);

};

namespace dgn_ElementHandler
{
    //=======================================================================================
    //! The ElementHandler for AnnotationTable
    //=======================================================================================
    struct AnnotationTableHandler : Annotation2d
    {
        ELEMENTHANDLER_DECLARE_MEMBERS(BIS_CLASS_AnnotationTable, AnnotationTable, AnnotationTableHandler, Annotation2d, DGNPLATFORM_EXPORT);
    };
};

//__PUBLISH_SECTION_END__
typedef bvector<AnnotationTableRowCP>     RowVector;
typedef bvector<AnnotationTableColumnCP>  ColumnVector;

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          SubTable
{
public:
    DPoint2d                            m_origin;
    DVec2d                              m_offset;
    DVec2d                              m_size;
    bvector<AnnotationTableRowCP>       m_rows;
    bvector<AnnotationTableColumnCP>    m_columns;

    /* ctor */  SubTable () { m_size.Zero(); }
    void        AddRow (AnnotationTableRowCP);
    void        AddColumn (AnnotationTableColumnCP);
};

struct SubTable;
typedef bvector<SubTable>   SubTables;
typedef SubTables*          SubTablesP;
typedef SubTables&          SubTablesR;
typedef SubTables const*    SubTablesCP;
typedef SubTables const&    SubTablesCR;

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          TablePositionedCell
{
AnnotationTableCellP    m_cell;
DPoint2d                m_origin;
};

struct   TablePositionedCells;

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct      TablePositionedCellIterator : RefCountedBase, std::iterator<std::forward_iterator_tag, TablePositionedCell const>
{
private:
    friend struct   TablePositionedCells;

    TablePositionedCell             m_positionedCell;
    double                          m_runningRowHeight;
    SubTables::const_iterator       m_subTableIter;
    SubTables::const_iterator       m_subTableIterEnd;
    RowVector::const_iterator       m_rowIter;
    RowVector::const_iterator       m_rowIterEnd;
    ColumnVector::const_iterator    m_columnIter;
    ColumnVector::const_iterator    m_columnIterEnd;

    TablePositionedCells const*     m_cellCollection;

    /* ctor */  TablePositionedCellIterator (TablePositionedCells const& collection, bool begin);

    AnnotationTableCellP  CellFromIterators   ();
    void            InitForNewSubTable  ();

public:
    DGNPLATFORM_EXPORT bool                 IsDifferent(TablePositionedCellIterator const& rhs) const;
    DGNPLATFORM_EXPORT void                 MoveToNext ();
    DGNPLATFORM_EXPORT TablePositionedCell const& GetCurrent () const;
};

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct      TablePositionedCells
{
private:
    //friend struct   AnnotationTableElement;
    friend struct   TablePositionedCellIterator;

    bool                        m_ownSubTables;
    SubTablesCP                 m_subTables;
    AnnotationTablePtr   m_table;

public:
    DGNPLATFORM_EXPORT TablePositionedCells (AnnotationTableCR, SubTablesCP, bool ownSubTables);
    DGNPLATFORM_EXPORT ~TablePositionedCells ();

    typedef VirtualCollectionIterator<TablePositionedCellIterator> const_iterator;
    typedef const_iterator iterator;    //!< only const iteration is possible

public:
    DGNPLATFORM_EXPORT const_iterator begin () const;           //!< Returns an iterator to the first element in the collection.
    DGNPLATFORM_EXPORT const_iterator end ()   const;           //!< Returns an iterator that points to the end of the collection.
};

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          TableFillBox
{
uint32_t        m_fillKey;
uint32_t        m_rowIndex;
DPoint2d        m_origin;
double          m_width;
double          m_height;
};

struct   TableFillBoxes;

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct  TableFillBoxIterator : RefCountedBase, std::iterator<std::forward_iterator_tag, TableFillBox const>
{
private:
    friend struct   TableFillBoxes;

    TableFillBox                        m_fillBox;
    TableFillBoxes const*               m_fillCollection;

    bool                                m_atEnd;
    DPoint2d                            m_rowOrigin;
    SubTables::const_iterator           m_subTableIter;
    SubTables::const_iterator           m_subTableIterEnd;
    RowVector::const_iterator           m_rowIter;
    RowVector::const_iterator           m_rowIterEnd;
    ColumnVector::const_iterator        m_columnIter;
    ColumnVector::const_iterator        m_columnIterEnd;
    FillRuns::const_iterator            m_fillRunIter;
    FillRuns::const_iterator            m_fillRunIterEnd;

    void            InitForNewSubTable();
    void            InitForNewRow();
    BentleyStatus   MoveToNextRow();
    void            GetHeightFromFillRun();

    TableFillBoxIterator (TableFillBoxes const& collection, bool begin);

public:
    bool                    IsDifferent (TableFillBoxIterator const& rhs) const;
    void                    MoveToNext  ();
    TableFillBox const&     GetCurrent  () const;
};

struct   AnnotationTableStroker;

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          TableFillBoxes
{
private:
    friend struct   AnnotationTableStroker;
    friend struct   TableFillBoxIterator;

    AnnotationTableStroker const&   m_stroker;
    SubTablesCR                     m_subTables;

    TableFillBoxes (AnnotationTableStroker const&, SubTablesCR);

    AnnotationTableCR    GetTable() const;
    FillRunsCR                  GetFillRuns(uint32_t rowIndex) const;

public:
    typedef VirtualCollectionIterator<TableFillBoxIterator> const_iterator;
    typedef const_iterator iterator;    //!< only const iteration is possible

public:
    const_iterator begin () const;           //!< Returns an iterator to the first element in the collection.
    const_iterator end ()   const;           //!< Returns an iterator that points to the end of the collection.
};

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          TableEdgeStroke
{
uint32_t        m_symbologyKey;
DPoint2d        m_origin;
DPoint2d        m_end;
};

struct   TableEdgeStrokes;

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct  TableEdgeStrokeIterator : RefCountedBase, std::iterator<std::forward_iterator_tag, TableEdgeStroke const>
{
private:
    friend struct   TableEdgeStrokes;

    enum class StrokePoint { Origin, End };

    TableEdgeStroke                     m_stroke;
    TableEdgeStrokes const*             m_strokeCollection;

    bool                                m_atEnd;
    bool                                m_firstEdge;
    DPoint2d                            m_hostOrigin;
    EdgeRuns::const_iterator            m_runIter;
    EdgeRuns::const_iterator            m_runIterEnd;
    SubTables::const_iterator           m_subTableIter;
    SubTables::const_iterator           m_subTableIterEnd;
    RowVector::const_iterator           m_rowIter;
    RowVector::const_iterator           m_rowIterEnd;
    ColumnVector::const_iterator        m_columnIter;
    ColumnVector::const_iterator        m_columnIterEnd;

    TableEdgeStrokeIterator (TableEdgeStrokes const& collection, bool begin);

    double          GetComponentLength (uint32_t index, bool span) const;
    DVec2dCP        GetComponentDirection (bool host) const;
    DVec2d          GetHostVector (uint32_t index, bool span) const;
    DVec2d          GetHostLengthVector (uint32_t index) const;
    DVec2d          GetHostSpanVector (uint32_t index) const;

    bool            AtEndOfSpan();
    uint32_t        GetSpanIndex();
    bool            AdvanceAlongSpan(StrokePoint);
    BentleyStatus   IncrementHostIter (uint32_t& newIndex);
    BentleyStatus   MoveToNextHost();

    void            InitRowIter();
    void            InitColumnIter();
    void            InitRunIterFromStart();
    void            InitRunIterFromHost (uint32_t index);
    void            InitForNewSubTable ();

public:
    bool                        IsDifferent(TableEdgeStrokeIterator const& rhs) const;
    void                        MoveToNext ();
    TableEdgeStroke const&      GetCurrent () const;
};

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          TableEdgeStrokes
{
private:
    friend struct   AnnotationTableStroker;
    friend struct   TableEdgeStrokeIterator;

    bool                        m_horizontal;
    AnnotationTablePtr   m_table;
    SubTablesCR                 m_subTables;

    TableEdgeStrokes (AnnotationTableCR, bool horizontal, SubTablesCR subTables);

public:
    typedef VirtualCollectionIterator<TableEdgeStrokeIterator> const_iterator;
    typedef const_iterator iterator;    //!< only const iteration is possible

public:
    const_iterator begin () const;      //!< Returns an iterator to the first element in the collection.
    const_iterator end ()   const;      //!< Returns an iterator that points to the end of the collection.
};

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          AnnotationTableStroker
{
private:
    AnnotationTableCR       m_table;
    GeometryBuilderR        m_geomBuilder;
    bvector<FillRuns>       m_allFillRuns;

    bool                    m_addFills;
    bool                    m_addTextBlocks;
    SubTables               m_subTables;

    void                    AppendRectangle (DPoint2dCR origin, double width, double height);

    void                    AppendFillBox (TableFillBox const&);
    void                    AppendEdgeStroke (TableEdgeStroke const&, bool horizontal);
    void                    AppendCell (AnnotationTableCellCR, DPoint2dCR cellOrigin);

    void                    LayoutSubTables (SubTablesR subTables) const;
    TableEdgeStrokes        ComputeEdgeStrokes (bool horizontal, SubTablesCR subTables) const;
    TableFillBoxes          ComputeFillBoxes (SubTablesCR subTables) const;
    TablePositionedCells    ComputePositionedCells (SubTablesCR) const;

    void                    ApplyCellToFillRuns (AnnotationTableCellCR cell);

#if defined (NEEDSWORK)
    void            DrawHilitedSubEntitiesGeometry ();
#endif

public:
    AnnotationTableStroker (AnnotationTableCR table, GeometryBuilderR builder);

    AnnotationTableCR    GetTable () const { return m_table; }
    FillRunsCR                  GetFillRuns (uint32_t rowIndex) const { return m_allFillRuns[rowIndex]; }

    void            WantAddTextBlocks          (bool v) { m_addTextBlocks = v; }
    void            WantAddFill                (bool v) { m_addFills = v; }

    void            AppendTableGeometry ();
#if defined (NEEDSWORK)
    void            StrokeBoundary (bool filled);
    void            DrawHilitedSubEntities ();

    SubTablesCR     GetSubTables () { return m_subTables; }
    static UInt32   GetTableHiliteColor (ViewContextR context);
#endif
};

//__PUBLISH_SECTION_START__
END_BENTLEY_DGN_NAMESPACE
