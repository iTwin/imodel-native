//-------------------------------------------------------------------------------------- 
//     $Source: PublicAPI/DgnPlatform/AnnotationTable.h $
//  $Copyright: (c) 2015 Bentley Systems, Incorporated. All rights reserved. $
//-------------------------------------------------------------------------------------- 
#pragma once

//__PUBLISH_SECTION_START__

#include <Bentley/RefCounted.h>
#include <Bentley/WString.h>
#include <ECDb/ECSqlStatement.h>
#include <DgnPlatform/Annotations/AnnotationTextBlockLayout.h>
#include <Bentley/stdcxx/bstdmap.h>

DGNPLATFORM_TYPEDEFS(AnnotationTableCellIndex);
DGNPLATFORM_TYPEDEFS(AnnotationTableElement);
DGNPLATFORM_TYPEDEFS(AnnotationTableAspect);
DGNPLATFORM_TYPEDEFS(AnnotationTableCell);
DGNPLATFORM_TYPEDEFS(AnnotationTableRow);
DGNPLATFORM_TYPEDEFS(AnnotationTableColumn);
DGNPLATFORM_TYPEDEFS(TableCellMarginValues);
DGNPLATFORM_TYPEDEFS(PropertyNames);

DGNPLATFORM_TYPEDEFS(CellContentHolder);
DGNPLATFORM_TYPEDEFS(MergeEntry);
//__PUBLISH_SECTION_END__
DGNPLATFORM_TYPEDEFS(TextBlockHolder);
//__PUBLISH_SECTION_START__

DGNPLATFORM_REF_COUNTED_PTR(AnnotationTableElement);

#define DGN_CLASSNAME_AnnotationTableElement    "AnnotationTableElement"
#define DGN_CLASSNAME_AnnotationTableHeader     "AnnotationTableHeader"
#define DGN_CLASSNAME_AnnotationTableRow        "AnnotationTableRow"
#define DGN_CLASSNAME_AnnotationTableColumn     "AnnotationTableColumn"
#define DGN_CLASSNAME_AnnotationTableCell       "AnnotationTableCell"
#define DGN_CLASSNAME_AnnotationTableMerge      "AnnotationTableMerge"
#define DGN_CLASSNAME_AnnotationTableFill       "AnnotationTableFill"
#define DGN_CLASSNAME_AnnotationTableSymbology  "AnnotationTableSymbology"
#define DGN_CLASSNAME_AnnotationTableEdgeRun    "AnnotationTableEdgeRun"

BEGIN_BENTLEY_DGNPLATFORM_NAMESPACE

typedef std::shared_ptr<CellContentHolder>  CellContentHolderPtr;

//! @addtogroup Annotations
//! @beginGroup

/*=================================================================================**//**
* Specifies a <row, col> position within a table.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct AnnotationTableCellIndex
{
private:
    static int const    _LT_ = -1;
    static int const    _EQ_ =  0;
    static int const    _GT_ =  1;

    inline int compare (AnnotationTableCellIndex const& other) const
        {
        if (row < other.row)                        return _LT_;
        if (row > other.row)                        return _GT_;
        if (col < other.col)                        return _LT_;
        if (col > other.col)                        return _GT_;

        return  _EQ_;
        }

//__PUBLISH_SECTION_END__
public:
    static AnnotationTableCellIndex     GetCellIndex (ECSqlStatement&, uint32_t colIndex);
    static void                         BindCellIndex (ECSqlStatement&, Utf8CP paramName, AnnotationTableCellIndexCR);

//__PUBLISH_SECTION_START__
public:
    uint32_t    row;
    uint32_t    col;

    //! Construct an index for cell 0,0.
    AnnotationTableCellIndex () : row(0), col(0) {}

    //! Construct an index for a specified cell.
    AnnotationTableCellIndex (uint32_t r, uint32_t c) : row(r), col(c) {}

    //! Test two indices for relative value.
    bool operator>  (AnnotationTableCellIndex const& other) const {return      compare (other) >  _EQ_;}
    //! Test two indices for relative value.
    bool operator<  (AnnotationTableCellIndex const& other) const {return      compare (other) <  _EQ_;}
    //! Test two indices for relative value.
    bool operator>= (AnnotationTableCellIndex const& other) const {return      compare (other) >= _EQ_;}
    //! Test two indices for relative value.
    bool operator<= (AnnotationTableCellIndex const& other) const {return      compare (other) <= _EQ_;}
    //! Test two indices for equality.
    bool operator== (AnnotationTableCellIndex const& other) const {return      compare (other) == _EQ_;}
    //! Test two indices for equality.
    bool operator!= (AnnotationTableCellIndex const& other) const {return      compare (other) != _EQ_;}

    //! Create a string representation of the index.
    DGNPLATFORM_EXPORT          WString        ToString() const;

    //! Initialize an index from a string in the format generated by ToString.
    DGNPLATFORM_EXPORT static   BentleyStatus  FromString (AnnotationTableCellIndexR, WCharCP);

    //! Create a string representation for a row index.
    DGNPLATFORM_EXPORT static   WString StringFromRowIndex      (uint32_t);
    //! Create a string representation for a column index.
    DGNPLATFORM_EXPORT static   WString StringFromColumnIndex   (uint32_t);

    //! Get the row index value from a string.
    DGNPLATFORM_EXPORT static   BentleyStatus  RowIndexFromString      (uint32_t&, WCharCP);
    //! Get the cell index value from a string.
    DGNPLATFORM_EXPORT static   BentleyStatus  ColumnIndexFromString   (uint32_t&, WCharCP);
};

/*=================================================================================**//**
* This enum represents the distinct regions within a TextTable.  A table can hold
* a unique TextStyle for each region that will be used when adding text to an empty
* cell.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum class AnnotationTableRegion
    {
    Body            = 0,
    TitleRow        = 1,
    HeaderRow       = 2,
    FooterRow       = 3,
    HeaderColumn    = 4,
    FooterColumn    = 5,
    };

/*=================================================================================**//**
* Used by TextTable::InsertRow and TextTable::InsertColumn.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum class TableInsertDirection
    {
    Before          = 0,
    After           = 1,
    };

/*=================================================================================**//**
* Describes how a table is broken up to be displayed as sub tables.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum class TableBreakType
    {
    None            = 0,
    Horizontal      = 1,
    Vertical        = 2,
    };

/*=================================================================================**//**
* Describes how each sub table is positioned relative to the previous sub table.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum class TableBreakPosition
    {
    Right           = 0,
    Left            = 1,
    Above           = 2,
    Below           = 3,
    Manual          = 4,
    };

/*=================================================================================**//**
* Describes how text will be positioned within a table cell.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum class TableCellAlignment
    {
    LeftTop         = 0,
    LeftMiddle      = 1,
    LeftBottom      = 2,
    CenterTop       = 3,
    CenterMiddle    = 4,
    CenterBottom    = 5,
    RightTop        = 6,
    RightMiddle     = 7,
    RightBottom     = 8,
    };

/*=================================================================================**//**
* Describes how text within a cell will be rotated relative to the table.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum class TableCellOrientation
    {
    Horizontal      = 0,
    Rotate90        = 1,
    Rotate270       = 2,
    Vertical        = 3,
    };

/*=================================================================================**//**
* Describes the type of a table row or column.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum class TableHeaderFooterType
    {
    Title           = 0,
    Header          = 1,
    Body            = 2,
    Footer          = 3,
    };

/*=================================================================================**//**
* Describes the various edge lines that surround a group of one or more table cells.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum TableCellListEdges
    {
    Top                   = 0,
    Bottom                = 1,
    Left                  = 2,
    Right                 = 3,
    Interior              = 4,
    Exterior              = 5,
    InteriorHorizontal    = 6,
    InteriorVertical      = 7,
    All                   = 50,
    };

/*=================================================================================**//**
* Used to specify the default fill of a table row.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum class TableRows
    {
    Odd             = 0,
    Even            = 1,
    All             = 50,
    };

/*=================================================================================**//**
* Used to specify the minimum gap between a cell's contents and its edges.
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct TableCellMarginValues
{
double  m_top;      ///<    Minimum distance between the top edge of a cell and its contents.
double  m_bottom;   ///<    Minimum distance between the bottom edge of a cell and its contents.
double  m_left;     ///<    Minimum distance between the left edge of a cell and its contents.
double  m_right;    ///<    Minimum distance between the right edge of a cell and its contents.
};

//__PUBLISH_SECTION_END__
/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
enum class SizeLockAction
    {
    TurnOn      = 1,
    TurnOff     = 2,
    NoChange    = 3,
    };

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          AnnotationTableSerializer
    {
private:
    AnnotationTableElementR             m_table;
/*
    bset<UInt32>                        m_usedSymbologyKeys;
    bset<UInt32>                        m_usedFillKeys;
    bool                                m_cacheXAttributes;
    bool                                m_updateRange;
    bool                                m_cleanedElement;
    bool                                m_deferStandalones;
    bvector<TextTableInstanceHolderP>   m_deferredHolders;
*/
    BentleyStatus   SerializeAspectChanges (AnnotationTableAspectR);
/*
    bool            ScheduleEdgeRuns (EdgeRunsR edgeRuns);
    void            DeleteAllPrivateInstances ();
    BentleyStatus   ScheduleDeferredInstances ();
*/
public:
    AnnotationTableSerializer (AnnotationTableElementR table/*, bool isDynamics, bool updateRange*/) : m_table(table) {};

    AnnotationTableElementR  GetElement () { return m_table; }

    DgnDbStatus       SerializeTableToDb ();
    };

//__PUBLISH_SECTION_START__

//=======================================================================================
// @bsiclass
//=======================================================================================
//! @private
template<class T_Primitive> class TableValue
{
private:
    bool            m_isValid;
    T_Primitive     m_value;

protected:
    void    SetValid () { m_isValid = true; }

public:
    TableValue () { m_isValid = false; }
    TableValue (T_Primitive v) { m_isValid = true; m_value = v; }
    TableValue (TableValue& rhs) { m_isValid = rhs.m_isValid; m_value = rhs.m_value; } 

    void        Clear () { m_isValid = false; }
    bool        IsValid () const { return m_isValid; }
    bool        IsNull () const { return ! m_isValid; }
    void        SetValue (T_Primitive v) { m_value = v; SetValid(); }
    T_Primitive GetValue () const { return IsValid() ? m_value : 0; }
};

typedef TableValue<int>         TableIntValue;      //!< @private
typedef TableValue<uint32_t>    TableUIntValue;     //!< @private
typedef TableValue<uint64_t>    TableUInt64Value;   //!< @private
typedef TableValue<double>      TableDoubleValue;   //!< @private
typedef TableValue<bool>        TableBoolValue;     //!< @private

//=======================================================================================
// @bsiclass
//=======================================================================================
//! @private
enum class AnnotationTableAspectType
    {
    Header      = 0,
    Row         = 1,
    Column      = 2,
    Cell        = 3,
    Merge       = 4,
    Fill        = 5,
    Symbology   = 6,
    EdgeRun     = 7,
    };

//=======================================================================================
// @bsiclass
//=======================================================================================
//! @private
struct AnnotationTableAspectDescr
{
AnnotationTableAspectType   m_type;
uint64_t                    m_aspectId;

/*ctor*/    AnnotationTableAspectDescr (AnnotationTableAspectType t, uint64_t id) : m_type(t), m_aspectId(id) {}
};

//=======================================================================================
// @bsiclass
//=======================================================================================
//! @private
struct PropertyDescr
    {
    int     m_propIndex;
    Utf8CP  m_propName;
    };

//=======================================================================================
// @bsiclass
//=======================================================================================
//! @private
struct PropertyNames : bvector <Utf8String>
{
    // This serves to ensure that the property name strings are correlated
    // to the PropIndex values.  In the SELECT statement, PropIndices are 
    // directly correlated to column indices.  So it's important that the
    // first name is propIdex=0, etc. and that no gaps exist.
    /* ctor */ PropertyNames (std::initializer_list<PropertyDescr> iList)
        {
        for (PropertyDescr const& item : iList)
            {
            BeAssert (item.m_propIndex == size());
            push_back (item.m_propName);
            }
        }
};

//=======================================================================================
// @bsiclass
//=======================================================================================
//! @private
struct AspectTypeData
    {
    AnnotationTableAspectType   m_type;
    bool                        m_isUniqueAspect;
    Utf8CP                      m_ecClassName;
    PropertyNames               m_propertyNames;

    Utf8String                  m_ecSqlInsertString;
    Utf8String                  m_ecSqlUpdateString;
    Utf8String                  m_ecSqlDeleteString;
    Utf8String                  m_ecSqlSelectString;
    Utf8String                  m_ecSqlSelectDupeString;

    /*ctor*/ AspectTypeData (AnnotationTableAspectType t, PropertyNamesCR p, bool u, Utf8CP c) : m_type(t), m_propertyNames(p), m_isUniqueAspect(u), m_ecClassName(c) {}
    };

//=======================================================================================
// @bsiclass
//=======================================================================================
struct AnnotationTableAspect
{
private:
    bool                        m_hasChanges;
    TableUInt64Value            m_aspectId;
    AnnotationTableElementR     m_table;

    static AspectTypeData const& GetAspectTypeData(AnnotationTableAspectType);

protected:
    /*ctor*/        AnnotationTableAspect (AnnotationTableElementR t) : m_table (t), m_hasChanges(false) {}
    /*ctor*/        AnnotationTableAspect (AnnotationTableAspectCR rhs);

    bool BindIfNull  (ECSqlStatement&, Utf8CP paramName, bool isNull);

    void BindInt     (ECSqlStatement&, Utf8CP paramName, TableIntValue const&);
    void BindUInt    (ECSqlStatement&, Utf8CP paramName, TableUIntValue const&);
    void BindInt64   (ECSqlStatement&, Utf8CP paramName, TableUInt64Value const&);
    void BindBool    (ECSqlStatement&, Utf8CP paramName, TableBoolValue const&);
    void BindDouble  (ECSqlStatement&, Utf8CP paramName, TableDoubleValue const&);

    void BindProperties (ECSqlStatement&, bool isUpdate);

    void    SetHasChanges ()    { m_hasChanges = true;  }
    void    ClearHasChanges ()  { m_hasChanges = false; }

    // To support insert, update, delete.
    virtual void                        _BindProperties (ECSqlStatement&) = 0;
    virtual void                        _AssignValue (int index, BeSQLite::EC::IECSqlValue const&) = 0;
    virtual void                        _CopyDataFrom (AnnotationTableAspectCR) {};

//__PUBLISH_SECTION_END__
public:
    void                CopyDataFrom (AnnotationTableAspectCR);
    void                AssignProperties (ECSqlStatement const& statement);
    void                SetAspectId (uint64_t id) { m_aspectId = id; }

    static BentleyStatus   DeleteAspectFromDb (AnnotationTableAspectType, uint64_t aspectId, AnnotationTableElementR table);
    static CachedECSqlStatementPtr  GetPreparedSelectStatement (AnnotationTableAspectType, AnnotationTableElementCR);
    static bool  DbContainsDuplicateRows (AnnotationTableAspectType, AnnotationTableElementCR);

    BentleyStatus       InsertInDb();
    BentleyStatus       UpdateInDb();
    BentleyStatus       DeleteFromDb();
//__PUBLISH_SECTION_START__

public:
    bool        HasChanges () const         { return m_hasChanges; }                        //!< @private
    bool        HasValidAspectId () const   { return m_aspectId.IsValid(); }                //!< @private
    uint64_t    GetAspectId () const        { return m_aspectId.GetValue(); }               //!< @private

    virtual AnnotationTableAspectType   _GetAspectType() const = 0;                         //!< @private
    virtual bool                        _IsUniqueAspect () const { return false; }          //!< @private
    virtual bool                        _IsRequiredOnElement () const { return false; }     //!< @private
    virtual bool                        _ShouldBePersisted ()   const { return true; }      //!< @private
    virtual void                        _FlushChangesToProperties() {}                      //!< @private

    AnnotationTableElementR     GetTable ()       { return m_table; }
    AnnotationTableElementCR    GetTable () const { return m_table; }

};

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
//! @private
struct MergeEntry : AnnotationTableAspect
{
private:
    AnnotationTableCellIndex    m_rootCell;
    TableUIntValue              m_rowSpan;
    TableUIntValue              m_columnSpan;

    enum class PropIndex
        {
        RootCell        = 0,    // no gaps allowed
        RowSpan         = 1,
        ColumnSpan      = 2,
        };

protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Merge; }
    virtual void                        _BindProperties(ECSqlStatement&) override;
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&) override;
    virtual bool                        _ShouldBePersisted() const override;
    void                                _CopyDataFrom (AnnotationTableAspectCR) override;

public:
    static PropertyNames            GetPropertyNames();
    void                            SetRootCell (AnnotationTableCellIndexCR val);
    WString                         ToString() const;

public:
    /*ctor*/                        MergeEntry (AnnotationTableElementR, AnnotationTableCellIndex rootCell);
    /*ctor*/                        MergeEntry (MergeEntryCR);

    MergeEntryR                     operator= (MergeEntryCR rhs);

    AnnotationTableCellIndexCR      GetRootIndex    ()  const;
    uint32_t                        GetRowSpan      ()  const;
    uint32_t                        GetColumnSpan   ()  const;

    void                            SetRootIndex (AnnotationTableCellIndexCR);
    void                            SetRowSpan      (uint32_t);
    void                            SetColumnSpan   (uint32_t);
};

//! @private
typedef Bstdcxx::bstdmap<AnnotationTableCellIndex, MergeEntry>    MergeMap;

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
//! @private
struct MergeDictionary : MergeMap
{
public:
    /*ctor*/                        MergeDictionary () {}

    WString                         ToString() const;

    MergeEntryCP                    GetMerge (AnnotationTableCellIndexCR) const;
    MergeEntryP                     GetMerge (AnnotationTableCellIndexCR);
    BentleyStatus                   DeleteMerge (AnnotationTableCellIndexCR, AnnotationTableElementR table);
    BentleyStatus                   AddMerge (MergeEntryCR);

    void                            AdjustMergesAfterIndex (uint32_t rowIndex, bool isRow, bool increment);

};

//__PUBLISH_SECTION_END__
/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          CellContentHolder
{
protected:
    AnnotationTableCellP            m_tableCell;

    /* ctor */                      CellContentHolder (AnnotationTableCellR c) { Initialize (c); }

public:
    void                            Initialize (AnnotationTableCellR c) { m_tableCell = &c; }

    virtual bool                    _IsEmpty () const = 0;
    virtual DVec2d                  _GetSize () const = 0;                  // The current size of the content
    virtual double                  _GetFullyCompressedHeight () const = 0; // Minimum height supported by the content
    virtual double                  _GetFullyExpandedHeight () const = 0;   // Natural height of the content
    virtual double                  _GetFullyCompressedWidth () const = 0;  // Minimum width supported by the content
    virtual double                  _GetFullyExpandedWidth () const = 0;    // Natural width of the content
    virtual void                    _Draw (DPoint3dCR origin, RotMatrixCR, TableCellAlignment, ViewContextR) const {}

    virtual void                    _SetAlignment (TableCellAlignment) {};
    virtual void                    _SetOrientation (TableCellOrientation) {};
    virtual void                    _FitContentToHeight (double height) = 0;
    virtual void                    _FitContentToWidth (double width) = 0;
    virtual void                    _FlushChangesToProperties () = 0;

    virtual TextBlockHolderP        _AsTextBlockHolder () = 0;
};

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct          TextBlockHolder : CellContentHolder
{
private:

enum TextBlockState
    {
    TEXTBLOCK_STATE_Uninitialized   = 0,
    TEXTBLOCK_STATE_Initialized     = 1,
    TEXTBLOCK_STATE_Changed         = 2,
    };

mutable AnnotationTextBlockPtr          m_textBlock;
mutable AnnotationTextBlockLayoutPtr    m_textBlockLayout;
mutable TextBlockState                  m_textBlockState;

    void            ReconcileCellPropertiesFromNewTextBlock();
    void            ReconcileJustificationForNewTextBlock();
    void            SetWordWrapLength (double length);
    double          GetMinimumWordWrapLength () const;
    double          GetNonWrappedLength () const;
    void            GetPaddedSizeAlignedWithTextBlock (double& width, double& height) const;
    void            SetTextBlockDirect (AnnotationTextBlockP textBlock) const;

public:
    /* ctor */                  TextBlockHolder (AnnotationTableCellR cell);
    TextBlockHolderR            operator= (TextBlockHolderCR other);

    AnnotationTextBlockCP       GetTextBlock () const;
    AnnotationTextBlockP        GetTextBlockForFieldProcessing();
    void                        SetTextBlock (AnnotationTextBlockCR textBlock);
    AnnotationTextBlockLayoutCP GetTextBlockLayout () const;

    // CellContentHolder
    virtual bool                    _IsEmpty () const override;
    virtual DVec2d                  _GetSize () const override;
    virtual double                  _GetFullyCompressedWidth () const override;
    virtual double                  _GetFullyExpandedWidth () const override;
    virtual double                  _GetFullyCompressedHeight () const override;
    virtual double                  _GetFullyExpandedHeight () const override;

    virtual void                    _SetAlignment (TableCellAlignment) override;
    virtual void                    _SetOrientation (TableCellOrientation) override;
    virtual void                    _FitContentToHeight (double height) override;
    virtual void                    _FitContentToWidth (double width) override;
    virtual TextBlockHolder*        _AsTextBlockHolder () override { return this; }
    virtual void                    _FlushChangesToProperties () override;

static  double          ComputeDescenderAdjustment (AnnotationTextStyleCR);
static  double          ComputeDescenderAdjustment (AnnotationTextBlockLayoutCR);

}; // TextBlockHolder

//__PUBLISH_SECTION_START__
//=======================================================================================
// @bsiclass
//=======================================================================================
struct AnnotationTableCell : AnnotationTableAspect
{
friend AnnotationTableElement;

private:
    AnnotationTableCellIndex    m_index;
    Byte const*                 m_rawTextBlock;
    size_t                      m_rawTextBlockBytes;
    TableUIntValue              m_fillKey;
    TableUIntValue              m_alignment;
    TableUIntValue              m_orientation;
    TableDoubleValue            m_marginTop;
    TableDoubleValue            m_marginBottom;
    TableDoubleValue            m_marginLeft;
    TableDoubleValue            m_marginRight;

    CellContentHolderPtr        m_contentHolder;

//__PUBLISH_SECTION_END__
    enum class PropIndex
        {
        CellIndex       = 0,    // must be first
        TextBlock       = 1,    // no gaps allowed
        FillKey         = 2,
        Alignment       = 3,
        Orientation     = 4,
        MarginTop       = 5,
        MarginBottom    = 6,
        MarginLeft      = 7,
        MarginRight     = 8,
        };

    void                                InitContentsToEmptyTextBlock ();

//__PUBLISH_SECTION_START__
protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Cell; }
    virtual void                        _BindProperties(ECSqlStatement&) override;
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&) override;
    virtual void                        _FlushChangesToProperties() override;
    virtual bool                        _ShouldBePersisted() const override;
    void                                _CopyDataFrom (AnnotationTableAspectCR) override;

//__PUBLISH_SECTION_END__
public:
    static PropertyNames                GetPropertyNames();

    void                                SetIndex (AnnotationTableCellIndexCR val);

    RotMatrix                           GetContentRotation () const;
    DPoint3d                            GetContentOrigin (DPoint3dCR cellOrigin, DVec3dCR xVec, DVec3dCR yVec) const;
    DVec2d                              GetContentSize () const;
    double                              GetFullyCompressedContentHeight () const;
    double                              GetFullyExpandedContentHeight () const;
    double                              GetFullyCompressedContentWidth () const;
    double                              GetFullyExpandedContentWidth () const;
    DVec2d                              GetAvailableContentSize() const;
    DVec2d                              GetEmptyMinimumSizeWithoutMargins() const;
    void                                FitContentToHeight (double height);
    void                                FitContentToWidth (double width);
    void                                SetSizeFromContents (DVec2dCP oldContentSize);
    DVec2d                              GetTextSize () const;

    void                                ApplyTextStyleByRegion ();
    void                                HeightChanged ();
    void                                WidthChanged ();

    bool                                IndexIsInSpan (AnnotationTableCellIndexCR) const;
    void                                SetAsMergedCellRoot (uint32_t rowSpan, uint32_t colSpan);
    void                                SetAsMergedCellInterior (bool isMerged);
    bool                                IsMergedCellInterior () const;
    void                                DeleteMergeCellInteriorRow();
    void                                DeleteMergeCellInteriorColumn();

    void                                SetAlignmentDirect (TableCellAlignment);
    void                                SetOrientationDirect (TableCellOrientation);
    void                                SetTextBlockDirect (AnnotationTextBlockCR);
    void                                SetMarginsDirect (TableCellMarginValuesCR);
    void const*                         GetBinaryTextBlock (size_t* numBytes);
    void                                AssignBinaryTextBlock (void const* data, size_t numBytes);
    void                                ClearBinaryTextBlock ();

    static AnnotationTextBlock::HorizontalJustification ToTextBlockJustification (TableCellAlignment);

//__PUBLISH_SECTION_START__

public:
    /*ctor*/        AnnotationTableCell (AnnotationTableElementR, AnnotationTableCellIndex index);
    /*ctor*/        AnnotationTableCell (AnnotationTableCellCR);

    AnnotationTableCellR operator= (AnnotationTableCellCR rhs);

//! Get the unique index that represents this cell.
DGNPLATFORM_EXPORT  AnnotationTableCellIndex    GetIndex         () const { return m_index; }
//! Get the TextTableRegion that hosts this cell.  The region is determined by the TableHeaderFooterType of the cell's row and column.  It cannot be controlled for individual cells.
DGNPLATFORM_EXPORT  AnnotationTableRegion       GetTableRegion   () const;
//! Get the TextBlock stored in this cell.  May be NULL.  Do not modify this TextBlock.  To change it, call TextBlock::Clone and then AnnotationTableCell::SetTextBlock.
DGNPLATFORM_EXPORT  AnnotationTextBlockCP       GetTextBlock     () const;
//! Returns true if the cell has no contents.
DGNPLATFORM_EXPORT  bool                        IsEmpty          () const;

//! Get the alignment stored in this cell.  The alignment controls the position of the contents within the cell.
DGNPLATFORM_EXPORT  TableCellAlignment          GetAlignment()      const;
//! Get the orientation stored in this cell.  The orientation controls the rotation of the contents within the cell.
DGNPLATFORM_EXPORT  TableCellOrientation        GetOrientation()    const;
//! Get the margins stored in this cell.  The margins control the minimum gap between a cell's contents and its edges.
DGNPLATFORM_EXPORT  TableCellMarginValues       GetMargins()        const;

//! Change the alignment stored in this cell.  The alignment controls the position of the contents within the cell.
DGNPLATFORM_EXPORT  void                        SetAlignment (TableCellAlignment);
//! Change the orientation stored in this cell.  The orientation controls the rotation of the contents within the cell.
DGNPLATFORM_EXPORT  void                        SetOrientation (TableCellOrientation);
//! Change the margins stored in this cell.  The margins control the minimum gap between a cell's contents and its edges.
DGNPLATFORM_EXPORT  void                        SetMargins (TableCellMarginValuesCR);

//! Get the size of this cell in UORs.  The x,y coordinates of the returned value represent the horizontal and vertical sizes of the cell in the table's coordinate system.
//! The size is determined by the hosting rows and columns and cannot be controlled for individual cells.
DGNPLATFORM_EXPORT  DVec2d                      GetSize () const;

#if defined (NEEDSWORK)
//! Set or remove a uniform color fill for this cell.  The options set by this method will override the default fill behavior dictated by the table.  See TextTable::GetDefaultFill.
//! To set a particular color call symb.SetFillColor before calling SetFill.  To turn off fill for this cell call symb.SetFillVisible(false) before calling SetFill.
DGNPLATFORM_EXPORT  void                        SetFillSymbology (TableSymbologyValuesCR symb);
#endif

//! Delete the contents of this cell.
DGNPLATFORM_EXPORT  void                        ClearContents ();
//! Specify text to be displayed in this cell.  It can be useful to call AnnotationTableCell::CreateEmptyTextBlock to start building the text based on the default formatting options.
//! Will replace the existing contents of this cell.
DGNPLATFORM_EXPORT  void                        SetTextBlock (AnnotationTextBlockCR);
//! Specify a text string to be displayed in this cell using the default formatting options for this cell.  Will replace the existing contents of this cell.
DGNPLATFORM_EXPORT  void                        SetTextString (Utf8CP);
//! Returns an empty TextBlock that is set up with the default formatting options for this cell.
DGNPLATFORM_EXPORT  AnnotationTextBlockPtr      CreateEmptyTextBlock    () const;

//! Get the number of rows spanned by this cell.  Typically each cell only spans a single row but the cell merging feature allows a cell to span multiple.  See TextTable::MergeCells.
DGNPLATFORM_EXPORT  uint32_t                    GetRowSpan () const;
//! Get the number of columns spanned by this cell.  Typically each cell only spans a single column but the cell merging feature allows a cell to span multiple.  See TextTable::MergeCells.
DGNPLATFORM_EXPORT  uint32_t                    GetColumnSpan () const;

#if defined (NEEDSWORK)
//! Get the fill override property stored on this cell.  If the cell doesn't store an override its displayed fill will be based on the default behavior of its row.  See TextTable::GetDefaultFill.
//! @param symb OUT if (false == symb.HasFillVisible) this cell uses its row's default fill.  Otherwise use symb.GetFillVisible and symb.GetFillColor to get the cell's fill override.
DGNPLATFORM_EXPORT  void                        GetFillSymbology (TableSymbologyValuesR symb) const;
//! Get a list of symbologies used to display the edges of this cell.  Note that for a merged cell it is possible for even a single edge to return multiple symbologies.  For
//! example, consider a cell that spans two columns.  That cell's Top edge may have two different symbologies.  This method is similiar to TextTable::GetEdgeSymbology except
//! that it only works on one cell.
//! @param symb  OUT List of unique symbologies on the requested edges of this cell.
//! @param edges IN  Edges from which to report.  Interior, InteriorHorizontal and InteriorVertical are ignored.
DGNPLATFORM_EXPORT  void                        GetEdgeSymbology (bvector<TableSymbologyValuesPtr>& symb, TableCellListEdges edges) const;
#endif

//! Change this cell to span only a single row and a single column.
DGNPLATFORM_EXPORT  void                        Unmerge ();

};

//=======================================================================================
// @bsiclass
//=======================================================================================
struct AnnotationTableRow : AnnotationTableAspect
{
friend AnnotationTableElement;

private:
    uint32_t                        m_index;
    TableBoolValue                  m_heightLock;
    TableDoubleValue                m_height;
    bvector<AnnotationTableCell>    m_cells;

//__PUBLISH_SECTION_END__
    enum class PropIndex
        {
        RowIndex    = 0,    // must be first
        HeightLock  = 1,    // no gaps allowed
        Height      = 2,
        };

    void                            InitializeInternalCollections();

//__PUBLISH_SECTION_START__
protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Row; }
    virtual void                        _BindProperties(ECSqlStatement&) override;
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&) override;
    virtual void                        _FlushChangesToProperties() override;
    virtual bool                        _ShouldBePersisted() const override;
    void                                _CopyDataFrom (AnnotationTableAspectCR) override;

public:
//__PUBLISH_SECTION_END__
    static PropertyNames                GetPropertyNames();

    void                                SetIndex (uint32_t);
    bvector<AnnotationTableCell>&       GetCellVectorR()          { return m_cells; }

    void                                ApplyHeaderFooterType ();

    // Finds all cells that intersect this row
    bvector<AnnotationTableCellP>       FindCells() const;

    void                                SetHeightLock    (bool);
    void                                SetHeightDirect (double);
    void                                SetHeight (double newHeight, SizeLockAction);
    void                                ShrinkHeightToContents ();
    void                                SetHeightFromContents (bool allowedToChangeContentLayout);
    double                              GetAlternateMinimumHeight () const;
    double                              GetMinimumHeight (bool allowedToChangeContentLayout) const;
    Utf8String                          ToString() const;

//__PUBLISH_SECTION_START__

public:
    /*ctor*/        AnnotationTableRow (AnnotationTableElementR, int index);
    /*ctor*/        AnnotationTableRow (AnnotationTableRowCR);

    AnnotationTableRowR operator= (AnnotationTableRowCR rhs);

//! Get the unique index that represents this row.
DGNPLATFORM_EXPORT  uint32_t                    GetIndex         () const { return m_index; }
//! Get the value of this row's height lock.  This setting controls how the row will react when contents of the table cells change size.
//! When the lock is false, the row's height will grow or shrink based on the content.  When the lock is true, the row's height will never
//! shrink as the content shrinks although it may grow but only if the content grows too large to fit.
DGNPLATFORM_EXPORT  bool                        GetHeightLock    () const;
//! Get the height of this row.
DGNPLATFORM_EXPORT  double                      GetHeight        () const;
//! Compute the minimum height possible for this row given the content of its cells.
DGNPLATFORM_EXPORT  double                      ComputeMinimumHeight () const;

//! Change the height of this row.  The row height cannot be made smaller than the height of the largest content including margins.
//! The height lock will be set to true for this row.  See AnnotationTableRow::GetHeightLock.
DGNPLATFORM_EXPORT  void                        SetHeight        (double);
//! Shrink the height of this row to fit the current contents of the cells.
//! The height lock will be set to false for this row.  See TextTableRow::GetHeightLock.
DGNPLATFORM_EXPORT  void                        SetHeightFromContents ();

//! Get the type of this row.  The row's type controls the default TextStyle for the row's cells.
DGNPLATFORM_EXPORT  TableHeaderFooterType       GetHeaderFooterType () const;
//! Set the type of this row.  The row's type controls the default TextStyle for the row's cells.
//! The type cannot by set to an arbitrary value.  The following rules apply:
//! - All title rows must occur before all rows of any other type.
//! - All header rows must occur after all title rows but before all rows of any other type.
//! - All body rows must occur after all title and header rows but before all footer rows.
//! - All footer rows must occur after all rows of any other type.
//! @param type IN new type
//! @returns ERROR if the type could not be set.  See the rules above.
DGNPLATFORM_EXPORT  BentleyStatus               SetHeaderFooterType (TableHeaderFooterType type);
};

//=======================================================================================
// @bsiclass
//=======================================================================================
struct AnnotationTableColumn : AnnotationTableAspect
{
friend AnnotationTableElement;

private:
    uint32_t                m_index;
    TableBoolValue          m_widthLock;
    TableDoubleValue        m_width;

//__PUBLISH_SECTION_END__
    enum class PropIndex
        {
        ColumnIndex = 0,    // must be first
        WidthLock   = 1,    // no gaps allowed
        Width       = 2,
        };

//__PUBLISH_SECTION_START__
protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Column; }
    virtual void                        _BindProperties(ECSqlStatement&);
    virtual void                        _AssignValue (int, BeSQLite::EC::IECSqlValue const&);
    virtual void                        _FlushChangesToProperties() override;
    virtual bool                        _ShouldBePersisted() const override;
    void                                _CopyDataFrom (AnnotationTableAspectCR) override;

//__PUBLISH_SECTION_END__
public:
    static PropertyNames                GetPropertyNames();
    void                                SetIndex (uint32_t);

    void                                ApplyHeaderFooterType ();

    // Finds all cells that intersect this column
    bvector<AnnotationTableCellP>       FindCells() const;

    void                                SetWidthLock    (bool);
    void                                SetWidthDirect (double);
    void                                SetWidth (double newWidth, SizeLockAction);
    void                                ShrinkWidthToContents ();
    double                              GetMinimumWidth (bool allowedToChangeContentLayout) const;
    void                                SetWidthFromContents (bool allowedToChangeContentLayout);
    double                              GetAlternateMinimumWidth () const;
    WString                             ToString() const;

//__PUBLISH_SECTION_START__

public:
    /*ctor*/        AnnotationTableColumn (AnnotationTableElementR, int index);
    /*ctor*/        AnnotationTableColumn (AnnotationTableColumnCR);

    AnnotationTableColumnR operator= (AnnotationTableColumnCR rhs);

//! Get the unique index that represents this column.
DGNPLATFORM_EXPORT  uint32_t                    GetIndex         () const { return m_index; }
//! Get the value of this column's width lock.  This setting controls how the column will react when contents of the table cells change size.
//! When the lock is false, the column's width will grow or shrink based on the content.  When the lock is true, the column's width will never
//! shrink as the content shrinks although it may grow but only if the content grows too large to fit.
DGNPLATFORM_EXPORT  bool                        GetWidthLock    () const;
//! Get the width of this column.
DGNPLATFORM_EXPORT  double                      GetWidth        () const;
//! Compute the minimum width possible for this column given the content of its cells.
DGNPLATFORM_EXPORT  double                      ComputeMinimumWidth () const;

//! Change the width of this column.  The column width cannot be made smaller than the width of the largest content including margins.
//! The width lock will be set to true for this column.  See AnnotationTableColumn::GetWidthLock.
DGNPLATFORM_EXPORT  void                        SetWidth        (double);
//! Shrink the width of this column to fit the current contents of the cells.
//! The width lock will be set to false for this column.  See TextTableColumn::GetWidthLock.
DGNPLATFORM_EXPORT  void                        SetWidthFromContents ();

//! Get the type of this column.  The column's type controls the default TextStyle for the column's cells.
//! TableHeaderFooterType::Title is not supported for columns.
DGNPLATFORM_EXPORT  TableHeaderFooterType       GetHeaderFooterType () const;
//! Set the type of this column.  The column's type controls the default TextStyle for the column's cells.
//! TableHeaderFooterType::Title is not supported for columns.
//! The type cannot by set to an arbitrary value.  The following rules apply:
//! - All header columns must occur before all columns of any other type.
//! - All body columns must occur after all header columns but before all footer columns.
//! - All footer columns must occur after all columns of any other type.
//! @param type IN new type
//! @returns ERROR if the type could not be set.  See the rules above.
DGNPLATFORM_EXPORT  BentleyStatus               SetHeaderFooterType (TableHeaderFooterType type);

};

//=======================================================================================
// @bsiclass
//=======================================================================================
//! @private
struct TableHeaderAspect : AnnotationTableAspect
{
friend AnnotationTableElement;

private:
    TableUIntValue          m_rowCount;
    TableUIntValue          m_columnCount;
    TableUInt64Value        m_textStyleId;
    TableUIntValue          m_titleRowCount;
    TableUIntValue          m_headerRowCount;
    TableUIntValue          m_footerRowCount;
    TableUIntValue          m_headerColumnCount;
    TableUIntValue          m_footerColumnCount;
    TableUIntValue          m_breakType;
    TableUIntValue          m_breakPosition;
    TableDoubleValue        m_breakLength;
    TableDoubleValue        m_breakGap;
    TableBoolValue          m_repeatHeaders;
    TableBoolValue          m_repeatFooters;
    TableDoubleValue        m_defaultColumnWidth;
    TableDoubleValue        m_defaultRowHeight;
    TableDoubleValue        m_defaultMarginTop;
    TableDoubleValue        m_defaultMarginBottom;
    TableDoubleValue        m_defaultMarginLeft;
    TableDoubleValue        m_defaultMarginRight;
    TableUIntValue          m_defaultCellAlignment;
    TableUIntValue          m_defaultCellOrientation;
    TableUIntValue          m_fillSymbologyKeyOddRow;
    TableUIntValue          m_fillSymbologyKeyEvenRow;
    TableUInt64Value        m_titleRowTextStyle;
    TableUInt64Value        m_headerRowTextStyle;
    TableUInt64Value        m_footerRowTextStyle;
    TableUInt64Value        m_headerColumnTextStyle;
    TableUInt64Value        m_footerColumnTextStyle;
    double                  m_backupTextHeight;
    int                     m_dataSourceProviderId;
    TableDoubleValue        m_bodyTextHeight;
    TableDoubleValue        m_titleRowTextHeight;
    TableDoubleValue        m_headerRowTextHeight;
    TableDoubleValue        m_footerRowTextHeight;
    TableDoubleValue        m_headerColumnTextHeight;
    TableDoubleValue        m_footerColumnTextHeight;

//__PUBLISH_SECTION_END__
    enum class PropIndex
        {
        RowCount                = 0,        // no gaps allowed
        ColumnCount             = 1, 
        TextStyleId             = 2,
        TitleRowCount           = 3,
        HeaderRowCount          = 4,
        FooterRowCount          = 5,
        HeaderColumnCount       = 6,
        FooterColumnCount       = 7,
        BreakType               = 8,
        BreakPosition           = 9,
        BreakLength             = 10,
        BreakGap                = 11,
        RepeatHeaders           = 12,
        RepeatFooters           = 13,
        DefaultColumnWidth      = 14,
        DefaultRowHeight        = 15,
        DefaultMarginTop        = 16,
        DefaultMarginBottom     = 17,
        DefaultMarginLeft       = 18,
        DefaultMarginRight      = 19,
        DefaultCellAlignment    = 20,
        DefaultCellOrientation  = 21,
        FillSymbologyKeyOddRow  = 22,
        FillSymbologyKeyEvenRow = 23,
        TitleRowTextStyle       = 24,
        HeaderRowTextStyle      = 25,
        FooterRowTextStyle      = 26,
        HeaderColumnTextStyle   = 27,
        FooterColumnTextStyle   = 28,
        BackupTextHeight        = 29,
        DataSourceProviderId    = 30,
        BodyTextHeight          = 31,
        TitleRowTextHeight      = 32,
        HeaderRowTextHeight     = 33,
        FooterRowTextHeight     = 34,
        HeaderColumnTextHeight  = 35,
        FooterColumnTextHeight  = 36,
        };

    TableHeaderAspect (AnnotationTableElementR);

    void        Invalidate ();

    int         GetInteger  (PropIndex) const;
    int         GetUInteger (PropIndex) const;
    double      GetDouble   (PropIndex) const;
    AnnotationTextStyleId  GetStyleId (PropIndex) const;

    void    SetInteger  (int, PropIndex);
    void    SetUInteger (int, PropIndex);
    void    SetBoolean  (bool, PropIndex);
    void    SetDouble   (double, PropIndex);
    void    SetStyleId (AnnotationTextStyleId, PropIndex);

//__PUBLISH_SECTION_START__
protected:
    // AnnotationTableAspect
    AnnotationTableAspectType           _GetAspectType() const override { return AnnotationTableAspectType::Header; }
    virtual void                        _BindProperties(ECSqlStatement&);
    virtual void                        _AssignValue (int propIndex, BeSQLite::EC::IECSqlValue const&) override;
    virtual bool                        _IsUniqueAspect () const override { return true; }
    virtual bool                        _IsRequiredOnElement () const override { return true; }
    virtual void                        _CopyDataFrom (AnnotationTableAspectCR rhsAspect) override;

//__PUBLISH_SECTION_END__
public:
    static PropertyNames                GetPropertyNames();
//__PUBLISH_SECTION_START__

public:
};

/*=================================================================================**//**
* An iterator that can step through the set of cells in a table.
* See AnnotationTableElement::GetCellCollection
+===============+===============+===============+===============+===============+======*/
struct      AnnotationTableCellIterator : RefCountedBase, std::iterator<std::forward_iterator_tag, AnnotationTableCell>
{
private:
    friend struct   AnnotationTableCellCollection;

    AnnotationTableCellP      m_cell;

    AnnotationTableCellCollection const*  m_parentCollection;
    AnnotationTableCellIterator (AnnotationTableCellCollection const& collection, bool begin);

public:

    DGNPLATFORM_EXPORT bool                 IsDifferent(AnnotationTableCellIterator const& rhs) const;  //!< Compare this with another iterator
    DGNPLATFORM_EXPORT void                 MoveToNext ();                                              //!< Advance the iterator to the next item
    DGNPLATFORM_EXPORT AnnotationTableCellR GetCurrent () const;                                        //!< Get the current item
};

/*=================================================================================**//**
* A collection that can iterate through the set of cells in a table.
* See AnnotationTable::GetCellCollection
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct      AnnotationTableCellCollection
{
private:
    friend struct   AnnotationTableElement;
    friend struct   AnnotationTableCellIterator;

    AnnotationTableElementPtr    m_table;

    AnnotationTableCellCollection (AnnotationTableElementCR table);

public:
    typedef ECN::VirtualCollectionIterator<AnnotationTableCellIterator> const_iterator;
    typedef const_iterator iterator;    //!< only const iteration is possible

public:
    DGNPLATFORM_EXPORT const_iterator begin () const;           //!< Returns an iterator to the first element in the collection.
    DGNPLATFORM_EXPORT const_iterator end ()   const;           //!< Returns an iterator that points to the end of the collection.
};

//=======================================================================================
// @bsiclass
//=======================================================================================
struct EXPORT_VTABLE_ATTRIBUTE AnnotationTableElement : PhysicalElement
{
//__PUBLISH_SECTION_END__
friend AnnotationTableSerializer;
//__PUBLISH_SECTION_START__

private:
    DGNELEMENT_DECLARE_MEMBERS(DGN_CLASSNAME_AnnotationTableElement, PhysicalElement) 

    TableHeaderAspect                       m_tableHeader;
    MergeDictionary                         m_mergeDictionary;
    bvector<AnnotationTableRow>             m_rows;
    bvector<AnnotationTableColumn>          m_columns;
    bvector<AnnotationTableAspectDescr>     m_aspectsPendingDelete;

    mutable bmap<AnnotationTableRegion, AnnotationTextStyleCPtr> m_textStyles;

    void                            UpdateGeometryRepresentation();
    DgnDbStatus                     SaveChanges();

    void                            Initialize (bool isNewTable);
    TableHeaderAspect&              GetHeaderAspect() { return m_tableHeader; }

    void                            Clear();
    void                            LoadCells();

    void        MarkAsMergedCellInteriors (AnnotationTableCellIndexCR, uint32_t rowSpan, uint32_t colSpan, bool loading);
    void        BumpRowHeaderFooterCount (AnnotationTableRowCR row, bool add);
    void        BumpColumnHeaderFooterCount (AnnotationTableColumnCR row, bool add);

    void        CopyPropsForNewRow    (uint32_t indexOfNewRow, uint32_t indexOfSeedRow);
    void        CopyPropsForNewColumn (uint32_t indexOfNewCol, uint32_t indexOfSeedCol);

    void        SetTitleRowCount     (uint32_t);
    void        SetHeaderRowCount    (uint32_t);
    void        SetFooterRowCount    (uint32_t);

    bool        HasOverlappingMerges (bvector<AnnotationTableCellP>& consumedRoots, AnnotationTableCellIndexCR rootIndex, uint32_t numRows, uint32_t numCols);

protected:
    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _OnInsert() override;
    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _OnUpdate(DgnElementCR original) override;

    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _InsertInDb() override;
    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _UpdateInDb() override;
    DGNPLATFORM_EXPORT  virtual DgnDbStatus                 _LoadFromDb() override;
    DGNPLATFORM_EXPORT  virtual void                        _CopyFrom(DgnElementCR) override;

//__PUBLISH_SECTION_END__
public:
    bvector<AnnotationTableRow>&            GetRowVectorR()             { return m_rows; }
    bvector<AnnotationTableRow> const&      GetRowVector() const        { return m_rows; }
    bvector<AnnotationTableColumn>&         GetColumnVectorR()          { return m_columns; }
    bvector<AnnotationTableColumn> const&   GetColumnVector() const     { return m_columns; }
    bvector<AnnotationTableAspectDescr>&    GetAspectsPendingDelete()   { return m_aspectsPendingDelete; }
    AnnotationTextStyleCP                   GetTextStyle (AnnotationTableRegion) const;
    void                                    SetTextStyleIdDirect (AnnotationTextStyleId val, AnnotationTableRegion region);
    void                                    DeleteAspect (AnnotationTableAspectCR);
    void                                    ConsiderRegionForAlternateMinimumSize (double& min, AnnotationTableRegion region, bool isHeight) const;

    MergeDictionary&                GetMergeDictionary()            { return m_mergeDictionary; }
    MergeDictionary const&          GetMergeDictionary() const      { return m_mergeDictionary; }

    AnnotationTableCellP            GetCell (AnnotationTableCellIndexCR cellIndex, bool allowMergedInteriors) const;

#if defined (NEEDSWORK)
    TableEdgeStrokes                ComputeEdgeStrokes (bool horizontal, SubTablesCR) const;
    EdgeRunsR                       GetTopEdgeRuns ()          { return m_topEdgeRuns; }
    EdgeRunsCR                      GetTopEdgeRuns () const    { return m_topEdgeRuns; }
    EdgeRunsR                       GetLeftEdgeRuns ()         { return m_leftEdgeRuns; }
    EdgeRunsCR                      GetLeftEdgeRuns () const   { return m_leftEdgeRuns; }
    EdgeRunsP                       GetEdgeRuns (EdgeRunHostType, uint32_t hostIndex);
    EdgeRunsCP                      GetEdgeRuns (EdgeRunHostType, uint32_t hostIndex) const;

    TableFillBoxes                  ComputeFillBoxes (SubTablesCR)  const;
#endif
    uint32_t                        GetFillSymbologyForRow (uint32_t) const;
    uint32_t                        GetFillSymbologyForOddRow()     const;
    uint32_t                        GetFillSymbologyForEvenRow()    const;
    void                            SetFillSymbologyForOddRow   (uint32_t);
    void                            SetFillSymbologyForEvenRow  (uint32_t);

    void                            CopyPropsForNewCell (AnnotationTableCellR newCell, AnnotationTableCellCR seedCell);

    void                            SetRowCount     (uint32_t v);
    void                            SetColumnCount  (uint32_t v);

    AnnotationTableRegion           GetTableRegion (AnnotationTableCellIndexCR cellIndex) const;
    TableHeaderFooterType           GetRowHeaderFooterType (uint32_t rowIndex) const;
    bool                            CanChangeRowHeaderFooterType (uint32_t rowIndex, TableHeaderFooterType newType) const;
    BentleyStatus                   ChangeRowHeaderFooterType (uint32_t rowIndex, TableHeaderFooterType newType);
    TableHeaderFooterType           GetColumnHeaderFooterType (uint32_t columnIndex) const;
    bool                            CanChangeColumnHeaderFooterType (uint32_t colIndex, TableHeaderFooterType newType) const;
    BentleyStatus                   ChangeColumnHeaderFooterType (uint32_t colIndex, TableHeaderFooterType newType);

    void                            SetHeaderColumnCount (uint32_t);
    void                            SetFooterColumnCount (uint32_t);

    static  AnnotationTableRegion   GetTableRegionFromRowType    (TableHeaderFooterType);
    static  AnnotationTableRegion   GetTableRegionFromColumnType (TableHeaderFooterType);
    static  void                    ClassifyTableRegion (TableHeaderFooterType& type, bool& isRow, AnnotationTableRegion);

    DVec2d                          GetEmptyMinimumSizeWithoutMargins (AnnotationTableRegion) const;
//__PUBLISH_SECTION_START__
public:
                    explicit                        AnnotationTableElement(CreateParams const& params);
DGNPLATFORM_EXPORT  static AnnotationTableElementPtr Create(CreateParams const& params);

                    static DgnClassId               QueryClassId(DgnDbR db) { return DgnClassId(db.Schemas().GetECClassId(DGN_ECSCHEMA_NAME, DGN_CLASSNAME_AnnotationTableElement)); }

                    static AnnotationTableElementCPtr Get(DgnDbR db, DgnElementId id) { return db.Elements().Get<AnnotationTableElement>(id); }
                    static AnnotationTableElementPtr GetForEdit(DgnDbR db, DgnElementId id) { return db.Elements().GetForEdit<AnnotationTableElement>(id); }
                    AnnotationTableElementCPtr      Insert() { return GetDgnDb().Elements().Insert<AnnotationTableElement>(*this); }
                    AnnotationTableElementCPtr      Update() { return GetDgnDb().Elements().Update<AnnotationTableElement>(*this); }
                    DgnDbStatus                     Delete() { return GetDgnDb().Elements().Delete(*this); }

                    bool                            IsValid () const;


DGNPLATFORM_EXPORT  uint32_t                        GetRowCount      ()                     const;  //!<    Get the number of rows in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetColumnCount   ()                     const;  //!<    Get the number of columns in this table.
#if defined (NEEDSWORK)
DGNPLATFORM_EXPORT  DPoint3d                        GetOrigin   ()                          const;  //!<    Get the origin which is the upper left corner of cell 0,0.
DGNPLATFORM_EXPORT  RotMatrix                       GetRotation ()                          const;  //!<    Get the rotation which defines the orientation of this table.
#endif
DGNPLATFORM_EXPORT  uint32_t                        GetTitleRowCount ()                     const;  //!<    Get the number of title rows in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetHeaderRowCount ()                    const;  //!<    Get the number of header rows in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetFooterRowCount ()                    const;  //!<    Get the number of footer rows in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetHeaderColumnCount ()                 const;  //!<    Get the number of header columns in this table.
DGNPLATFORM_EXPORT  uint32_t                        GetFooterColumnCount ()                 const;  //!<    Get the number of footer columns in this table.
#if defined (NEEDSWORK)
DGNPLATFORM_EXPORT  TableBreakType                  GetBreakType ()                         const;  //!<    Get the break type of this table.
DGNPLATFORM_EXPORT  TableBreakPosition              GetBreakPosition ()                     const;  //!<    Get the break position for this table.
DGNPLATFORM_EXPORT  double                          GetBreakLength ()                       const;  //!<    Get the break length in UORs for this table.  Any cells that don't fit within this length will flow into a new subtable.
DGNPLATFORM_EXPORT  double                          GetBreakGap ()                          const;  //!<    Get the break gap in UORs for this table.  This controlls the spacing between subtables.
DGNPLATFORM_EXPORT  bool                            GetRepeatHeaders ()                     const;  //!<    Get the flag defining if header rows will be repeated in sub tables created by breaking.
DGNPLATFORM_EXPORT  bool                            GetRepeatFooters ()                     const;  //!<    Get the flag defining if footer rows will be repeated in sub tables created by breaking.
#endif
DGNPLATFORM_EXPORT double                           GetDefaultColumnWidth ()                const;  //!<    Get the default column width in UORs which will be used by columns that don't have a specific width set.
DGNPLATFORM_EXPORT double                           GetDefaultRowHeight ()                  const;  //!<    Get the default row height in UORs which will be used by rows that don't have a specific height set.
DGNPLATFORM_EXPORT  TableCellMarginValues           GetDefaultMargins ()                    const;  //!<    Get the default cell margins in UORs which will be used by cells that don't have specific margins set.
#if defined (NEEDSWORK)
DGNPLATFORM_EXPORT  UInt32                          GetDefaultLineColor ()                  const;  //!<    Get the default line color which will be used by edge lines that don't have a specific color set.
DGNPLATFORM_EXPORT  Int32                           GetDefaultLineStyle ()                  const;  //!<    Get the default line style which will be used by edge lines that don't have a specific style set.
DGNPLATFORM_EXPORT  UInt32                          GetDefaultLineWeight()                  const;  //!<    Get the default line weight which will be used by edge lines that don't have a specific weight set.
#endif
DGNPLATFORM_EXPORT  TableCellAlignment              GetDefaultCellAlignment()               const;  //!<    Get the default alignment which will be used by cells that don't have a specific alignment set.
DGNPLATFORM_EXPORT  TableCellOrientation            GetDefaultCellOrientation()             const;  //!<    Get the default orientation which will be used by cells that don't have a specific orientation set.
DGNPLATFORM_EXPORT  AnnotationTextStyleId           GetTextStyleId (AnnotationTableRegion)  const;  //!<    Get the default text style which will be used to create text for empty cells.

DGNPLATFORM_EXPORT void        SetTextStyleId           (AnnotationTextStyleId, AnnotationTableRegion); //!<    Change the default text style which will be used to create text for empty cells.
DGNPLATFORM_EXPORT void        SetBreakType             (TableBreakType);                           //!<    Change the break type of this table.
DGNPLATFORM_EXPORT void        SetBreakPosition         (TableBreakPosition);                       //!<    Change the break position for this table.
DGNPLATFORM_EXPORT void        SetBreakLength           (double);                                   //!<    Change the break length in UORs for this table.  Any cells that don't fit within this length will flow into a new subtable.
DGNPLATFORM_EXPORT void        SetBreakGap              (double);                                   //!<    Change the break gap in UORs for this table.  This controlls the spacing between subtables.
DGNPLATFORM_EXPORT void        SetRepeatHeaders         (bool);                                     //!<    Change the flag defining if header rows will be repeated in sub tables created by breaking.
DGNPLATFORM_EXPORT void        SetRepeatFooters         (bool);                                     //!<    Change the flag defining if footer rows will be repeated in sub tables created by breaking.
DGNPLATFORM_EXPORT void        SetDefaultColumnWidth    (double);                                   //!<    Change the default column width in UORs which will be used by columns that don't have a specific width set.
DGNPLATFORM_EXPORT void        SetDefaultRowHeight      (double);                                   //!<    Change the default row height in UORs which will be used by rows that don't have a specific height set.
DGNPLATFORM_EXPORT void        SetDefaultMargins        (TableCellMarginValuesCR);                  //!<    Change the default cell margins in UORs which will be used by cells that don't have specific margins set.
//DGNPLATFORM_EXPORT void        SetDefaultLineColor      (uint32_t);                                 //!<    Change the default line color which will be used by edge lines that don't have a specific color set.
//DGNPLATFORM_EXPORT void        SetDefaultLineStyle      (int32_t);                                  //!<    Change the default line style which will be used by edge lines that don't have a specific style set.
//DGNPLATFORM_EXPORT void        SetDefaultLineWeight     (uint32_t);                                 //!<    Change the default line weight which will be used by edge lines that don't have a specific weight set.
//DGNPLATFORM_EXPORT void        SetDefaultFill           (TableSymbologyValuesCR, TableRows rows);   //!<    Change the default fill parameters which will be used by cells that don't have a specific fill set.
DGNPLATFORM_EXPORT void        SetDefaultCellOrientation(TableCellOrientation);                     //!<    Change the default orientation which will be used by cells that don't have a specific orientation set.
DGNPLATFORM_EXPORT void        SetDefaultCellAlignment  (TableCellAlignment);                       //!<    Change the default alignment which will be used by cells that don't have a specific alignment set.

DGNPLATFORM_EXPORT  AnnotationTableRowCP        GetRow (uint32_t rowIndex) const;                       //!<    Get an object representing a row by its index.  Will return NULL if the index is out of range.
DGNPLATFORM_EXPORT  AnnotationTableRowP         GetRow (uint32_t rowIndex);                             //!<    Get an object representing a row by its index.  Will return NULL if the index is out of range.

DGNPLATFORM_EXPORT  AnnotationTableColumnCP     GetColumn (uint32_t colIndex) const;                    //!<    Get an object representing a column by its index.  Will return NULL if the index is out of range.
DGNPLATFORM_EXPORT  AnnotationTableColumnP      GetColumn (uint32_t colIndex);                          //!<    Get an object representing a column by its index.  Will return NULL if the index is out of range.

//! Get an object representing a cell by its index.  For merged cells (those with row and or column span greater than 1) only the upper left TableCellIndex represents the cell.
//! Consider a cell at index 2,2 with a column span of 2.  Index 2,2 represents the cell.  The index 2,3 represents a cell that was consumed and GetCell will return NULL when asked for cell 2,3.
//! @param cellIndex IN    The index of the desired cell.
//! @return NULL if the index is out of range or if the index refers to a position consumed by a merged cell.
DGNPLATFORM_EXPORT  AnnotationTableCellP                  GetCell (AnnotationTableCellIndexCR cellIndex) const;

//! Insert a new row into the table.  It is only possible to insert directly before (above) or after (below) the seed row.
//! @param indexOfSeedRow IN    The seed row's properties but not its contents will be copied to form the new row.
//! @param dir            IN    The location of the new row either before or after the seed row.
DGNPLATFORM_EXPORT  BentleyStatus                   InsertRow (uint32_t indexOfSeedRow, TableInsertDirection dir);
//! Delete an existing row from the table.
DGNPLATFORM_EXPORT  BentleyStatus                   DeleteRow (uint32_t indexOfOldRow);

//! Insert a new column into the table.  It is only possible to insert directly before (to the left of) or after (to the right of) the seed column.
//! @param indexOfSeedColumn IN     The seed columns's properties but not its contents will be copied to form the new column.
//! @param dir               IN     The location of the new column either before or after the seed column.
DGNPLATFORM_EXPORT  BentleyStatus                   InsertColumn (uint32_t indexOfSeedColumn, TableInsertDirection dir);
//! Delete an existing column from the table.
DGNPLATFORM_EXPORT  BentleyStatus                   DeleteColumn (uint32_t indexOfOldColumn);

//! Get a collection that can be used to iterate all the cells in the table.  This method is more convenient than calling GetCell in a nested for loop.
//! \code
//! for (AnnotationTableCellCR cell : table.GetCellCollection())
//!     // do something with cell
//! \endcode
DGNPLATFORM_EXPORT  AnnotationTableCellCollection         GetCellCollection () const;

//! Change the row and/or column span of a cell.  This will fail if it would consume a part of another merged cell.
//! @param root    IN The upper left cell index of the merged cell.
//! @param numRows IN the number of rows that will be spanned by the merged cell.
//! @param numCols IN the number of columns that will be spanned by the merged cell.
//! @return ERROR if the merging could not be done.
DGNPLATFORM_EXPORT  BentleyStatus                   MergeCells (AnnotationTableCellIndexCR root, uint32_t numRows, uint32_t numCols);

#if defined (NEEDSWORK)
//! Get the edge line symbologies used to draw the edges of a collection of cells.
//! @param symb  OUT A list of unique symbologies from the requested edges.
//! @param edges IN  Specifies which edges to query.
//! @param cells IN  Specifies which cells to query.
DGNPLATFORM_EXPORT  void                            GetEdgeSymbology (bvector<TableSymbologyValuesPtr>& symb, TableCellListEdges edges, bvector<AnnotationTableCellIndex> const& cells) const;
//! Change the edge line symbology used to draw the edges of a collection of cells.
//! @param symb  IN  The symbology to apply to the specified edges.
//! @param edges IN  Specifies which edges to change.
//! @param cells IN  Specifies which cells to change.
DGNPLATFORM_EXPORT  void                            SetEdgeSymbology (TableSymbologyValuesCR symb, TableCellListEdges edges, bvector<AnnotationTableCellIndex> const& cells);
#endif

//! Get the overall width of this table.  This is equivalent to summing all the column widths.  This method ignores the effects of table breaking.
DGNPLATFORM_EXPORT  double                          GetWidth  ()  const;
//! Get the overrall height of this table.  This is equivalent to summing all the row heights.  This method ignores the effects of table breaking.
DGNPLATFORM_EXPORT  double                          GetHeight () const;

//! Get the overall width of this table.  Each column will be resized proportionally to its original size in the table.  Will fail if the input value is less than
//! the sum of the minimum widths for all the columns.
DGNPLATFORM_EXPORT  void                            SetWidth  (double val);
//! Get the overrall height of this table.  Each row will be resized proportionally to its original size in the table.  Will fail if the input value is less than
//! the sum of the minimum heights for all the rows.
DGNPLATFORM_EXPORT  void                            SetHeight (double val);

//! Create a new table from scratch.  All table properties will be initialized to safe default values.
//! @param rowCount         IN  The number of rows in the table.
//! @param columnCount      IN  The number of columns in the table.
//! @param textStyleId      IN  The default TextStyle.
//! @param backupTextHeight IN  Used when textStyleId refers to a style with zero text height.
//! @param params           IN  General element parameters
DGNPLATFORM_EXPORT  static  AnnotationTableElementPtr            Create(uint32_t rowCount, uint32_t columnCount, AnnotationTextStyleId textStyleId, double backupTextHeight, CreateParams const& params);


};

namespace dgn_ElementHandler
{
    //=======================================================================================
    //! The ElementHandler for AnnotationTableElement
    //=======================================================================================
    struct AnnotationTableHandler : Physical
    {
        ELEMENTHANDLER_DECLARE_MEMBERS(DGN_CLASSNAME_AnnotationTableElement, AnnotationTableElement, AnnotationTableHandler, Physical, DGNPLATFORM_EXPORT);
    };
};



//! @endGroup

END_BENTLEY_DGNPLATFORM_NAMESPACE
