/*--------------------------------------------------------------------------------------+
|
|     $Source: docs/overview/BIS.overviewPage $
|
|  $Copyright: (c) 2014 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/

//=======================================================================================
// BIS overview page
//=======================================================================================
//__PUBLISH_SECTION_START__
/** @page Overview_BIS Working with Entities, Items, and Elements

The DgnDb DgnPlatform models real-world physical objects using entities, items, and graphical elements.  Specifically:

@li A @b PhysicalEntity represents the identity and function of the real-world object
@li A @b PhysicalItem represents the form (3D geometry) and physical properties of the real-world object
@li Multiple @b DgnElement instances are used for graphically displaying the real-world object

Taken together, these describe a <em>modeled object</em>.  
Properties of the <em>modeled object</em> are typically stored on the entity or within classes that are related to the entity.
Essentially, entities are the center of the DgnDb universe...

<!-- ---------------------------------------------------------------------------------- -->
@section BIS_Entities Entities

Each <em>modeled object</em> (whether it already exists in the real world or will exist) has 1 and exactly 1 @b PhysicalEntity.
The C++ classes related to physical entities are:

@li @b PhysicalEntity is a in-memory data object associated with a persistent entity
@li @b PhysicalEntityHandler controls the lifecyle of a @b PhysicalEntity and is responsible for creating and deleting entities.  It it also notified when a entity is inserted, updated, or deleted.
@li @b PhysicalEntityKey identifies a physical entity instance without actually requiring that instance to be in memory.

Applications are expected to subclass @b PhysicalEntity and subclass @b PhysicalEntityHandler and associate them to an @b ECClass (derived from the PhysicalEntity ECClass).
A @b PhysicalEntityKey holds the @b ECInstanceId and the @b ECClassId so that it can identify physical entities of any subclass.  
Just an @b ECInstanceId would not be enough.

@see BentleyApi::DgnPlatform::PhysicalEntity
@see BentleyApi::DgnPlatform::PhysicalEntityHandler
@see BentleyApi::DgnPlatform::PhysicalEntityKey
@see BentleyApi::DgnPlatform::DgnProject

If the proper @b PhysicalEntityHandler for a particular @b PhysicalEntity is known, then the handler's @e Singleton instance can be used directly.
If the proper @b PhysicalEntityHandler is not known, it can be looked up via the @b HandlerRegistry.

@see BentleyApi::DgnPlatform::HandlerRegistry

<!-- ---------------------------------------------------------------------------------- -->
@section BIS_Items Items

If the @b PhysicalEntity has been @e fulfilled (form has been determined), then there is 1 @b PhysicalItem associated with the @b PhysicalEntity.
If the @b PhysicalEntity has not been @e fulfilled (function specified, but form not determined), then there are zero physical items associated with the @b PhysicalEntity.
Thus, a @b PhysicalItem represents the three-dimensional form of a <em>modeled object</em> from the physical world.
The primary role of a @b PhysicalItem is to define the object's @b PhysicalGeometry and other physical properties (like material, for example).
The C++ classes related to physical entities are:

@li @b PhysicalItem is an in-memory data object associated with a persistent physical item and is used to update an existing item.
@li @b PhysicalItemHandler is responsible for creating and deleting items, and is notified when an item is inserted, updated, or deleted.
@li @b PhysicalItemKey identifies a physical item instance without actually requiring that instance to be in memory.

Applications are expected to subclass @b PhysicalItem and subclass @b PhysicalItemHandler and associate them to an @b ECClass (derived from the PhysicalItem ECClass).
A @b PhysicalItemKey holds the @b ECInstanceId and the @b ECClassId so that it can identify physical items of any subclass.  
Just an @b ECInstanceId would not be enough.

@see BentleyApi::DgnPlatform::PhysicalItem
@see BentleyApi::DgnPlatform::PhysicalItemHandler
@see BentleyApi::DgnPlatform::PhysicalItemKey

If the proper @b PhysicalItemHandler for a particular @b PhysicalItem is known, then the handler's @e Singleton instance can be used directly.
If the proper @b PhysicalItemHandler is not known, it can be looked up via the @b HandlerRegistry.

@see BentleyApi::DgnPlatform::HandlerRegistry

<!-- ---------------------------------------------------------------------------------- -->
@section BIS_PhysicalGeometry PhysicalGeometry

@b PhysicalGeometry is meant to be shared (in memory) so is stored in @a local coordinates with an item-specific placement (which defines an item --> world transformation).
Placements are defined by an origin (translation) and a set of rotation angles (yaw, pitch, and roll stored in degrees).

@see Bentley::DPoint3d
@see BentleyApi::YawPitchRollAngles

Each physical item stores an item-aligned @a Bounds (more exact but requires transformation into item-specific coordinates) in addition to the world-aligned range box (fast, but can be less exact depending on rotation) stored in the @b DgnProject range tree.

@see BentleyApi::Bounds

@b PhysicalGeometry holds an unordered list of @a placed geometry parts.
Geometry parts are intended to be highly shared (in memory and when persisted), so that is why a part-specific @a placement (which defines a part --> item transformation) is stored separately.
Each geometry part is @a categorized by its @b Level and @b SubLevel.  
This categorization makes the geometry more meaningful and eliminates the need to reverse-engineer business meaning from graphics.

@see BentleyApi::DgnPlatform::PhysicalGeometry
@see BentleyApi::DgnPlatform::PlacedPhysicalGeometryPart
@see BentleyApi::DgnPlatform::PhysicalGeometryPart
@see BentleyApi::DgnPlatform::DgnLevels::SubLevel

<!-- ---------------------------------------------------------------------------------- -->
@section BIS_Elements Elements

Elements provide the way to persist graphics (versus graphics drawn temporarily to a view). 
Element graphics are typically generated from the @b PhysicalGeometry of a @b PhysicalItem via a @b PhysicalGraphicsGenerator (which implements various display rules).
These rules map @b PhysicalGeometry to graphical elements and assign graphics-specific properties like symbology, transparency, and rendering material.
Each graphical element is associated to exactly 1 @b PhysicalItem (and therefore exactly 1 @b PhysicalEntity).  However, there can be N graphical elements per @b PhysicalItem.
Graphical elements provide a way to visualize and graphically select physical entities and items.
No "business data" is directly stored on a graphical element.  
Instead, "business data" is stored in entities and items that are related to the element.

@see BentleyApi::DgnPlatform::PhysicalGraphics
@see BentleyApi::DgnPlatform::PhysicalGraphicsGenerator
@see BentleyApi::DgnPlatform::ElementIdSet

*/
