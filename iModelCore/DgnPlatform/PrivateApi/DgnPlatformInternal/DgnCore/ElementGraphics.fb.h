//--------------------------------------------------------------------------------------
//     $Source: PrivateApi/DgnPlatformInternal/DgnCore/ElementGraphics.fb.h $
//  $Copyright: (c) 2017 Bentley Systems, Incorporated. All rights reserved. $
//--------------------------------------------------------------------------------------
// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ELEMENTGRAPHICS_BENTLEYB0200_DGN_FB_H_
#define FLATBUFFERS_GENERATED_ELEMENTGRAPHICS_BENTLEYB0200_DGN_FB_H_

#include "flatbuffers/flatbuffers.h"


namespace BentleyB0200 {
namespace Dgn {
namespace FB {

struct DPoint3d;
struct DPoint2d;
struct DVec3d;
struct RotMatrix;
struct Transform;
struct FaceSymbology;
struct FaceSymbologyIndex;
struct PointPrimitive;
struct PointPrimitive2d;
struct ArcPrimitive;
struct BRepData;
struct OCBRepData;
struct GeometryPart;
struct BasicSymbology;
struct LineStyleModifiers;
struct Material;
struct AreaFill;
struct DwgHatchDefLine;
struct AreaPattern;

enum GradientMode {
  GradientMode_None = 0,
  GradientMode_Linear = 1,
  GradientMode_Curved = 2,
  GradientMode_Cylindrical = 3,
  GradientMode_Spherical = 4,
  GradientMode_Hemispherical = 5
};

inline const char **EnumNamesGradientMode() {
  static const char *names[] = { "None", "Linear", "Curved", "Cylindrical", "Spherical", "Hemispherical", nullptr };
  return names;
}

inline const char *EnumNameGradientMode(GradientMode e) { return EnumNamesGradientMode()[e]; }

enum BoundaryType {
  BoundaryType_None = 0,
  BoundaryType_Open = 1,
  BoundaryType_Closed = 2
};

inline const char **EnumNamesBoundaryType() {
  static const char *names[] = { "None", "Open", "Closed", nullptr };
  return names;
}

inline const char *EnumNameBoundaryType(BoundaryType e) { return EnumNamesBoundaryType()[e]; }

enum FillDisplay {
  FillDisplay_None = 0,
  FillDisplay_ByView = 1,
  FillDisplay_Always = 2,
  FillDisplay_Blanking = 3
};

inline const char **EnumNamesFillDisplay() {
  static const char *names[] = { "None", "ByView", "Always", "Blanking", nullptr };
  return names;
}

inline const char *EnumNameFillDisplay(FillDisplay e) { return EnumNamesFillDisplay()[e]; }

enum GeometryClass {
  GeometryClass_Primary = 0,
  GeometryClass_Construction = 1,
  GeometryClass_Dimension = 2,
  GeometryClass_Pattern = 3
};

inline const char **EnumNamesGeometryClass() {
  static const char *names[] = { "Primary", "Construction", "Dimension", "Pattern", nullptr };
  return names;
}

inline const char *EnumNameGeometryClass(GeometryClass e) { return EnumNamesGeometryClass()[e]; }

enum BRepType {
  BRepType_Solid = 0,
  BRepType_Sheet = 1,
  BRepType_Wire = 2
};

inline const char **EnumNamesBRepType() {
  static const char *names[] = { "Solid", "Sheet", "Wire", nullptr };
  return names;
}

inline const char *EnumNameBRepType(BRepType e) { return EnumNamesBRepType()[e]; }

MANUALLY_ALIGNED_STRUCT(8) DPoint3d {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DPoint3d(double x, double y, double z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
  double z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(DPoint3d, 24);

MANUALLY_ALIGNED_STRUCT(8) DPoint2d {
 private:
  double x_;
  double y_;

 public:
  DPoint2d(double x, double y)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(DPoint2d, 16);

MANUALLY_ALIGNED_STRUCT(8) DVec3d {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DVec3d(double x, double y, double z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
  double z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(DVec3d, 24);

MANUALLY_ALIGNED_STRUCT(8) RotMatrix {
 private:
  double x00_;
  double x01_;
  double x02_;
  double x10_;
  double x11_;
  double x12_;
  double x20_;
  double x21_;
  double x22_;

 public:
  RotMatrix(double x00, double x01, double x02, double x10, double x11, double x12, double x20, double x21, double x22)
    : x00_(flatbuffers::EndianScalar(x00)), x01_(flatbuffers::EndianScalar(x01)), x02_(flatbuffers::EndianScalar(x02)), x10_(flatbuffers::EndianScalar(x10)), x11_(flatbuffers::EndianScalar(x11)), x12_(flatbuffers::EndianScalar(x12)), x20_(flatbuffers::EndianScalar(x20)), x21_(flatbuffers::EndianScalar(x21)), x22_(flatbuffers::EndianScalar(x22)) { }

  double x00() const { return flatbuffers::EndianScalar(x00_); }
  double x01() const { return flatbuffers::EndianScalar(x01_); }
  double x02() const { return flatbuffers::EndianScalar(x02_); }
  double x10() const { return flatbuffers::EndianScalar(x10_); }
  double x11() const { return flatbuffers::EndianScalar(x11_); }
  double x12() const { return flatbuffers::EndianScalar(x12_); }
  double x20() const { return flatbuffers::EndianScalar(x20_); }
  double x21() const { return flatbuffers::EndianScalar(x21_); }
  double x22() const { return flatbuffers::EndianScalar(x22_); }
};
STRUCT_END(RotMatrix, 72);

MANUALLY_ALIGNED_STRUCT(8) Transform {
 private:
  double x00_;
  double x01_;
  double x02_;
  double tx_;
  double x10_;
  double x11_;
  double x12_;
  double ty_;
  double x20_;
  double x21_;
  double x22_;
  double tz_;

 public:
  Transform(double x00, double x01, double x02, double tx, double x10, double x11, double x12, double ty, double x20, double x21, double x22, double tz)
    : x00_(flatbuffers::EndianScalar(x00)), x01_(flatbuffers::EndianScalar(x01)), x02_(flatbuffers::EndianScalar(x02)), tx_(flatbuffers::EndianScalar(tx)), x10_(flatbuffers::EndianScalar(x10)), x11_(flatbuffers::EndianScalar(x11)), x12_(flatbuffers::EndianScalar(x12)), ty_(flatbuffers::EndianScalar(ty)), x20_(flatbuffers::EndianScalar(x20)), x21_(flatbuffers::EndianScalar(x21)), x22_(flatbuffers::EndianScalar(x22)), tz_(flatbuffers::EndianScalar(tz)) { }

  double x00() const { return flatbuffers::EndianScalar(x00_); }
  double x01() const { return flatbuffers::EndianScalar(x01_); }
  double x02() const { return flatbuffers::EndianScalar(x02_); }
  double tx() const { return flatbuffers::EndianScalar(tx_); }
  double x10() const { return flatbuffers::EndianScalar(x10_); }
  double x11() const { return flatbuffers::EndianScalar(x11_); }
  double x12() const { return flatbuffers::EndianScalar(x12_); }
  double ty() const { return flatbuffers::EndianScalar(ty_); }
  double x20() const { return flatbuffers::EndianScalar(x20_); }
  double x21() const { return flatbuffers::EndianScalar(x21_); }
  double x22() const { return flatbuffers::EndianScalar(x22_); }
  double tz() const { return flatbuffers::EndianScalar(tz_); }
};
STRUCT_END(Transform, 96);

MANUALLY_ALIGNED_STRUCT(8) FaceSymbology {
 private:
  uint8_t useColor_;
  uint8_t useMaterial_;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif
  int16_t __padding0;
#ifdef __clang__
#pragma clang diagnostic pop
#endif
  uint32_t color_;
  int64_t materialId_;
  double transparency_;
  DPoint2d uv_;

 public:
  FaceSymbology(uint8_t useColor, uint8_t useMaterial, uint32_t color, int64_t materialId, double transparency, const DPoint2d &uv)
    : useColor_(flatbuffers::EndianScalar(useColor)), useMaterial_(flatbuffers::EndianScalar(useMaterial)), __padding0(0), color_(flatbuffers::EndianScalar(color)), materialId_(flatbuffers::EndianScalar(materialId)), transparency_(flatbuffers::EndianScalar(transparency)), uv_(uv) { (void)__padding0; }

  uint8_t useColor() const { return flatbuffers::EndianScalar(useColor_); }
  uint8_t useMaterial() const { return flatbuffers::EndianScalar(useMaterial_); }
  uint32_t color() const { return flatbuffers::EndianScalar(color_); }
  int64_t materialId() const { return flatbuffers::EndianScalar(materialId_); }
  double transparency() const { return flatbuffers::EndianScalar(transparency_); }
  const DPoint2d &uv() const { return uv_; }
};
STRUCT_END(FaceSymbology, 40);

MANUALLY_ALIGNED_STRUCT(4) FaceSymbologyIndex {
 private:
  uint32_t faceIndex_;
  uint32_t symbIndex_;

 public:
  FaceSymbologyIndex(uint32_t faceIndex, uint32_t symbIndex)
    : faceIndex_(flatbuffers::EndianScalar(faceIndex)), symbIndex_(flatbuffers::EndianScalar(symbIndex)) { }

  uint32_t faceIndex() const { return flatbuffers::EndianScalar(faceIndex_); }
  uint32_t symbIndex() const { return flatbuffers::EndianScalar(symbIndex_); }
};
STRUCT_END(FaceSymbologyIndex, 8);

struct PointPrimitive : private flatbuffers::Table {
  const flatbuffers::Vector<const DPoint3d *> *coords() const { return GetPointer<const flatbuffers::Vector<const DPoint3d *> *>(4); }
  BoundaryType boundary() const { return static_cast<BoundaryType>(GetField<int8_t>(6, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* coords */) &&
           verifier.Verify(coords()) &&
           VerifyField<int8_t>(verifier, 6 /* boundary */) &&
           verifier.EndTable();
  }
  bool has_coords() const { return CheckField(4); }
  bool has_boundary() const { return CheckField(6); }
};

struct PointPrimitiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coords(flatbuffers::Offset<flatbuffers::Vector<const DPoint3d *>> coords) { fbb_.AddOffset(4, coords); }
  void add_boundary(BoundaryType boundary) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(boundary), 0); }
  PointPrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PointPrimitiveBuilder &operator=(const PointPrimitiveBuilder &);
  flatbuffers::Offset<PointPrimitive> Finish() {
    auto o = flatbuffers::Offset<PointPrimitive>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<PointPrimitive> CreatePointPrimitive(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<const DPoint3d *>> coords = 0,
   BoundaryType boundary = BoundaryType_None) {
  PointPrimitiveBuilder builder_(_fbb);
  builder_.add_coords(coords);
  builder_.add_boundary(boundary);
  return builder_.Finish();
}

struct PointPrimitive2d : private flatbuffers::Table {
  const flatbuffers::Vector<const DPoint2d *> *coords() const { return GetPointer<const flatbuffers::Vector<const DPoint2d *> *>(4); }
  BoundaryType boundary() const { return static_cast<BoundaryType>(GetField<int8_t>(6, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* coords */) &&
           verifier.Verify(coords()) &&
           VerifyField<int8_t>(verifier, 6 /* boundary */) &&
           verifier.EndTable();
  }
  bool has_coords() const { return CheckField(4); }
  bool has_boundary() const { return CheckField(6); }
};

struct PointPrimitive2dBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coords(flatbuffers::Offset<flatbuffers::Vector<const DPoint2d *>> coords) { fbb_.AddOffset(4, coords); }
  void add_boundary(BoundaryType boundary) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(boundary), 0); }
  PointPrimitive2dBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PointPrimitive2dBuilder &operator=(const PointPrimitive2dBuilder &);
  flatbuffers::Offset<PointPrimitive2d> Finish() {
    auto o = flatbuffers::Offset<PointPrimitive2d>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<PointPrimitive2d> CreatePointPrimitive2d(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<const DPoint2d *>> coords = 0,
   BoundaryType boundary = BoundaryType_None) {
  PointPrimitive2dBuilder builder_(_fbb);
  builder_.add_coords(coords);
  builder_.add_boundary(boundary);
  return builder_.Finish();
}

struct ArcPrimitive : private flatbuffers::Table {
  const DPoint3d *center() const { return GetStruct<const DPoint3d *>(4); }
  const DVec3d *vector0() const { return GetStruct<const DVec3d *>(6); }
  const DVec3d *vector90() const { return GetStruct<const DVec3d *>(8); }
  double start() const { return GetField<double>(10, 0); }
  double sweep() const { return GetField<double>(12, 0); }
  BoundaryType boundary() const { return static_cast<BoundaryType>(GetField<int8_t>(14, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DPoint3d>(verifier, 4 /* center */) &&
           VerifyField<DVec3d>(verifier, 6 /* vector0 */) &&
           VerifyField<DVec3d>(verifier, 8 /* vector90 */) &&
           VerifyField<double>(verifier, 10 /* start */) &&
           VerifyField<double>(verifier, 12 /* sweep */) &&
           VerifyField<int8_t>(verifier, 14 /* boundary */) &&
           verifier.EndTable();
  }
  bool has_center() const { return CheckField(4); }
  bool has_vector0() const { return CheckField(6); }
  bool has_vector90() const { return CheckField(8); }
  bool has_start() const { return CheckField(10); }
  bool has_sweep() const { return CheckField(12); }
  bool has_boundary() const { return CheckField(14); }
};

struct ArcPrimitiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_center(const DPoint3d *center) { fbb_.AddStruct(4, center); }
  void add_vector0(const DVec3d *vector0) { fbb_.AddStruct(6, vector0); }
  void add_vector90(const DVec3d *vector90) { fbb_.AddStruct(8, vector90); }
  void add_start(double start) { fbb_.AddElement<double>(10, start, 0); }
  void add_sweep(double sweep) { fbb_.AddElement<double>(12, sweep, 0); }
  void add_boundary(BoundaryType boundary) { fbb_.AddElement<int8_t>(14, static_cast<int8_t>(boundary), 0); }
  ArcPrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ArcPrimitiveBuilder &operator=(const ArcPrimitiveBuilder &);
  flatbuffers::Offset<ArcPrimitive> Finish() {
    auto o = flatbuffers::Offset<ArcPrimitive>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<ArcPrimitive> CreateArcPrimitive(flatbuffers::FlatBufferBuilder &_fbb,
   const DPoint3d *center = 0,
   const DVec3d *vector0 = 0,
   const DVec3d *vector90 = 0,
   double start = 0,
   double sweep = 0,
   BoundaryType boundary = BoundaryType_None) {
  ArcPrimitiveBuilder builder_(_fbb);
  builder_.add_sweep(sweep);
  builder_.add_start(start);
  builder_.add_vector90(vector90);
  builder_.add_vector0(vector0);
  builder_.add_center(center);
  builder_.add_boundary(boundary);
  return builder_.Finish();
}

struct BRepData : private flatbuffers::Table {
  const Transform *entityTransform() const { return GetStruct<const Transform *>(4); }
  BRepType brepType() const { return static_cast<BRepType>(GetField<int8_t>(6, 0)); }
  const flatbuffers::Vector<uint8_t> *entityData() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(8); }
  const flatbuffers::Vector<const FaceSymbology *> *symbology() const { return GetPointer<const flatbuffers::Vector<const FaceSymbology *> *>(10); }
  const flatbuffers::Vector<const FaceSymbologyIndex *> *symbologyIndex() const { return GetPointer<const flatbuffers::Vector<const FaceSymbologyIndex *> *>(12); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Transform>(verifier, 4 /* entityTransform */) &&
           VerifyField<int8_t>(verifier, 6 /* brepType */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* entityData */) &&
           verifier.Verify(entityData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* symbology */) &&
           verifier.Verify(symbology()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 12 /* symbologyIndex */) &&
           verifier.Verify(symbologyIndex()) &&
           verifier.EndTable();
  }
  bool has_entityTransform() const { return CheckField(4); }
  bool has_brepType() const { return CheckField(6); }
  bool has_entityData() const { return CheckField(8); }
  bool has_symbology() const { return CheckField(10); }
  bool has_symbologyIndex() const { return CheckField(12); }
};

struct BRepDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entityTransform(const Transform *entityTransform) { fbb_.AddStruct(4, entityTransform); }
  void add_brepType(BRepType brepType) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(brepType), 0); }
  void add_entityData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData) { fbb_.AddOffset(8, entityData); }
  void add_symbology(flatbuffers::Offset<flatbuffers::Vector<const FaceSymbology *>> symbology) { fbb_.AddOffset(10, symbology); }
  void add_symbologyIndex(flatbuffers::Offset<flatbuffers::Vector<const FaceSymbologyIndex *>> symbologyIndex) { fbb_.AddOffset(12, symbologyIndex); }
  BRepDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BRepDataBuilder &operator=(const BRepDataBuilder &);
  flatbuffers::Offset<BRepData> Finish() {
    auto o = flatbuffers::Offset<BRepData>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<BRepData> CreateBRepData(flatbuffers::FlatBufferBuilder &_fbb,
   const Transform *entityTransform = 0,
   BRepType brepType = BRepType_Solid,
   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData = 0,
   flatbuffers::Offset<flatbuffers::Vector<const FaceSymbology *>> symbology = 0,
   flatbuffers::Offset<flatbuffers::Vector<const FaceSymbologyIndex *>> symbologyIndex = 0) {
  BRepDataBuilder builder_(_fbb);
  builder_.add_symbologyIndex(symbologyIndex);
  builder_.add_symbology(symbology);
  builder_.add_entityData(entityData);
  builder_.add_entityTransform(entityTransform);
  builder_.add_brepType(brepType);
  return builder_.Finish();
}

struct OCBRepData : private flatbuffers::Table {
  BRepType brepType() const { return static_cast<BRepType>(GetField<int8_t>(4, 0)); }
  const flatbuffers::Vector<uint8_t> *entityData() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(6); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* brepType */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* entityData */) &&
           verifier.Verify(entityData()) &&
           verifier.EndTable();
  }
  bool has_brepType() const { return CheckField(4); }
  bool has_entityData() const { return CheckField(6); }
};

struct OCBRepDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_brepType(BRepType brepType) { fbb_.AddElement<int8_t>(4, static_cast<int8_t>(brepType), 0); }
  void add_entityData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData) { fbb_.AddOffset(6, entityData); }
  OCBRepDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  OCBRepDataBuilder &operator=(const OCBRepDataBuilder &);
  flatbuffers::Offset<OCBRepData> Finish() {
    auto o = flatbuffers::Offset<OCBRepData>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<OCBRepData> CreateOCBRepData(flatbuffers::FlatBufferBuilder &_fbb,
   BRepType brepType = BRepType_Solid,
   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData = 0) {
  OCBRepDataBuilder builder_(_fbb);
  builder_.add_entityData(entityData);
  builder_.add_brepType(brepType);
  return builder_.Finish();
}

struct GeometryPart : private flatbuffers::Table {
  int64_t geomPartId() const { return GetField<int64_t>(4, 0); }
  const DPoint3d *origin() const { return GetStruct<const DPoint3d *>(6); }
  double yaw() const { return GetField<double>(8, 0); }
  double pitch() const { return GetField<double>(10, 0); }
  double roll() const { return GetField<double>(12, 0); }
  double scale() const { return GetField<double>(14, 1.0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* geomPartId */) &&
           VerifyField<DPoint3d>(verifier, 6 /* origin */) &&
           VerifyField<double>(verifier, 8 /* yaw */) &&
           VerifyField<double>(verifier, 10 /* pitch */) &&
           VerifyField<double>(verifier, 12 /* roll */) &&
           VerifyField<double>(verifier, 14 /* scale */) &&
           verifier.EndTable();
  }
  bool has_geomPartId() const { return CheckField(4); }
  bool has_origin() const { return CheckField(6); }
  bool has_yaw() const { return CheckField(8); }
  bool has_pitch() const { return CheckField(10); }
  bool has_roll() const { return CheckField(12); }
  bool has_scale() const { return CheckField(14); }
};

struct GeometryPartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_geomPartId(int64_t geomPartId) { fbb_.AddElement<int64_t>(4, geomPartId, 0); }
  void add_origin(const DPoint3d *origin) { fbb_.AddStruct(6, origin); }
  void add_yaw(double yaw) { fbb_.AddElement<double>(8, yaw, 0); }
  void add_pitch(double pitch) { fbb_.AddElement<double>(10, pitch, 0); }
  void add_roll(double roll) { fbb_.AddElement<double>(12, roll, 0); }
  void add_scale(double scale) { fbb_.AddElement<double>(14, scale, 1.0); }
  GeometryPartBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GeometryPartBuilder &operator=(const GeometryPartBuilder &);
  flatbuffers::Offset<GeometryPart> Finish() {
    auto o = flatbuffers::Offset<GeometryPart>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<GeometryPart> CreateGeometryPart(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t geomPartId = 0,
   const DPoint3d *origin = 0,
   double yaw = 0,
   double pitch = 0,
   double roll = 0,
   double scale = 1.0) {
  GeometryPartBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_roll(roll);
  builder_.add_pitch(pitch);
  builder_.add_yaw(yaw);
  builder_.add_geomPartId(geomPartId);
  builder_.add_origin(origin);
  return builder_.Finish();
}

struct BasicSymbology : private flatbuffers::Table {
  int64_t subCategoryId() const { return GetField<int64_t>(4, 0); }
  uint32_t color() const { return GetField<uint32_t>(6, 0); }
  uint32_t weight() const { return GetField<uint32_t>(8, 0); }
  int64_t lineStyleId() const { return GetField<int64_t>(10, 0); }
  double transparency() const { return GetField<double>(12, 0); }
  int32_t displayPriority() const { return GetField<int32_t>(14, 0); }
  GeometryClass geomClass() const { return static_cast<GeometryClass>(GetField<int8_t>(16, 0)); }
  uint8_t useColor() const { return GetField<uint8_t>(18, 0); }
  uint8_t useWeight() const { return GetField<uint8_t>(20, 0); }
  uint8_t useStyle() const { return GetField<uint8_t>(22, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* subCategoryId */) &&
           VerifyField<uint32_t>(verifier, 6 /* color */) &&
           VerifyField<uint32_t>(verifier, 8 /* weight */) &&
           VerifyField<int64_t>(verifier, 10 /* lineStyleId */) &&
           VerifyField<double>(verifier, 12 /* transparency */) &&
           VerifyField<int32_t>(verifier, 14 /* displayPriority */) &&
           VerifyField<int8_t>(verifier, 16 /* geomClass */) &&
           VerifyField<uint8_t>(verifier, 18 /* useColor */) &&
           VerifyField<uint8_t>(verifier, 20 /* useWeight */) &&
           VerifyField<uint8_t>(verifier, 22 /* useStyle */) &&
           verifier.EndTable();
  }
  bool has_subCategoryId() const { return CheckField(4); }
  bool has_color() const { return CheckField(6); }
  bool has_weight() const { return CheckField(8); }
  bool has_lineStyleId() const { return CheckField(10); }
  bool has_transparency() const { return CheckField(12); }
  bool has_displayPriority() const { return CheckField(14); }
  bool has_geomClass() const { return CheckField(16); }
  bool has_useColor() const { return CheckField(18); }
  bool has_useWeight() const { return CheckField(20); }
  bool has_useStyle() const { return CheckField(22); }
};

struct BasicSymbologyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subCategoryId(int64_t subCategoryId) { fbb_.AddElement<int64_t>(4, subCategoryId, 0); }
  void add_color(uint32_t color) { fbb_.AddElement<uint32_t>(6, color, 0); }
  void add_weight(uint32_t weight) { fbb_.AddElement<uint32_t>(8, weight, 0); }
  void add_lineStyleId(int64_t lineStyleId) { fbb_.AddElement<int64_t>(10, lineStyleId, 0); }
  void add_transparency(double transparency) { fbb_.AddElement<double>(12, transparency, 0); }
  void add_displayPriority(int32_t displayPriority) { fbb_.AddElement<int32_t>(14, displayPriority, 0); }
  void add_geomClass(GeometryClass geomClass) { fbb_.AddElement<int8_t>(16, static_cast<int8_t>(geomClass), 0); }
  void add_useColor(uint8_t useColor) { fbb_.AddElement<uint8_t>(18, useColor, 0); }
  void add_useWeight(uint8_t useWeight) { fbb_.AddElement<uint8_t>(20, useWeight, 0); }
  void add_useStyle(uint8_t useStyle) { fbb_.AddElement<uint8_t>(22, useStyle, 0); }
  BasicSymbologyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BasicSymbologyBuilder &operator=(const BasicSymbologyBuilder &);
  flatbuffers::Offset<BasicSymbology> Finish() {
    auto o = flatbuffers::Offset<BasicSymbology>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<BasicSymbology> CreateBasicSymbology(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t subCategoryId = 0,
   uint32_t color = 0,
   uint32_t weight = 0,
   int64_t lineStyleId = 0,
   double transparency = 0,
   int32_t displayPriority = 0,
   GeometryClass geomClass = GeometryClass_Primary,
   uint8_t useColor = 0,
   uint8_t useWeight = 0,
   uint8_t useStyle = 0) {
  BasicSymbologyBuilder builder_(_fbb);
  builder_.add_transparency(transparency);
  builder_.add_lineStyleId(lineStyleId);
  builder_.add_subCategoryId(subCategoryId);
  builder_.add_displayPriority(displayPriority);
  builder_.add_weight(weight);
  builder_.add_color(color);
  builder_.add_useStyle(useStyle);
  builder_.add_useWeight(useWeight);
  builder_.add_useColor(useColor);
  builder_.add_geomClass(geomClass);
  return builder_.Finish();
}

struct LineStyleModifiers : private flatbuffers::Table {
  uint32_t modifiers() const { return GetField<uint32_t>(4, 0); }
  double scale() const { return GetField<double>(6, 0); }
  double dashScale() const { return GetField<double>(8, 0); }
  double gapScale() const { return GetField<double>(10, 0); }
  double startWidth() const { return GetField<double>(12, 0); }
  double endWidth() const { return GetField<double>(14, 0); }
  double distPhase() const { return GetField<double>(16, 0); }
  double fractPhase() const { return GetField<double>(18, 0); }
  const DPoint3d *normal() const { return GetStruct<const DPoint3d *>(20); }
  double yaw() const { return GetField<double>(22, 0); }
  double pitch() const { return GetField<double>(24, 0); }
  double roll() const { return GetField<double>(26, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* modifiers */) &&
           VerifyField<double>(verifier, 6 /* scale */) &&
           VerifyField<double>(verifier, 8 /* dashScale */) &&
           VerifyField<double>(verifier, 10 /* gapScale */) &&
           VerifyField<double>(verifier, 12 /* startWidth */) &&
           VerifyField<double>(verifier, 14 /* endWidth */) &&
           VerifyField<double>(verifier, 16 /* distPhase */) &&
           VerifyField<double>(verifier, 18 /* fractPhase */) &&
           VerifyField<DPoint3d>(verifier, 20 /* normal */) &&
           VerifyField<double>(verifier, 22 /* yaw */) &&
           VerifyField<double>(verifier, 24 /* pitch */) &&
           VerifyField<double>(verifier, 26 /* roll */) &&
           verifier.EndTable();
  }
  bool has_modifiers() const { return CheckField(4); }
  bool has_scale() const { return CheckField(6); }
  bool has_dashScale() const { return CheckField(8); }
  bool has_gapScale() const { return CheckField(10); }
  bool has_startWidth() const { return CheckField(12); }
  bool has_endWidth() const { return CheckField(14); }
  bool has_distPhase() const { return CheckField(16); }
  bool has_fractPhase() const { return CheckField(18); }
  bool has_normal() const { return CheckField(20); }
  bool has_yaw() const { return CheckField(22); }
  bool has_pitch() const { return CheckField(24); }
  bool has_roll() const { return CheckField(26); }
};

struct LineStyleModifiersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_modifiers(uint32_t modifiers) { fbb_.AddElement<uint32_t>(4, modifiers, 0); }
  void add_scale(double scale) { fbb_.AddElement<double>(6, scale, 0); }
  void add_dashScale(double dashScale) { fbb_.AddElement<double>(8, dashScale, 0); }
  void add_gapScale(double gapScale) { fbb_.AddElement<double>(10, gapScale, 0); }
  void add_startWidth(double startWidth) { fbb_.AddElement<double>(12, startWidth, 0); }
  void add_endWidth(double endWidth) { fbb_.AddElement<double>(14, endWidth, 0); }
  void add_distPhase(double distPhase) { fbb_.AddElement<double>(16, distPhase, 0); }
  void add_fractPhase(double fractPhase) { fbb_.AddElement<double>(18, fractPhase, 0); }
  void add_normal(const DPoint3d *normal) { fbb_.AddStruct(20, normal); }
  void add_yaw(double yaw) { fbb_.AddElement<double>(22, yaw, 0); }
  void add_pitch(double pitch) { fbb_.AddElement<double>(24, pitch, 0); }
  void add_roll(double roll) { fbb_.AddElement<double>(26, roll, 0); }
  LineStyleModifiersBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LineStyleModifiersBuilder &operator=(const LineStyleModifiersBuilder &);
  flatbuffers::Offset<LineStyleModifiers> Finish() {
    auto o = flatbuffers::Offset<LineStyleModifiers>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<LineStyleModifiers> CreateLineStyleModifiers(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t modifiers = 0,
   double scale = 0,
   double dashScale = 0,
   double gapScale = 0,
   double startWidth = 0,
   double endWidth = 0,
   double distPhase = 0,
   double fractPhase = 0,
   const DPoint3d *normal = 0,
   double yaw = 0,
   double pitch = 0,
   double roll = 0) {
  LineStyleModifiersBuilder builder_(_fbb);
  builder_.add_roll(roll);
  builder_.add_pitch(pitch);
  builder_.add_yaw(yaw);
  builder_.add_fractPhase(fractPhase);
  builder_.add_distPhase(distPhase);
  builder_.add_endWidth(endWidth);
  builder_.add_startWidth(startWidth);
  builder_.add_gapScale(gapScale);
  builder_.add_dashScale(dashScale);
  builder_.add_scale(scale);
  builder_.add_normal(normal);
  builder_.add_modifiers(modifiers);
  return builder_.Finish();
}

struct Material : private flatbuffers::Table {
  uint8_t useMaterial() const { return GetField<uint8_t>(4, 0); }
  int64_t materialId() const { return GetField<int64_t>(6, 0); }
  const DPoint3d *origin() const { return GetStruct<const DPoint3d *>(8); }
  const DPoint3d *size() const { return GetStruct<const DPoint3d *>(10); }
  double yaw() const { return GetField<double>(12, 0); }
  double pitch() const { return GetField<double>(14, 0); }
  double roll() const { return GetField<double>(16, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, 4 /* useMaterial */) &&
           VerifyField<int64_t>(verifier, 6 /* materialId */) &&
           VerifyField<DPoint3d>(verifier, 8 /* origin */) &&
           VerifyField<DPoint3d>(verifier, 10 /* size */) &&
           VerifyField<double>(verifier, 12 /* yaw */) &&
           VerifyField<double>(verifier, 14 /* pitch */) &&
           VerifyField<double>(verifier, 16 /* roll */) &&
           verifier.EndTable();
  }
  bool has_useMaterial() const { return CheckField(4); }
  bool has_materialId() const { return CheckField(6); }
  bool has_origin() const { return CheckField(8); }
  bool has_size() const { return CheckField(10); }
  bool has_yaw() const { return CheckField(12); }
  bool has_pitch() const { return CheckField(14); }
  bool has_roll() const { return CheckField(16); }
};

struct MaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_useMaterial(uint8_t useMaterial) { fbb_.AddElement<uint8_t>(4, useMaterial, 0); }
  void add_materialId(int64_t materialId) { fbb_.AddElement<int64_t>(6, materialId, 0); }
  void add_origin(const DPoint3d *origin) { fbb_.AddStruct(8, origin); }
  void add_size(const DPoint3d *size) { fbb_.AddStruct(10, size); }
  void add_yaw(double yaw) { fbb_.AddElement<double>(12, yaw, 0); }
  void add_pitch(double pitch) { fbb_.AddElement<double>(14, pitch, 0); }
  void add_roll(double roll) { fbb_.AddElement<double>(16, roll, 0); }
  MaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MaterialBuilder &operator=(const MaterialBuilder &);
  flatbuffers::Offset<Material> Finish() {
    auto o = flatbuffers::Offset<Material>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Material> CreateMaterial(flatbuffers::FlatBufferBuilder &_fbb,
   uint8_t useMaterial = 0,
   int64_t materialId = 0,
   const DPoint3d *origin = 0,
   const DPoint3d *size = 0,
   double yaw = 0,
   double pitch = 0,
   double roll = 0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_roll(roll);
  builder_.add_pitch(pitch);
  builder_.add_yaw(yaw);
  builder_.add_materialId(materialId);
  builder_.add_size(size);
  builder_.add_origin(origin);
  builder_.add_useMaterial(useMaterial);
  return builder_.Finish();
}

struct AreaFill : private flatbuffers::Table {
  FillDisplay fill() const { return static_cast<FillDisplay>(GetField<int8_t>(4, 0)); }
  uint32_t color() const { return GetField<uint32_t>(6, 0); }
  uint8_t useColor() const { return GetField<uint8_t>(8, 0); }
  uint8_t isBgColor() const { return GetField<uint8_t>(10, 0); }
  double transparency() const { return GetField<double>(12, 0); }
  GradientMode mode() const { return static_cast<GradientMode>(GetField<int8_t>(14, 0)); }
  uint16_t flags() const { return GetField<uint16_t>(16, 0); }
  double angle() const { return GetField<double>(18, 0); }
  double tint() const { return GetField<double>(20, 0); }
  double shift() const { return GetField<double>(22, 0); }
  const flatbuffers::Vector<uint32_t> *colors() const { return GetPointer<const flatbuffers::Vector<uint32_t> *>(24); }
  const flatbuffers::Vector<double> *values() const { return GetPointer<const flatbuffers::Vector<double> *>(26); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* fill */) &&
           VerifyField<uint32_t>(verifier, 6 /* color */) &&
           VerifyField<uint8_t>(verifier, 8 /* useColor */) &&
           VerifyField<uint8_t>(verifier, 10 /* isBgColor */) &&
           VerifyField<double>(verifier, 12 /* transparency */) &&
           VerifyField<int8_t>(verifier, 14 /* mode */) &&
           VerifyField<uint16_t>(verifier, 16 /* flags */) &&
           VerifyField<double>(verifier, 18 /* angle */) &&
           VerifyField<double>(verifier, 20 /* tint */) &&
           VerifyField<double>(verifier, 22 /* shift */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 24 /* colors */) &&
           verifier.Verify(colors()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 26 /* values */) &&
           verifier.Verify(values()) &&
           verifier.EndTable();
  }
  bool has_fill() const { return CheckField(4); }
  bool has_color() const { return CheckField(6); }
  bool has_useColor() const { return CheckField(8); }
  bool has_isBgColor() const { return CheckField(10); }
  bool has_transparency() const { return CheckField(12); }
  bool has_mode() const { return CheckField(14); }
  bool has_flags() const { return CheckField(16); }
  bool has_angle() const { return CheckField(18); }
  bool has_tint() const { return CheckField(20); }
  bool has_shift() const { return CheckField(22); }
  bool has_colors() const { return CheckField(24); }
  bool has_values() const { return CheckField(26); }
};

struct AreaFillBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fill(FillDisplay fill) { fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fill), 0); }
  void add_color(uint32_t color) { fbb_.AddElement<uint32_t>(6, color, 0); }
  void add_useColor(uint8_t useColor) { fbb_.AddElement<uint8_t>(8, useColor, 0); }
  void add_isBgColor(uint8_t isBgColor) { fbb_.AddElement<uint8_t>(10, isBgColor, 0); }
  void add_transparency(double transparency) { fbb_.AddElement<double>(12, transparency, 0); }
  void add_mode(GradientMode mode) { fbb_.AddElement<int8_t>(14, static_cast<int8_t>(mode), 0); }
  void add_flags(uint16_t flags) { fbb_.AddElement<uint16_t>(16, flags, 0); }
  void add_angle(double angle) { fbb_.AddElement<double>(18, angle, 0); }
  void add_tint(double tint) { fbb_.AddElement<double>(20, tint, 0); }
  void add_shift(double shift) { fbb_.AddElement<double>(22, shift, 0); }
  void add_colors(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> colors) { fbb_.AddOffset(24, colors); }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<double>> values) { fbb_.AddOffset(26, values); }
  AreaFillBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AreaFillBuilder &operator=(const AreaFillBuilder &);
  flatbuffers::Offset<AreaFill> Finish() {
    auto o = flatbuffers::Offset<AreaFill>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<AreaFill> CreateAreaFill(flatbuffers::FlatBufferBuilder &_fbb,
   FillDisplay fill = FillDisplay_None,
   uint32_t color = 0,
   uint8_t useColor = 0,
   uint8_t isBgColor = 0,
   double transparency = 0,
   GradientMode mode = GradientMode_None,
   uint16_t flags = 0,
   double angle = 0,
   double tint = 0,
   double shift = 0,
   flatbuffers::Offset<flatbuffers::Vector<uint32_t>> colors = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> values = 0) {
  AreaFillBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_tint(tint);
  builder_.add_angle(angle);
  builder_.add_transparency(transparency);
  builder_.add_values(values);
  builder_.add_colors(colors);
  builder_.add_color(color);
  builder_.add_flags(flags);
  builder_.add_mode(mode);
  builder_.add_isBgColor(isBgColor);
  builder_.add_useColor(useColor);
  builder_.add_fill(fill);
  return builder_.Finish();
}

struct DwgHatchDefLine : private flatbuffers::Table {
  double angle() const { return GetField<double>(4, 0); }
  const DPoint2d *through() const { return GetStruct<const DPoint2d *>(6); }
  const DPoint2d *offset() const { return GetStruct<const DPoint2d *>(8); }
  const flatbuffers::Vector<double> *dashes() const { return GetPointer<const flatbuffers::Vector<double> *>(10); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, 4 /* angle */) &&
           VerifyField<DPoint2d>(verifier, 6 /* through */) &&
           VerifyField<DPoint2d>(verifier, 8 /* offset */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 10 /* dashes */) &&
           verifier.Verify(dashes()) &&
           verifier.EndTable();
  }
  bool has_angle() const { return CheckField(4); }
  bool has_through() const { return CheckField(6); }
  bool has_offset() const { return CheckField(8); }
  bool has_dashes() const { return CheckField(10); }
};

struct DwgHatchDefLineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_angle(double angle) { fbb_.AddElement<double>(4, angle, 0); }
  void add_through(const DPoint2d *through) { fbb_.AddStruct(6, through); }
  void add_offset(const DPoint2d *offset) { fbb_.AddStruct(8, offset); }
  void add_dashes(flatbuffers::Offset<flatbuffers::Vector<double>> dashes) { fbb_.AddOffset(10, dashes); }
  DwgHatchDefLineBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DwgHatchDefLineBuilder &operator=(const DwgHatchDefLineBuilder &);
  flatbuffers::Offset<DwgHatchDefLine> Finish() {
    auto o = flatbuffers::Offset<DwgHatchDefLine>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<DwgHatchDefLine> CreateDwgHatchDefLine(flatbuffers::FlatBufferBuilder &_fbb,
   double angle = 0,
   const DPoint2d *through = 0,
   const DPoint2d *offset = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> dashes = 0) {
  DwgHatchDefLineBuilder builder_(_fbb);
  builder_.add_angle(angle);
  builder_.add_dashes(dashes);
  builder_.add_offset(offset);
  builder_.add_through(through);
  return builder_.Finish();
}

struct AreaPattern : private flatbuffers::Table {
  const DPoint3d *origin() const { return GetStruct<const DPoint3d *>(4); }
  const RotMatrix *rotation() const { return GetStruct<const RotMatrix *>(6); }
  double space1() const { return GetField<double>(8, 0); }
  double space2() const { return GetField<double>(10, 0); }
  double angle1() const { return GetField<double>(12, 0); }
  double angle2() const { return GetField<double>(14, 0); }
  double scale() const { return GetField<double>(16, 0); }
  uint32_t color() const { return GetField<uint32_t>(18, 0); }
  uint32_t weight() const { return GetField<uint32_t>(20, 0); }
  uint8_t useColor() const { return GetField<uint8_t>(22, 0); }
  uint8_t useWeight() const { return GetField<uint8_t>(24, 0); }
  uint8_t invisibleBoundary() const { return GetField<uint8_t>(26, 0); }
  uint8_t snappable() const { return GetField<uint8_t>(28, 0); }
  int64_t symbolId() const { return GetField<int64_t>(30, 0); }
  const flatbuffers::Vector<flatbuffers::Offset<DwgHatchDefLine>> *defLine() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DwgHatchDefLine>> *>(32); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DPoint3d>(verifier, 4 /* origin */) &&
           VerifyField<RotMatrix>(verifier, 6 /* rotation */) &&
           VerifyField<double>(verifier, 8 /* space1 */) &&
           VerifyField<double>(verifier, 10 /* space2 */) &&
           VerifyField<double>(verifier, 12 /* angle1 */) &&
           VerifyField<double>(verifier, 14 /* angle2 */) &&
           VerifyField<double>(verifier, 16 /* scale */) &&
           VerifyField<uint32_t>(verifier, 18 /* color */) &&
           VerifyField<uint32_t>(verifier, 20 /* weight */) &&
           VerifyField<uint8_t>(verifier, 22 /* useColor */) &&
           VerifyField<uint8_t>(verifier, 24 /* useWeight */) &&
           VerifyField<uint8_t>(verifier, 26 /* invisibleBoundary */) &&
           VerifyField<uint8_t>(verifier, 28 /* snappable */) &&
           VerifyField<int64_t>(verifier, 30 /* symbolId */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 32 /* defLine */) &&
           verifier.Verify(defLine()) &&
           verifier.VerifyVectorOfTables(defLine()) &&
           verifier.EndTable();
  }
  bool has_origin() const { return CheckField(4); }
  bool has_rotation() const { return CheckField(6); }
  bool has_space1() const { return CheckField(8); }
  bool has_space2() const { return CheckField(10); }
  bool has_angle1() const { return CheckField(12); }
  bool has_angle2() const { return CheckField(14); }
  bool has_scale() const { return CheckField(16); }
  bool has_color() const { return CheckField(18); }
  bool has_weight() const { return CheckField(20); }
  bool has_useColor() const { return CheckField(22); }
  bool has_useWeight() const { return CheckField(24); }
  bool has_invisibleBoundary() const { return CheckField(26); }
  bool has_snappable() const { return CheckField(28); }
  bool has_symbolId() const { return CheckField(30); }
  bool has_defLine() const { return CheckField(32); }
};

struct AreaPatternBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_origin(const DPoint3d *origin) { fbb_.AddStruct(4, origin); }
  void add_rotation(const RotMatrix *rotation) { fbb_.AddStruct(6, rotation); }
  void add_space1(double space1) { fbb_.AddElement<double>(8, space1, 0); }
  void add_space2(double space2) { fbb_.AddElement<double>(10, space2, 0); }
  void add_angle1(double angle1) { fbb_.AddElement<double>(12, angle1, 0); }
  void add_angle2(double angle2) { fbb_.AddElement<double>(14, angle2, 0); }
  void add_scale(double scale) { fbb_.AddElement<double>(16, scale, 0); }
  void add_color(uint32_t color) { fbb_.AddElement<uint32_t>(18, color, 0); }
  void add_weight(uint32_t weight) { fbb_.AddElement<uint32_t>(20, weight, 0); }
  void add_useColor(uint8_t useColor) { fbb_.AddElement<uint8_t>(22, useColor, 0); }
  void add_useWeight(uint8_t useWeight) { fbb_.AddElement<uint8_t>(24, useWeight, 0); }
  void add_invisibleBoundary(uint8_t invisibleBoundary) { fbb_.AddElement<uint8_t>(26, invisibleBoundary, 0); }
  void add_snappable(uint8_t snappable) { fbb_.AddElement<uint8_t>(28, snappable, 0); }
  void add_symbolId(int64_t symbolId) { fbb_.AddElement<int64_t>(30, symbolId, 0); }
  void add_defLine(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DwgHatchDefLine>>> defLine) { fbb_.AddOffset(32, defLine); }
  AreaPatternBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AreaPatternBuilder &operator=(const AreaPatternBuilder &);
  flatbuffers::Offset<AreaPattern> Finish() {
    auto o = flatbuffers::Offset<AreaPattern>(fbb_.EndTable(start_, 15));
    return o;
  }
};

inline flatbuffers::Offset<AreaPattern> CreateAreaPattern(flatbuffers::FlatBufferBuilder &_fbb,
   const DPoint3d *origin = 0,
   const RotMatrix *rotation = 0,
   double space1 = 0,
   double space2 = 0,
   double angle1 = 0,
   double angle2 = 0,
   double scale = 0,
   uint32_t color = 0,
   uint32_t weight = 0,
   uint8_t useColor = 0,
   uint8_t useWeight = 0,
   uint8_t invisibleBoundary = 0,
   uint8_t snappable = 0,
   int64_t symbolId = 0,
   flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DwgHatchDefLine>>> defLine = 0) {
  AreaPatternBuilder builder_(_fbb);
  builder_.add_symbolId(symbolId);
  builder_.add_scale(scale);
  builder_.add_angle2(angle2);
  builder_.add_angle1(angle1);
  builder_.add_space2(space2);
  builder_.add_space1(space1);
  builder_.add_defLine(defLine);
  builder_.add_weight(weight);
  builder_.add_color(color);
  builder_.add_rotation(rotation);
  builder_.add_origin(origin);
  builder_.add_snappable(snappable);
  builder_.add_invisibleBoundary(invisibleBoundary);
  builder_.add_useWeight(useWeight);
  builder_.add_useColor(useColor);
  return builder_.Finish();
}

}  // namespace FB
}  // namespace Dgn
}  // namespace BentleyB0200

#endif  // FLATBUFFERS_GENERATED_ELEMENTGRAPHICS_BENTLEYB0200_DGN_FB_H_
