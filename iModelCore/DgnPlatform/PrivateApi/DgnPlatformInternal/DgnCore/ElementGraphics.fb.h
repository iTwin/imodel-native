//--------------------------------------------------------------------------------------
//     $Source: PrivateApi/DgnPlatformInternal/DgnCore/ElementGraphics.fb.h $
//  $Copyright: (c) 2015 Bentley Systems, Incorporated. All rights reserved. $
//--------------------------------------------------------------------------------------
// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_ELEMENTGRAPHICS_BENTLEYG06_DGNPLATFORM_FB_H_
#define FLATBUFFERS_GENERATED_ELEMENTGRAPHICS_BENTLEYG06_DGNPLATFORM_FB_H_

#include "flatbuffers/flatbuffers.h"


namespace BentleyG06 {
namespace DgnPlatform {
namespace FB {

struct DPoint3d;
struct DPoint2d;
struct DVec3d;
struct Transform;
struct FaceSymbology;
struct PointPrimitive;
struct PointPrimitive2d;
struct ArcPrimitive;
struct BRepData;
struct BeginSubCategory;
struct GeomPart;
struct BasicSymbology;
struct AreaFill;

enum GradientMode {
  GradientMode_None = 0,
  GradientMode_Linear = 1,
  GradientMode_Curved = 2,
  GradientMode_Cylindrical = 3,
  GradientMode_Spherical = 4,
  GradientMode_Hemispherical = 5
};

inline const char **EnumNamesGradientMode() {
  static const char *names[] = { "None", "Linear", "Curved", "Cylindrical", "Spherical", "Hemispherical", nullptr };
  return names;
}

inline const char *EnumNameGradientMode(GradientMode e) { return EnumNamesGradientMode()[e]; }

enum BoundaryType {
  BoundaryType_None = 0,
  BoundaryType_Open = 1,
  BoundaryType_Closed = 2
};

inline const char **EnumNamesBoundaryType() {
  static const char *names[] = { "None", "Open", "Closed", nullptr };
  return names;
}

inline const char *EnumNameBoundaryType(BoundaryType e) { return EnumNamesBoundaryType()[e]; }

enum FillDisplay {
  FillDisplay_None = 0,
  FillDisplay_ByView = 1,
  FillDisplay_Always = 2,
  FillDisplay_Blanking = 3
};

inline const char **EnumNamesFillDisplay() {
  static const char *names[] = { "None", "ByView", "Always", "Blanking", nullptr };
  return names;
}

inline const char *EnumNameFillDisplay(FillDisplay e) { return EnumNamesFillDisplay()[e]; }

enum GeometryClass {
  GeometryClass_Primary = 0,
  GeometryClass_Construction = 1,
  GeometryClass_Dimension = 2,
  GeometryClass_Pattern = 3
};

inline const char **EnumNamesGeometryClass() {
  static const char *names[] = { "Primary", "Construction", "Dimension", "Pattern", nullptr };
  return names;
}

inline const char *EnumNameGeometryClass(GeometryClass e) { return EnumNamesGeometryClass()[e]; }

MANUALLY_ALIGNED_STRUCT(8) DPoint3d {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DPoint3d(double x, double y, double z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
  double z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(DPoint3d, 24);

MANUALLY_ALIGNED_STRUCT(8) DPoint2d {
 private:
  double x_;
  double y_;

 public:
  DPoint2d(double x, double y)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(DPoint2d, 16);

MANUALLY_ALIGNED_STRUCT(8) DVec3d {
 private:
  double x_;
  double y_;
  double z_;

 public:
  DVec3d(double x, double y, double z)
    : x_(flatbuffers::EndianScalar(x)), y_(flatbuffers::EndianScalar(y)), z_(flatbuffers::EndianScalar(z)) { }

  double x() const { return flatbuffers::EndianScalar(x_); }
  double y() const { return flatbuffers::EndianScalar(y_); }
  double z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(DVec3d, 24);

MANUALLY_ALIGNED_STRUCT(8) Transform {
 private:
  double x00_;
  double x01_;
  double x02_;
  double tx_;
  double x10_;
  double x11_;
  double x12_;
  double ty_;
  double x20_;
  double x21_;
  double x22_;
  double tz_;

 public:
  Transform(double x00, double x01, double x02, double tx, double x10, double x11, double x12, double ty, double x20, double x21, double x22, double tz)
    : x00_(flatbuffers::EndianScalar(x00)), x01_(flatbuffers::EndianScalar(x01)), x02_(flatbuffers::EndianScalar(x02)), tx_(flatbuffers::EndianScalar(tx)), x10_(flatbuffers::EndianScalar(x10)), x11_(flatbuffers::EndianScalar(x11)), x12_(flatbuffers::EndianScalar(x12)), ty_(flatbuffers::EndianScalar(ty)), x20_(flatbuffers::EndianScalar(x20)), x21_(flatbuffers::EndianScalar(x21)), x22_(flatbuffers::EndianScalar(x22)), tz_(flatbuffers::EndianScalar(tz)) { }

  double x00() const { return flatbuffers::EndianScalar(x00_); }
  double x01() const { return flatbuffers::EndianScalar(x01_); }
  double x02() const { return flatbuffers::EndianScalar(x02_); }
  double tx() const { return flatbuffers::EndianScalar(tx_); }
  double x10() const { return flatbuffers::EndianScalar(x10_); }
  double x11() const { return flatbuffers::EndianScalar(x11_); }
  double x12() const { return flatbuffers::EndianScalar(x12_); }
  double ty() const { return flatbuffers::EndianScalar(ty_); }
  double x20() const { return flatbuffers::EndianScalar(x20_); }
  double x21() const { return flatbuffers::EndianScalar(x21_); }
  double x22() const { return flatbuffers::EndianScalar(x22_); }
  double tz() const { return flatbuffers::EndianScalar(tz_); }
};
STRUCT_END(Transform, 96);

MANUALLY_ALIGNED_STRUCT(8) FaceSymbology {
 private:
  uint32_t index_;
  uint32_t color_;
  double transparency_;
  int64_t materialId_;

 public:
  FaceSymbology(uint32_t index, uint32_t color, double transparency, int64_t materialId)
    : index_(flatbuffers::EndianScalar(index)), color_(flatbuffers::EndianScalar(color)), transparency_(flatbuffers::EndianScalar(transparency)), materialId_(flatbuffers::EndianScalar(materialId)) { }

  uint32_t index() const { return flatbuffers::EndianScalar(index_); }
  uint32_t color() const { return flatbuffers::EndianScalar(color_); }
  double transparency() const { return flatbuffers::EndianScalar(transparency_); }
  int64_t materialId() const { return flatbuffers::EndianScalar(materialId_); }
};
STRUCT_END(FaceSymbology, 24);

struct PointPrimitive : private flatbuffers::Table {
  const flatbuffers::Vector<const DPoint3d *> *coords() const { return GetPointer<const flatbuffers::Vector<const DPoint3d *> *>(4); }
  BoundaryType boundary() const { return static_cast<BoundaryType>(GetField<int8_t>(6, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* coords */) &&
           verifier.Verify(coords()) &&
           VerifyField<int8_t>(verifier, 6 /* boundary */) &&
           verifier.EndTable();
  }
  bool has_coords() const { return CheckField(4); }
  bool has_boundary() const { return CheckField(6); }
};

struct PointPrimitiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coords(flatbuffers::Offset<flatbuffers::Vector<const DPoint3d *>> coords) { fbb_.AddOffset(4, coords); }
  void add_boundary(BoundaryType boundary) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(boundary), 0); }
  PointPrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PointPrimitiveBuilder &operator=(const PointPrimitiveBuilder &);
  flatbuffers::Offset<PointPrimitive> Finish() {
    auto o = flatbuffers::Offset<PointPrimitive>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<PointPrimitive> CreatePointPrimitive(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<const DPoint3d *>> coords = 0,
   BoundaryType boundary = BoundaryType_None) {
  PointPrimitiveBuilder builder_(_fbb);
  builder_.add_coords(coords);
  builder_.add_boundary(boundary);
  return builder_.Finish();
}

struct PointPrimitive2d : private flatbuffers::Table {
  const flatbuffers::Vector<const DPoint2d *> *coords() const { return GetPointer<const flatbuffers::Vector<const DPoint2d *> *>(4); }
  BoundaryType boundary() const { return static_cast<BoundaryType>(GetField<int8_t>(6, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 4 /* coords */) &&
           verifier.Verify(coords()) &&
           VerifyField<int8_t>(verifier, 6 /* boundary */) &&
           verifier.EndTable();
  }
  bool has_coords() const { return CheckField(4); }
  bool has_boundary() const { return CheckField(6); }
};

struct PointPrimitive2dBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coords(flatbuffers::Offset<flatbuffers::Vector<const DPoint2d *>> coords) { fbb_.AddOffset(4, coords); }
  void add_boundary(BoundaryType boundary) { fbb_.AddElement<int8_t>(6, static_cast<int8_t>(boundary), 0); }
  PointPrimitive2dBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PointPrimitive2dBuilder &operator=(const PointPrimitive2dBuilder &);
  flatbuffers::Offset<PointPrimitive2d> Finish() {
    auto o = flatbuffers::Offset<PointPrimitive2d>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<PointPrimitive2d> CreatePointPrimitive2d(flatbuffers::FlatBufferBuilder &_fbb,
   flatbuffers::Offset<flatbuffers::Vector<const DPoint2d *>> coords = 0,
   BoundaryType boundary = BoundaryType_None) {
  PointPrimitive2dBuilder builder_(_fbb);
  builder_.add_coords(coords);
  builder_.add_boundary(boundary);
  return builder_.Finish();
}

struct ArcPrimitive : private flatbuffers::Table {
  const DPoint3d *center() const { return GetStruct<const DPoint3d *>(4); }
  const DVec3d *vector0() const { return GetStruct<const DVec3d *>(6); }
  const DVec3d *vector90() const { return GetStruct<const DVec3d *>(8); }
  double start() const { return GetField<double>(10, 0); }
  double sweep() const { return GetField<double>(12, 0); }
  BoundaryType boundary() const { return static_cast<BoundaryType>(GetField<int8_t>(14, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<DPoint3d>(verifier, 4 /* center */) &&
           VerifyField<DVec3d>(verifier, 6 /* vector0 */) &&
           VerifyField<DVec3d>(verifier, 8 /* vector90 */) &&
           VerifyField<double>(verifier, 10 /* start */) &&
           VerifyField<double>(verifier, 12 /* sweep */) &&
           VerifyField<int8_t>(verifier, 14 /* boundary */) &&
           verifier.EndTable();
  }
  bool has_center() const { return CheckField(4); }
  bool has_vector0() const { return CheckField(6); }
  bool has_vector90() const { return CheckField(8); }
  bool has_start() const { return CheckField(10); }
  bool has_sweep() const { return CheckField(12); }
  bool has_boundary() const { return CheckField(14); }
};

struct ArcPrimitiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_center(const DPoint3d *center) { fbb_.AddStruct(4, center); }
  void add_vector0(const DVec3d *vector0) { fbb_.AddStruct(6, vector0); }
  void add_vector90(const DVec3d *vector90) { fbb_.AddStruct(8, vector90); }
  void add_start(double start) { fbb_.AddElement<double>(10, start, 0); }
  void add_sweep(double sweep) { fbb_.AddElement<double>(12, sweep, 0); }
  void add_boundary(BoundaryType boundary) { fbb_.AddElement<int8_t>(14, static_cast<int8_t>(boundary), 0); }
  ArcPrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ArcPrimitiveBuilder &operator=(const ArcPrimitiveBuilder &);
  flatbuffers::Offset<ArcPrimitive> Finish() {
    auto o = flatbuffers::Offset<ArcPrimitive>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<ArcPrimitive> CreateArcPrimitive(flatbuffers::FlatBufferBuilder &_fbb,
   const DPoint3d *center = 0,
   const DVec3d *vector0 = 0,
   const DVec3d *vector90 = 0,
   double start = 0,
   double sweep = 0,
   BoundaryType boundary = BoundaryType_None) {
  ArcPrimitiveBuilder builder_(_fbb);
  builder_.add_sweep(sweep);
  builder_.add_start(start);
  builder_.add_vector90(vector90);
  builder_.add_vector0(vector0);
  builder_.add_center(center);
  builder_.add_boundary(boundary);
  return builder_.Finish();
}

struct BRepData : private flatbuffers::Table {
  const Transform *entityTransform() const { return GetStruct<const Transform *>(4); }
  const flatbuffers::Vector<uint8_t> *entityData() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(6); }
  const flatbuffers::Vector<const FaceSymbology *> *faceAttachments() const { return GetPointer<const flatbuffers::Vector<const FaceSymbology *> *>(8); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Transform>(verifier, 4 /* entityTransform */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 6 /* entityData */) &&
           verifier.Verify(entityData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 8 /* faceAttachments */) &&
           verifier.Verify(faceAttachments()) &&
           verifier.EndTable();
  }
  bool has_entityTransform() const { return CheckField(4); }
  bool has_entityData() const { return CheckField(6); }
  bool has_faceAttachments() const { return CheckField(8); }
};

struct BRepDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entityTransform(const Transform *entityTransform) { fbb_.AddStruct(4, entityTransform); }
  void add_entityData(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData) { fbb_.AddOffset(6, entityData); }
  void add_faceAttachments(flatbuffers::Offset<flatbuffers::Vector<const FaceSymbology *>> faceAttachments) { fbb_.AddOffset(8, faceAttachments); }
  BRepDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BRepDataBuilder &operator=(const BRepDataBuilder &);
  flatbuffers::Offset<BRepData> Finish() {
    auto o = flatbuffers::Offset<BRepData>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<BRepData> CreateBRepData(flatbuffers::FlatBufferBuilder &_fbb,
   const Transform *entityTransform = 0,
   flatbuffers::Offset<flatbuffers::Vector<uint8_t>> entityData = 0,
   flatbuffers::Offset<flatbuffers::Vector<const FaceSymbology *>> faceAttachments = 0) {
  BRepDataBuilder builder_(_fbb);
  builder_.add_faceAttachments(faceAttachments);
  builder_.add_entityData(entityData);
  builder_.add_entityTransform(entityTransform);
  return builder_.Finish();
}

struct BeginSubCategory : private flatbuffers::Table {
  int64_t subCategoryId() const { return GetField<int64_t>(4, 0); }
  const DPoint3d *origin() const { return GetStruct<const DPoint3d *>(6); }
  double yaw() const { return GetField<double>(8, 0); }
  double pitch() const { return GetField<double>(10, 0); }
  double roll() const { return GetField<double>(12, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* subCategoryId */) &&
           VerifyField<DPoint3d>(verifier, 6 /* origin */) &&
           VerifyField<double>(verifier, 8 /* yaw */) &&
           VerifyField<double>(verifier, 10 /* pitch */) &&
           VerifyField<double>(verifier, 12 /* roll */) &&
           verifier.EndTable();
  }
  bool has_subCategoryId() const { return CheckField(4); }
  bool has_origin() const { return CheckField(6); }
  bool has_yaw() const { return CheckField(8); }
  bool has_pitch() const { return CheckField(10); }
  bool has_roll() const { return CheckField(12); }
};

struct BeginSubCategoryBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subCategoryId(int64_t subCategoryId) { fbb_.AddElement<int64_t>(4, subCategoryId, 0); }
  void add_origin(const DPoint3d *origin) { fbb_.AddStruct(6, origin); }
  void add_yaw(double yaw) { fbb_.AddElement<double>(8, yaw, 0); }
  void add_pitch(double pitch) { fbb_.AddElement<double>(10, pitch, 0); }
  void add_roll(double roll) { fbb_.AddElement<double>(12, roll, 0); }
  BeginSubCategoryBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BeginSubCategoryBuilder &operator=(const BeginSubCategoryBuilder &);
  flatbuffers::Offset<BeginSubCategory> Finish() {
    auto o = flatbuffers::Offset<BeginSubCategory>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<BeginSubCategory> CreateBeginSubCategory(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t subCategoryId = 0,
   const DPoint3d *origin = 0,
   double yaw = 0,
   double pitch = 0,
   double roll = 0) {
  BeginSubCategoryBuilder builder_(_fbb);
  builder_.add_roll(roll);
  builder_.add_pitch(pitch);
  builder_.add_yaw(yaw);
  builder_.add_subCategoryId(subCategoryId);
  builder_.add_origin(origin);
  return builder_.Finish();
}

struct GeomPart : private flatbuffers::Table {
  int64_t geomPartId() const { return GetField<int64_t>(4, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, 4 /* geomPartId */) &&
           verifier.EndTable();
  }
  bool has_geomPartId() const { return CheckField(4); }
};

struct GeomPartBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_geomPartId(int64_t geomPartId) { fbb_.AddElement<int64_t>(4, geomPartId, 0); }
  GeomPartBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GeomPartBuilder &operator=(const GeomPartBuilder &);
  flatbuffers::Offset<GeomPart> Finish() {
    auto o = flatbuffers::Offset<GeomPart>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<GeomPart> CreateGeomPart(flatbuffers::FlatBufferBuilder &_fbb,
   int64_t geomPartId = 0) {
  GeomPartBuilder builder_(_fbb);
  builder_.add_geomPartId(geomPartId);
  return builder_.Finish();
}

struct BasicSymbology : private flatbuffers::Table {
  uint32_t color() const { return GetField<uint32_t>(4, 0); }
  uint32_t weight() const { return GetField<uint32_t>(6, 0); }
  double transparency() const { return GetField<double>(8, 0); }
  int32_t displayPriority() const { return GetField<int32_t>(10, 0); }
  uint8_t useColor() const { return GetField<uint8_t>(12, 0); }
  uint8_t useWeight() const { return GetField<uint8_t>(14, 0); }
  GeometryClass geomClass() const { return static_cast<GeometryClass>(GetField<int8_t>(16, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, 4 /* color */) &&
           VerifyField<uint32_t>(verifier, 6 /* weight */) &&
           VerifyField<double>(verifier, 8 /* transparency */) &&
           VerifyField<int32_t>(verifier, 10 /* displayPriority */) &&
           VerifyField<uint8_t>(verifier, 12 /* useColor */) &&
           VerifyField<uint8_t>(verifier, 14 /* useWeight */) &&
           VerifyField<int8_t>(verifier, 16 /* geomClass */) &&
           verifier.EndTable();
  }
  bool has_color() const { return CheckField(4); }
  bool has_weight() const { return CheckField(6); }
  bool has_transparency() const { return CheckField(8); }
  bool has_displayPriority() const { return CheckField(10); }
  bool has_useColor() const { return CheckField(12); }
  bool has_useWeight() const { return CheckField(14); }
  bool has_geomClass() const { return CheckField(16); }
};

struct BasicSymbologyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(uint32_t color) { fbb_.AddElement<uint32_t>(4, color, 0); }
  void add_weight(uint32_t weight) { fbb_.AddElement<uint32_t>(6, weight, 0); }
  void add_transparency(double transparency) { fbb_.AddElement<double>(8, transparency, 0); }
  void add_displayPriority(int32_t displayPriority) { fbb_.AddElement<int32_t>(10, displayPriority, 0); }
  void add_useColor(uint8_t useColor) { fbb_.AddElement<uint8_t>(12, useColor, 0); }
  void add_useWeight(uint8_t useWeight) { fbb_.AddElement<uint8_t>(14, useWeight, 0); }
  void add_geomClass(GeometryClass geomClass) { fbb_.AddElement<int8_t>(16, static_cast<int8_t>(geomClass), 0); }
  BasicSymbologyBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  BasicSymbologyBuilder &operator=(const BasicSymbologyBuilder &);
  flatbuffers::Offset<BasicSymbology> Finish() {
    auto o = flatbuffers::Offset<BasicSymbology>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<BasicSymbology> CreateBasicSymbology(flatbuffers::FlatBufferBuilder &_fbb,
   uint32_t color = 0,
   uint32_t weight = 0,
   double transparency = 0,
   int32_t displayPriority = 0,
   uint8_t useColor = 0,
   uint8_t useWeight = 0,
   GeometryClass geomClass = GeometryClass_Primary) {
  BasicSymbologyBuilder builder_(_fbb);
  builder_.add_transparency(transparency);
  builder_.add_displayPriority(displayPriority);
  builder_.add_weight(weight);
  builder_.add_color(color);
  builder_.add_geomClass(geomClass);
  builder_.add_useWeight(useWeight);
  builder_.add_useColor(useColor);
  return builder_.Finish();
}

struct AreaFill : private flatbuffers::Table {
  FillDisplay fill() const { return static_cast<FillDisplay>(GetField<int8_t>(4, 0)); }
  uint32_t color() const { return GetField<uint32_t>(6, 0); }
  double transparency() const { return GetField<double>(8, 0); }
  GradientMode mode() const { return static_cast<GradientMode>(GetField<int8_t>(10, 0)); }
  uint16_t flags() const { return GetField<uint16_t>(12, 0); }
  double angle() const { return GetField<double>(14, 0); }
  double tint() const { return GetField<double>(16, 0); }
  double shift() const { return GetField<double>(18, 0); }
  const flatbuffers::Vector<uint32_t> *colors() const { return GetPointer<const flatbuffers::Vector<uint32_t> *>(20); }
  const flatbuffers::Vector<double> *values() const { return GetPointer<const flatbuffers::Vector<double> *>(22); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, 4 /* fill */) &&
           VerifyField<uint32_t>(verifier, 6 /* color */) &&
           VerifyField<double>(verifier, 8 /* transparency */) &&
           VerifyField<int8_t>(verifier, 10 /* mode */) &&
           VerifyField<uint16_t>(verifier, 12 /* flags */) &&
           VerifyField<double>(verifier, 14 /* angle */) &&
           VerifyField<double>(verifier, 16 /* tint */) &&
           VerifyField<double>(verifier, 18 /* shift */) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 20 /* colors */) &&
           verifier.Verify(colors()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, 22 /* values */) &&
           verifier.Verify(values()) &&
           verifier.EndTable();
  }
  bool has_fill() const { return CheckField(4); }
  bool has_color() const { return CheckField(6); }
  bool has_transparency() const { return CheckField(8); }
  bool has_mode() const { return CheckField(10); }
  bool has_flags() const { return CheckField(12); }
  bool has_angle() const { return CheckField(14); }
  bool has_tint() const { return CheckField(16); }
  bool has_shift() const { return CheckField(18); }
  bool has_colors() const { return CheckField(20); }
  bool has_values() const { return CheckField(22); }
};

struct AreaFillBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fill(FillDisplay fill) { fbb_.AddElement<int8_t>(4, static_cast<int8_t>(fill), 0); }
  void add_color(uint32_t color) { fbb_.AddElement<uint32_t>(6, color, 0); }
  void add_transparency(double transparency) { fbb_.AddElement<double>(8, transparency, 0); }
  void add_mode(GradientMode mode) { fbb_.AddElement<int8_t>(10, static_cast<int8_t>(mode), 0); }
  void add_flags(uint16_t flags) { fbb_.AddElement<uint16_t>(12, flags, 0); }
  void add_angle(double angle) { fbb_.AddElement<double>(14, angle, 0); }
  void add_tint(double tint) { fbb_.AddElement<double>(16, tint, 0); }
  void add_shift(double shift) { fbb_.AddElement<double>(18, shift, 0); }
  void add_colors(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> colors) { fbb_.AddOffset(20, colors); }
  void add_values(flatbuffers::Offset<flatbuffers::Vector<double>> values) { fbb_.AddOffset(22, values); }
  AreaFillBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AreaFillBuilder &operator=(const AreaFillBuilder &);
  flatbuffers::Offset<AreaFill> Finish() {
    auto o = flatbuffers::Offset<AreaFill>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<AreaFill> CreateAreaFill(flatbuffers::FlatBufferBuilder &_fbb,
   FillDisplay fill = FillDisplay_None,
   uint32_t color = 0,
   double transparency = 0,
   GradientMode mode = GradientMode_None,
   uint16_t flags = 0,
   double angle = 0,
   double tint = 0,
   double shift = 0,
   flatbuffers::Offset<flatbuffers::Vector<uint32_t>> colors = 0,
   flatbuffers::Offset<flatbuffers::Vector<double>> values = 0) {
  AreaFillBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_tint(tint);
  builder_.add_angle(angle);
  builder_.add_transparency(transparency);
  builder_.add_values(values);
  builder_.add_colors(colors);
  builder_.add_color(color);
  builder_.add_flags(flags);
  builder_.add_mode(mode);
  builder_.add_fill(fill);
  return builder_.Finish();
}

}  // namespace FB
}  // namespace DgnPlatform
}  // namespace BentleyG06

#endif  // FLATBUFFERS_GENERATED_ELEMENTGRAPHICS_BENTLEYG06_DGNPLATFORM_FB_H_
