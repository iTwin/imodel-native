//:>--------------------------------------------------------------------------------------+
//:>
//:>     $Source: PrivateApi/ImagePPInternal/gra/HRAImageSurface.h $
//:>
//:>  $Copyright: (c) 2016 Bentley Systems, Incorporated. All rights reserved. $
//:>
//:>+--------------------------------------------------------------------------------------

#pragma once

#include <Bentley/Bentley.h>
#include <Bentley/RefCounted.h>
#include <ImagePP/h/HmrMacro.h>

#include <ImagePP/all/h/HRPPixelType.h>
#include <ImagePP/all/h/HRAImageOp.h>
#include "ImageCommon.h" //<ImagePPInternal/gra/ImageCommon.h>

#include <ImagePP/all/h/HCDPacket.h>
#include <ImagePP/all/h/HCDPacketRLE.h>


BEGIN_IMAGEPP_NAMESPACE 

struct ImageEditorN8;
struct ImageEditorN1;
struct ImageEditorSampleRle;
struct ImageEditorPacketRle;

struct HRASampleN1Surface;
struct HRASampleN8Surface;
struct HRASampleRleSurface;
struct HRAPacketN1Surface;
struct HRAPacketN8Surface;
struct HRAPacketCodecRleSurface;
struct HRAPacketRleSurface;

/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct SurfaceVisitor
    {
    virtual ImagePPStatus _Visit(HRASampleN1Surface& surface) = 0;
    virtual ImagePPStatus _Visit(HRASampleN8Surface& surface) = 0;
    virtual ImagePPStatus _Visit(HRASampleRleSurface& surface) = 0;
    virtual ImagePPStatus _Visit(HRAPacketN1Surface& surface) = 0;
    virtual ImagePPStatus _Visit(HRAPacketN8Surface& surface) = 0;
    virtual ImagePPStatus _Visit(HRAPacketCodecRleSurface& surface) = 0;    
    virtual ImagePPStatus _Visit(HRAPacketRleSurface& surface) = 0;    
    };

/*---------------------------------------------------------------------------------**//**
* Each surface must provide a typdef to an HRAImageSurfaceXXX::ImageEditor.
* Caller will use the editor as a template parameter to its processing algorithm 
* to benefit from code inlining or at a minimum avoid virtual calls.
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRAImageSurface : public RefCountedBase
{
public:

    IMAGEPPTEST_EXPORT uint32_t GetWidth() const;
    IMAGEPPTEST_EXPORT uint32_t GetHeight() const;

    IMAGEPPTEST_EXPORT HRPPixelType const& GetPixelType() const;

    IMAGEPPTEST_EXPORT HFCPtr<HRPPixelType> GetPixelTypePtr();

    //! Create a standalone contiguous copy starting at the offset position.
    //! If the requested area is outside the source physical area, missing pixels will be generated by clamping.
    HRAImageSamplePtr CopyToSample(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset, IImageAllocatorR allocator) const;

    HRAImageSamplePtr CreateBufferReference(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset) const;
    ImagePPStatus Accept(SurfaceVisitor& visitor);
  
protected:
    HRAImageSurface() = delete;
    HRAImageSurface(HRAImageSurface const&) = delete;
    HRAImageSurface& operator= (HRAImageSurface const&) = delete;

    HRAImageSurface(uint32_t width, uint32_t height, HFCPtr<HRPPixelType> const& pPixelType);
    virtual ~HRAImageSurface();

    virtual HRAImageSamplePtr _CopyToSample(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset, IImageAllocatorR allocator) const = 0;
    virtual ImagePPStatus _Accept(SurfaceVisitor& visitor) = 0;
    virtual HRAImageSamplePtr _CreateBufferReference(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset) const = 0;

    HRAPacketN8SurfaceP AsPacketN8Surface() { return _AsPacketN8Surface(); }
    HRAPacketCodecRleSurfaceP AsPacketCodecRLESurface() { return _AsPacketCodecRLESurface(); }
    HRAPacketRleSurfaceP AsPacketRLESurface() { return _AsPacketRLESurface(); }
    
    virtual HRAPacketN8SurfaceP _AsPacketN8Surface() { return NULL; }
    virtual HRAPacketCodecRleSurfaceP _AsPacketCodecRLESurface(){ return NULL; }
    virtual HRAPacketRleSurfaceP _AsPacketRLESurface(){ return NULL; }
    
    uint32_t m_width;
    uint32_t m_height;
    HFCPtr<HRPPixelType> m_pixelType;
};

/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRASampleSurface : public HRAImageSurface
{
public:
    IMAGEPPTEST_EXPORT static HRASampleSurfacePtr Create(HRAImageSampleR sample);
        
    Byte const* GetDataCP(size_t& pitch) const;

    HRAImageSampleCR GetSample() const { return *m_pSample; }
    HRAImageSampleR GetSampleR() { return *m_pSample; }

    void Clear() { _Clear(); }

protected:
    virtual void _Clear() = 0;
    virtual HRAImageSamplePtr _CreateBufferReference(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset) const override;
    HRASampleSurface(HRAImageSampleR sample);
    
    HRAImageSamplePtr m_pSample;
};

/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRASampleN1Surface : public HRASampleSurface
{
public:
    friend HRASampleSurface;

    typedef ImageEditorN1 ImageEditor;

    Byte* GetDataP(size_t& pitch);
    
protected:
    HRASampleN1Surface(HRAImageSampleR sample);

    virtual HRAImageSamplePtr _CopyToSample(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset, IImageAllocatorR allocator) const;
    virtual void _Clear() override;
    virtual ImagePPStatus _Accept(SurfaceVisitor& visitor) override { return visitor._Visit(*this); }
};


/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRASampleN8Surface : public HRASampleSurface
{
public:
    friend HRASampleSurface;
   
    //typedef LineReaderN8<DataSourceSurfaceSample> LineReader;
    typedef ImageEditorN8 ImageEditor;

protected:
    HRASampleN8Surface(HRAImageSampleR sample);

    virtual HRAImageSamplePtr _CopyToSample(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset, IImageAllocatorR allocator) const;
    virtual void _Clear() override;
    virtual ImagePPStatus _Accept(SurfaceVisitor& visitor) override { return visitor._Visit(*this); }
};

/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRASampleRleSurface : public HRASampleSurface
{
public:    
    friend HRASampleSurface;

    typedef ImageEditorSampleRle ImageEditor;
    /*---------------------------------------------------------------------------------**//**
    * Lightweight reader that tries to be as direct as possible. 
    * Meant to be call per line in stretch and per pixel in warp.
    * @bsiclass
    +---------------+---------------+---------------+---------------+---------------+------*/
    struct LineReader
        {
        /*---------------------------------------------------------------------------------**//**
        * @bsimethod                                                   Mathieu.Marchand  10/2014
        +---------------+---------------+---------------+---------------+---------------+------*/
        LineReader(HRASampleRleSurface const& sample) 
        :m_sample(sample.GetSample()),
         m_pBufferRle(sample.GetSample().GetBufferRleCP())
            {
            m_pData = m_sample.GetBufferCP()->GetDataCP(m_pitch); 
            }
        
        /*---------------------------------------------------------------------------------**//**
        * @bsimethod                                                   Mathieu.Marchand  09/2014
        +---------------+---------------+---------------+---------------+---------------+------*/
        inline Byte const* GetLineDataCP(uint32_t line) const 
            {   
            BeAssert(line < m_sample.GetHeight());

            return m_pData + line*m_pitch;
            }

        /*---------------------------------------------------------------------------------**//**
        * @bsimethod                                                   Mathieu.Marchand  09/2014
        +---------------+---------------+---------------+---------------+---------------+------*/
        inline Byte const* GetLineDataCP(uint32_t line, size_t& dataSize) const 
            {   
            BeAssert(line < m_sample.GetHeight());
            
            dataSize = m_pBufferRle->GetLineDataSize(line);
            return m_pData + line*m_pitch; 
            }
    
        HRAImageBufferRleCP m_pBufferRle;
        HRAImageSampleCR m_sample;
        Byte const* m_pData;
        size_t m_pitch;
        };

protected:
    HRASampleRleSurface(HRAImageSampleR sample);

    virtual HRAImageSamplePtr _CopyToSample(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset, IImageAllocatorR allocator) const;
    virtual void _Clear() override;
    virtual ImagePPStatus _Accept(SurfaceVisitor& visitor) override { return visitor._Visit(*this); }
};

/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRAPacketSurface : public HRAImageSurface
{
public:
    HCDPacket const& GetPacket() const;

    //! pitch is ignored for compressed(RLE) packet.
    static HRAImageSurfacePtr Create(uint32_t width, uint32_t height, HFCPtr<HRPPixelType> const& pPixelType, HFCPtr<HCDPacket>& packet, size_t pitch);

protected:
    HRAPacketSurface(uint32_t width, uint32_t height, HFCPtr<HRPPixelType> const& pPixelType, HFCPtr<HCDPacket>& packet);
    
    HFCPtr<HCDPacket> GetPacketPtr() const;

    HFCPtr<HCDPacket> m_packet;
};

/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRAPacketN1Surface : public HRAPacketSurface
{
public:
    friend HRAPacketSurface;

    //typedef LineReaderN8<DataSourcePacketIdentity> LineReader;
    typedef ImageEditorN1 ImageEditor;
       
    Byte* GetDataP(size_t& pitch);

    Byte const* GetDataCP(size_t& pitch) const {return const_cast<HRAPacketN1Surface*>(this)->GetDataP(pitch);}

protected:
    HRAPacketN1Surface(uint32_t width, uint32_t height, HFCPtr<HRPPixelType> const& pPixelType, HFCPtr<HCDPacket>& packet, size_t pitch);

    virtual HRAImageSamplePtr _CopyToSample(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset, IImageAllocatorR allocator) const;
    virtual HRAImageSamplePtr _CreateBufferReference(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset) const override;

    virtual HRAPacketN1SurfaceP _AsPacketN1Surface() { return this; }

    virtual ImagePPStatus _Accept(SurfaceVisitor& visitor) override { return visitor._Visit(*this); }

    size_t m_pitch;
};

/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRAPacketN8Surface : public HRAPacketSurface
{
public:
    friend HRAPacketSurface;

    //typedef LineReaderN8<DataSourcePacketIdentity> LineReader;
    typedef ImageEditorN8 ImageEditor;
       
    Byte* GetDataP(size_t& pitch);

    Byte const* GetDataCP(size_t& pitch) const {return const_cast<HRAPacketN8Surface*>(this)->GetDataP(pitch);}

protected:
    HRAPacketN8Surface(uint32_t width, uint32_t height, HFCPtr<HRPPixelType> const& pPixelType, HFCPtr<HCDPacket>& packet, size_t pitch);

    virtual HRAImageSamplePtr _CopyToSample(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset, IImageAllocatorR allocator) const;
    virtual HRAImageSamplePtr _CreateBufferReference(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset) const override;

    virtual HRAPacketN8SurfaceP _AsPacketN8Surface() { return this; }

    virtual ImagePPStatus _Accept(SurfaceVisitor& visitor) override { return visitor._Visit(*this); }

    size_t m_pitch;
};

/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRAPacketCodecRleSurface : public HRAPacketSurface
{
public:
    friend HRAPacketSurface;

    typedef ImageEditorPacketRle ImageEditor;

    /*---------------------------------------------------------------------------------**//**
    * Lightweight reader that tries to be as direct as possible. 
    * Meant to be call per line in stretch and per pixel in warp.
    * @bsiclass
    +---------------+---------------+---------------+---------------+---------------+------*/
    struct LineReader
        {
        LineReader(HRAPacketCodecRleSurfaceCR surface) 
        :m_surface(surface)
            {
            BeAssert(surface.GetPacket().GetCodec() != NULL && surface.GetPacket().GetCodec()->IsCompatibleWith(HCDCodecHMRRLE1::CLASS_ID) &&
                 static_cast<HCDCodecHMRRLE1*>(surface.GetPacket().GetCodec().GetPtr())->HasLineIndexesTable());

            m_pDataRle = surface.GetPacket().GetBufferAddress();
            m_pLineIndexes = static_cast<HCDCodecHMRRLE1*>(surface.GetPacket().GetCodec().GetPtr())->GetLineIndexesTable();
            }
        
        /*---------------------------------------------------------------------------------**//**
        * @bsimethod                                                   Mathieu.Marchand  09/2014
        +---------------+---------------+---------------+---------------+---------------+------*/
        inline Byte const* GetLineDataCP(uint32_t line) const 
            {   
            BeAssert(line < m_surface.GetHeight());

            return m_pDataRle + (m_pLineIndexes[line] / 2); // indexes are in UInt16.
            }

        /*---------------------------------------------------------------------------------**//**
        * @bsimethod                                                   Mathieu.Marchand  09/2014
        +---------------+---------------+---------------+---------------+---------------+------*/
        inline Byte const* GetLineDataCP(uint32_t line, size_t& dataSize) const 
            {   
            BeAssert(line < m_surface.GetHeight());
            
            if (line >= m_surface.GetHeight())
                {
                dataSize = m_surface.GetPacket().GetDataSize() - m_pLineIndexes[m_surface.GetHeight()-1]*2;
                return m_pDataRle + (m_pLineIndexes[line] * 2); // indexes are in UInt16.
                }

            dataSize = m_pLineIndexes[line + 1]*2;
            return m_pDataRle + (m_pLineIndexes[line] * 2); // indexes are in UInt16.
            }
    
        HRAPacketCodecRleSurfaceCR m_surface;
        Byte const* m_pDataRle;
        uint32_t const* m_pLineIndexes;
        };
    

protected:
    
    virtual HRAPacketCodecRleSurfaceP _AsPacketCodecRLESurface() override { return this; }
    virtual HRAImageSamplePtr _CreateBufferReference(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset) const override { status = IMAGEPP_STATUS_UnknownError; return NULL;}

    virtual ImagePPStatus _Accept(SurfaceVisitor& visitor) override { return visitor._Visit(*this); }

private:
};

/*---------------------------------------------------------------------------------**//**
* @bsiclass
+---------------+---------------+---------------+---------------+---------------+------*/
struct HRAPacketRleSurface : public HRAImageSurface
{
public:
    typedef ImageEditorPacketRle ImageEditor;
    friend ImageEditor;

    // A lightweight reader that tries to be as direct as possible. Meant to be call per line in stretch and per pixel in warp.
    struct LineReader
        {
        LineReader(HRAPacketRleSurfaceCR surface) :m_surface(surface){}
        
        Byte const* GetLineDataCP(uint32_t line) const { return m_surface.GetLineDataCP(line);}
        Byte const* GetLineDataCP(uint32_t line, size_t& dataSize) const { return m_surface.GetLineDataCP(line, dataSize);}       

        HRAPacketRleSurfaceCR m_surface;
        };

    //! Construct an empty surface.  Strip must be added with 'AppendStrip()'.
    static HRAPacketRleSurfacePtr CreateSurface(uint32_t width, uint32_t height, HFCPtr<HRPPixelType> const& pPixelType, uint32_t stripHeight);

    void AppendStrip(HFCPtr<HRABitmapRLE>& pStrip);

protected:

    virtual HRAImageSamplePtr _CopyToSample(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset, IImageAllocatorR allocator) const;
    virtual HRAImageSamplePtr _CreateBufferReference(ImagePPStatus& status, uint32_t width, uint32_t height, PixelOffset64 const& offset) const override { status = IMAGEPP_STATUS_UnknownError; return NULL;}

    inline Byte const* GetLineDataCP(uint32_t line) const {return const_cast<HRAPacketRleSurface*>(this)->GetLineDataP(line);}
    inline Byte const* GetLineDataCP(uint32_t line, size_t& dataSize) const {return const_cast<HRAPacketRleSurface*>(this)->GetLineDataP(line, dataSize);}

    /*---------------------------------------------------------------------------------**//**
    * @bsimethod                                                   Mathieu.Marchand  09/2014
    +---------------+---------------+---------------+---------------+---------------+------*/
    inline Byte* GetLineDataP(uint32_t line)
        {   
        uint32_t packetOffsetY;

        HCDPacketRLE& packet = GetPacketRLE(packetOffsetY, line);

        return packet.GetLineBuffer(line - packetOffsetY);
        }

    /*---------------------------------------------------------------------------------**//**
    * @bsimethod                                                   Mathieu.Marchand  09/2014
    +---------------+---------------+---------------+---------------+---------------+------*/
    inline Byte* GetLineDataP(uint32_t line, size_t& dataSize)
        {   
        uint32_t packetOffsetY;

        HCDPacketRLE& packet = GetPacketRLE(packetOffsetY, line);

        dataSize = packet.GetLineDataSize(line - packetOffsetY);

        return packet.GetLineBuffer(line - packetOffsetY);
        }    

    /*---------------------------------------------------------------------------------**//**
    * @bsimethod                                                   Mathieu.Marchand  09/2014
    +---------------+---------------+---------------+---------------+---------------+------*/
    HCDPacketRLE& GetPacketRLE(uint32_t& packetOffsetY, uint32_t line)
        {
        BeAssert((line / m_stripHeight) < m_strips.size()); 

        packetOffsetY = (line / m_stripHeight) * m_stripHeight;
        
        return *m_strips[line / m_stripHeight].second;
        }

    HRAPacketRleSurface(uint32_t width, uint32_t height, HFCPtr<HRPPixelType> const& pPixelType, uint32_t stripHeight);
    
    uint32_t GetStripHeight() const { return m_stripHeight; }


    virtual HRAPacketRleSurfaceP _AsPacketRleSurface(){ return this; }

    virtual ImagePPStatus _Accept(SurfaceVisitor& visitor) override { return visitor._Visit(*this); }

private:
    typedef bvector<pair<HFCPtr<HRABitmapRLE>, HCDPacketRLE*> > StripsVector;
    uint32_t m_stripHeight;
    StripsVector m_strips;
};



END_IMAGEPP_NAMESPACE
