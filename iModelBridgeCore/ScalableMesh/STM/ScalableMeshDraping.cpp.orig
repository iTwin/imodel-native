#include "ScalableMeshPCH.h"
#include "ScalableMeshDraping.h"
#include <queue>

BEGIN_BENTLEY_SCALABLEMESH_NAMESPACE

struct SMDrapedLine;
struct SMDrapedPoint : RefCounted<IDTMDrapedLinePoint>
    {
    private: 
        DPoint3d m_pt;
        DTMDrapedLinePtr m_lineRef;
    protected:
        virtual DTMStatusInt _GetPointCoordinates(DPoint3d& coordP) const override
            {
            coordP = m_pt;
            return DTMStatusInt::DTM_SUCCESS;
            }
        virtual double _GetDistanceAlong() const override;
        virtual DTMDrapedLineCode _GetCode() const override
            {
            return DTMDrapedLineCode::Tin;
            }

        SMDrapedPoint(const DPoint3d& val, DTMDrapedLinePtr line)
            {
            m_pt = val;
            m_lineRef = line;
            }
    public:
        static SMDrapedPoint* Create(const DPoint3d& val, DTMDrapedLinePtr line)
            {
            return new SMDrapedPoint(val, line);
            }
    };

struct SMDrapedLine : RefCounted<IDTMDrapedLine>
    {
    private:
        bvector<DPoint3d> m_linePts;

    protected:
        virtual DTMStatusInt _GetPointByIndex(DTMDrapedLinePointPtr& ret, unsigned int index) const override
            {
            if (index >= m_linePts.size()) return DTMStatusInt::DTM_ERROR;
            ret = SMDrapedPoint::Create(m_linePts[index], DTMDrapedLinePtr((IDTMDrapedLine*)this));
            return DTMStatusInt::DTM_SUCCESS;
            }
        virtual DTMStatusInt _GetPointByIndex(DPoint3dP ptP, double* distanceP, DTMDrapedLineCode* codeP, unsigned int index) const override
            {
            if (index >= m_linePts.size()) return DTMStatusInt::DTM_ERROR;
            *ptP = m_linePts[index];
            return DTMStatusInt::DTM_SUCCESS;
            }
        virtual unsigned int _GetPointCount() const override
            {
            return (unsigned int)m_linePts.size();
            }
        SMDrapedLine(bvector<DPoint3d>& line)
            {
            m_linePts = line;
            }

    public:
        static SMDrapedLine* Create(bvector<DPoint3d>& line)
            {
            return new SMDrapedLine(line);
            }
        double GetDistanceUntil(const DPoint3d& pt)
            {
            auto it = m_linePts.begin();
            bool foundPt = false;
            double dist = 0.0;
            if (it->x == pt.x && it->y == pt.y && it->z == pt.z) return dist;
            while (++it != m_linePts.end() && foundPt)
                {
                dist += DVec3d::FromStartEnd(*(it - 1), *it).Magnitude();
                if (it->x == pt.x && it->y == pt.y && it->z == pt.z) foundPt = true;
                }
            return dist;
            }

    };

double SMDrapedPoint::_GetDistanceAlong() const
    {
    return dynamic_cast<SMDrapedLine*>(m_lineRef.get())->GetDistanceUntil(m_pt);
    }


bool MeshTraversalQueue::TryStartTraversal(bool& needProjectionToFindFirstTriangle)
    {
    IScalableMeshNodeQueryParamsPtr params = IScalableMeshNodeQueryParams::CreateParams();
    IScalableMeshNodeRayQueryPtr query = ((IScalableMesh*)m_mrDTM.get())->GetNodeQueryInterface();
    MeshTraversalStep firstStep;
    firstStep.currentSegment = 0;
    firstStep.startPoint = m_polylineToDrape[0];
    firstStep.hasEndPoint = false;
    firstStep.fetchNeighborsOnly = false;
    firstStep.nodeRef = nullptr;
    firstStep.direction = -1;
    DPoint3d* ptr = new DPoint3d();
    *ptr = firstStep.startPoint;
    needProjectionToFindFirstTriangle = false;
    if (query->Query(firstStep.linkedNode, ptr, NULL, 0, params) != SUCCESS)
        {
        //2d ray query to find node along line segment
        IScalableMeshNodeQueryParamsPtr paramsLine = IScalableMeshNodeQueryParams::CreateParams();
        paramsLine->SetDirection(DVec3d::FromStartEndNormalize(m_polylineToDrape[0], m_polylineToDrape[1]));
        paramsLine->SetDepth(DVec3d::FromStartEnd(m_polylineToDrape[0], m_polylineToDrape[1]).Magnitude());
        paramsLine->Set2d(true);
        IScalableMeshNodeRayQueryPtr queryLine = ((IScalableMesh*)m_mrDTM.get())->GetNodeQueryInterface();
        if (queryLine->Query(firstStep.linkedNode, ptr, NULL, 0, paramsLine) != SUCCESS || firstStep.linkedNode.get() == nullptr) return false;
        DRange3d nodeRange = firstStep.linkedNode->GetContentExtent();
        DRange2d nodeRange2d = DRange2d::From(DPoint2d::From(nodeRange.low.x, nodeRange.low.y), DPoint2d::From(nodeRange.high.x, nodeRange.high.y));
        DPoint2d pt1 = DPoint2d::From(m_polylineToDrape[0].x, m_polylineToDrape[0].y);
        DPoint2d pt2 = DPoint2d::From(m_polylineToDrape[1].x - m_polylineToDrape[0].x, m_polylineToDrape[1].y - m_polylineToDrape[0].y);
        DPoint2d intersect;
        if (!bsiDRange2d_intersectRay(&nodeRange2d, NULL, NULL, &intersect, NULL, &pt1, &pt2)) return false;
        firstStep.startPoint.x = intersect.x;
        firstStep.startPoint.y = intersect.y;
        firstStep.startPoint.z = nodeRange.high.z;
        needProjectionToFindFirstTriangle = true;
        }
    delete ptr;
    if (firstStep.linkedNode.get() == nullptr) return false;
    m_nodesRemainingToDrape.push(firstStep);
    return true;
    }

bool MeshTraversalQueue::HasNodesToProcess()
    {
    return m_nodesRemainingToDrape.size() > 0;
    }

bool MeshTraversalQueue::NextAlongElevation()
    {
    bool addedNeighbors = false;
    bvector<IScalableMeshNodePtr> neighbors = m_currentStep.linkedNode->GetNeighborAt(0, 0, m_currentStep.direction);
    if (neighbors.size() == 0 && m_currentStep.direction == -1)
        {
        m_currentStep.direction = 1;
        if (m_currentStep.nodeRef != nullptr) neighbors = m_currentStep.nodeRef->GetNeighborAt(0, 0, m_currentStep.direction);
        else neighbors = m_currentStep.linkedNode->GetNeighborAt(0, 0, m_currentStep.direction);
        }
    if (neighbors.size() > 0) addedNeighbors = true;
    else if (m_currentStep.nodeRef != nullptr)
        {
        addedNeighbors = true;
        MeshTraversalStep nextNode = { m_currentStep.nodeRef, m_currentStep.startPoint,
            m_currentStep.hasEndPoint, m_currentStep.endPointOfLastProjection, m_currentStep.currentSegment, true, IScalableMeshNodePtr(nullptr), (char)-1 };
        m_nodesRemainingToDrape.push(nextNode);
        }
    for (auto nextPtr : neighbors)
        {
        MeshTraversalStep nextNode = { nextPtr, m_currentStep.startPoint,
            m_currentStep.hasEndPoint, m_currentStep.endPointOfLastProjection, m_currentStep.currentSegment, false,
            m_currentStep.nodeRef != nullptr ? m_currentStep.nodeRef : m_currentStep.linkedNode, m_currentStep.direction };
        m_nodesRemainingToDrape.push(nextNode);
        }
    return addedNeighbors;
    }

void MeshTraversalQueue::ComputeDirectionOfNextNode()
    {
    double param = -1;
    DRange3d ext = m_currentStep.linkedNode->GetNodeExtent();
    DPlane3d right = DPlane3d::From3Points(DPoint3d::From(ext.high.x, ext.high.y, ext.high.z), DPoint3d::From(ext.high.x, ext.low.y, ext.high.z), DPoint3d::From(ext.high.x, ext.high.y, ext.low.z));
    DPlane3d left = DPlane3d::From3Points(DPoint3d::From(ext.low.x, ext.high.y, ext.high.z), DPoint3d::From(ext.low.x, ext.low.y, ext.high.z), DPoint3d::From(ext.low.x, ext.high.y, ext.low.z));
    DPlane3d nearPlane = DPlane3d::From3Points(DPoint3d::From(ext.high.x, ext.low.y, ext.high.z), DPoint3d::From(ext.low.x, ext.low.y, ext.high.z), DPoint3d::From(ext.high.x, ext.low.y, ext.low.z));
    DPlane3d farPlane = DPlane3d::From3Points(DPoint3d::From(ext.high.x, ext.high.y, ext.high.z), DPoint3d::From(ext.low.x, ext.high.y, ext.high.z), DPoint3d::From(ext.high.x, ext.high.y, ext.low.z));

    /*ext.high.x += 0.00001;
    ext.low.x -= 0.00001;
    ext.low.y -= 0.00001;
    ext.high.y += 0.00001;*/
    //compute last intersection of polyline with extent of node (XY)
    for (size_t pt = m_currentStep.currentSegment; pt < m_numPointsOnPolyline - 1; pt++)
        {
        double lowestParam = DBL_MAX;
        DSegment3d seg = DSegment3d::From(m_polylineToDrape[pt], m_polylineToDrape[pt + 1]);
        if (ext.IsContained(m_polylineToDrape[pt + 1], 2))
            {
            if (pt == m_numPointsOnPolyline - 2) m_endOfLineInNode = m_polylineToDrape[m_numPointsOnPolyline - 1]; //line ends in node
            continue;
            }
        if (bsiDSegment3d_intersectDPlane3d(&seg, &m_endOfLineInNode, &param, &right) && param >= 0.0 && param <= 1.0 && ext.IsContained(m_endOfLineInNode, 2))
            {
            if (lowestParam <= 1.0 && param > lowestParam)
                {
                m_intersectionWithNextNode = 0;
                break;
                }
            if (lowestParam > 1.0) m_intersectionWithNextNode = 0;
            lowestParam = param;
            }
        if (bsiDSegment3d_intersectDPlane3d(&seg, &m_endOfLineInNode, &param, &left) && param >= 0.0 && param <= 1.0 && ext.IsContained(m_endOfLineInNode, 2))
            {
            if (lowestParam <= 1.0 && param > lowestParam)
                {
                m_intersectionWithNextNode = 1;
                break;
                }
            if (lowestParam > 1.0) m_intersectionWithNextNode = 1;
            lowestParam = param;
            }
        if (bsiDSegment3d_intersectDPlane3d(&seg, &m_endOfLineInNode, &param, &nearPlane) && param >= 0.0 && param <= 1.0 && ext.IsContained(m_endOfLineInNode, 2))
            {
            if (lowestParam <= 1.0 && param > lowestParam)
                {
                m_intersectionWithNextNode = 2;
                break;
                }
            if (lowestParam > 1.0) m_intersectionWithNextNode = 2;
            lowestParam = param;
            }
        if (bsiDSegment3d_intersectDPlane3d(&seg, &m_endOfLineInNode, &param, &farPlane) && param >= 0.0 && param <= 1.0 && ext.IsContained(m_endOfLineInNode, 2))
            {
            if (lowestParam <= 1.0 && param > lowestParam)
                {
                m_intersectionWithNextNode = 3;
                break;
                }
            if (lowestParam > 1.0) m_intersectionWithNextNode = 3;
            lowestParam = param;
            }
        if (lowestParam <= 1.0) break;
        }
    }

bool MeshTraversalQueue::NextAlongDirection()
    {
    if (m_intersectionWithNextNode == 255) ComputeDirectionOfNextNode();
    if (m_intersectionWithNextNode != 255 && !bsiDPoint3d_pointEqualTolerance(&m_endOfLineInNode, &m_polylineToDrape[m_numPointsOnPolyline - 1], 1e-10))
        {
        char relativeX = (m_intersectionWithNextNode == 0 ? 1 : (m_intersectionWithNextNode == 1 ? -1 : 0));
        char relativeY = (m_intersectionWithNextNode == 3 ? 1 : (m_intersectionWithNextNode == 2 ? -1 : 0));
        bvector<IScalableMeshNodePtr> neighbors = m_currentStep.linkedNode->GetNeighborAt(relativeX, relativeY, 0);
        for (auto nextPtr : neighbors)
            {
            MeshTraversalStep nextNode = { nextPtr, m_currentStep.startPoint,
                m_currentStep.hasEndPoint, m_currentStep.endPointOfLastProjection, m_currentStep.currentSegment, false, IScalableMeshNodePtr(nullptr), m_currentStep.direction };
            m_nodesRemainingToDrape.push(nextNode);
            }
        return neighbors.size() > 0;
        }
    else return false;
    }

void MeshTraversalQueue::Clear()
    {
    m_nodesRemainingToDrape = std::queue<MeshTraversalStep>();
    }

MeshTraversalStep& MeshTraversalQueue::Step()
    {
    m_currentStep = m_nodesRemainingToDrape.front();
    //m_nodesRemainingToDrape.pop();
    m_intersectionWithNextNode = 255;
    return m_currentStep;
    }


DTMStatusInt ScalableMeshDraping::_DrapePoint(double* elevationP, double* slopeP, double* aspectP, DPoint3d triangle[3], int* drapedTypeP, DPoint3dCR point)
    {
    assert(!"Not implemented");
    return DTMStatusInt::DTM_ERROR;
    }

DTMStatusInt ScalableMeshDraping::_DrapeLinear(DTMDrapedLinePtr& ret, DPoint3dCP pts, int numPoints)
    {
    bvector<bvector<DPoint3d>> drapedPointsTemp(numPoints);
    //Trying to find point to start drape
    bool findTriangleAlongRay = false;
    MeshTraversalQueue queue(pts, numPoints);
    queue.UseScalableMesh(m_mrDtmPtr);
    if (!queue.TryStartTraversal(findTriangleAlongRay)) return DTMStatusInt::DTM_ERROR;
    IScalableMeshMeshPtr meshP = NULL;
    while (queue.HasNodesToProcess())
        {
        MeshTraversalStep startNode = queue.Step();
        DRay3d ray = DRay3d::FromOriginAndVector(startNode.startPoint, DVec3d::From(0,0,-1)); //what would we do if we need to use different draping directions?
        bool withinMesh = false;
        int triangle[3] = { -1, -1, -1 };
        //MTGNodeId triangleEdge = -1;
        DSegment3d segClipped;
        DRange1d fraction;
        if (startNode.linkedNode->GetPointCount() > 4 && !startNode.fetchNeighborsOnly)
            {
            DRay3d toTileInterior = DRay3d::FromOriginAndVector(startNode.startPoint, DVec3d::FromStartEnd(pts[startNode.currentSegment], pts[startNode.currentSegment + 1]));
            //NEEDSWORK_SM: would be better to just use a 2d clipping function here (if 2.5d) or project the ray and extent along drape direction (if 3d)
            toTileInterior.direction.z = 0; //regardless of how the lines were drawn, we are assuming they're projected straight-on. Not sure what's to be done for 3D.
            toTileInterior.origin.z = startNode.linkedNode->GetContentExtent().low.z;
            if (!findTriangleAlongRay && !ray.ClipToRange(startNode.linkedNode->GetContentExtent(), segClipped, fraction)) continue;
            else if (findTriangleAlongRay && !toTileInterior.ClipToRange(startNode.linkedNode->GetContentExtent(), segClipped, fraction))
                {
                //it is possible that the ray intersects the right tile, but there is no mesh over the intersection. If that is the case, 
                //then we need to find and add the neighbors to the list. If it is not, we can skip over this tile.
                toTileInterior.origin.z = startNode.linkedNode->GetNodeExtent().low.z;
                if (!toTileInterior.ClipToRange(startNode.linkedNode->GetNodeExtent(), segClipped, fraction)) continue;
                }
            else
                {
                meshP = startNode.linkedNode->GetMesh(true);
                if (!findTriangleAlongRay) withinMesh = meshP->FindTriangleForProjectedPoint(triangle, startNode.startPoint, !startNode.linkedNode->ArePoints3d());
                if (findTriangleAlongRay || !withinMesh)
                    {
                    withinMesh = meshP->FindTriangleAlongRay(triangle, toTileInterior);
                    }
                }
            }
        bool addedNeighbors = false;
        //no intersection found with triangle mesh; look down
        //This algorithm looks first (if 3D) for neighbors above or below the current node. (If 2d, the octree region is flattened, so that all data should be in the bottom-most node,
        //so that there is no need to look up or down). Specifically, we first look below the node (general case would be in the direction of projection), then above (same direction opposite
        // orientation). When doing that we preserve a reference to the "original" node that prompted the search so that it is the basis for the next pass.
        // When all elevations are unsuccessfully exhausted, look if there's a reference, and push it with a "last pass" marker.On those references, neighbors in drape direction should
        // be pursued. This means we will skip all empty nodes in drape direction, if applicable, and find the next node that has a mesh to drape on.
        if (!withinMesh)
            {
            queue.Clear();
            if (startNode.linkedNode->ArePoints3d() && !startNode.fetchNeighborsOnly)
                {
                addedNeighbors = queue.NextAlongElevation();
                }               
            if (addedNeighbors) continue;
            }
  
        //no intersection found with triangle mesh; add relevant neighbors
        if (!withinMesh)
            {
            //also add neighbors in the direction of the line
            if (!addedNeighbors) queue.NextAlongDirection();
            continue;
            }
       // queue.Clear();

        findTriangleAlongRay = false;
        //DPoint3d endPoint;
        //begin greedy drape
       /* if (ERROR == meshP->ProjectPolyLineOnMesh(endPoint, drapedPointsTemp, &pts[0], (int)numPoints, &startNode.currentSegment, triangle, startNode.startPoint))
            {
            //can't find triangle
            DRay3d toTileInterior = DRay3d::FromOriginAndVector(startNode.startPoint, DVec3d::FromStartEnd(pts[startNode.currentSegment], pts[startNode.currentSegment + 1]));
            if (meshP->FindTriangleAlongRay(triangle, toTileInterior))
                {
                if (ERROR == meshP->ProjectPolyLineOnMesh(endPoint, drapedPointsTemp, &pts[0], (int)numPoints, &startNode.currentSegment, triangle, startNode.startPoint))
                    {
                    return DTMStatusInt::DTM_ERROR;
                    }
                }
            else
                {
                endPoint = startNode.startPoint; //possible hole, try next node
                }
            }*/

       /* if (startNode.currentSegment < numPoints - 1 || pow(DRay3d::FromOriginAndVector(pts[numPoints - 1], DVec3d::From(0, 0, -1)).DirectionDotVectorToTarget(endPoint), 2) != (DVec3d::FromStartEnd(pts[numPoints - 1], endPoint)).MagnitudeSquared())
            {
            DRange3d ext = startNode.linkedNode->GetNodeExtent();
            //drape did not reach end of node, but line still has segment. Try to find current segment in neighbor instead
            if ((!startNode.hasEndPoint && ext.IsContained(endPoint, 2)) || startNode.hasEndPoint && !bsiDPoint3d_pointEqualTolerance(&endPoint, &startNode.endPointOfLastProjection, 0.000001))
                {
                if (startNode.currentSegment >= numPoints - 1) break;
                findTriangleAlongRay = true;
                }
            bool addedNodes = false;
            if (findTriangleAlongRay && startNode.linkedNode->ArePoints3d()) //again for 3d we need to check the top and bottom neighbors
                {
                addedNodes = queue.NextAlongElevation();
                }
            if (!addedNodes)
                {
                queue.NextAlongDirection();
                }
            }*/
        }
        bvector<DPoint3d> drapedLine;
        for (size_t i = 0; i < drapedPointsTemp.size();i++)
        for (auto pt : drapedPointsTemp[i]) drapedLine.push_back(pt);
        ret = SMDrapedLine::Create(drapedLine);
        return DTMStatusInt::DTM_SUCCESS;
    }

ScalableMeshDraping::ScalableMeshDraping(IScalableMeshPtr scMesh) : m_mrDtmPtr(scMesh) {}

END_BENTLEY_SCALABLEMESH_NAMESPACE
