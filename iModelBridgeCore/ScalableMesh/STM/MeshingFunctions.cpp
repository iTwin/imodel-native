#include "ScalableMeshPCH.h"
#include <eigen\Eigen\Dense>
#include <PCLWrapper\IDefines.h>
#include <PCLWrapper\INormalCalculator.h>
#include "MeshingFunctions.h"

#pragma warning(disable: 4714) //thanks to Eigen: https://forum.kde.org/viewtopic.php?f=74&t=120746


//those are the parameters for the bunny dataset, change them for others
//todo: add some form of first-guess estimation for at least neighborRad and the number of cells, other parameters can stay constant for now.
double sphereRad = 100;  //1/10 to 1/4 neighborRad. Used for normal estimation if using radius search. Not used currently.
double neighborRad = 500; //radius for finding neighbors for sphere fit. If no neighbor within radius, grid cell will not produce triangles. Base value is for full-res, is adjusted for lower levels.
double sphereFactor = 0.33f; //0.1 to (about) 1.5. Is a factor used as multiplier to neighborRad for adjusting distance for weight function. Larger means more permissive.
int max_nn = 40; //max number of neighbors to use in fit, used to limit matrix size
int xcells = 25; //number of grid cells in the 3 dimensions, total number is xcells*ycells*zcells
int ycells = 25;
int zcells = 15;
int paramBeta = 1000; //weight of normal vs. positional constraints. Should be between 100 and 100000. 
double rad = neighborRad;

void computeGridDistancesAPSS(std::vector<float>* distances, std::vector<DPoint3d>* points, std::vector<DVec3d>* normals, Eigen::Vector3f bb_min, Eigen::Vector3f bb_max, size_t level, size_t depth)
    {
    //set radius parameter according to current octree level and depth
    neighborRad = (bb_max - bb_min).norm() / 4;
    sphereRad = neighborRad / 5;
    rad = neighborRad;
    float cellRatio = 1.0;
    if (points->size() < 5000) cellRatio = 0.5;
    if (points->size() < 500) cellRatio = 0.25;
    if (points->size() < 50) cellRatio = 0.125;
    xcells = 20; //number of grid cells in the 3 dimensions, total number is xcells*ycells*zcells
    ycells = 20;
    zcells = 10;
    xcells = ceil(xcells*cellRatio);
    ycells = ceil(ycells*cellRatio);
    zcells = ceil(zcells*cellRatio);
    for (size_t i = level; i < depth; i++) rad *= 8;
    distances->resize((xcells + 1)*(ycells + 1)*(zcells + 1));
    void* handle = nullptr;
    Bentley::PCLUtility::INormalCalculator::InitKdTree(&handle,&((*points)[0]), points->size());
#pragma omp parallel for num_threads(6)
    for (int x = 0; x <= xcells; x++)
        {
        for (int y = 0; y <= ycells; y++)
            {

            for (int z = 0; z <= zcells; z++)
                {
                Eigen::Vector3f point(
                    bb_min[0] - sphereRad + (bb_max[0] + sphereRad - (bb_min[0] - sphereRad)) * x / xcells,
                    bb_min[1] - sphereRad + (bb_max[1] + sphereRad - (bb_min[1] - sphereRad)) * y / ycells,
                    bb_min[2] - sphereRad + (bb_max[2] + sphereRad - (bb_min[2] - sphereRad)) * z / zcells);
                //float density = points->size() / (bb_max - bb_min).norm();
                int * indicesArr = new int[max_nn];
                size_t size = 0;
                std::vector<int> indices;
                //std::vector<float> distances;
                //tree->radiusSearch(PointXYZ(point[0], point[1], point[2]), neighborRad, indices, distances, max_nn);
                Bentley::PCLUtility::INormalCalculator::RadiusSearch(indicesArr, &size, handle, point, rad, max_nn);
                if (size == 0) continue;
                indices.resize(size);
                memcpy(&indices[0], indicesArr, size);
                delete[] indicesArr;
                Eigen::DiagonalMatrix<float, Eigen::Dynamic> W(indices.size() * 4); //nxn weight matrix
                Eigen::MatrixXf D(indices.size() * 4, 5);
                Eigen::MatrixXf b(indices.size() * 4, 1);
                if (indices.size() > 0 && computeWeightMatrixAndNormalConstraints(b, D, W, points, &indices, point, normals))
                    {
                    (*distances)[x*(ycells + 1)*(zcells + 1) + y*(zcells + 1) + z] = isosurfaceAtPointWithNormals(b, D, W, point);
                    }
                else
                    {
                    //return NaN to prevent extrapolation when too far out of region of influence of all points
                    (*distances)[x*(ycells + 1)*(zcells + 1) + y*(zcells + 1) + z] = std::numeric_limits<float>::quiet_NaN();
                    }
                }
            }
        }
    Bentley::PCLUtility::INormalCalculator::ReleaseKdTree(handle);
    }

/**
Finds the surface scalar field value at point test_point for the sphere generated by point test_point.
*/
float isosurfaceAtPointWithNormals(Eigen::MatrixXf& b, Eigen::MatrixXf& D, Eigen::DiagonalMatrix<float, Eigen::Dynamic>& W, Eigen::Vector3f& test_point)
    {
    Eigen::Matrix<float, 5, 5> A; //covariance matrix
    Eigen::Matrix<float, 5, 1> b2;
    Eigen::MatrixXf X = D.transpose()*W;
    A = X*D;
    b2 = X*b;
    Eigen::Matrix<float, 5, 1> u = A.inverse()*b2;
    Eigen::Matrix<float, 1, 5> x;
    x << 1, test_point.x(), test_point.y(), test_point.z(), test_point.transpose()*test_point;
    double Su = x*u;
    return Su;
    }

float phi(float distance)
    {
    if (distance < 0.99) return pow(1 - pow(distance, 2), 4);
    else return 0;
    }

int computeWeightMatrixAndNormalConstraints(Eigen::MatrixXf& b, Eigen::MatrixXf& D, Eigen::DiagonalMatrix<float, Eigen::Dynamic>& W, std::vector<DPoint3d>* cloud, std::vector<int>* samples, Eigen::Vector3f& test_point, std::vector<DVec3d>* computed_normals)
    {
    Eigen::Vector4f norm;
    //float curvature;

    for (int i = 0; i < samples->size(); i++)
        {
        DPoint3d point = (*cloud)[samples->at(i)];
        DVec3d n = (*computed_normals)[samples->at(i)];
        Eigen::Vector3f normal = Eigen::Vector3f(n.x, n.y, n.z);
        Eigen::Vector3f vec_pt = Eigen::Vector3f(point.x, point.y, point.z);
        Eigen::Vector3f basis[3] = { Eigen::Vector3f(1, 0, 0), Eigen::Vector3f(0, 1, 0), Eigen::Vector3f(0, 0, 1) };
        //weight
        W.diagonal()[4 * i] = phi((vec_pt - test_point).norm() / (rad*sphereFactor));
        W.diagonal()[4 * i + 1] = W.diagonal()[4 * i] * paramBeta;
        W.diagonal()[4 * i + 2] = W.diagonal()[4 * i] * paramBeta;
        W.diagonal()[4 * i + 3] = W.diagonal()[4 * i] * paramBeta;
        //positional and derivative constraints
        D.row(4 * i) << 1, point.x, point.y, point.z, vec_pt.transpose()*vec_pt;
        D.row(4 * i + 1) << 0, basis[0][0], basis[0][1], basis[0][2], 2 * basis[0].transpose()*vec_pt;
        D.row(4 * i + 2) << 0, basis[1][0], basis[1][1], basis[1][2], 2 * basis[1].transpose() * vec_pt;
        D.row(4 * i + 3) << 0, basis[2][0], basis[2][1], basis[2][2], 2 * basis[2].transpose() * vec_pt;
        //normals
        b(4 * i, 0) = 0;
        b(4 * i + 1, 0) = basis[0].transpose()*normal;
        b(4 * i + 2, 0) = basis[1].transpose()*normal;
        b(4 * i + 3, 0) = basis[2].transpose()*normal;
        }
    return (int)samples->size();
    }

void marchingTetrahedra(std::vector<float>* vertex_triangles, std::vector<float>* distances_grid, const Eigen::Vector3f& bb_min, const Eigen::Vector3f& bb_max)
    {
//    int len = (xcells + 1)*(ycells + 1)*(zcells + 1);
    int n_triangles = 0;
//#pragma omp parallel for num_threads(6)
    for (int x = 0; x <= xcells - 1; x++)
        {
        for (int y = 0; y <= ycells - 1; y++)
            {
            for (int z = 0; z <= zcells - 1; z++)
                {
                Eigen::Vector3f p000(
                    bb_min[0] - sphereRad + (bb_max[0] + sphereRad - (bb_min[0] - sphereRad)) * x / xcells,
                    bb_min[1] - sphereRad + (bb_max[1] + sphereRad - (bb_min[1] - sphereRad)) * y / ycells,
                    bb_min[2] - sphereRad + (bb_max[2] + sphereRad - (bb_min[2] - sphereRad)) * z / zcells);
                Eigen::Vector3f p111(
                    bb_min[0] - sphereRad + (bb_max[0] + sphereRad - (bb_min[0] - sphereRad))* (x + 1) / xcells,
                    bb_min[1] - sphereRad + (bb_max[1] + sphereRad - (bb_min[1] - sphereRad)) * (y + 1) / ycells,
                    bb_min[2] - sphereRad + (bb_max[2] + sphereRad - (bb_min[2] - sphereRad))  * (z + 1) / zcells);
                Eigen::Vector3f p001(p000.x(), p000.y(), p111.z());
                Eigen::Vector3f p010(p000.x(), p111.y(), p000.z());
                Eigen::Vector3f p011(p000.x(), p111.y(), p111.z());
                Eigen::Vector3f p100(p111.x(), p000.y(), p000.z());
                Eigen::Vector3f p101(p111.x(), p000.y(), p001.z());
                Eigen::Vector3f p110(p111.x(), p111.y(), p000.z());
                Eigen::Vector3i indices[8] = { Eigen::Vector3i(x, y, z), Eigen::Vector3i(x, y, z + 1), Eigen::Vector3i(x, y + 1, z), Eigen::Vector3i(x, y + 1, z + 1),
                    Eigen::Vector3i(x + 1, y, z), Eigen::Vector3i(x + 1, y, z + 1),
                    Eigen::Vector3i(x + 1, y + 1, z), Eigen::Vector3i(x + 1, y + 1, z + 1) };

                //generate triangles for cell
                n_triangles += generate_triangles_tetrahedra(vertex_triangles, distances_grid, p000, p001, p010, p110, indices[0], indices[1], indices[2], indices[6]);
                n_triangles += generate_triangles_tetrahedra(vertex_triangles, distances_grid, p000, p001, p100, p110, indices[0], indices[1], indices[4], indices[6]);
                n_triangles += generate_triangles_tetrahedra(vertex_triangles, distances_grid, p001, p100, p101, p110, indices[1], indices[4], indices[5], indices[6]);
                n_triangles += generate_triangles_tetrahedra(vertex_triangles, distances_grid, p001, p110, p101, p111, indices[1], indices[6], indices[5], indices[7]);
                n_triangles += generate_triangles_tetrahedra(vertex_triangles, distances_grid, p001, p011, p110, p111, indices[1], indices[3], indices[6], indices[7]);
                n_triangles += generate_triangles_tetrahedra(vertex_triangles, distances_grid, p001, p010, p011, p110, indices[1], indices[2], indices[3], indices[6]);
                }
            }
        }
    }

Eigen::Vector3f interpolate(const Eigen::Vector3f& p0, const Eigen::Vector3f& p1, float val0, float val1)
    {
    if (fabs(val0) < 0.0001 && fabs(val0) < fabs(val1)) return p0;
    else if (fabs(val1) < 0.0001 && fabs(val0) >= fabs(val1)) return p1;
    float coefficient = -val0 / (val1 - val0);
    return Eigen::Vector3f(p0.x() + coefficient*(p1.x() - p0.x()),
                           p0.y() + coefficient*(p1.y() - p0.y()),
                           p0.z() + coefficient*(p1.z() - p0.z()));
    }

inline void create_triangle(float* tri, const Eigen::Vector3f& v0, const Eigen::Vector3f& v1, const Eigen::Vector3f& v2)
    {
    tri[0] = v0.x();
    tri[1] = v0.y();
    tri[2] = v0.z();
    tri[3] = v1.x();
    tri[4] = v1.y();
    tri[5] = v1.z();
    tri[6] = v2.x();
    tri[7] = v2.y();
    tri[8] = v2.z();
    }

int generate_triangles_tetrahedra(std::vector<float>* vertex_triangles, std::vector<float>* distances_grid,  //grid
                                  const Eigen::Vector3f& v0, const Eigen::Vector3f& v1, const Eigen::Vector3f& v2, const Eigen::Vector3f& v3, //coords
                                  const Eigen::Vector3i& i0, const Eigen::Vector3i& i1, const Eigen::Vector3i& i2, const Eigen::Vector3i& i3) //indices
    {

    /*
    Determine which of the 16 cases we have given which vertices
    are above or below the isosurface
    */
    int triindex = 0;
    int n_triangles = 0;
    float val0 = (*distances_grid)[i0.x()*(ycells + 1)*(zcells + 1) + i0.y()*(zcells + 1) + i0.z()],
        val1 = (*distances_grid)[i1.x()*(ycells + 1)*(zcells + 1) + i1.y()*(zcells + 1) + i1.z()],
        val2 = (*distances_grid)[i2.x()*(ycells + 1)*(zcells + 1) + i2.y()*(zcells + 1) + i2.z()],
        val3 = (*distances_grid)[i3.x()*(ycells + 1)*(zcells + 1) + i3.y()*(zcells + 1) + i3.z()];
    if (val0 < 0) triindex |= 1;
    if (val1 < 0) triindex |= 2;
    if (val2 < 0) triindex |= 4;
    if (val3 < 0) triindex |= 8;
    float tri[9] = { 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    if (std::isnan(val0) || std::isnan(val1) || std::isnan(val2) || std::isnan(val3))
        {
        //    cout << "NaN found, no triangles produced for tetrahedron" << endl;
        return 0;
        }
    Eigen::Vector3f point1, point2;
  //  if (triindex != 0) push_tetrahedron(tet, v0, v1, v2, v3);
    /* Form the vertices of the triangles for each case */
    switch (triindex)
        {
        case 0x00: //all positive (above surface)
        case 0x0F: //all negative (below surface)
            break;
        case 0x0E: //all corners below surface, corner 0 above
        case 0x01: //corner 0 below surface, all others above
            //triangle is created between corner 0 and the face formed by 1,2,3. 
            create_triangle(tri, interpolate(v0, v1, val0, val1), interpolate(v0, v2, val0, val2), interpolate(v0, v3, val0, val3));
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            n_triangles = 1;
            break;
        case 0x0D: //all corners below surface, corner 1 above
        case 0x02://corner 1 below surface, all others above
            //triangle is created between corner 1 and the face formed by 0,2,3.
            create_triangle(tri, interpolate(v1, v0, val1, val0), interpolate(v1, v3, val1, val3), interpolate(v1, v2, val1, val2));
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            n_triangles = 1;
            break;
        case 0x0C:
        case 0x03:
            //intersection is a quad: between corners 0-1 and 2-3. 
            point1 = interpolate(v0, v2, val0, val2);
            point2 = interpolate(v1, v3, val1, val3);
            create_triangle(tri, interpolate(v0, v3, val0, val3), point1, point2);
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            create_triangle(tri, point2, interpolate(v1, v2, val1, val2), point1);
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            n_triangles = 2;
            break;
        case 0x0B:
        case 0x04:
            create_triangle(tri, interpolate(v2, v0, val2, val0), interpolate(v2, v1, val2, val1), interpolate(v2, v3, val2, val3));
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            n_triangles = 1;
            break;
        case 0x0A:
        case 0x05:
            point1 = interpolate(v0, v1, val0, val1);
            point2 = interpolate(v2, v3, val2, val3);
            create_triangle(tri, point1, point2, interpolate(v0, v3, val0, val3));
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            create_triangle(tri, point1, interpolate(v1, v2, val1, val2), point2);
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            n_triangles = 2;
            break;
        case 0x09:
        case 0x06:
            point1 = interpolate(v0, v1, val0, val1);
            point2 = interpolate(v2, v3, val2, val3);
            create_triangle(tri, point1, interpolate(v1, v3, val1, val3), point2);
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            create_triangle(tri, point1, interpolate(v0, v2, val0, val2), point2);
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            n_triangles = 2;
            break;
        case 0x07:
        case 0x08:
            create_triangle(tri, interpolate(v3, v0, val3, val0), interpolate(v3, v2, val3, val2), interpolate(v3, v1, val3, val1));
            for (int i = 0; i < 9; i++) vertex_triangles->push_back(tri[i]);
            n_triangles = 1;
            break;
        }
    return n_triangles;
    }