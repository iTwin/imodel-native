/*--------------------------------------------------------------------------------------+
|
|   Code partially derived from Michael Garland's demo application called "QSlim"
|   (version 1.0) which intends to demonstrate an algorithm of mesh simplification based
|   on Garland and Heckbert(1997) "Surface Simplification Using Quadric Error Metrics".
|   The code of the demo is said to be in the public domain.
|   See: http://www.cs.cmu.edu/afs/cs/Web/People/garland/quadrics/qslim10.html
|
|   $Revision: 1.0 $
|       $Date: 2014/09/17 $
|     $Author: Christian.Cote $
|
+--------------------------------------------------------------------------------------*/

#include <ScalableMeshPCH.h>
#include "GarlandMeshFilter.h"


GarlandMeshFilter::GarlandMeshFilter()
{
    m_model = new Model();
    m_heap = new Heap();
    InitSettings();
}

GarlandMeshFilter::~GarlandMeshFilter()
{
    delete m_model;
    delete m_heap;

    auto infoIter(m_pairInfoVector.begin());
    auto infoIterEnd(m_pairInfoVector.end());

    while (infoIter != infoIterEnd)
    {
        delete *infoIter;
        infoIter++;
    }
}

/*---------------------------------------------------------------------------------**//**
*   Initializes the parameters with predefined values.
+---------------+---------------+---------------+---------------+---------------+------*/
void GarlandMeshFilter::InitSettings()
{
    m_verticeNumberTarget = 0;
    
    m_errorTolerance = HUGE;
    m_usePlaneConstraint = true;
    m_useVertexConstraint = false;
    m_preserveBoundaries = false;
    m_preserveMeshQuality = false;
    m_constrainBoundaries = false;
    m_boundaryConstraintWeight = DEFAULT_BOUNDARY_CONSTRAINT_WEIGHT;
    m_weightByArea = false;
    m_placementPolicy = PLACE_OPTIMAL;
    m_pairSelectionTolerance = 0.0;
    m_constraintQuadricType = PLANE_CONSTRAINT;
}

/*---------------------------------------------------------------------------------**//**
*   Sets parameters, build the adjacency model and then remove degenerated faces
*   and unused vertices.
+---------------+---------------+---------------+---------------+---------------+------*/
void GarlandMeshFilter::EdgeCollapseInit(int verticeNumberTarget)
{
    m_verticeNumberTarget = verticeNumberTarget;

    // The default value for the boundary constraint weight is 1.0 (means no constraint).
    SetBoundaryConstraint(100.0); 

    SetConstraintQuadricType(PLANE_CONSTRAINT);

    // HUGE means the error is not considered.
    m_errorTolerance = HUGE; 

    m_pairSelectionTolerance = 0.0;
    m_preserveMeshQuality = false;
    m_weightByArea = false;
    m_placementPolicy = PLACE_OPTIMAL;
}

void GarlandMeshFilter::AddPointToAdjacencyModel(double x, double y, double z)
{
    m_model->AddVertice(x, y, z);
}

void GarlandMeshFilter::AddFaceToAdjacencyModel(Int32 indexA, Int32 indexB, Int32 indexC)
{
    m_model->AddFace(indexA, indexB, indexC);
}

void GarlandMeshFilter::SetConstraintQuadricType(ConstraintQuadricType constraintQuadricType)
{
    if (constraintQuadricType == PLANE_CONSTRAINT)
    {
        m_usePlaneConstraint = true;
    }
    else if (constraintQuadricType == VERTEX_CONSTRAINT)
    {
        m_useVertexConstraint = true;
    }
}

void GarlandMeshFilter::SetBoundaryConstraint(real_Garland boundaryConstraintWeight)
{
    if (boundaryConstraintWeight > DEFAULT_BOUNDARY_CONSTRAINT_WEIGHT)
    {
        m_constrainBoundaries = true;
        m_boundaryConstraintWeight = boundaryConstraintWeight;  
    }
}

void GarlandMeshFilter::GetRemainingPoints(vector<DPoint3d>& points)
{
    return m_model->GetRemainingPoints(points);
}

void GarlandMeshFilter::GetRemainingFaceIndexes(vector<Int32>& faceIndexes)
{
    return m_model->GetRemainingFaceIndexes(faceIndexes);
}

// To be used once the model has been built with adding vertices and faces.
// Initialization before the cleanup in the function CleanUpAdjacencyModel().
void GarlandMeshFilter::UpdateFaceAndVerticeCount()
{
    m_model->validVertCount = m_model->InitialVerticeCount();
    m_model->validEdgeCount = m_model->InitialEdgeCount();
    m_model->validFaceCount = m_model->InitialFaceCount();
}

void GarlandMeshFilter::CleanUpAdjacencyModel()
{
    // Get rid of degenerate faces
    //-----------------------------------------------
    for (int i = 0; i < m_model->InitialFaceCount(); i++)  
    {
        if (!m_model->GetFace(i)->Plane().IsValid())
        {
            m_model->KillFace(m_model->GetFace(i));
        }
    }
    m_model->RemoveDegeneracy(m_model->AllFaces());

    // Get rid of unused vertices
    //-----------------------------------------------
    for (int i = 0; i<m_model->InitialVerticeCount(); i++)
    {
        if (m_model->GetVertex(i)->EdgeUses().length() == 0)
            m_model->GetVertex(i)->Kill();
    }
}

int GarlandMeshFilter::GetValidFaceCount()
{
    return m_model->validFaceCount;
}

int GarlandMeshFilter::GetValidVertexCount()
{
    return m_model->validVertCount;
}

int GarlandMeshFilter::GetInitialFaceCount()
{
    return m_model->InitialFaceCount();
}

int GarlandMeshFilter::GetInitialVertexCount()
{
    return m_model->InitialVerticeCount();
}

/*---------------------------------------------------------------------------------**//**
*   1- Distributes the constaints and build the heap.
*   2- Performs edge contraction until reaching the expected number of faces or 
*      max error.
*   3- Returns the information defining the new simplified mesh.
+---------------+---------------+---------------+---------------+---------------+------*/
void GarlandMeshFilter::EdgeCollapseRun()
{     
    InitializeHeap();
    bool availablePairsInHeap = true;

    while ( m_model->validVertCount > m_verticeNumberTarget &&
            EvalDecimateMinError() < m_errorTolerance &&
            availablePairsInHeap)
    {
        availablePairsInHeap = DecimateContract();
    }
}

/*---------------------------------------------------------------------------------**//**
*   The remaining code was initially found in the file called "Decimate.cpp".
+---------------+---------------+---------------+---------------+---------------+------*/


/*---------------------------------------------------------------------------------**//**
*   Low-level routines for manipulating pairs.
+---------------+---------------+---------------+---------------+---------------+------*/
vert_info& GarlandMeshFilter::GetVertexInfo(Vertex *v)
{
    return m_verticeInfoArray(v->ValidID());
}

bool GarlandMeshFilter::CheckForPair(Vertex *v0, Vertex *v1)
{
    const pair_buffer& pairs = GetVertexInfo(v0).pairs;

    for (int i = 0; i<pairs.length(); i++)
    {
        if (pairs(i)->v0 == v1 || pairs(i)->v1 == v1)
        {
            return true;
        }
    }
    return false;
}

pair_info* GarlandMeshFilter::CreateNewPair(Vertex *v0, Vertex *v1)
{    
    vert_info& v0_info = GetVertexInfo(v0);
    vert_info& v1_info = GetVertexInfo(v1);

    pair_info *pair = new pair_info(v0, v1);

    m_pairInfoVector.push_back(pair);

    v0_info.pairs.add(pair);
    v1_info.pairs.add(pair);

    return pair;
}

void GarlandMeshFilter::DeletePair(pair_info *pair)
{
    vert_info& v0_info = GetVertexInfo(pair->v0);
    vert_info& v1_info = GetVertexInfo(pair->v1);

    v0_info.pairs.remove(v0_info.pairs.find(pair));
    v1_info.pairs.remove(v1_info.pairs.find(pair));

    if (pair->isInHeap())
        m_heap->kill(pair->getHeapPos());
 
}

/*---------------------------------------------------------------------------------**//**
*   Decimation process including:
*        - PairIsValid
*        - ComputePairInfoAndUpdateHeap
*        - DoContract
+---------------+---------------+---------------+---------------+---------------+------*/
bool GarlandMeshFilter::PairIsValid(Vertex *u, Vertex *v)
{
    return norm2(*u - *v) < m_proximityLimit;
}

int GarlandMeshFilter::PredictFace(Face& F, Vertex *v1, Vertex *v2, Vec3& vnew, Vec3& f1, Vec3& f2, Vec3& f3)
{
    int nmapped = 0;

    if (F.GetVertex(0) == v1 || F.GetVertex(0) == v2)
    {
        f1 = vnew;  nmapped++;
    }
    else f1 = *F.GetVertex(0);

    if (F.GetVertex(1) == v1 || F.GetVertex(1) == v2)
    {
        f2 = vnew;  nmapped++;
    }
    else f2 = *F.GetVertex(1);

    if (F.GetVertex(2) == v1 || F.GetVertex(2) == v2)
    {
        f3 = vnew;  nmapped++;
    }
    else f3 = *F.GetVertex(2);

    return nmapped;
}

real_Garland GarlandMeshFilter::PairMeshPenalty(Vertex* v1, Vertex* v2, Vec3& vnew)
{
    static face_buffer changed;
    changed.reset();

    m_model->ContractionRegion(v1, v2, changed);

    // real_Garland Nsum = 0;
    real_Garland Nmin = 0;

    for (int i = 0; i<changed.length(); i++)
    {
        Face& F = *changed(i);
        Vec3 f1, f2, f3;

        int nmapped = PredictFace(F, v1, v2, vnew, f1, f2, f3);

        // Only consider non-degenerate faces
        if (nmapped < 2)
        {
            Plane Pnew(f1, f2, f3);
            real_Garland delta = Pnew.Normal() * F.Plane().Normal();

            if (Nmin > delta) Nmin = delta;
        }
    }
    //return (-Nmin) * MESH_INVERSION_PENALTY;
    if (Nmin < 0.0)
        return MESH_INVERSION_PENALTY;
    else
        return 0.0;
}

void GarlandMeshFilter::ComputePairInfoAndUpdateHeap(pair_info *pair)
{
    Vertex *v0 = pair->v0;
    Vertex *v1 = pair->v1;

    vert_info& v0_info = GetVertexInfo(v0);
    vert_info& v1_info = GetVertexInfo(v1);

    Mat4 Q = v0_info.Q + v1_info.Q;
    real_Garland norm = v0_info.norm + v1_info.norm;

    pair->cost = Quadrix_PairTarget(Q, v0, v1, pair->candidate, m_placementPolicy, m_preserveBoundaries);

    if (m_weightByArea)
        pair->cost /= norm;

    if (m_preserveMeshQuality)
        pair->cost += PairMeshPenalty(v0, v1, pair->candidate);

    // NOTICE:  In the heap we use the negative cost.  That's because
    //          the heap is implemented as a MAX heap.
    if (pair->isInHeap())
    {
        m_heap->update(pair, (float)-pair->cost);
    }
    else
    {
        m_heap->insert(pair, (float)-pair->cost);
    }
}

void GarlandMeshFilter::DoContract(pair_info *pair)
{
    Vertex *v0 = pair->v0;  Vertex *v1 = pair->v1;
    vert_info& v0_info = GetVertexInfo(v0);
    vert_info& v1_info = GetVertexInfo(v1);
    Vec3 vnew = pair->candidate;
    int i;

    // Makes v0 be the new vertex
    v0_info.Q += v1_info.Q;
    v0_info.norm += v1_info.norm;

    // Performs the actual contraction
    static face_buffer changed;
    changed.reset();
    m_model->Contract(v0, v1, vnew, changed);

    // Removes the pair that we just contracted
    DeletePair(pair);

    // Recalculates pairs associated with v0
    for (i = 0; i<v0_info.pairs.length(); i++)
    {
        pair_info *p = v0_info.pairs(i);
        ComputePairInfoAndUpdateHeap(p);
    }

    // Process pairs associated with now dead vertex

    static pair_buffer condemned(6); // collect condemned pairs for execution
    condemned.reset();

    for (i = 0; i<v1_info.pairs.length(); i++)
    {
        pair_info *p = v1_info.pairs(i);

        Vertex *u;
        if (p->v0 == v1)
        {
            u = p->v1;
        }
        else if (p->v1 == v1)
        {
            u = p->v0;
        }
        else
        {
            throw "Decimate.DoContract: Bogus pair.\n";
        }

        if (!CheckForPair(u, v0))
        {
            p->v0 = v0;
            p->v1 = u;
            v0_info.pairs.add(p);
            ComputePairInfoAndUpdateHeap(p);
        }
        else
            condemned.add(p);
    }

    for (i = 0; i < condemned.length(); i++)
    {
        DeletePair(condemned(i));
    }        
    v1_info.pairs.reset(); // safety precaution
}

/*---------------------------------------------------------------------------------**//**
*   External interface: setup and single step iteration.
+---------------+---------------+---------------+---------------+---------------+------*/

bool GarlandMeshFilter::EvalDecimateQuadric(Vertex *v, Mat4& Q)
{
    if (m_verticeInfoArray.length() > 0)
    {
        Q = m_verticeInfoArray(v->uniqID).Q;
        return true;
    }
    else
        return false;
}

bool GarlandMeshFilter::DecimateContract()
{
    heap_node *top;
    pair_info *pair;

    top = m_heap->extract();
    if (!top) return false;
    pair = (pair_info *)top->obj;

    while (!pair->isValid())
    {
        DeletePair(pair);
        top = m_heap->extract();
        if (!top) return false;
        pair = (pair_info *)top->obj;
    }

    DoContract(pair);
    m_model->validVertCount--; 
    return true;
}

real_Garland GarlandMeshFilter::EvalDecimateError(Vertex *v)
{
    vert_info& info = GetVertexInfo(v);

    real_Garland err = Quadrix_EvaluateVertex(*v, info.Q);

    if (m_weightByArea)
        err /= info.norm;

    return err;
}

real_Garland GarlandMeshFilter::EvalDecimateMinError()
{
    heap_node *top;
    pair_info *pair;

    for (;;)
    {
        top = m_heap->top();
        if (!top) return -1.0;
        pair = (pair_info *)top->obj;

        if (pair->isValid())
                break;

        top = m_heap->extract();
        DeletePair(pair);
    }

    return pair->cost;
}

real_Garland GarlandMeshFilter::EvalDecimateMaxError()
{
    real_Garland max_err = 0;

    for (int i = 0; i<m_model->InitialVerticeCount(); i++)
        if (m_model->GetVertex(i)->IsValid())
        {
        max_err = MAX_Garland(max_err, EvalDecimateError(m_model->GetVertex(i)));
        }

    return max_err;
}

// Creates the heap and initializes attributes 
// used to order the vertex in the heap.
// m_pairSelectionTolerance has to be set at this point.
void GarlandMeshFilter::InitializeHeap()
{
    int i, j;
    m_verticeInfoArray.init(m_model->InitialVerticeCount());

    // Distributing shape constraints.
    if (m_useVertexConstraint)
        for (i = 0; i<m_model->InitialVerticeCount(); i++)
        {
        Vertex *v = m_model->GetVertex(i);
                if (v->IsValid())
                        GetVertexInfo(v).Q = Quadrix_GetVertexConstraint(*v);
        }

    for (i = 0; i<m_model->InitialFaceCount(); i++)
        if (m_model->GetFace(i)->IsValid())
        {
            if (m_usePlaneConstraint)
            {
                Mat4 Q = Quadrix_GetPlaneConstraint(*m_model->GetFace(i));
                real_Garland norm = 0.0;

                if (m_weightByArea)
                {
                    norm = m_model->GetFace(i)->Area();
                    Q *= norm;
                }
                for (j = 0; j<3; j++)
                {
                    GetVertexInfo(m_model->GetFace(i)->GetVertex(j)).Q += Q;
                    GetVertexInfo(m_model->GetFace(i)->GetVertex(j)).norm += norm;
                }
            }
        }

    if (m_constrainBoundaries)
    {
        // Accumulates discontinuity constraints.
        for (i = 0; i<m_model->InitialEdgeCount(); i++)
            if (m_model->GetEdge(i)->IsValid() && Quadrix_CheckForDiscontinuity(m_model->GetEdge(i)))
            {
                Mat4 B = Quadrix_GetDiscontinuityConstraint(m_model->GetEdge(i));
                real_Garland norm = 0.0;

                if (m_weightByArea)
                {
                    norm = norm2(*m_model->GetEdge(i)->Org() - *m_model->GetEdge(i)->Dest());
                    B *= norm;
                }
                B *= m_boundaryConstraintWeight;
                GetVertexInfo(m_model->GetEdge(i)->Org()).Q += B;
                GetVertexInfo(m_model->GetEdge(i)->Org()).norm += norm;
                GetVertexInfo(m_model->GetEdge(i)->Dest()).Q += B;
                GetVertexInfo(m_model->GetEdge(i)->Dest()).norm += norm;
            }
    }

    // Sets the size of the heap.
    m_heap->resize(m_model->validEdgeCount);
    int pair_count = 0;

    // Collectes pairs [edges].
    for (i = 0; i<m_model->InitialEdgeCount(); i++)
        if (m_model->GetEdge(i)->IsValid())
        {
            pair_info *pair = CreateNewPair(m_model->GetEdge(i)->Org(), m_model->GetEdge(i)->Dest());
            ComputePairInfoAndUpdateHeap(pair);
            pair_count++;
        }

    if (m_pairSelectionTolerance<0)
    {
        // Auto-limit at 5% of model radius.
        m_pairSelectionTolerance = m_model->bounds.radius * 0.05;
    }
    m_proximityLimit = m_pairSelectionTolerance * m_pairSelectionTolerance;
    if (m_proximityLimit > 0)
    {
        // Collecting pairs based on the limit.
        ProximityGrid grid(m_model->bounds.minVec, m_model->bounds.maxVec, m_pairSelectionTolerance);
        for (i = 0; i<m_model->InitialVerticeCount(); i++)
            grid.AddPoint(m_model->GetVertex(i));

        buffer<Vec3 *> nearby(32);
        for (i = 0; i<m_model->InitialVerticeCount(); i++)
        {
            nearby.reset();
            grid.ProximalPoints(m_model->GetVertex(i), nearby);

            for (j = 0; j<nearby.length(); j++)
            {
                Vertex *v1 = m_model->GetVertex(i);
                Vertex *v2 = (Vertex *)nearby(j);

                if (v1->IsValid() && v2->IsValid())
                {
                    if (!CheckForPair(v1, v2))
                    {
                        pair_info *pair = CreateNewPair(v1, v2);
                        ComputePairInfoAndUpdateHeap(pair);
                        pair_count++;
                    }
                }
            }
        }
    }
    else
    {
            // Ignoring non-edge pairs [limit=0].
    }
    // Decimates: Designated "pair_count" pairs.
}

/*---------------------------------------------------------------------------------**//**
*   Save the current model as an obj file.
+---------------+---------------+---------------+---------------+---------------+------*/
void GarlandMeshFilter::OutputModelToFile(string outputFilepath)
{
    m_model->OutputToFile(outputFilepath);
}

/*---------------------------------------------------------------------------------**//**
*   Save a mesh passed as parameter to an obj file.
+---------------+---------------+---------------+---------------+---------------+------*/
void GarlandMeshFilter::OutputMeshToFile(string fileName,
                                         size_t nbVertices, const DPoint3d* vertices,
                                         size_t nbFaceIndexes, const Int32* faceIndexes)
{
    ofstream out;
    out.open(fileName);

    if (out)
    {
        out << "# OBJ file format with extension .obj" << endl;
        out << "# vertex count = " << nbVertices << endl;
        out << "# face count = " << nbFaceIndexes << endl;
    
        // Vertices
        for (size_t i = 0; i < nbVertices; i++)
        {
            out << "v " << vertices[i].x << " " << vertices[i].y << " " << vertices[i].z << endl;
        }

        // Faces
        for (size_t j = 0; j < nbFaceIndexes; j += 3)
        {
            if ((j + 2) <  nbFaceIndexes)
            {
                out << "f " << faceIndexes[j] << " " << faceIndexes[j+1] << " " << faceIndexes[j+2] << endl;
            }
        }

        out.close();
    }
}




