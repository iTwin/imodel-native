/*--------------------------------------------------------------------------------------+
|
|     $Source: DgnV8/ConvertViewAttachments.cpp $
|
|  $Copyright: (c) 2018 Bentley Systems, Incorporated. All rights reserved. $
|
+--------------------------------------------------------------------------------------*/
#include "ConverterInternal.h"
#include "SheetAttachmentViewHelper.h"
#include <Geom/DPoint3dOps.h>

// We enter this namespace in order to avoid having to qualify all of the types, such as bmap, that are common
// to bim and v8. The problem is that the V8 Bentley namespace is shifted in.
BEGIN_DGNDBSYNC_DGNV8_NAMESPACE

/*=================================================================================**//**
* @bsiclass
+===============+===============+===============+===============+===============+======*/
struct AttachedDrawingGenerator : Converter::ProxyGraphicsDrawingFactory
    {
    Converter& m_sheetConverter;
    ResolvedModelMapping const& m_sheetModelMapping;
    bmap<DgnV8Api::ElementId, ResolvedModelMappingWithElement> m_drawingsForAttachments;

    ResolvedModelMappingWithElement _CreateAndInsertDrawing(DgnAttachmentCR, ResolvedModelMapping const&, Converter&) override;
    ResolvedModelMapping _GetDrawing(DgnV8Api::ElementId v8AttachmentId, ResolvedModelMapping const& parentModel, Converter& converter) override;

    AttachedDrawingGenerator(Converter& sc, ResolvedModelMapping const& smm) : m_sheetConverter(sc), m_sheetModelMapping(smm) {}
    };

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      11/16
+---------------+---------------+---------------+---------------+---------------+------*/
bool Converter::DrawingHas3DAttachment(DgnV8ModelR drawingModel)
    {
    if (drawingModel.Is3D()) // Only (generated) drawings
        return nullptr;

    auto v8Attachments = GetAttachments(drawingModel);
    if (nullptr == v8Attachments)
        return nullptr;

    DgnV8Api::DgnAttachment const* nvAttachment = nullptr;
    for (auto v8Attachment : *v8Attachments)
        {
        if (v8Attachment->Is3d())
            return true;
        }
    return false;
    }


/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      11/16
+---------------+---------------+---------------+---------------+---------------+------*/
BentleyStatus Converter::GetRangeFromSectionView(DRange3dR range, DgnAttachmentCR v8Attachment, ResolvedModelMapping const& sheetModelMapping, bool isSheetProxyGraphics)
    {
    //  The caller is generating a view of a BIM DrawingModel that is to be attached to a sheet and wants to know the origin and extents that the view should have.
    //  This function is focused on one special case: the BIM DrawingModel was generated by a section-like named view.
    //  In that case, the most accurate way to compute the range of the DrawingModel's generated graphics is to use the range of the section-like named view,
    //  suitably transformed to the BIM SHEET'S coordinates.
    //  Note that, because of UnnestAttachments, we know that every section-cut attachment is a direct attachment to the sheet. So, its proxygraphics are always in the CS of the sheet.
    if (!v8Attachment.GetDgnModelP()->Is3d())
        return BSIERROR;

    BeAssert(v8Attachment.GetDgnModelP()->Is3d() && "UnnestAttachments must guarantee that all section-cut attachments are directly attached to the sheet");
    BeAssert(isSheetProxyGraphics);

    // Use the drawing manager's range calculation. This is what uStn uses to attach views of section cuts.
    Bentley::DPoint3d drawCompOrg;
    Bentley::DPoint3d drawCompSize;
    Bentley::RotMatrix drawCompRmatrix = Bentley::RotMatrix::FromIdentity(); // *** NEEDS WORK: what rotation matrix is it expecting?
    DgnV8Api::DrawingManager::ComputeBoundaryFromAttachment(drawCompOrg, drawCompSize, drawCompRmatrix, v8Attachment);
    Bentley::DRange3d v8SectionRange;
    v8SectionRange.InitFrom(drawCompOrg);
    v8SectionRange.Extend(Bentley::DPoint3d::FromSumOf(drawCompOrg, drawCompSize));

    if (v8SectionRange.IsEmpty() || v8SectionRange.IsPoint() || v8SectionRange.IsAlmostZeroX() || v8SectionRange.IsAlmostZeroY())
        {
        // If something is wrong the drawingmanager's caculation, fall back on the old way of getting the range directly from the saved view.
        auto nv = v8Attachment.GetNamedView();
        if (!nv.IsValid())
            return BSIERROR;

        Bentley::DRange3d nvRange;
        if (Bentley::BSISUCCESS != nv->GetRange(nvRange))
            return BSIERROR;

        Bentley::Transform toV8Parent;
        Bentley::mdlRefFile_getTransformToParent(&toV8Parent, &v8Attachment, nullptr);
        //v8Attachment.GetTransformToParent(toV8Parent, true);
        toV8Parent.Multiply(&nvRange.low, 2);

        // TRICKY: The range of the section cut will be both 3D and flipped.
        //          That is, in order to put the forward graphics behind the drawing plane, the range will run from
        //          right to left in x. That looks like an empty range. To get around that, we get the box around the range
        //          and then extract the normal min/max range points from that.
        Bentley::DPoint3d nvBoxCorners[8];
        nvRange.Get8Corners(nvBoxCorners);
    
        v8SectionRange = Bentley::DRange3d::DRange3d::From(nvBoxCorners, 8);
        }

    // Get the view range into BIM Sheet:Model coordinates
    Transform toBim = sheetModelMapping.GetTransform();
    toBim.Multiply(range, (DRange3dR)v8SectionRange);

    return BSISUCCESS;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      11/16
+---------------+---------------+---------------+---------------+---------------+------*/
void Converter::AddV8ModelToRange(Bentley::DRange3dR range, DgnV8ModelR v8Model)
    {
    v8Model.FillSections(DgnV8Api::DgnModelSections::Model);
    DgnV8Api::PersistentElementRefList* graphicElements = v8Model.GetGraphicElementsP();
    if (nullptr == graphicElements)
        return;

    for (DgnV8Api::PersistentElementRef* v8Element : *graphicElements)
        {
        DgnV8Api::EditElementHandle v8eh(v8Element);
        Bentley::DRange3d eleRange;
        if ((nullptr != v8eh.GetDisplayHandler()) && (Bentley::BSISUCCESS == v8eh.GetDisplayHandler()->CalcElementRange(v8eh, eleRange, nullptr)))
            {
            range.Extend(eleRange.low);
            range.Extend(eleRange.high);
            }
        }
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      08/16
+---------------+---------------+---------------+---------------+---------------+------*/
ResolvedModelMappingWithElement Converter::SheetsCreateAndInsertDrawing(DgnAttachmentCR v8Attachment, ResolvedModelMapping const& parentModel)
    {
    // Create a BIM drawing model to put them in.
    auto drawing = CreateDrawing(nullptr, Utf8String(v8Attachment.GetLogicalName()).c_str());
    
    ResolvedModelMappingWithElement rmme;

    // NB: We must insert the drawing element now, so that we have an ElementId for the DrawingModel
    // Note that InsertConversionResults also inserts the new element mapping into syncinfo
    ElementConversionResults newDrawingElement;
    newDrawingElement.m_element = drawing;
    DgnV8Api::EditElementHandle v8eh(v8Attachment.GetElementId(), &parentModel.GetV8Model());
    InsertConversionResults(newDrawingElement, v8eh, parentModel);
    rmme.SetModeledElementMapping(newDrawingElement.m_mapping); 

    auto drawingModel = DrawingModel::Create(*drawing);
    drawingModel->Insert();

    // Map the PARENT model to this new drawing (since we are going to put the attachment's proxy graphics into the drawing).
    SyncInfo::V8ModelMapping smapping;
    auto refTrans = ComputeAttachmentTransform(parentModel.GetTransform(), v8Attachment);
    GetSyncInfo().InsertModel(smapping, drawingModel->GetModelId(), parentModel.GetV8Model(), refTrans);

    rmme.SetResolvedModelMapping(ResolvedModelMapping(*drawingModel, parentModel.GetV8Model(), smapping, &v8Attachment));

    return rmme;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      08/16
+---------------+---------------+---------------+---------------+---------------+------*/
ResolvedModelMappingWithElement AttachedDrawingGenerator::_CreateAndInsertDrawing(DgnAttachmentCR v8Attachment, 
                                                                                  ResolvedModelMapping const& parentModel, 
                                                                                    Converter& converter)
    {
    return m_drawingsForAttachments[v8Attachment.GetElementId()] = m_sheetConverter.SheetsCreateAndInsertDrawing(v8Attachment, parentModel);
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      08/16
+---------------+---------------+---------------+---------------+---------------+------*/
ResolvedModelMapping AttachedDrawingGenerator::_GetDrawing(DgnV8Api::ElementId v8AttachmentId, ResolvedModelMapping const& parentModel, Converter& converter)
    {
    return m_drawingsForAttachments[v8AttachmentId];
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      08/16
+---------------+---------------+---------------+---------------+---------------+------*/
Utf8String Converter::SheetsComputeViewAttachmentName(DgnAttachmentCR v8DgnAttachment) const
    {
    Utf8String name;
    name.Sprintf(".%x:%llx ", (unsigned int)v8DgnAttachment.GetParent().GetDgnModelP()->GetModelId(), 
                                  (uint64_t)v8DgnAttachment.GetElementId());
    name = name + Utf8String(v8DgnAttachment.GetParent().GetModelNameCP());
    name = name + " -- ";
    name = name + GetFileBaseName(*v8DgnAttachment.GetDgnModelP()->GetDgnFileP());
    name = name + " / ";
    name = name + Utf8String(v8DgnAttachment.GetDgnModelP()->GetModelName());
    name = name + " (view)";
    return name;
    /*
    Utf8PrintfString name(".%x:%llx %s", (unsigned int)v8DgnAttachment.GetParent().GetDgnModelP()->GetModelId(), 
                          (uint64_t)v8DgnAttachment.GetElementId(), 
                          _GetNamePrefix().c_str());
    name.append(Utf8String(v8DgnAttachment.GetParent().GetModelNameCP()).c_str());
    name.append(" / ");
    name.append(Utf8String(const_cast<DgnAttachmentR>(v8DgnAttachment).GetAttachName(false).c_str()).c_str());
    return name;
    */
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      08/16
+---------------+---------------+---------------+---------------+---------------+------*/
void Converter::SheetsCreateViewAttachment(ElementConversionResults& results, 
                                           ResolvedModelMapping const& v8SheetModelMapping, DgnAttachmentR v8DgnAttachment,
                                           DgnViewId attachedViewId, int updateSeq, bool isViewInSheetCoordinates)
    {
    auto const& v8SheetToBimSheet = v8SheetModelMapping.GetTransform();
    auto& sheetModel = *v8SheetModelMapping.GetDgnModel().ToSheetModelP();

    //  Compute the extents of the ViewAttachment
    Placement2d placement;
    auto& bbox = placement.GetElementBoxR();
    bbox.low.Zero();

    auto attachedView = ViewDefinition::Get(GetDgnDb(), attachedViewId);
    BeAssert(attachedView.IsValid());
    DVec3d viewExtents = attachedView->GetExtents();
    DPoint3d viewOrigin = attachedView->GetOrigin();

    if (isViewInSheetCoordinates)
        {
        // viewed model is in sheet coordinates already, so viewattachment is 1:1
        placement.GetOriginR() = DPoint2d::From(viewOrigin);
        bbox.high = DPoint2d::From(viewExtents);
        }
    else if (nullptr != v8DgnAttachment.GetDgnModelP())
        {
        ViewControllerPtr controller = attachedView->LoadViewController();
        if (!controller.IsValid())
            {
            BeDataAssert(false && "failed to load sheet attachment");
            ReportError(Converter::IssueCategory::Unknown(), Converter::Issue::ConvertFailure(), "CreateViewAttachment failed - target model of the attached view was not converted");
            return;
            }

        // Scaled view - THE SHAPE OF A SCALED VIEW ATTACHMENT MUST BE EXACTLY PROPORTIONAL TO THE TARGET VIEW DELTA.
        auto refModelMapping = FindFirstModelMappedTo(*v8DgnAttachment.GetDgnModelP());
        if (!refModelMapping.IsValid())
            {
            BeDataAssert(false && "failed to infer scaled range of sheet attachment");
            ReportError(Converter::IssueCategory::Unknown(), Converter::Issue::ConvertFailure(), "CreateViewAttachment failed - target model of the attached view was not converted");
            return;
            }

        //  Transform the range of the attached BIM view to the sheet using the V8 ref transform.
        //  That gives us the shape, the size, and the location of the attachment on the sheet. See note below on why that is so.
        Transform bimToV8Design;
        bimToV8Design.InverseOf(refModelMapping.GetTransform());

        Transform v8DesignToV8Sheet;
        Bentley::mdlRefFile_getTransformToParent((Bentley::Transform*) &v8DesignToV8Sheet , &v8DgnAttachment, nullptr);
        auto bimDesignToBimSheet = Transform::FromProduct(v8SheetToBimSheet, v8DesignToV8Sheet, bimToV8Design);

        RotMatrix rot = attachedView->GetRotation();
        DPoint3d orgView = viewOrigin;
        rot.Multiply(orgView);
        DPoint3d corner;
        corner.SumOf(orgView, viewExtents);
        rot.MultiplyTranspose(corner);

        bimDesignToBimSheet.Multiply(&viewOrigin, &viewOrigin, 1);
        bimDesignToBimSheet.Multiply(&corner, &corner, 1);

        placement.GetOriginR().x = viewOrigin.x;
        placement.GetOriginR().y = viewOrigin.y;

        bbox.high.x = corner.x - viewOrigin.x;
        bbox.high.y = corner.y - viewOrigin.y;
        }

    if (bbox.IsEmpty() || bbox.IsNull() || bbox.IsPoint())
        {
        //BeDataAssert(false && "failed to infer scaled range of sheet attachment");
        //ReportError(Converter::IssueCategory::Unknown(), Converter::Issue::ConvertFailure(), "CreateViewAttachment failed to infer scaled range of sheet attachment");
        // No sense in creating a view of an empty model
        return;
        }

    // Capture the scale of the drawing. Note that this is an absolute scale, not relative to the sheet. So, if the V8
    // attachment scale is 1.0, then the drawing's scale is equal to the sheet's scale.
    // Note that the scale factor on a V8 DgnAttachment is a small number (V8 uses this to scale the attached design down to the sheet).
    auto dscale = v8DgnAttachment.GetUserScaleFromRefToRoot(nullptr);
    if ((0 == BeNumerical::Compare(dscale, 1.0)) || (0 == BeNumerical::Compare(dscale, 0.0)))
        dscale = GetDgnDb().Elements().Get<Sheet::Element>(sheetModel.GetModeledElementId())->GetScale();
    else
        dscale = 1/dscale; // note: we capture and store the denominator of the scale -- that is, we want a big number.

    //  Convert the attachment's clip
    ClipVectorPtr clipVector;
    DgnV8Api::DgnAttachmentClips refClip;
    refClip.Init(v8DgnAttachment, nullptr, /*relativeToImmediateParent*/false);    // false means transform to "world" which in this context means the sheet

    if (refClip.HasClips() && refClip.HasViewletClips())
        clipVector = ConvertClip(refClip.CalculateClip(nullptr), &v8SheetModelMapping.GetTransform());

    DgnCategoryId attachmentCategoryId = GetOrCreateDrawingCategoryId(*GetJobDefinitionModel(), CATEGORY_NAME_Attachments);

    auto viewAttachment = new Sheet::ViewAttachment(GetDgnDb(), sheetModel.GetModelId(), attachedViewId, attachmentCategoryId, placement);
    viewAttachment->SetDisplayPriority(attachedView->IsSpatialView() ? updateSeq * 10 : 0);
    viewAttachment->SetScale(dscale);
    if (clipVector.IsValid())
        viewAttachment->SetClip(*clipVector);

    results.m_element = viewAttachment;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      08/16
+---------------+---------------+---------------+---------------+---------------+------*/
ResolvedModelMapping Converter::SheetsFindModelForAttachment(DgnAttachmentCR v8DgnAttachment)
    {
    auto attachedV8Model = v8DgnAttachment.GetDgnModelP();
    if (nullptr == attachedV8Model)
        {
        ReportError(Converter::IssueCategory::Unknown(), Converter::Issue::ConvertFailure(), 
                    Utf8PrintfString("CreateViewAttachment - missing target model for attachment %s", 
                                        Converter::IssueReporter::FmtAttachment(v8DgnAttachment).c_str()).c_str());
        return ResolvedModelMapping();
        }

    ResolvedModelMapping importedModel = FindFirstModelMappedTo(*attachedV8Model);
    if (importedModel.IsValid())
        return importedModel;
        
    // This is the first that we've seen a reference to this model.
    // If it's 3-D, then we can't convert it, as we don't know how it is mapped into the physical coordinate system.
    // If it's 2-D, then we could theoretically convert it, but that is fraught with complications. It really is up to 
    //  the caller to have used the DrawingConverter before trying to convert sheets.
    ReportError(Converter::IssueCategory::Unknown(), Converter::Issue::ConvertFailure(), 
                Utf8PrintfString("CreateViewAttachment - target model for attachment %s is 3-D but is not referenced into root model", 
                                    Converter::IssueReporter::FmtAttachment(v8DgnAttachment).c_str()).c_str());
    return ResolvedModelMapping();
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      11/16
+---------------+---------------+---------------+---------------+---------------+------*/
void Converter::SheetsConvertViewAttachment(ResolvedModelMapping const& v8SheetModelMapping, DgnAttachmentR v8DgnAttachment, 
                                            GeometricModelP proxyModel, ViewFactory& nvvf, DgnV8ViewInfoCP v8SheetViewInfo, int updSeq)
    {
    bool isFromProxyGraphics = (nullptr != proxyModel);
    auto& sheetModel = *v8SheetModelMapping.GetDgnModel().ToSheetModelP();

    //  First, make sure we have the viewed model.
    //  If the model was previously created (from proxygraphics), then we already know it. If it's not a proxy model, then get it from syncinfo.
    GeometricModelP viewedModel = proxyModel;
    if (nullptr == viewedModel)
        {
        auto m = SheetsFindModelForAttachment(v8DgnAttachment);
        if (m.IsValid())
            viewedModel = const_cast<GeometricModel*>(m.GetDgnModel().ToGeometricModel());

        if (nullptr == viewedModel)
            return; // NB: returning early will cause an existing ViewAttachment element to be deleted
        }

    //  Next, find or generate (or update) the view for this attachment
    DgnViewId viewId = SheetsGetViewForAttachment(isFromProxyGraphics, *viewedModel, v8DgnAttachment, v8SheetModelMapping, v8SheetViewInfo, nvvf);
    if (!viewId.IsValid())
        return; // NB: returning early will cause an existing ViewAttachment element to be deleted

    //  Finally, create (or update) the ViewAttachment element on the sheet
    IChangeDetector::SearchResults prov;
    DgnV8Api::EditElementHandle v8AttachmentEh(v8DgnAttachment.GetElementId(), v8DgnAttachment.GetParentModelRefP());
    ElementConversionResults results;
    auto chooseViewAttachment = ElementFilters::GetViewAttachmentElementFiter();
    if (GetChangeDetector()._IsElementChanged(prov, *this, v8AttachmentEh, v8SheetModelMapping, &chooseViewAttachment))
        SheetsCreateViewAttachment(results, v8SheetModelMapping, v8DgnAttachment, viewId, updSeq, isFromProxyGraphics);
    else
        {
        auto existingAttachment = GetDgnDb().Elements().Get<Sheet::ViewAttachment>(prov.GetExistingElementId());
        if (!existingAttachment.IsValid())
            {
            BeAssert(false);
            }
        else
            {
            BeAssert((existingAttachment->GetAttachedViewId() == viewId) && "If v8 attachment is unchanged, then there's no reason why we would have generated a new ViewDefinition for the attachment.");
            }
        }
    ProcessConversionResults(results, prov, v8AttachmentEh, v8SheetModelMapping);
    }

typedef bmap<DgnModelRefCP, int> UpdateSequence;
/*---------------------------------------------------------------------------------**//**
* Get the update sequence number for each attachement to a sheet. Values are adjusted relative to the sheet.
* That is, the sheet will always have a value of 0. Entries before the sheet will have negative values, and those after it will be positive.
* The purpose of this routine is to help approximate the relative position of elements on a sheet. 
* In v8, all 3d model attachements are drawn using Viewlets, which means that *all* of their graphics appear either below (if they are in the update sequence
* before ) or above (if they are after) elements on the sheet and each other. 
* We need to set up display priority values for the BIM view attachments that approximates that appearance. 
* Note that in v8 all 2d models are simply drawn with a linear (z=0) transform, so their display priorities are interspersed with each other and with 
* elements on the sheet. What a mess.
* @bsimethod                                    Keith.Bentley                   02/17
+---------------+---------------+---------------+---------------+---------------+------*/
static UpdateSequence getSheetUpdateSequence(DgnV8ModelR v8sheet)
    {
    UpdateSequence updSeq;

    DgnV8Api::DgnModelRefList v8UpdateSequence; 
    v8sheet.FillUpdateList(v8UpdateSequence, true, true, true);
    int i=0, sheetSlot=0;
    for (DgnModelRefCP modelRef : v8UpdateSequence)
        {
        if (modelRef == &v8sheet)
            sheetSlot = i;
        updSeq[modelRef] = i++;
        }

    for (auto& entry : updSeq)
        entry.second -= sheetSlot;

    return updSeq;
    }

/*---------------------------------------------------------------------------------**//**
* @bsimethod                                    Sam.Wilson                      11/16
+---------------+---------------+---------------+---------------+---------------+------*/
void Converter::SheetsConvertViewAttachments(ResolvedModelMapping const& v8SheetModelMapping, Bentley::ViewInfoCP v8SheetView, ViewFactory& nvvf)
    {
    if (!v8SheetModelMapping.GetDgnModel().IsSheetModel())
        {
        BeAssert(false);
        return;
        }
    auto& sheetModel = *v8SheetModelMapping.GetDgnModel().ToSheetModelP();
    auto& v8SheetModel = v8SheetModelMapping.GetV8Model();

    AttachedDrawingGenerator drawingGenerator(*this, v8SheetModelMapping);

    CreateSheetExtractionAttachments(v8SheetModelMapping, drawingGenerator, v8SheetView);

    auto attachments = GetAttachments(v8SheetModel);
    if (nullptr == attachments)
        return;

    UpdateSequence updSeq = getSheetUpdateSequence(v8SheetModelMapping.GetV8Model());

    // Convert the V8 attachments to view attachments
    for (DgnV8Api::DgnAttachment* v8DgnAttachment : *attachments)
        {
        if (!v8DgnAttachment->IsDisplayed() || nullptr == v8DgnAttachment->GetDgnModelP())
            continue;

        auto i = drawingGenerator.m_drawingsForAttachments.find(v8DgnAttachment->GetElementId());
        bool isFromProxyGraphics = (i != drawingGenerator.m_drawingsForAttachments.end());
        auto proxyModel = isFromProxyGraphics? i->second.GetDgnModel().ToGeometricModelP(): nullptr;

        auto it = updSeq.find(v8DgnAttachment);
        int seq = it == updSeq.end() ? 0 : it->second;
        SheetsConvertViewAttachment(v8SheetModelMapping, *v8DgnAttachment, proxyModel, nvvf, v8SheetView, seq);
        _OnSheetsConvertViewAttachment(v8SheetModelMapping, *v8DgnAttachment);

        auto childAttachments = GetAttachments(*v8DgnAttachment);

        if (nullptr != childAttachments)
            {
            for (auto childAttachment : *childAttachments)
                {
                if (_UseRenderedViewAttachmentFor(*childAttachment))
                    {
                    SheetsConvertViewAttachment(v8SheetModelMapping, *childAttachment, nullptr, nvvf, v8SheetView, 0);
                    _OnSheetsConvertViewAttachment(v8SheetModelMapping, *childAttachment);
                    }
                }
            }
        }
    }

END_DGNDBSYNC_DGNV8_NAMESPACE

/*
Notes: 

    Converting BIM design coordinates to BIM sheet coordinates via a V8 ref transform.

    In general, there is no known relationship between a sheet's coordinate system and the coordinate system of a 
    drawing or physical coordinates. When converting a V8 sheet, however, we do know the relationship: The reference 
    transform of the DgnAttachment on the V8 sheet. We can use this as a bridge, like this:
                             
        BIM view range    --bimToV8Design-------------> V8 design model coordinates
                                                        |
                                                        ref transform
                                                        |
                                                        v
        BIM sheet coordinates <--v8SheetToBim---------  V8 sheet model coordinates


    where:
    -- bimToV8Design is the inverse of the transform from the V8 design model to BIM.
    -- v8SheetToBim is the transform from V8 sheet model to meters.

    Note that the V8 ref transform also includes the desired scale factor that shrinks the design to the sheet.
*/


                        